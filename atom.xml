<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>😊</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2022-09-24T16:00:00.000Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>lzl121373</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>&lt;Redis设计与实现&gt;第四部分</title>
    <link href="http://example.com/2022/09/25/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E7%AC%AC%E5%9B%9B%E9%83%A8%E5%88%86/"/>
    <id>http://example.com/2022/09/25/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E7%AC%AC%E5%9B%9B%E9%83%A8%E5%88%86/</id>
    <published>2022-09-24T16:00:00.000Z</published>
    <updated>2022-09-24T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="独立功能的实现"><a href="#独立功能的实现" class="headerlink" title="独立功能的实现"></a>独立功能的实现</h1><h2 id="发布与订阅"><a href="#发布与订阅" class="headerlink" title="发布与订阅"></a>发布与订阅</h2><p>Redis的发布与订阅功能由PUBLISH、SUBSCRIBE、PSUBSCRIBE等命令组成。</p><p>通过执行SUBSCRIBE命令，客户端可以订阅一个或多个频道，从而成为这些频道的订阅者（subscriber）：每当有其他客户端向被订阅的频道发送消息（message）时，频道的所有订阅者都会收到这条消息。</p><p>除了订阅频道之外，客户端还可以通过执行PSUBSCRIBE命令订阅一个或多个模式，从而成为这些模式的订阅者：每当有其他客户端向某个频道发送消息时，消息不仅会被发送给这个频道的所有订阅者，它还会被发送给所有与这个频道相匹配的模式的订阅者。</p><h3 id="频道的订阅与退订"><a href="#频道的订阅与退订" class="headerlink" title="频道的订阅与退订"></a>频道的订阅与退订</h3><p>当一个客户端执行SUBSCRIBE命令订阅某个或某些频道的时候，这个客户端与被订阅频道之间就建立起了一种订阅关系。</p><p>Redis将所有频道的订阅关系都保存在服务器状态的pubsub_channels字典里面，这个字典的键是某个被订阅的频道，而键的值则是一个链表，链表里面记录了所有订阅这个频道的客户端：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"><span class="comment">//保存所有频道的订阅关系</span></span><br><span class="line">    dict *pubsub_channels;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="/..%5Cimg%5CRedis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%5Cpubsub_channels%E5%AD%97%E5%85%B8%E7%A4%BA%E4%BE%8B.png" alt="pubsub_channels字典示例"></p><h4 id="订阅频道"><a href="#订阅频道" class="headerlink" title="订阅频道"></a>订阅频道</h4><p>每当客户端执行SUBSCRIBE命令订阅某个或某些频道的时候，服务器都会将客户端与被订阅的频道在pubsub_channels字典中进行关联。</p><p>根据频道是否已经有其他订阅者，关联操作分为两种情况执行：</p><ul><li>如果频道已经有其他订阅者，那么它在pubsub_channels字典中必然有相应的订阅者链表，程序唯一要做的就是将客户端添加到订阅者链表的末尾。</li><li>如果频道还未有任何订阅者，那么它必然不存在于pubsub_channels字典，程序首先要在pubsub_channels字典中为频道创建一个键，并将这个键的值设置为空链表，然后再将客户端添加到链表，成为链表的第一个元素。</li></ul><p>SUBSCRIBE命令的实现可以用以下伪代码来描述：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">def subscribe (*all_input_channels):</span><br><span class="line"># 遍历输入的所有频道</span><br><span class="line">for channel in all_input_channels:</span><br><span class="line">#如果channel不存在于pubsub_channels字典（没有任何订阅者）</span><br><span class="line">#那么在字典中添加channel键，并设置它的值为空链表</span><br><span class="line">if channel not in server.pubsub_channels:</span><br><span class="line">server.pubsub_channels[channel] = []</span><br><span class="line"></span><br><span class="line">#将订阅者添加到频道所对应的链表的末尾</span><br><span class="line">server.pubsub_channels[channel].append(client)</span><br></pre></td></tr></table></figure><h4 id="退订频道"><a href="#退订频道" class="headerlink" title="退订频道"></a>退订频道</h4><p>UNSUBSCRIBE命令的行为和SUBSCRIBE命令的行为正好相反，当一个客户端退订某个或某些频道的时候，服务器将从pubsub_channels中解除客户端与被退订频道之间的关联：</p><ul><li>程序会根据被退订频道的名字，在pubsub_channels字典中找到频道对应的订阅者链表，然后从订阅者链表中删除退订客户端的信息。</li><li>如果删除退订客户端之后，频道的订阅者链表变成了空链表，那么说明这个频道已经没有任何订阅者了，程序将从pubsub_channels字典中删除频道对应的键。</li></ul><p>UNSUBSCRIBE命令的实现可以用以下伪代码来描述：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">def unsubscribe(*all_input_channels):</span><br><span class="line">#遍历要退订的所有频道</span><br><span class="line">for channel in all_input_channels:</span><br><span class="line">#在订阅者链表中删除退订的客户端</span><br><span class="line">server.pubsub_channels[channel].remove(client)</span><br><span class="line">#如果频道已经没有任何订阅者了（订阅者链表为空）</span><br><span class="line">#那么将频道从字典中删除</span><br><span class="line">if len(server.pubsub_channels[channel]) == 0:</span><br><span class="line">server.pubsub_channels.remove (channel)</span><br></pre></td></tr></table></figure><h3 id="模式的订阅与退订"><a href="#模式的订阅与退订" class="headerlink" title="模式的订阅与退订"></a>模式的订阅与退订</h3><p>前面说过，服务器将所有频道的订阅关系都保存在服务器状态的pubsub_channels属性里面，与此类似，服务器也将所有模式的订阅关系都保存在服务器状态的pubsub_patterns属性里面：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span> &#123;</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//保存所有模式订阅关系</span></span><br><span class="line">    <span class="built_in">list</span> *pubsub_patterns;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>pubsub_patterns属性是一个链表，链表中的每个节点都包含着一个pubsubPattern结构，这个结构的pattern属性记录了被订阅的模式，而client属性则记录了订阅模式的客户端：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">pubsubPattern</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//订阅模式的客户端</span></span><br><span class="line">    redisClient *client;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//被订阅的模式</span></span><br><span class="line">robj *pattern;</span><br><span class="line">&#125; pubsubPattern;</span><br></pre></td></tr></table></figure><h4 id="订阅模式"><a href="#订阅模式" class="headerlink" title="订阅模式"></a>订阅模式</h4><p>每当客户端执行PSUBSCRIBE命令订阅某个或某些模式的时候，服务器会对每个被订阅的模式执行以下两个操作：</p><ol><li>新建一个pubsubPattern结构，将结构的pattern属性设置为被订阅的模式，client属性设置为订阅模式的客户端。</li><li>将pubsubPattern结构添加到pubsub_patterns链表的表尾。</li></ol><p>PSUBSCRIBE命令的实现原理可以用以下伪代码来描述：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">def psubscribe(*all_input_patterns):</span><br><span class="line">#遍历输入的所有模式</span><br><span class="line">for pattern in all_input_patterns:</span><br><span class="line">#创建新的pubsubPattern结构</span><br><span class="line">#记录被订阅的模式，以及订阅模式的客户端</span><br><span class="line">pubsubPattern = create_new_pubsubPattern()</span><br><span class="line">pubsubPattern.client = client</span><br><span class="line">pubsubPattern.pattern = pattern</span><br><span class="line"></span><br><span class="line">#将新的pubsubPattern追加到pubsub_patterns链表末尾</span><br><span class="line">server.pubsub_patterns.append(pubsubPattern)</span><br></pre></td></tr></table></figure><h4 id="退订模式"><a href="#退订模式" class="headerlink" title="退订模式"></a>退订模式</h4><p>模式的退订命令PUNSUBSCRIBE是PSUBSCRIBE命令的反操作：当一个客户端退订某个或某些模式的时候，服务器将在pubsub_patterns链表中查找并删除那些pattern属性为被退订模式，并且client属性为执行退订命令的客户端的pubsubPattern结构。</p><p>PUNSUBSCRIBE命令的实现原理可以用以下伪代码来描述：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">def punsubscribe(*all_input_patterns):</span><br><span class="line">#遍历所有要退订的模式</span><br><span class="line">for pattern in all_input_patterns:</span><br><span class="line">#遍历pubsub_patterns链表中的所有pubsubPattern结构</span><br><span class="line">for pubsubPattern in server.pubsub_patterns:</span><br><span class="line"></span><br><span class="line">#如果当前客户端和pubsubPattern记录的客户端相同</span><br><span class="line">#并且要退订的模式也和pubsubPattern记录的模式相同</span><br><span class="line">if client == pubsubPattern.client and \</span><br><span class="line">pattern == pubsubPattern.pattern:</span><br><span class="line"></span><br><span class="line">#那么将这个pubsubPattern从链表中删除</span><br><span class="line">server.pubsub_patterns.remove(pubsubPattern)</span><br></pre></td></tr></table></figure><h3 id="发送消息"><a href="#发送消息" class="headerlink" title="发送消息"></a>发送消息</h3><p>当一个Redis客户端执行PUBLISH &lt;channel&gt; &lt;message&gt;命令将消息message发送给频道channel的时候，服务器需要执行以下两个动作：</p><ol><li>将消息message发送给channel频道的所有订阅者。</li><li>如果有一个或多个模式pattern与频道channel相匹配，那么将消息message发送给pattern模式的订阅者。</li></ol><h4 id="将消息发送给频道订阅者"><a href="#将消息发送给频道订阅者" class="headerlink" title="将消息发送给频道订阅者"></a>将消息发送给频道订阅者</h4><p>因为服务器状态中的pubsub_channels字典记录了所有频道的订阅关系，所以为了将消息发送给channel频道的所有订阅者，PUBLISH命令要做的就是在pubsub_channels字典里找到频道channel的订阅者名单（一个链表），然后将消息发送给名单上的所有客户端。</p><p>PUBLISH命令将消息发送给频道订阅者的方法可以用以下伪代码来描述：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">def channel_publish(channel, message):</span><br><span class="line">#如果channel键不存在于pubsub_channels字典中</span><br><span class="line">#那么说明channel频道没有任何订阅者</span><br><span class="line">#程序不做发送动作，直接返回</span><br><span class="line">if channel not in server.pubsub_channels:</span><br><span class="line">return</span><br><span class="line"></span><br><span class="line">#运行到这里，说明channel频道至少有一个订阅者</span><br><span class="line">#程序遍历channel频道的订阅者链表</span><br><span class="line">#将消息发送给所有订阅者</span><br><span class="line">for subscriber in server.pubsub_channels[channel]:</span><br><span class="line">send_message(subscriber, message)</span><br></pre></td></tr></table></figure><h4 id="将消息发送给模式订阅者"><a href="#将消息发送给模式订阅者" class="headerlink" title="将消息发送给模式订阅者"></a>将消息发送给模式订阅者</h4><p>因为服务器状态中的pubsub_patterns链表记录了所有模式的订阅关系，所以为了将消息发送给所有与channel频道相匹配的模式的订阅者，PUBLISH命令要做的就是遍历整个pubsub_patterns链表，查找那些与channel频道相匹配的模式，并将消息发送给订阅了这些模式的客户端。</p><p>PUBLISH命令将消息发送给模式订阅者的方法可以用以下伪代码来描述：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def pattern_publish(channel, message):</span><br><span class="line">#遍历所有模式订阅消息</span><br><span class="line">for pubsubPattern in server.pubsub_patterns:</span><br><span class="line">#如果频道和模式相匹配</span><br><span class="line">if match(channel, pubsubPattern.pattern):</span><br><span class="line">#那么将消息发送给订阅该模式的客户端</span><br><span class="line">send_message(pubsubPattern.client, message)</span><br></pre></td></tr></table></figure><p>最后，PUBLISH命令的实现可以用以下伪代码来描述：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def publish(channel, message):</span><br><span class="line">#将消息发送给channel频道的所有订阅者</span><br><span class="line">channel_publish(channel, message)</span><br><span class="line">#将消息发送给所有和channel频道相匹配的模式的订阅者</span><br><span class="line">pattern_publish(channel,message)</span><br></pre></td></tr></table></figure><h3 id="查看订阅消息"><a href="#查看订阅消息" class="headerlink" title="查看订阅消息"></a>查看订阅消息</h3><p>PUBSUB命令是Redis 2.8新增加的命令之一，客户端可以通过这个命令来查看频道或者模式的相关信息，比如某个频道目前有多少订阅者，又或者某个模式目前有多少订阅者，诸如此类。</p><h4 id="PUBSUB-CHANNELS"><a href="#PUBSUB-CHANNELS" class="headerlink" title="PUBSUB CHANNELS"></a>PUBSUB CHANNELS</h4><p>PUBSUB CHANNELS [pattern]子命令用于返回服务器当前被订阅的频道，其中pattern参数是可选的：</p><ul><li>如果不给定pattern参数，那么命令返回服务器当前被订阅的所有频道。</li><li>如果给定pattern参数，那么命令返回服务器当前被订阅的频道中那些与pattern模式相匹配的频道。</li></ul><p>这个子命令是通过遍历服务器pubsub_channels字典的所有键（每个键都是一个被订阅的道道)，然后记录并返回所有符合条件的频道来实现的，这个过程可以用以下伪代码来描述：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">def pubsub_channels(pattern=None):</span><br><span class="line">#一个列表，用于记录所有符合条件的频道</span><br><span class="line">channel_list = []</span><br><span class="line"></span><br><span class="line">#遍历服务器中的所有频道</span><br><span class="line">#（也即是pubsub_channels字典的所有键）</span><br><span class="line">for channel in server.pubsub_channels:</span><br><span class="line">#当以下两个条件的任意一个满足时，将频道添加到链表里面:</span><br><span class="line">#1)用户没有指定pattern参数</span><br><span class="line">#2)用户指定了pattern参数，并且channel和pattern匹配</span><br><span class="line">if (pattern is None) or match (channel, pattern):</span><br><span class="line">channel_list.append(channel)</span><br><span class="line"></span><br><span class="line">#向客户端返回频道列表</span><br><span class="line">return channel_list</span><br></pre></td></tr></table></figure><h4 id="PUBSUB-NUMSUB"><a href="#PUBSUB-NUMSUB" class="headerlink" title="PUBSUB NUMSUB"></a>PUBSUB NUMSUB</h4><p>PUBSUB NUMSUB [channel-1 channel-2 … channel-n]子命令接受任意多个频道作为输入参数，并返回这些频道的订阅者数量。</p><p>这个子命令是通过在pubsub_channels字典中找到频道对应的订阅者链表，然后返回订阅者链表的长度来实现的（订阅者链表的长度就是频道订阅者的数量），这个过程可以用以下伪代码来描述：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">def pubsub_numsub(*all_input_channels):</span><br><span class="line">#遍历输入的所有频道</span><br><span class="line">for channel in all_input_channels:</span><br><span class="line">#如果pubsub_channels字典中没有channel这个键</span><br><span class="line">#那么说明channel频道没有任何订阅者</span><br><span class="line">if channel not in server.pubsub_channels:</span><br><span class="line">#返回频道名</span><br><span class="line">reply_channel_name(channel)</span><br><span class="line">#订阅者数量为0</span><br><span class="line">reply_subscribe_count(0)</span><br><span class="line"></span><br><span class="line">#如果pubsub_channels字典中存在channel键</span><br><span class="line">#那么说明channel频道至少有一个订阅者</span><br><span class="line">else:</span><br><span class="line">#返回频道名</span><br><span class="line">reply_channel_name(channel)</span><br><span class="line">#订阅者链表的长度就是订阅者数量</span><br><span class="line">reply_subscribe_count(len(server.pubsub_channels[channel]))</span><br></pre></td></tr></table></figure><h4 id="PUBSUB-NUMPAT"><a href="#PUBSUB-NUMPAT" class="headerlink" title="PUBSUB NUMPAT"></a>PUBSUB NUMPAT</h4><p>PUBSUB NUMPAT子命令用于返回服务器当前被订阅模式的数量。</p><p>这个子命令是通过返回pubsub_patterns链表的长度来实现的，因为这个链表的长度就是服务器被订阅模式的数量，这个过程可以用以下伪代码来描述：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">def pubsub_numpat():</span><br><span class="line"># pubsub_patterns链表的长度就是被订阅模式的数量</span><br><span class="line">reply_pattern_count(len(server.pubsub_patterns))</span><br></pre></td></tr></table></figure><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><p>Redis通过MULTI、EXEC、WATCH等命令来实现事务（transaction）功能。事务提供了一种将多个命令请求打包，然后一次性、按顺序地执行多个命令的机制，并且在事务执行期间，服务器不会中断事务而改去执行其他客户端的命令请求，它会将事务中的所有命令都执行完毕，然后才去处理其他客户端的命令请求。</p><p>以下是一个事务执行的过程，该事务首先以一个MULTI命令为开始，接着将多个命令放入事务当中，最后由EXEC命令将这个事务提交（commit）给服务器执行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; MULTI</span><br><span class="line">OK</span><br><span class="line">redis&gt; SET &quot;name&quot; &quot;Practical Common Lisp&quot;</span><br><span class="line">QUEUED</span><br><span class="line">redis&gt; GET &quot;name&quot;</span><br><span class="line">QUEUED</span><br><span class="line">redis&gt; SET &quot;author&quot; &quot;Peter seibel&quot;</span><br><span class="line">QUEUED</span><br><span class="line">redis&gt; GET &quot;author&quot;</span><br><span class="line">QUEUED</span><br><span class="line">redis&gt; EXEC</span><br><span class="line">1)OK</span><br><span class="line">2)&quot;Practical Common Lisp&quot;</span><br><span class="line">3)OK</span><br><span class="line">4)&quot;Peter seibel&quot;</span><br></pre></td></tr></table></figure><h3 id="事务的实现"><a href="#事务的实现" class="headerlink" title="事务的实现"></a>事务的实现</h3><p>一个事务从开始到结束通常会经历以下三个阶段：</p><ol><li>事务开始。</li><li>命令入队。</li><li>事务执行。</li></ol><h4 id="事务开始"><a href="#事务开始" class="headerlink" title="事务开始"></a>事务开始</h4><p>MULTI命令的执行标志着事务的开始：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; MULTI</span><br><span class="line">OK</span><br></pre></td></tr></table></figure><p>MULTI命令可以将执行该命令的客户端从非事务状态切换至事务状态，这一切换是通过在客户端状态的flags属性中打开REDIS_MULTI标识来完成的，MULTI命令的实现可以用以下伪代码来表示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def MULTI():</span><br><span class="line">#打开事务标识</span><br><span class="line">client.flags |= REDIS_MULTI</span><br><span class="line">#返回OK回复</span><br><span class="line">replyOK()</span><br></pre></td></tr></table></figure><h4 id="命令入队"><a href="#命令入队" class="headerlink" title="命令入队"></a>命令入队</h4><p>当一个客户端处于非事务状态时，这个客户端发送的命令会立即被服务器执行。</p><p>与此不同的是，当一个客户端切换到事务状态之后，服务器会根据这个客户端发来的不同命令执行不同的操作：</p><ul><li>如果客户端发送的命令为EXEC、DISCARD、WATCH、MULTI四个命令的其中一个，那么服务器立即执行这个命令。</li><li>与此相反，如果客户端发送的命令是EXEC、DISCARD、WATCH、MULTI四个命令以外的其他命令，那么服务器并不立即执行这个命令，而是将这个命令放入一个事务队列里面，然后向客户端返回QUEUED回复。</li></ul><h4 id="事务队列"><a href="#事务队列" class="headerlink" title="事务队列"></a>事务队列</h4><p>每个Redis客户端都有自己的事务状态，这个事务状态保存在客户端状态的mstate属性里面：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisClient</span> &#123;</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//事务状态</span></span><br><span class="line">multiState mstate;<span class="comment">/* MULTI/EXEC state */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125; redisClient;</span><br></pre></td></tr></table></figure><p>事务状态包含一个事务队列，以及一个已人队命令的计数器（也可以说是事务队列的长度）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">multiState</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//事务队列，FIFO顺序</span></span><br><span class="line">    multiCmd *commands;</span><br><span class="line">    <span class="comment">//已入队命令计数</span></span><br><span class="line">    <span class="type">int</span> count;</span><br><span class="line"></span><br><span class="line">&#125; multiState;</span><br></pre></td></tr></table></figure><p>事务队列是一个multiCmd类型的数组，数组中的每个multiCmd结构都保存了一个已入队命令的相关信息，包括指向命令实现函数的指针、命令的参数，以及参数的数量：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">multiCmd</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//参数</span></span><br><span class="line">robj **argv;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//参数数量</span></span><br><span class="line">    <span class="type">int</span> argc;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//命令指针</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisCommand</span> *<span class="title">cmd</span>;</span></span><br><span class="line">&#125; multiCmd;</span><br></pre></td></tr></table></figure><p>事务队列以先进先出（FIFO）的方式保存入队的命令，较先人队的命令会被放到数组的前面，而较后入队的命令则会被放到数组的后面。</p><h4 id="执行事务"><a href="#执行事务" class="headerlink" title="执行事务"></a>执行事务</h4><p>当一个处于事务状态的客户端向服务器发送EXEC命令时，这个EXEC命令将立即被服务器执行。服务器会遍历这个客户端的事务队列，执行队列中保存的所有命令，最后将执行命令所得的结果全部返回给客户端。</p><p>EXEC命令的实现原理可以用以下伪代码来描述：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">def <span class="title function_">EXEC</span><span class="params">()</span>:</span><br><span class="line"></span><br><span class="line">#创建空白的回复队列</span><br><span class="line">reply_queue = []</span><br><span class="line"></span><br><span class="line">#遍历事务队列中的每个项</span><br><span class="line">#读取命令的参数，参数的个数，以及要执行的命令</span><br><span class="line"><span class="keyword">for</span> argv, argc, cmd in client.mstate.commands:</span><br><span class="line"></span><br><span class="line">#执行命令，并取得命令的返回值</span><br><span class="line">reply = execute_command(cmd, argv, argc)</span><br><span class="line">#将返回值追加到回复队列末尾</span><br><span class="line">reply_queue.append(reply)</span><br><span class="line"></span><br><span class="line">#移除REDIS_MULTI标识，让客户端回到非事务状态</span><br><span class="line">client.flags &amp;= ~REDIS_MULTI</span><br><span class="line"></span><br><span class="line">#清空客户端的事务状态，包括:</span><br><span class="line">#<span class="number">1</span>)清零入队命令计数器</span><br><span class="line">#<span class="number">2</span>)释放事务队列</span><br><span class="line">client.mstate.count = <span class="number">0</span></span><br><span class="line">release_transaction_queue(client.mstate.commands)</span><br><span class="line">#将事务的执行结果返回给客户端</span><br><span class="line">send_reply_to_client(client, reply_queue)</span><br></pre></td></tr></table></figure><h3 id="WATCH命令的实现"><a href="#WATCH命令的实现" class="headerlink" title="WATCH命令的实现"></a>WATCH命令的实现</h3><p>WATCH命令是一个乐观锁（optimistic locking），它可以在EXEC命令执行之前，监视任意数量的数据库键，并在EXEC命令执行时，检查被监视的键是否至少有一个已经被修改过了，如果是的话，服务器将拒绝执行事务，并向客户端返回代表事务执行失败的空回复。</p><h4 id="使用WATCH命令监视数据库键"><a href="#使用WATCH命令监视数据库键" class="headerlink" title="使用WATCH命令监视数据库键"></a>使用WATCH命令监视数据库键</h4><p>每个Redis数据库都保存着一个watched_keys字典，这个字典的键是某个被WATCH命令监视的数据库键，而字典的值则是一个链表，链表中记录了所有监视相应数据库键的客户端：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisDb</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//正在被WATCH命令监视的键</span></span><br><span class="line">    dict *watched_keys;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125; redisDb;</span><br></pre></td></tr></table></figure><p>通过watched_keys字典，服务器可以清楚地知道哪些数据库键正在被监视，以及哪些客户端正在监视这些数据库键。</p><h4 id="监视机制的触发"><a href="#监视机制的触发" class="headerlink" title="监视机制的触发"></a>监视机制的触发</h4><p>所有对数据库进行修改的命令，比如SET、LPUSH、SADD、ZREM、DEL、FLUSHDB等等，在执行之后都会调用multi.c&#x2F;touchWatchKey函数对watched_keys字典进行检查，查看是否有客户端正在监视刚刚被命令修改过的数据库键，如果有的话，那么touchWatchKey函数会将监视被修改键的客户端的REDIS_DIRTY_CAS标识打开，表示该客户端的事务安全性已经被破坏。</p><p>touchWatchKey函数的定义可以用以下伪代码来描述：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">def touchWatchKey(db, key):</span><br><span class="line">#如果键key存在于数据库的watched_keys字典中</span><br><span class="line">#那么说明至少有一个客户端在监视这个key</span><br><span class="line">if key in db.watched_keys:</span><br><span class="line">#遍历所有监视键key的客户端</span><br><span class="line">for client in db.watched_keys[key]:</span><br><span class="line">#打开标识</span><br><span class="line">client.flags |= REDIS_DIRTY_CAS</span><br></pre></td></tr></table></figure><h4 id="判断事务是否安全"><a href="#判断事务是否安全" class="headerlink" title="判断事务是否安全"></a>判断事务是否安全</h4><p>当服务器接收到一个客户端发来的EXEC命令时，服务器会根据这个客户端是否打开了REDIS_DIRTY_CAS标识来决定是否执行事务：</p><ul><li>如果客户端的REDIS_DIRTY_CAS标识已经被打开，那么说明客户端所监视的键当中，至少有一个键已经被修改过了，在这种情况下，客户端提交的事务已经不再安全，所以服务器会拒绝执行客户端提交的事务。</li><li>如果客户端的REDIS_DIRTY_CAS标识没有被打开，那么说明客户端监视的所有键都没有被修改过（或者客户端没有监视任何键），事务仍然是安全的，服务器将执行客户端提交的这个事务。</li></ul><h3 id="事务的ACID性质"><a href="#事务的ACID性质" class="headerlink" title="事务的ACID性质"></a>事务的ACID性质</h3><p>在传统的关系式数据库中，常常用ACID性质来检验事务功能的可靠性和安全性。在Redis中，事务总是具有原子性（Atomicity）、一致性（Consistency）和隔离性（Isolation），并且当Redis运行在某种特定的持久化模式下时，事务也具有耐久性（Durability）。</p><h4 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h4><p>事务具有原子性指的是，数据库将事务中的多个操作当作一个整体来执行，服务器要么就执行事务中的所有操作，要么就一个操作也不执行。</p><p>对于Redis的事务功能来说，事务队列中的命令要么就全部都执行，要么就一个都不执行，因此，Redis的事务是具有原子性的。</p><p>Redis的事务和传统的关系型数据库事务的最大区别在于，Redis不支持事务回滚机制（rollback），即使事务队列中的某个命令在执行期间出现了错误，整个事务也会继续执行下去，直到将事务队列中的所有命令都执行完毕为止。</p><h4 id="一致性"><a href="#一致性" class="headerlink" title="一致性"></a>一致性</h4><p>事务具有一致性指的是，如果数据库在执行事务之前是一致的，那么在事务执行之后，无论事务是否执行成功，数据库也应该仍然是一致的。</p><p>“一致”指的是数据符合数据库本身的定义和要求，没有包含非法或者无效的错误数据。</p><p>Redis通过谨慎的错误检测和简单的设计来保证事务的一致性，以下三个小节将分别介绍三个Redis事务可能出错的地方，并说明Redis是如何妥善地处理这些错误，从而确保事务的一致性的。</p><h5 id="入队错误"><a href="#入队错误" class="headerlink" title="入队错误"></a>入队错误</h5><p>如果一个事务在入队命令的过程中，出现了命令不存在，或者命令的格式不正确等情况，那么Redis将拒绝执行这个事务。</p><p>因为服务器会拒绝执行入队过程中出现错误的事务，所以Redis事务的一致性不会被带有入队错误的事务影响。</p><h5 id="执行错误"><a href="#执行错误" class="headerlink" title="执行错误"></a>执行错误</h5><p>除了入队时可能发生错误以外，事务还可能在执行的过程中发生错误。关于这种错误有两个需要说明的地方：</p><ul><li>执行过程中发生的错误都是一些不能在入队时被服务器发现的错误，这些错误只会在命令实际执行时被触发。</li><li>即使在事务的执行过程中发生了错误，服务器也不会中断事务的执行，它会继续执行事务中余下的其他命令，并且已执行的命令（包括执行命令所产生的结果）不会被出错的命令影响。</li></ul><p>因为在事务执行的过程中，出错的命令会被服务器识别出来，并进行相应的错误处理，所以这些出错命令不会对数据库做任何修改，也不会对事务的一致性产生任何影响。</p><h5 id="服务器停机"><a href="#服务器停机" class="headerlink" title="服务器停机"></a>服务器停机</h5><p>如果Redis服务器在执行事务的过程中停机，那么根据服务器所使用的持久化模式，可能有以下情况出现：</p><ul><li>如果服务器运行在无持久化的内存模式下，那么重启之后的数据库将是空白的，因此数据总是一致的。</li><li>如果服务器运行在RDB模式下，那么在事务中途停机不会导致不一致性，因为服务器可以根据现有的RDB文件来恢复数据，从而将数据库还原到一个一致的状态。如果找不到可供使用的RDB文件，那么重启之后的数据库将是空白的，而空白数据库总是一致的。</li><li>如果服务器运行在AOF模式下，那么在事务中途停机不会导致不一致性，因为服务器可以根据现有的AOF文件来恢复数据，从而将数据库还原到一个一致的状态。如果找不到可供使用的AOF文件，那么重启之后的数据库将是空白的，而空白数据库总是一致的。</li></ul><p>综上所述，无论Redis服务器运行在哪种持久化模式下，事务执行中途发生的停机都不会影响数据库的一致性。</p><h4 id="隔离性"><a href="#隔离性" class="headerlink" title="隔离性"></a>隔离性</h4><p>事务的隔离性指的是，即使数据库中有多个事务并发地执行，各个事务之间也不会互相影响，并且在并发状态下执行的事务和串行执行的事务产生的结果完全相同。</p><p>因为Redis使用单线程的方式来执行事务（以及事务队列中的命令），并且服务器保证，在执行事务期间不会对事务进行中断，因此，Redis的事务总是以串行的方式运行的，并且事务也总是具有隔离性的。</p><h4 id="耐久性"><a href="#耐久性" class="headerlink" title="耐久性"></a>耐久性</h4><p>事务的耐久性指的是，当一个事务执行完毕时，执行这个事务所得的结果已经被保存到永久性存储介质（比如硬盘）里面了，即使服务器在事务执行完毕之后停机，执行事务所得的结果也不会丢失。</p><p>因为Redis的事务不过是简单地用队列包裹起了一组Redis命令，Redis并没有为事务提供任何额外的持久化功能，所以Redis事务的耐久性由Redis所使用的持久化模式决定：</p><ul><li>当服务器在无持久化的内存模式下运作时，事务不具有耐久性：一旦服务器停机，包括事务数据在内的所有服务器数据都将丢失。</li><li>当服务器在RDB持久化模式下运作时，服务器只会在特定的保存条件被满足时，才会执行BGSAVE命令，对数据库进行保存操作，并且异步执行的BGSAVE不能保证事务数据被第一时间保存到硬盘里面，因此RDB持久化模式下的事务也不具有耐久性。</li><li>当服务器运行在AOF持久化模式下，并且appendfsync选项的值为always时，程序总会在执行命令之后调用同步（sync）函数，将命令数据真正地保存到硬盘里面，因此这种配置下的事务是具有耐久性的。</li><li>当服务器运行在AOF持久化模式下，并且appendfsync选项的值为everysec时，程序会每秒同步一次命令数据到硬盘。因为停机可能会恰好发生在等待同步的那一秒钟之内，这可能会造成事务数据丢失，所以这种配置下的事务不具有耐久性。</li><li>当服务器运行在AOF持久化模式下，并且appendfsync选项的值为no时，程序会交由操作系统来决定何时将命令数据同步到硬盘。因为事务数据可能在等待同步的过程中丢失，所以这种配置下的事务不具有耐久性。</li></ul><h2 id="Lua脚本"><a href="#Lua脚本" class="headerlink" title="Lua脚本"></a>Lua脚本</h2><p>Redis从2.6版本开始引入对Lua脚本的支持，通过在服务器中嵌入Lua环境，Redis客户端可以使用Lua脚本，直接在服务器端原子地执行多个Redis命令。</p><p>其中，使用EVAL命令可以直接对输入的脚本进行求值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; EVAL &quot;return &#x27;hello world&#x27;&quot; 0</span><br><span class="line">&quot;hello world&quot;</span><br></pre></td></tr></table></figure><p>而使用EVALSHA命令则可以根据脚本的SHA1校验和来对脚本进行求值，但这个命令要求校验和对应的脚本必须至少被EVAL命令执行过一次：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; EVAL &quot;return 1+1&quot; 0</span><br><span class="line">(integer)2</span><br><span class="line">redis&gt; EVALSHA &quot;a27e7e8a43702b7046d4f6a7ccf5b60cef6b9bd9&quot; 0 //上一个脚本的校验和</span><br><span class="line">integer) 2</span><br></pre></td></tr></table></figure><p>或者这个校验和对应的脚本曾经被SCRIPT LOAD命令载入过：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SCRIPT LOAD &quot;return 2*2&quot;</span><br><span class="line">&quot;4475bfb5919b5ad16424cb5074d4724ae833e72&quot;</span><br><span class="line">redis&gt; EVALSHA &quot;4475bfb5919b5ad16424cb50f7464724ae833e72&quot; 0</span><br><span class="line">(integer) 4</span><br></pre></td></tr></table></figure><p>本章将对Redis服务器中与Lua脚本有关的各个部分进行介绍。</p><p>首先，本章将介绍Redis服务器初始化Lua环境的整个过程，说明Redis对Lua环境进行了哪些修改，而这些修改又对用户执行Lua脚本产生了什么影响和限制。</p><p>接着，本章将介绍与Lua环境进行协作的两个组件，它们分别是负责执行Lua脚本中包含Redis命令的伪客户端，以及负责保存传入服务器的Lua脚本的脚本字典。了解伪客户端可以知道脚本中的Redis命令在执行时，服务器与Lua环境的交互过程，而了解脚本字典则有助于理解SCRIPT EXISTS命令和脚本复制功能的实现原理。</p><p>在这之后，本章将介绍EVAL命令和EVALSHA命令的实现原理，说明Lua脚本在Redis服务器中是如何被执行的，并对管理脚本的四个命令——SCRIPT FLUSH命令、SCRIPT EXISTS命令、SCRIPT LOAD命令、SCRIPT KILL 命令的实现原理进行介绍。</p><p>最后，本章将以介绍Redis在主从服务器之间复制Lua脚本的方法作为本章的结束。</p><h3 id="创建并修改Lua环境"><a href="#创建并修改Lua环境" class="headerlink" title="创建并修改Lua环境"></a>创建并修改Lua环境</h3><p>为了在Redis服务器中执行Lua脚本，Redis在服务器内嵌了一个Lua环境（environ-ment），并对这个Lua环境进行了一系列修改，从而确保这个Lua环境可以满足Redis服务器的需要。<br>Redis服务器创建并修改Lua环境的整个过程由以下步骤组成：</p><ol><li>创建一个基础的Lua环境，之后的所有修改都是针对这个环境进行的。</li><li>载人多个函数库到Lua环境里面，让Lua脚本可以使用这些函数库来进行数据操作。</li><li>创建全局表格redis，这个表格包含了对Redis进行操作的函数，比如用于在Lua脚本中执行Redis命令的redis.call函数。</li><li>使用Redis自制的随机函数来替换Lua原有的带有副作用的随机函数，从而避免在脚本中引入副作用。</li><li>创建排序辅助函数，Lua环境使用这个辅佐函数来对一部分Redis命令的结果进行排序，从而消除这些命令的不确定性。</li><li>创建redis.pcall函数的错误报告辅助函数，这个函数可以提供更详细的出错信息。</li><li>对Lua环境中的全局环境进行保护，防止用户在执行Lua脚本的过程中，将额外的全局变量添加到Lua环境中。</li><li>将完成修改的Lua环境保存到服务器状态的lua属性中，等待执行服务器传来的Lua脚本。</li></ol><h4 id="创建Lua环境"><a href="#创建Lua环境" class="headerlink" title="创建Lua环境"></a>创建Lua环境</h4><p>在最开始的这一步，服务器首先调用Lua的CAPI函数lua_open，创建一个新的Lua环境。</p><p>因为lua_open函数创建的只是一个基本的Lua环境，为了让这个Lua环境可以满足Redis的操作要求，接下来服务器将对这个Lua环境进行一系列修改。</p><h4 id="载入函数库"><a href="#载入函数库" class="headerlink" title="载入函数库"></a>载入函数库</h4><p>Redis修改Lua环境的第一步，就是将以下函数库载入到Lua环境里面：</p><ul><li>基础库（base library）：这个库包含Lua的核心（core）函数，error、pairs、tostring、pcal等。另外，为了防止用户从外部文件中引入不安全的代码，库中的loadfile函数会被删除。</li><li>表格库（table library）：这个库包含用于处理表格的通用函数，比如table.concat、table.insert、table.remove、table.sort等。</li><li>字符串库（string library）：这个库包含用于处理字符串的通用函数，比如用于对字符串进行查找的string.find函数，对字符串进行格式化的string.format函数，查看字符串长度的string.len函数，对字符串进行翻转的string.reverse函数等。</li><li>数学库（math library）：这个库是标准C语言数学库的接口，它包括计算绝对值的math.abs函数，返回多个数中的最大值和最小值的math.max函数和math.min函数，计算二次方根的math.sqrt函数，计算对数的math.log函数等。</li><li>调试库（debug library）：这个库提供了对程序进行调试所需的函数，比如对程序设置钩子和取得钩子的debug.sethook函数和debug.gethook函数，返回给定函数相关信息的debug. getinfo函数，为对象设置元数据的debug.setmetatable函数，获取对象元数据的debug.getmetatable函数等。</li><li>Lua CJSON库：这个库用于处理UTF-8编码的JSON格式，其中cjson.decode函数将一个JSON格式的字符串转换为一个Lua值，而cjson.encode函数将一个Lua值序列化为JSON格式的字符串。</li><li>Struct库：这个库用于在Lua值和C结构（struct）之间进行转换，函数struct.pack将多个Lua值打包成一个类结构（struct-like）字符串，而函数struct.unpack则从一个类结构字符串中解包出多个Lua值。</li><li>Lua cmsgpack库：这个库用于处理MessagePack格式的数据，其中cmsgpack.pack 函数将Lua值转换为MessagePack数据，而cmsgpack.unpack函数则将MessagePack数据转换为Lua值。</li></ul><p>通过使用这些功能强大的函数库，Lua脚本可以直接对执行Redis命令获得的数据进行复杂的操作。</p><h4 id="创建redis全局表格"><a href="#创建redis全局表格" class="headerlink" title="创建redis全局表格"></a>创建redis全局表格</h4><p>在这一步，服务器将在Lua环境中创建一个redis表格（table），并将它设为全局变量。这个redis表格包含以下函数：</p><ul><li>用于执行Redis命令的redis.call和redis.pcall函数。</li><li>用于记录Redis日志（log）的redis.log函数，以及相应的日志级别（level）常量：redis.LOG_DEBUG，redis.LOG_VERBOSE，redis.LOG_NOTICE，以及redis.LOG_WARNING。</li><li>用于计算SHA1校验和的redis.sha1hex函数。</li><li>用于返回错误信息的redis.error_reply函数和redis.status_reply函数。</li></ul><p>在这些函数里面，最常用也最重要的要数redis.call函数和redis.pcall函数，通过这两个函数，用户可以直接在Lua脚本中执行Redis命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis &gt; EVAL &quot;return redis.call(&#x27;PING&#x27;)&quot; 0</span><br><span class="line">PONG</span><br></pre></td></tr></table></figure><h4 id="使用Redis自制的随机函数来替换Lua原有的随机函数"><a href="#使用Redis自制的随机函数来替换Lua原有的随机函数" class="headerlink" title="使用Redis自制的随机函数来替换Lua原有的随机函数"></a>使用Redis自制的随机函数来替换Lua原有的随机函数</h4><p>为了保证相同的脚本可以在不同的机器上产生相同的结果，Redis要求所有传入服务器的Lua脚本，以及Lua环境中的所有函数，都必须是无副作用（side effect）的纯函数（pure function）。</p><p>但是，在之前载入Lua环境的math函数库中，用于生成随机数的math.random函数和math.randomseed函数都是带有副作用的，它们不符合Redis对Lua环境的无副作用要求。</p><p>因为这个原因，Redis使用自制的函数替换了math库中原有的math.random函数和math.randomseed函数，替换之后的两个函数有以下特征：</p><ul><li>对于相同的seed来说，math.random总产生相同的随机数序列，这个函数是一个纯函数。</li><li>除非在脚本中使用math.randomseed显式地修改seed，否则每次运行脚本时，Lua环境都使用固定的math.randomseed(0)语句来初始化seed。</li></ul><h4 id="创建排序辅助函数"><a href="#创建排序辅助函数" class="headerlink" title="创建排序辅助函数"></a>创建排序辅助函数</h4><p>对于Lua脚本来说，另一个可能产生不一致数据的地方是那些带有不确定性质的命令。比如对于一个集合键来说，因为集合元素的排列是无序的，所以即使两个集合的元素完全相同，它们的输出结果也可能并不相同。</p><p>考虑下面这个集合例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SADD fruit apple banana cherry</span><br><span class="line">(integer) 3</span><br><span class="line"></span><br><span class="line">redis&gt; SMEMBERS fruit</span><br><span class="line">1) &quot;cherry&quot;</span><br><span class="line">2) &quot;banana&quot;</span><br><span class="line">3) &quot;apple&quot;</span><br><span class="line"></span><br><span class="line">redis&gt; SADD another-fruit cherry banana apple</span><br><span class="line">(integer) 3</span><br><span class="line"></span><br><span class="line">redis&gt; SMEMBERS another-fruit</span><br><span class="line">1) &quot;apple&quot;</span><br><span class="line">2) &quot;banana&quot;</span><br><span class="line">3) &quot;cherry&quot;</span><br></pre></td></tr></table></figure><p>这个例子中的fruit集合和another-fruit集合包含的元素是完全相同的，只是因为集合添加元素的顺序不同，SMEMBERS命令的输出就产生了不同的结果。</p><p>Redis将SMEMBERS这种在相同数据集上可能会产生不同输出的命令称为“带有不确定性的命令”，这些命令包括：</p><ul><li>SINTER</li><li>SUNION</li><li>SDIFF</li><li>SMEMBERS</li><li>HKEYS</li><li>HVALS</li><li>KEYS</li></ul><p>为了消除这些命令带来的不确定性，服务器会为Lua环境创建一个排序辅助函数__redis__compare_helper，当Lua脚本执行完一个带有不确定性的命令之后，程序会使用__redis__compare_helper作为对比函数，自动调用table.sort函数对命令的返回值做一次排序，以此来保证相同的数据集总是产生相同的输出。</p><p>举个例子，如果我们在Lua脚本中对fruit集合和another-fruit集合执行SMEMBERS命令，那么两个脚本将得出相同的结果，因为脚本已经对SMEMBERS命令的输出进行过排序了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; EVAL &quot;return redis.call(&#x27;SMEMBERS&#x27;, KEYS[1])&quot; 1 fruit</span><br><span class="line">1）&quot;apple&quot;</span><br><span class="line">2) &quot;banana&quot;</span><br><span class="line">3) &quot;cherry&quot;</span><br><span class="line"></span><br><span class="line">redis&gt; EVAL &quot;return redis.call(&#x27;SMEMBERS&#x27;, KEYS[1])&quot; 1 another-fruit</span><br><span class="line">1) &quot;apple&quot;</span><br><span class="line">2) &quot;banana&quot;</span><br><span class="line">3) &quot;cherry&quot;</span><br></pre></td></tr></table></figure><h4 id="创建redis-pcall函数的错误报告辅助函数"><a href="#创建redis-pcall函数的错误报告辅助函数" class="headerlink" title="创建redis.pcall函数的错误报告辅助函数"></a>创建redis.pcall函数的错误报告辅助函数</h4><p>在这一步，服务器将为Lua环境创建一个名为__redis__err__handler的错误处理函数，当脚本调用redis.pcall函数执行Redis命令，并且被执行的命令出现错误时，__redis__err__handler就会打印出错代码的来源和发生错误的行数，为程序的调试提供方便。</p><h4 id="保护Lua的全局环境"><a href="#保护Lua的全局环境" class="headerlink" title="保护Lua的全局环境"></a>保护Lua的全局环境</h4><p>在这一步，服务器将对Lua环境中的全局环境进行保护，确保传入服务器的脚本不会因为忘记使用local关键字而将额外的全局变量添加到Lua环境里面。</p><p>不过Redis并未禁止用户修改已存在的全局变量，所以在执行Lua脚本的时候，必须非常小心，以免错误地修改了已存在的全局变量。</p><h4 id="将Lua环境保存到服务器状态的lua属性里面"><a href="#将Lua环境保存到服务器状态的lua属性里面" class="headerlink" title="将Lua环境保存到服务器状态的lua属性里面"></a>将Lua环境保存到服务器状态的lua属性里面</h4><p>经过以上的一系列修改，Redis服务器对Lua环境的修改工作到此就结束了，在最后的这一步，服务器会将Lua环境和服务器状态的lua属性关联起来。</p><p><img src="/..%5Cimg%5CRedis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%5C%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%8A%B6%E6%80%81%E4%B8%AD%E7%9A%84Lua%E7%8E%AF%E5%A2%83.png" alt="服务器状态中的Lua环境"></p><p>因为Redis使用串行化的方式来执行Redis命令，所以在任何特定时间里，最多都只会有一个脚本能够被放进Lua环境里面运行，因此，整个Redis服务器只需要创建一个Lua环境即可。</p><h3 id="Lua环境协作组件"><a href="#Lua环境协作组件" class="headerlink" title="Lua环境协作组件"></a>Lua环境协作组件</h3><p>除了创建并修改Lua环境之外，Redis服务器还创建了两个用于与Lua环境进行协作的组件，它们分别是负责执行Lua脚本中的Redis命令的伪客户端，以及用于保存Lua脚本的lua_scripts字典。</p><h4 id="伪客户端"><a href="#伪客户端" class="headerlink" title="伪客户端"></a>伪客户端</h4><p>因为执行Redis命令必须有相应的客户端状态，所以为了执行Lua脚本中包含的Redis命令，Redis服务器专门为Lua环境创建了一个伪客户端，并由这个伪客户端负责处理Lua脚本中包含的所有Redis命令。</p><p>Lua脚本使用redis.call函数或者redis.pcall函数执行一个Redis命令，需要完成以下步骤：</p><ol><li>Lua环境将redis.call函数或者redis.pcall函数想要执行的命令传给伪客户端。</li><li>伪客户端将脚本想要执行的命令传给命令执行器。</li><li>命令执行器执行伪客户端传给它的命令，并将命令的执行结果返回给伪客户端。</li><li>伪客户端接收命令执行器返回的命令结果，并将这个命令结果返回给Lua环境。</li><li>Lua环境在接收到命令结果之后，将该结果返回给redis.call函数或者redis.pcall函数。</li><li>接收到结果的redis.call函数或者redis.pcall函数会将命令结果作为函数返回值返回给脚本中的调用者。</li></ol><p><img src="/..%5Cimg%5CRedis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%5CLua%E8%84%9A%E6%9C%AC%E6%89%A7%E8%A1%8CRedis%E5%91%BD%E4%BB%A4%E6%97%B6%E7%9A%84%E9%80%9A%E4%BF%A1%E6%AD%A5%E9%AA%A4.png" alt="Lua脚本执行Redis命令时的通信步骤"></p><h4 id="lua-scripts字典"><a href="#lua-scripts字典" class="headerlink" title="lua_scripts字典"></a>lua_scripts字典</h4><p>除了伪客户端之外，Redis服务器为Lua环境创建的另一个协作组件是lua_scripts字典，这个字典的键为某个Lua脚本的SHA1校验和（checksum），而字典的值则是SHA1校验和对应的Lua脚本：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span> &#123;</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">dict *lua_scripts;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Redis服务器会将所有被EVAL命令执行过的Lua脚本，以及所有被SCRIPT LOAD命令载入过的Lua脚本都保存到lua_scripts 字典里面。</p><p>lua_scripts字典有两个作用，一个是实现SCRIPT EXISTS命令，另一个是实现脚本复制功能。</p><h3 id="EVAL命令的实现"><a href="#EVAL命令的实现" class="headerlink" title="EVAL命令的实现"></a>EVAL命令的实现</h3><p>EVAL命令的执行过程可以分为以下三个步骤：</p><ol><li>根据客户端给定的Lua脚本，在 Lua环境中定义一个Lua函数。</li><li>将客户端给定的脚本保存到lua_scripts字典，等待将来进一步使用。</li><li>执行刚刚在Lua环境中定义的函数，以此来执行客户端给定的Lua脚本。</li></ol><p>以下三个小节将以：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; EVAL &quot;return &#x27;hello world&#x27;&quot; 0</span><br><span class="line">&quot;hello world&quot;</span><br></pre></td></tr></table></figure><p>命令为示例，分别介绍EVAL命令执行的三个步骤。</p><h4 id="定义脚本函数"><a href="#定义脚本函数" class="headerlink" title="定义脚本函数"></a>定义脚本函数</h4><p>当客户端向服务器发送EVAL命令，要求执行某个Lua脚本的时候，服务器首先要做的就是在Lua环境中，为传入的脚本定义一个与这个脚本相对应的Lua函数，其中，Lua函数的名字由f_前缀加上脚本的SHA1校验和（四十个字符长）组成，而函数的体（body）则是脚本本身。<br>举个例子，对于命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EVAL &quot;return &#x27;hello world&#x27;&quot; 0</span><br></pre></td></tr></table></figure><p>来说，服务器将在Lua环境中定义以下函数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function f_5332031c6b470dc5a0dd9b4bf2030dea6d65de91()</span><br><span class="line">return &#x27;hello world&#x27;</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>因为客户端传入的脚本为return ‘hello world ‘，而这个脚本的SHA1校验和为5332031c6b470dc5a0dd9b4bf2030dea6d65de91，所以函数的名字为f_5332031c6b470dc5a0dd9b4bf2030dea6d65de91，而函数的体则为return ‘hello world ‘。</p><p>使用函数来保存客户端传入的脚本有以下好处：</p><ul><li>执行脚本的步骤非常简单，只要调用与脚本相对应的函数即可。</li><li>通过函数的局部性来让Lua环境保持清洁，减少了垃圾回收的工作量，并且避免了使用全局变量。</li><li>如果某个脚本所对应的函数在Lua环境中被定义过至少一次，那么只要记得这个脚本的SHA1校验和，服务器就可以在不知道脚本本身的情况下，直接通过调用Lua函数来执行脚本，这是EVALSHA命令的实现原理。</li></ul><h4 id="将脚本保存到lua-scripts字典"><a href="#将脚本保存到lua-scripts字典" class="headerlink" title="将脚本保存到lua_scripts字典"></a>将脚本保存到lua_scripts字典</h4><p>EVAL命令要做的第二件事是将客户端传入的脚本保存到服务器的lua_scripts字典里面。举个例子，对于命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EVAL &quot;return &#x27;hello worid&#x27;&quot; 0</span><br></pre></td></tr></table></figure><p>来说，服务器将在lua_scripts字典中新添加一个键值对，其中键为Lua脚本的SHA1校验和：</p><p>5332031c6b470dc5a0dd9b4bf2030dea6d65de91</p><p>而值则为Lua脚本本身：</p><p>return ‘hello world’</p><h4 id="执行脚本函数"><a href="#执行脚本函数" class="headerlink" title="执行脚本函数"></a>执行脚本函数</h4><p>在为脚本定义函数，并且将脚本保存到lua_scripts字典之后，服务器还需要进行一些设置钩子、传入参数之类的准备动作，才能正式开始执行脚本。</p><p>整个准备和执行脚本的过程如下：</p><ol><li>将EVAL命令中传入的键名（key name）参数和脚本参数分别保存到KEYS数组和ARGV数组，然后将这两个数组作为全局变量传入到Lua环境里面。</li><li>为Lua环境装载超时处理钩子（hook），这个钩子可以在脚本出现超时运行情况时，让客户端通过SCRIPT KILL命令停止脚本，或者通过SHUTDOWN命令直接关闭服务器。</li><li>执行脚本函数。</li><li>移除之前装载的超时钩子。</li><li>将执行脚本函数所得的结果保存到客户端状态的输出缓冲区里面，等待服务器将结果返回给客户端。</li><li>对Lua环境执行垃圾回收操作。</li></ol><h3 id="EVALSHA命令的实现"><a href="#EVALSHA命令的实现" class="headerlink" title="EVALSHA命令的实现"></a>EVALSHA命令的实现</h3><p>本章前面介绍EVAL命令的实现时说过，每个被EVAL命令成功执行过的Lua脚本，在Lua环境里面都有一个与这个脚本相对应的Lua函数，函数的名字由f_前缀加上40个字符长的SHA1校验和组成，例如f_5332031c6b470dc5a0dd9b4bf2030dea6d65de91。</p><p>只要脚本对应的函数曾经在Lua环境里面定义过，那么即使不知道脚本的内容本身，客户端也可以根据脚本的SHA1校验和来调用脚本对应的函数，从而达到执行脚本的目的，这就是EVALSHA命令的实现原理。</p><p>可以用伪代码来描述这一原理：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">def EVALSHA(sha1):</span><br><span class="line">#拼接出函数的名字</span><br><span class="line">#例如:f_5332031c6b470dc5a0dd9b4bf2030dea6d65de91func name = &quot;f_&quot;+ sha1</span><br><span class="line">#查看这个函数在Lua环境中是否存在</span><br><span class="line">if function_exists_in_lua_env(func_name):</span><br><span class="line">#如果函数存在，那么执行它</span><br><span class="line">execute_lua_function(func_name)</span><br><span class="line">else:</span><br><span class="line">#如果函数不存在，那么返回一个错误</span><br><span class="line">send_script_error(&quot;SCRIPT NOT FOUND&quot;)</span><br></pre></td></tr></table></figure><h3 id="脚本管理命令的实现"><a href="#脚本管理命令的实现" class="headerlink" title="脚本管理命令的实现"></a>脚本管理命令的实现</h3><p>除了EVAL命令和EVALSHA命令之外，Redis中与Lua脚本有关的命令还有四个，它们分别是SCRIPT FLUSH命令、SCRIPT EXISTS命令、SCRIPT LOAD命令、以及SCRIPT KILL命令。</p><h4 id="SCRIPT-FLUSH"><a href="#SCRIPT-FLUSH" class="headerlink" title="SCRIPT FLUSH"></a>SCRIPT FLUSH</h4><p>SCRIPT FLUSH命令用于清除服务器中所有和Lua脚本有关的信息，这个命令会释放并重建lua_scripts字典，关闭现有的Lua环境并重新创建一个新的Lua环境。</p><p>以下为SCRIPT FLUSH命令的实现伪代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">def SCRIPT_FLUSH():</span><br><span class="line">#释放脚本字典</span><br><span class="line">dictRelease(server.lua_scripts)</span><br><span class="line">#重建脚本字典</span><br><span class="line">server.lua_scripts = dictCreate(...)</span><br><span class="line">#关闭Lua环境</span><br><span class="line">lua_close(server.lua)</span><br><span class="line">#初始化一个新的Lua环境</span><br><span class="line">server.lua = init_lua_env()</span><br></pre></td></tr></table></figure><h4 id="SCRIPT-EXISTS"><a href="#SCRIPT-EXISTS" class="headerlink" title="SCRIPT EXISTS"></a>SCRIPT EXISTS</h4><p>SCRIPT EXISTS命令根据输入的SHA1校验和，检查校验和对应的脚本是否存在于服务器中。</p><p>SCRIPT EXISTS命令是通过检查给定的校验和是否存在于lua_scripts字典来实现的，以下是该命令的实现伪代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">def SCRIPT_EXISTS(*sha1_list):</span><br><span class="line">#结果列表</span><br><span class="line">result_list = []</span><br><span class="line">#遍历输入的所有SHA1校验和</span><br><span class="line">for sha1 in sha1_list:</span><br><span class="line">#检查校验和是否为lua_scripts字典的键</span><br><span class="line">#如果是的话，那么表示校验和对应的脚本存在</span><br><span class="line">#否则的话，脚本就不存在</span><br><span class="line">if sha1 in server.lua_scripts:</span><br><span class="line">#存在用1表示</span><br><span class="line">result_list.append(1)</span><br><span class="line">else:</span><br><span class="line">#不存在用0表示</span><br><span class="line">result_list.append(0)</span><br><span class="line">#向客户端返回结果列表</span><br><span class="line">send_list_reply(result_list)</span><br></pre></td></tr></table></figure><p>实现SCRIPT EXISTS实际上并不需要lua_scripts字典的值。如果lua_scripts字典只用于实现SCRIPT EXISTS命令的话，那么字典只需要保存Lua脚本的SHA1校验和就可以了，并不需要保存Lua脚本本身。lua_scripts字典既保存脚本的SHA1校验和，又保存脚本本身的原因是为了实现脚本复制功能。</p><h4 id="SCRIPT-LOAD"><a href="#SCRIPT-LOAD" class="headerlink" title="SCRIPT LOAD"></a>SCRIPT LOAD</h4><p>SCRIPT LOAD命令所做的事情和EVAL命令执行脚本时所做的前两步完全一样：命令首先在Lua环境中为脚本创建相对应的函数，然后再将脚本保存到lua_scripts字典里面。完成了这些步骤之后，客户端就可以使用EVALSHA命令来执行前面被SCRIPT LOAD命令载入的脚本了。</p><h4 id="SCRIPT-KILL"><a href="#SCRIPT-KILL" class="headerlink" title="SCRIPT KILL"></a>SCRIPT KILL</h4><p>如果服务器设置了lua-time-limit配置选项，那么在每次执行Lua脚本之前，服务器都会在Lua环境里面设置一个超时处理钩子（hook）。</p><p>超时处理钩子在脚本运行期间，会定期检查脚本已经运行了多长时间，一旦钩子发现脚本的运行时间已经超过了lua-time-limit选项设置的时长，钩子将定期在脚本运行的间隙中，查看是否有SCRIPT KILL命令或者SHUTDOWN命令到达服务器。</p><p>如果超时运行的脚本未执行过任何写入操作，那么客户端可以通过SCRIPTKILL命令来指示服务器停止执行这个脚本，并向执行该脚本的客户端发送一个错误回复。处理完SCRIPT KILL命令之后，服务器可以继续运行。</p><p>另一方面，如果脚本已经执行过写入操作，那么客户端只能用SHUTDOWN nosave命令来停止服务器，从而防止不合法的数据被写入数据库中。</p><h3 id="脚本复制"><a href="#脚本复制" class="headerlink" title="脚本复制"></a>脚本复制</h3><p>与其他普通Redis命令一样，当服务器运行在复制模式之下时，具有写性质的脚本命令也会被复制到从服务器，这些命令包括EVAL命令、EVALSHA命令、SCRIPT FLUSH命令，以及SCRIPT LOAD命令。</p><h4 id="复制EVAL命令、SCRIPT-FLUSH命令和SCRIPT-LOAD命令"><a href="#复制EVAL命令、SCRIPT-FLUSH命令和SCRIPT-LOAD命令" class="headerlink" title="复制EVAL命令、SCRIPT FLUSH命令和SCRIPT LOAD命令"></a>复制EVAL命令、SCRIPT FLUSH命令和SCRIPT LOAD命令</h4><p>Redis复制EVAL、SCRIPT FLUSH、SCRIPT LOAD三个命令的方法和复制其他普通Redis命令的方法一样，当主服务器执行完以上三个命令的其中一个时，主服务器会直接将被执行的命令传播（propagate）给所有从服务器，如下图所示。</p><p><img src="/..%5Cimg%5CRedis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%5C%E5%B0%86%E8%84%9A%E6%9C%AC%E5%91%BD%E4%BB%A4%E4%BC%A0%E6%92%AD%E7%BB%99%E4%BB%8E%E6%9C%8D%E5%8A%A1%E5%99%A8.png" alt="将脚本命令传播给从服务器"></p><h5 id="EVAL"><a href="#EVAL" class="headerlink" title="EVAL"></a>EVAL</h5><p>对于EVAL命令来说，在主服务器执行的Lua脚本同样会在所有从服务器中执行。</p><p>主服务器在执行这个EVAL命令之后，将向所有从服务器传播这条EVAL命令，从服务器会接收并执行这条EVAL命令，最终结果是，主从服务器双方都会执行该脚本并将脚本保存在脚本字典里面。</p><h5 id="SCRIPT-FLUSH-1"><a href="#SCRIPT-FLUSH-1" class="headerlink" title="SCRIPT FLUSH"></a>SCRIPT FLUSH</h5><p>如果客户端向主服务器发送SCRIPT FLUSH命令，那么主服务器也会向所有从服务器传播SCRIPT FLUSH命令。<br>最终的结果是，主从服务器双方都会重置自己的Lua环境，并清空自己的脚本字典。</p><h5 id="SCRIPT-LOAD-1"><a href="#SCRIPT-LOAD-1" class="headerlink" title="SCRIPT LOAD"></a>SCRIPT LOAD</h5><p>如果客户端使用SCRIPT LOAD命令，向主服务器载人一个Lua脚本，那么主服务器将向所有从服务器传播相同的SCRIPTLOAD命令，使得所有从服务器也会载人相同的Lua脚本。</p><p>最终的结果是，主从服务器双方都会载入脚本。</p><h4 id="复制EVALSHA命令"><a href="#复制EVALSHA命令" class="headerlink" title="复制EVALSHA命令"></a>复制EVALSHA命令</h4><p>EVALSHA命令是所有与Lua脚本有关的命令中，复制操作最复杂的一个，因为主服务器与从服务器载入Lua脚本的情况可能有所不同，所以主服务器不能像复制EVAL命令、SCRIPT LOAD命令或者SCRIPT FLUSH命令那样，直接将EVALSHA命令传播给从服务器。对于一个在主服务器被成功执行的EVALSHA命令来说，相同的EVALSHA命令在从服务器执行时却可能会出现脚本未找到（not found）错误。</p><p>举个例子，假设现在有一个主服务器master，如果客户端向主服务器发送命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">master&gt; SCRIPT LOAD &quot;return &#x27;hello world&#x27;&quot;</span><br><span class="line">&quot;5332031c6b470dc5a0dd9b4bf2030dea6d65de91&quot;</span><br></pre></td></tr></table></figure><p>那么在执行这个SCRIPT LOAD命令之后，SHA1值为5332031c6b470dc5a0dd9b4bf2030dea6d65de91的脚本就存在于主服务器中了。</p><p>现在，假设一个从服务器slave1开始复制主服务器master，如果master不想办法将脚本：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;return &#x27;hello world&#x27;&quot;</span><br></pre></td></tr></table></figure><p>传送给slave1载入的话，那么当客户端向主服务器发送命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">master&gt; EVALSHA &quot;5332031c6b470dc5a0dd9b4bf2030dea6d65de91&quot; 0</span><br><span class="line">&quot;hello world&quot;</span><br></pre></td></tr></table></figure><p>的时候，master将成功执行这个EVALSHA命令，而当master将这个命令传播给slave1执行的时候，slave1却会出现脚本未找到错误：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">slave1&gt; EVALSHA &quot;5332031c6b470dc5a0dd9b4bf2030dea6d65de91&quot; 0</span><br><span class="line">(error) NOSCRIPT No matching script. Please use EVAL.</span><br></pre></td></tr></table></figure><p>更为复杂的是，因为多个从服务器之间载入Lua脚本的情况也可能各有不同，所以即使一个 EVALSHA命令可以在某个从服务器成功执行，也不代表这个EVALSHA命令就一定可以在另一个从服务器成功执行。</p><p>举个例子，假设有主服务器master和从服务器slave1，并且slave1一直复制着master，所以master载入的所有Lua脚本，slave1也有载入（通过传播EVAL命令或者SCRIPT LOAD命令来实现)。</p><p>例如说，如果客户端向master发送命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">master&gt; SCRIPT LOAD &quot;return &#x27;hello world&#x27;&quot;</span><br><span class="line">&quot;5332031c6b470dc5a0dd9b4bf2030dea6d65de91&quot;</span><br></pre></td></tr></table></figure><p>那么这个命令也会被传播到slave1上面，所以master和slave1都会成功载人SHA1校验和为5332031c6b470dc5a0dd9b4bf2030dea6d65de91的Lua脚本。</p><p>如果这时，一个新的从服务器slave2开始复制主服务器master，如果master不想办法将脚本：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;return &#x27;hello world&#x27;&quot;</span><br></pre></td></tr></table></figure><p>传送给slave2的话，那么当客户端向主服务器发送命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">master&gt; EVALSHA &quot;5332031c6b470dc5a0dd9b4bf2030dea6d65de91&quot; 0</span><br><span class="line">&quot;hello world&quot;</span><br></pre></td></tr></table></figure><p>的时候，master和slave1都将成功执行这个EVALSHA命令，而slave2却会发生脚本未找到错误。</p><p>为了防止以上假设的情况出现，Redis要求主服务器在传播EVALSHA命令的时候，必须确保EVALSHA命令要执行的脚本已经被所有从服务器载入过，如果不能确保这一点的话，主服务器会将EVALSHA命令转换成一个等价的EVAL命令，然后通过传播EVAL命令来代替EVALSHA命令。</p><p>传播EVALSHA命令，或者将EVALSHA命令转换成EVAL命令，都需要用到服务器状态的lua_scripts字典和repl_scriptcache_dict字典。</p><h5 id="判断传播EVALSHA命令是否安全的方法"><a href="#判断传播EVALSHA命令是否安全的方法" class="headerlink" title="判断传播EVALSHA命令是否安全的方法"></a>判断传播EVALSHA命令是否安全的方法</h5><p>主服务器使用服务器状态的repl_scriptcache_dict字典记录自己已经将哪些脚本传播给了所有从服务器：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span> &#123;</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">dict *repl_scriptcache_dict;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>repl_scriptcache_dict字典的键是一个个Lua脚本的SHA1校验和，而字典的值则全部都是NULL，当一个校验和出现在repl_scriptcache_dict字典时，说明这个校验和对应的Lua脚本已经传播给了所有从服务器，主服务器可以直接向从服务器传播包含这个SHA1校验和的EVALSHA命令，而不必担心从服务器会出现脚本未找到错误。</p><p>另一方面，如果一个脚本的SHA1校验和存在于lua_scripts字典，但是却不存在于repl_scriptcache_dict字典，那么说明校验和对应的Lua脚本已经被主服务器载人，但是并没有传播给所有从服务器，如果我们尝试向从服务器传播包含这个SHA1校验和的EVALSHA命令，那么至少有一个从服务器会出现脚本未找到错误。</p><h5 id="清空repl-scriptcache-dict字典"><a href="#清空repl-scriptcache-dict字典" class="headerlink" title="清空repl_scriptcache_dict字典"></a>清空repl_scriptcache_dict字典</h5><p>每当主服务器添加一个新的从服务器时，主服务器都会清空自己的repl_scriptcache_dict字典，这是因为随着新从服务器的出现，repl_scriptcache_dict字典里面记录的脚本已经不再被所有从服务器载入过，所以主服务器会清空repl_scriptcache_dict字典，强制自己重新向所有从服务器传播脚本，从而确保新的从服务器不会出现脚本未找到错误。</p><h5 id="EVALSHA命令转换成EVAL命令的方法"><a href="#EVALSHA命令转换成EVAL命令的方法" class="headerlink" title="EVALSHA命令转换成EVAL命令的方法"></a>EVALSHA命令转换成EVAL命令的方法</h5><p>通过使用EVALSHA命令指定的SHA1校验和，以及lua_scripts字典保存的Lua脚本，服务器总可以将一个EVALSHA命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EVALSHA &lt;sha1&gt; &lt;numkeys&gt; [key...] [arg...]</span><br></pre></td></tr></table></figure><p>转换成一个等价的EVAL命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EVAL &lt;script&gt; &lt;numkeys&gt; [key...] [arg...]</span><br></pre></td></tr></table></figure><p>具体的转换方法如下：</p><ol><li>根据SHA1校验和sha1，在lua_scripts字典中查找sha1对应的Lua脚本script。</li><li>将原来的EVALSHA命令请求改写成EVAL命令请求，并且将校验和sha1改成脚本script，至于numkeys、key、arg等参数则保持不变。</li></ol><p>如果一个SHA1值所对应的Lua脚本没有被所有从服务器载入过，那么主服务器可以将EVALSHA命令转换成等价的EVAL命令，然后通过传播等价的EVAL命令来代替原本想要传播的EVALSHA命令，以此来产生相同的脚本执行效果，并确保所有从服务器都不会出现脚本未找到错误。</p><p>另外，因为主服务器在传播完EVAL命令之后，会将被传播脚本的SHA1校验和（也即是原本EVALSHA命令指定的那个校验和）添加到repl_scriptcache_dict字典里面，如果之后EVALSHA命令再次指定这个SHA1校验和，主服务器就可以直接传播EVALSHA命令，而不必再次对EVALSHA命令进行转换。</p><h5 id="传播EVALSHA命令的方法"><a href="#传播EVALSHA命令的方法" class="headerlink" title="传播EVALSHA命令的方法"></a>传播EVALSHA命令的方法</h5><p>当主服务器成功在本机执行完一个EVALSHA命令之后，它将根据EVALSHA命令指定的SHA1校验和是否存在于repl_scriptcache_dict字典来决定是向从服务器传播EVALSHA命令还是EVAL命令：</p><ol><li>如果EVALSHA命令指定的SHA1校验和存在于repl_scriptcache_dict字典，那么主服务器直接向从服务器传播EVALSHA命令。</li><li>如果EVALSHA命令指定的SHA1校验和不存在于repl_scriptcache_dict字典，那么主服务器会将EVALSHA命令转换成等价的EVAL命令，然后传播这个等价的EVAL命令，并将EVALSHA命令指定的SHA1校验和添加到repl_scriptcache_dict字典里面。</li></ol><p><img src="/..%5Cimg%5CRedis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%5C%E4%B8%BB%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%88%A4%E6%96%AD%E4%BC%A0%E6%92%ADEVAL%E8%BF%98%E6%98%AFEVALSHA%E7%9A%84%E8%BF%87%E7%A8%8B.png" alt="主服务器判断传播EVAL还是EVALSHA的过程"></p><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><p>Redis的SORT命令可以对列表键、集合键或者有序集合键的值进行排序。</p><h3 id="SORT-lt-key-gt-命令的实现"><a href="#SORT-lt-key-gt-命令的实现" class="headerlink" title="SORT &lt;key&gt;命令的实现"></a>SORT &lt;key&gt;命令的实现</h3><p>SORT命令的最简单执行形式为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SORT &lt;key&gt;</span><br></pre></td></tr></table></figure><p>这个命令可以对一个包含数字值的键key进行排序。</p><p>以下示例展示了如何使用SORT命令对一个包含三个数字值的列表键进行排序：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; RPUSH numbers 3 1 2</span><br><span class="line">(integer) 3</span><br><span class="line"></span><br><span class="line">redis&gt; SORT numbers</span><br><span class="line">1) &quot;1&quot;</span><br><span class="line">2) &quot;2&quot;</span><br><span class="line">3) &quot;3&quot;</span><br></pre></td></tr></table></figure><p>服务器执行SORT numbers命令的详细步骤如下：</p><ol><li>创建一个和numbers列表长度相同的数组，该数组的每个项都是一个redis.h&#x2F;redissortObject结构，如图21-1所示。</li><li>遍历数组，将各个数组项的obj指针分别指向numbers列表的各个项，构成obj指针和列表项之间的一对一关系，如图21-2所示。</li><li>遍历数组，将各个obj指针所指向的列表项转换成一个double类型的浮点数，并将这个浮点数保存在相应数组项的u.score属性里面，如图21-3所示。</li><li>根据数组项u.score属性的值，对数组进行数字值排序，排序后的数组项按u.score属性的值从小到大排列，如图21-4所示。</li><li>遍历数组，将各个数组项的obj指针所指向的列表项作为排序结果返回给客户端，程序首先访问数组的索引0，返回u.score值为1.0的列表项”1”；然后访问数组的索引1，返回u.score值为2.0的列表项”2”；最后访问数组的索引2，返回u.score值为3.0的列表项”3”。</li></ol><p>其他sORT <key>命令的执行步骤也和这里给出的SORT numbers命令的执行步骤类似。</p><p><img src="/..%5Cimg%5CRedis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%5CredisSortObject%E6%95%B0%E7%BB%84.png" alt="redisSortObject数组.png"></p><p><img src="/..%5Cimg%5CRedis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%5C%E5%B0%86obj%E6%8C%87%E9%92%88%E6%8C%87%E5%90%91%E5%88%97%E8%A1%A8%E7%9A%84%E5%90%84%E4%B8%AA%E9%A1%B9.png" alt="将obj指针指向列表的各个项.png"></p><p><img src="/..%5Cimg%5CRedis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%5C%E8%AE%BE%E7%BD%AE%E6%95%B0%E7%BB%84%E9%A1%B9%E7%9A%84u.score%E5%B1%9E%E6%80%A7.png" alt="设置数组项的u.score属性"></p><p><img src="/..%5Cimg%5CRedis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%5C%E6%8E%92%E5%BA%8F%E5%90%8E%E7%9A%84%E6%95%B0%E7%BB%84.png" alt="排序后的数组"></p><p>以下是redisSortObject结构的完整定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">redisSortObject</span> &#123;</span></span><br><span class="line"><span class="comment">//被排序键的值</span></span><br><span class="line">robj *obj;</span><br><span class="line"><span class="comment">//权重</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line"><span class="comment">//排序数字值时使用</span></span><br><span class="line">        <span class="type">double</span> score;</span><br><span class="line"><span class="comment">//排序带有BY选项的字符串值时使用</span></span><br><span class="line">        robj *cmpobj;</span><br><span class="line">&#125; u;</span><br><span class="line">&#125; redisSortObject;</span><br></pre></td></tr></table></figure><p>SORT命令为每个被排序的键都创建一个与键长度相同的数组，数组的每个项都是一个redisSortObject结构，根据SORT命令使用的选项不同，程序使用redisSortObject结构的方式也不同。</p><h3 id="ALPHA选项的实现"><a href="#ALPHA选项的实现" class="headerlink" title="ALPHA选项的实现"></a>ALPHA选项的实现</h3><p>通过使用ALPHA选项，SORT命令可以对包含字符串值的键进行排序：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SORT &lt;key&gt; ALPHA</span><br></pre></td></tr></table></figure><p>以下命令展示了如何使用SORT命令对一个包含三个字符串值的集合键进行排序：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SADD fruits apple banana cherry</span><br><span class="line">(integer) 3</span><br><span class="line"></span><br><span class="line">#元素在集合中是乱序存放的</span><br><span class="line">redis&gt; SMEMBERS fruits</span><br><span class="line">1) &quot;apple&quot;</span><br><span class="line">2) &quot;cherry&quot;</span><br><span class="line">3) &quot;banana&quot;</span><br><span class="line"></span><br><span class="line">#对fruits键进行字符串排序</span><br><span class="line">redis&gt; SORT fruits ALPHA</span><br><span class="line">1) &quot;apple&quot;</span><br><span class="line">2) &quot;banana&quot;</span><br><span class="line">3) &quot;cherry&quot;</span><br></pre></td></tr></table></figure><p>服务器执行SORT fruits ALPHA命令的详细步骤如下：</p><ol><li>创建一个redisSortObject结构数组，数组的长度等于fruits集合的大小。</li><li>遍历数组，将各个数组项的obj指针分别指向fruits集合的各个元素，如图21-5所示。</li><li>根据obj指针所指向的集合元素，对数组进行字符串排序，排序后的数组项按集合元素的字符串值从小到大排列：因为”apple”、”banana”、 “cherry”三个字符串的大小顺序为”apple”&lt;”banana”&lt;”cherry”，所以排序后数组的第一项指向”apple”元素，第二项指向”banana”元素，第三项指向”cherry”元素，如图21-6所示。</li><li>遍历数组，依次将数组项的obj指针所指向的元素返回给客户端。</li></ol><p>其他SORT &lt;key&gt; ALPHA命令的执行步骤也和这里给出的SORT fruits ALPHA命令的执行步骤类似。</p><p>![sort alpha示例](..\img\Redis设计与实现\sort alpha示例.png)</p><h3 id="ASC选项和DESC选项"><a href="#ASC选项和DESC选项" class="headerlink" title="ASC选项和DESC选项"></a>ASC选项和DESC选项</h3><p>在默认情况下，SORT命令执行升序排序，排序后的结果按值的大小从小到大排列，以下两个命令是完全等价的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SORT &lt;key&gt;</span><br><span class="line">SORT &lt;key&gt; ASC</span><br></pre></td></tr></table></figure><p>相反地，在执行SORT命令时使用DESC选项，可以让命令执行降序排序，让排序后的结果按值的大小从大到小排列：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SORT &lt;key&gt; DESC</span><br></pre></td></tr></table></figure><p>升序排序和降序排序都由相同的快速排序算法执行，它们之间的不同之处在于：</p><ul><li>在执行升序排序时，排序算法使用的对比函数产生升序对比结果。</li><li>而在执行降序排序时，排序算法所使用的对比函数产生降序对比结果。</li></ul><p>因为升序对比和降序对比的结果正好相反，所以它们会产生元素排列方式正好相反的两种排序结果。</p><h3 id="BY选项的实现"><a href="#BY选项的实现" class="headerlink" title="BY选项的实现"></a>BY选项的实现</h3><p>在默认情况下，SORT命令使用被排序键包含的元素作为排序的权重，元素本身决定了元素在排序之后所处的位置。</p><p>例如，在下面这个例子里面，排序fruits集合所使用的权重就是”apple”、”banana”、”cherry”三个元素本身：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SADD fruits &quot;apple&quot; &quot;banana&quot; &quot;cherry&quot;</span><br><span class="line">(integer) 3</span><br><span class="line">redis&gt; SORT fruits ALPHA</span><br><span class="line">1) &quot;apple&quot;</span><br><span class="line">2) &quot;banana&quot;</span><br><span class="line">3) &quot;cherry&quot;</span><br></pre></td></tr></table></figure><p>另一方面，通过使用BY选项，SORT命令可以指定某些字符串键或者某个哈希键所包含的某些域（field）来作为元素的权重，对一个键进行排序。</p><p>例如，以下这个例子就使用苹果、香蕉、樱桃三种水果的价钱，对集合键fruits进行了排序：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; MSET apple-price 8 banana-price 5.5 cherry-price 7</span><br><span class="line">OK</span><br><span class="line">redis&gt; SORT fruits BY *-price</span><br><span class="line">1) &quot;banana&quot;</span><br><span class="line">2) &quot;cherry”</span><br><span class="line">3) &quot;apple&quot;</span><br></pre></td></tr></table></figure><p>服务器执行SORT fruits BY *-price命令的详细步骤如下：</p><ol><li>创建一个redisSortObject结构数组，数组的长度等于fruits集合的大小。</li><li>遍历数组，将各个数组项的obj指针分别指向fruits集合的各个元素，如图21-9所示。</li><li>遍历数组，根据各个数组项的obj指针所指向的集合元素，以及BY选项所给定的模式*-price，查找相应的权重键：<ul><li>对于”apple”元素，查找程序返回权重键”apple-price”。</li><li>对于”banana”元素，查找程序返回权重键”banana-price”。</li><li>对于”cherry”元素，查找程序返回权重键”cherry-price”。</li></ul></li><li>将各个权重键的值转换成一个double类型的浮点数，然后保存在相应数组项的u.score属性里面，如图21-10所示：<ul><li>“apple”元素的权重键”apple-price”的值转换之后为8.0。</li><li>“banana”元素的权重键”banana-price”的值转换之后为5.5。</li><li>“cherry”元素的权重键”cherry-price”的值转换之后为7.0。</li></ul></li><li>以数组项u.score属性的值为权重，对数组进行排序，得到一个按u.score属性的值从小到大排序的数组,如图21-11所示：<ul><li>权重为5.5的”banana”元素位于数组的索引0位置上。</li><li>权重为7.0的”cherry”元素位于数组的索引1位置上。</li><li>权重为8.0的”apple”元素位于数组的索引2位置上。</li></ul></li><li>遍历数组，依次将数组项的obj指针所指向的集合元素返回给客户端。</li></ol><p>其他SORT &lt;key&gt; BY &lt;pattern&gt;命令的执行步骤也和这里给出的步骤类似。</p><p><img src="/..%5Cimg%5CRedis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%5CBY%E6%8E%92%E5%BA%8F%EF%BC%881%EF%BC%89.png" alt="BY排序（1）"></p><p><img src="/..%5Cimg%5CRedis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%5CBY%E6%8E%92%E5%BA%8F%EF%BC%882%EF%BC%89.png" alt="BY排序（2）"></p><p><img src="/..%5Cimg%5CRedis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%5CBY%E6%8E%92%E5%BA%8F%EF%BC%883%EF%BC%89.png" alt="BY排序（3）"></p><h3 id="带有ALPHA选项的BY选项的实现"><a href="#带有ALPHA选项的BY选项的实现" class="headerlink" title="带有ALPHA选项的BY选项的实现"></a>带有ALPHA选项的BY选项的实现</h3><p>BY选项默认假设权重键保存的值为数字值，如果权重键保存的是字符串值的话，那么就需要在使用BY选项的同时，配合使用ALPHA选项。</p><p>服务器执行SORT fruits BY *-id ALPHA命令的详细步骤如下：</p><ol><li>创建一个redisSortObject结构数组，数组的长度等于fruits集合的大小。</li><li>遍历数组，将各个数组项的obj指针分别指向fruits集合的各个元素。</li><li>遍历数组，根据各个数组项的obj指针所指向的集合元素，以及BY选项所给定的模式*-id，查找相应的权重键。</li><li>将各个数组项的u.cmpobj指针分别指向相应的权重键（一个字符串对象）。</li><li>以各个数组项的权重键的值为权重，对数组执行字符串排序。</li><li>遍历数组，依次将数组项的obj指针所指向的集合元素返回给客户端。</li></ol><p>其他SORT &lt;key&gt; BY &lt;pattern&gt; ALPHA命令的执行步骤也和这里给出的步骤类似。</p><h3 id="LIMIT选项的实现"><a href="#LIMIT选项的实现" class="headerlink" title="LIMIT选项的实现"></a>LIMIT选项的实现</h3><p>在默认情况下，SORT命令总会将排序后的所有元素都返回给客户端。</p><p>但是，通过LIMIT选项，我们可以让SORT命令只返回其中一部分已排序的元素。LIMIT选项的格式为LIMIT &lt;offset&gt; &lt;count&gt;：</p><ul><li>offset参数表示要跳过的已排序元素数量。</li><li>count参数表示跳过给定数量的已排序元素之后，要返回的已排序元素数量。</li></ul><p>服务器执行SORT alphabet ALPHA LIMIT 0 4命令的详细步骤如下：</p><ol><li>创建一个redisSortObject结构数组，数组的长度等于alphabet集合的大小。</li><li>遍历数组，将各个数组项的obj指针分别指向alphabet集合的各个元素。</li><li>根据obj指针所指向的集合元素，对数组进行字符串排序。</li><li>根据选项LIMIT 0 4，将指针移动到数组的索引0上面，然后依次访问array [0]、array[1]、array[2]、array[3]这4个数组项，并将数组项的obj指针所指向的元素”a”、”b”、”c”、”d”返回给客户端。</li></ol><h3 id="GET选项的实现"><a href="#GET选项的实现" class="headerlink" title="GET选项的实现"></a>GET选项的实现</h3><p>在默认情况下，SORT命令在对键进行排序之后，总是返回被排序键本身所包含的元素。</p><p>但是，通过使用GET选项，我们可以让SORT命令在对键进行排序之后，根据被排序的元素，以及GET选项所指定的模式，查找并返回某些键的值。</p><p>服务器执行SORT students ALPHA GET*-name命令的详细步骤如下：</p><ol><li>创建一个redisSortObject结构数组，数组的长度等于students集合的大小。</li><li>遍历数组，将各个数组项的obj指针分别指向students集合的各个元素。</li><li>根据obj指针所指向的集合元素，对数组进行字符串排序。</li><li>遍历数组，根据数组项obj指针所指向的集合元素，以及GET选项所给定的*一name模式，查找相应的键。</li><li>遍历查找程序返回的三个键，并向客户端返回它们的值。</li></ol><p>因为一个SORT命令可以带有多个GET选项，所以随着GET选项的增多，命令要执行的查找操作也会增多。</p><p>SORT命令在执行其他带有GET选项的排序操作时，执行的步骤也和这里给出的步骤类似。</p><h3 id="STORE选项的实现"><a href="#STORE选项的实现" class="headerlink" title="STORE选项的实现"></a>STORE选项的实现</h3><p>在默认情况下，SORT命令只向客户端返回排序结果，而不保存排序结果。但是，通过使用STORE 选项，我们可以将排序结果保存在指定的键里面，并在有需要时重用这个排序结果。</p><p>服务器执行SORT students ALPHA STORE sorted_students命令的详细步骤如下：</p><ol><li>创建一个redisSortObject结构数组，数组的长度等于students集合的大小。</li><li>遍历数组，将各个数组项的obj指针分别指向students集合的各个元素。</li><li>根据obj指针所指向的集合元素，对数组进行字符串排序。</li><li>检查sorted_students键是否存在，如果存在的话，那么删除该键。</li><li>设置sorted_students为空白的列表键。</li><li>遍历数组，将排序后的三个元素”jack”、”peter”和”tom”依次推入sorted_students列表的末尾，相当于执行命令RPUSH sorted_students “jack”、”peter”、”tom”。</li><li>遍历数组，向客户端返回”jack”、”peter”、”tom”三个元素。</li></ol><p>SORT命令在执行其他带有STORE选项的排序操作时，执行的步骤也和这里给出的步骤类似。</p><h3 id="多个选项的执行顺序"><a href="#多个选项的执行顺序" class="headerlink" title="多个选项的执行顺序"></a>多个选项的执行顺序</h3><h4 id="选项的执行顺序"><a href="#选项的执行顺序" class="headerlink" title="选项的执行顺序"></a>选项的执行顺序</h4><p>如果按照选项来划分的话，一个SORT命令的执行过程可以分为以下四步：</p><ol><li>排序：在这一步，命令会使用ALPHA、ASC或DESC、BY这几个选项，对输入键进行排序，并得到一个排序结果集。</li><li>限制排序结果集的长度：在这一步，命令会使用LIMIT选项，对排序结果集的长度进行限制，只有LIMIT选项指定的那部分元素会被保留在排序结果集中。</li><li>获取外部键：在这一步，命令会使用GET选项，根据排序结果集中的元素，以及GET选项指定的模式，查找并获取指定键的值，并用这些值来作为新的排序结果集。</li><li>保存排序结果集：在这一步，命令会使用STORE选项，将排序结果集保存到指定的键上面去。</li><li>向客户端返回排序结果集：在最后这一步，命令遍历排序结果集，并依次向客户端返回排序结果集中的元素。</li></ol><p>在以上这些步骤中，后一个步骤必须在前一个步骤完成之后进行。</p><h4 id="选项的摆放顺序"><a href="#选项的摆放顺序" class="headerlink" title="选项的摆放顺序"></a>选项的摆放顺序</h4><p>另外要提醒的一点是，调用SORT命令时，除了GET选项之外，改变选项的摆放顺序并不会影响SORT命令执行这些选项的顺序。</p><p>例如，命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SORT &lt;key&gt; ALPHA DESC BY &lt;by-pattern&gt; LIMIT &lt;offset&gt; &lt;count&gt; GET &lt;get-pattern&gt; STORE &lt;store_key&gt;</span><br><span class="line"></span><br><span class="line">SORT &lt;key&gt; LIMIT &lt;offset&gt; &lt;count&gt; BY &lt;by-pattern&gt; ALPHA GET &lt;get-pattern&gt; STORE &lt;store_key&gt; DESC</span><br><span class="line"></span><br><span class="line">SORT &lt;key&gt; STORE &lt;store_key&gt; DESC BY &lt;by-pattern&gt; GET &lt;get-pattern&gt; ALPHA LIMIT &lt;offset&gt; &lt;count&gt;</span><br></pre></td></tr></table></figure><p>都产生完全相同的排序数据集。不过，如果命令包含了多个GET选项，那么在调整选项的位置时，我们必须保证多个GET选项的摆放顺序不变，这才可以让排序结果集保持不变。<br>例如，命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SORT &lt;key&gt; GET &lt;pattern-a&gt; GET &lt;pattern-b&gt; STORE &lt;store_key&gt;</span><br><span class="line"></span><br><span class="line">SORT &lt;key&gt; STORE &lt;store_key&gt; GET &lt;pattern-a&gt; GET &lt;pattern-b&gt;</span><br></pre></td></tr></table></figure><p>产生的排序结果集是完全一样的，但如果将两个GET选项的顺序调整一下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SORT &lt;key&gt; STORE &lt;store_key&gt; GET &lt;pattern-b&gt; GET &lt;pattern-a&gt;</span><br></pre></td></tr></table></figure><p>那么这个命令产生的排序结果集就会和前面两个命令产生的排序结果集不同。因此在调整SORT命令各个选项的摆放顺序时，必须小心处理GET选项。</p><h2 id="二进制位数组"><a href="#二进制位数组" class="headerlink" title="二进制位数组"></a>二进制位数组</h2><p>Redis提供了SETBIT、GETBIT、BITCOUNT、BITOP四个命令用于处理二进制位数组（bit array，又称“位数组”）。</p><p>其中，SETBIT命令用于为位数组指定偏移量上的二进制位设置值，位数组的偏移量从0开始计数，而二进制位的值则可以是0或者1：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SETBIT bit 0 1# 0000 0001</span><br><span class="line">(integer) 0</span><br><span class="line">redis&gt; SETBIT bit 3 1# 0000 1001</span><br><span class="line">(integer) 0</span><br><span class="line">redis&gt; SETBIT bit 0 0# 0000 1000</span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure><p>而GETBIT命令则用于获取位数组指定偏移量上的二进制位的值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; GETBIT bit 0# 0000 1000</span><br><span class="line">(integer) 0</span><br><span class="line">redis&gt; GETBIT bit 3 # 0000 1000</span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure><p>BITCOUNT命令用于统计位数组里面，值为1的二进制位的数量：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; BITCOUNT bit# 0000 1000</span><br><span class="line">(integer) 1</span><br><span class="line">redis&gt; SETBIT bit 0 1# 0000 1001</span><br><span class="line">(integer) 0</span><br><span class="line">redis&gt; BITCOUNT bit</span><br><span class="line">(integer) 2</span><br><span class="line">redis&gt; SETBIT bit 1 1# 0000 1011</span><br><span class="line">(integer) 0</span><br><span class="line">redis&gt; BITCOUNT bit</span><br><span class="line">(integer) 3</span><br></pre></td></tr></table></figure><p>最后，BITOP命令既可以对多个位数组进行按位与（and）、按位或（or）、按位异或（xor）运算：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SETBIT x 3 1# x = 0000 1011</span><br><span class="line">(integer) 0</span><br><span class="line">redis&gt; SETBIT x 1 1</span><br><span class="line">(integer) 0</span><br><span class="line">redis&gt; SETBIT x 0 1</span><br><span class="line">(integer) 0</span><br><span class="line">redis&gt; SETBIT y 2 1# y = 0000 0110</span><br><span class="line">(integer) 0</span><br><span class="line">redis&gt; SETBIT y 1 1</span><br><span class="line">(integer) 0</span><br><span class="line">redis&gt; SETBIT z 2 1# z = 0000 0101</span><br><span class="line">(integer) 0</span><br><span class="line">redis&gt; SETBIT z 0 1</span><br><span class="line">(integer) 0</span><br><span class="line">redis&gt; BITOP AND and-result x y z# 0000 0000</span><br><span class="line">(integer) 1</span><br><span class="line">redis&gt; BITOP OR or-result x y z# 0000 1111</span><br><span class="line">(integer) 1</span><br><span class="line">redis&gt; BITOP XOR xor-result x y z# 0000 1000</span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure><p>也可以对给定的位数组进行取反（not）运算：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SETBIT value 0 1# 0000 1001</span><br><span class="line">(integer) 0</span><br><span class="line">redis&gt; SETBIT value 3 1</span><br><span class="line">(integer) 0</span><br><span class="line">redis&gt; BITOP NOT not-value value # 1111 0110</span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure><p>本章将对Redis表示位数组的方法进行说明，并介绍GETBIT、SETBIT、BITCOUNT、BITOP四个命令的实现原理。</p><h3 id="位数组的表示"><a href="#位数组的表示" class="headerlink" title="位数组的表示"></a>位数组的表示</h3><p>Redis使用字符串对象来表示位数组，因为字符串对象使用的SDS数据结构是二进制安全的，所以程序可以直接使用SDS结构来保存位数组，并使用SDS结构的操作函数来处理位数组。</p><p>图22-1展示了用SDS表示的，一字节长的位数组：</p><ul><li>redisObject.type的值为REDIS_STRING，表示这是一个字符串对象。</li><li>sdshdr.len的值为1，表示这个SDS保存了一个一字节长的位数组。</li><li>buf数组中的buf[0]字节保存了一字节长的位数组。</li><li>buf数组中的buf [1]字节保存了SDS程序自动追加到值的末尾的空字符’\0’。</li></ul><p><img src="/..%5Cimg%5CRedis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%5CSDS%E4%BD%8D%E6%95%B0%E7%BB%84.png" alt="SDS位数组"></p><p>因为本章介绍的操作涉及二进制位，为了清晰地展示各个位的值，本章会对SDS中buf数组的展示方式进行一些修改，让各个字节的各个位都可以清楚地展现出来。比如说，本章会将前面图22-1展示的SDS值改成图22-2所示的样子。</p><p><img src="/..%5Cimg%5CRedis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%5C%E4%B8%80%E5%AD%97%E8%8A%82%E9%95%BF%E7%9A%84%E4%B8%BA%E6%95%B0%E7%BB%84%E7%9A%84SDS%E8%A1%A8%E7%A4%BA.png" alt="一字节长的为数组的SDS表示"></p><p>现在，buf数组的每个字节都用一行来表示，每行的第一个格子buf[i]表示这是buf数组的哪个字节，而buf[i]之后的八个格子则分别代表这一字节中的八个位。</p><p>需要注意的是，buf数组保存位数组的顺序和我们平时书写位数组的顺序是完全相反的，例如，在图22-2的buf[0]字节中，各个位的值分别是1、0、1、1、0、0、1、0，这表示buf[0]字节保存的位数组为0100 1101。使用逆序来保存位数组可以简化SETBIT命令的实现，详细的情况稍后在介绍SETBIT命令的实现原理时会说到。</p><p>图22-3展示了另一个位数组示例：</p><ul><li>sdshdr.len属性的值为3，表示这个SDS保存了一个三字节长的位数组。</li><li>位数组由buf数组中的buf[0]、buf[1]、buf[2]三个字节保存，和之前说明的一样，buf数组使用逆序来保存位数组：位数组1111 0000 1100 0011 1010 0101在buf数组中会被保存为1010 0101 1100 0011 0000 1111。</li></ul><p><img src="/..%5Cimg%5CRedis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%5C%E4%B8%89%E5%AD%97%E8%8A%82%E9%95%BF%E7%9A%84%E4%BD%8D%E6%95%B0%E7%BB%84%E7%9A%84SDS%E8%A1%A8%E7%A4%BA.png" alt="三字节长的位数组的SDS表示"></p><h3 id="GETBIT命令的实现"><a href="#GETBIT命令的实现" class="headerlink" title="GETBIT命令的实现"></a>GETBIT命令的实现</h3><p>GETBIT命令用于返回位数组bitarray在offset偏移量上的二进制位的值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GETBIT &lt;bitarray&gt; &lt;offset&gt;</span><br></pre></td></tr></table></figure><p>GETBIT命令的执行过程如下：</p><ol><li>计算byte&#x3D;⌊offset ÷ 8⌋,byte值记录了offset偏移量指定的二进制位保存在位数组的哪个字节。</li><li>计算bit&#x3D;(offset mod 8)+1，bit值记录了offset偏移量指定的二进制位是byte字节的第几个二进制位。</li><li>根据byte值和bit值，在位数组bitarray中定位offset偏移量指定的二进制位，并返回这个位的值。</li></ol><p>因为GETBIT命令执行的所有操作都可以在常数时间内完成，所以该命令的算法复杂度位O(1)。</p><h3 id="SETBIT命令的完成"><a href="#SETBIT命令的完成" class="headerlink" title="SETBIT命令的完成"></a>SETBIT命令的完成</h3><p>SETBIT用于将位数组bitarray在offset偏移量上的二进制位的值设置为value，并向客户端返回二进制位被设置之前的旧值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SETBIT &lt;bitarray&gt; &lt;offset&gt; &lt;value&gt;</span><br></pre></td></tr></table></figure><p>以下是SETBIT命令的执行过程：</p><ol><li>计算len &#x3D; ⌊offset ÷ 8⌋ + 1，len值记录了保存offset偏移量指定的二进制位至少需要多少字节。</li><li>检查bitarray键保存的位数组（也即是SDS）的长度是否小于len，如果是的话，将SDS的长度扩展为len字节，并将所有新扩展空间的二进制位的值设置为0。</li><li>计算byte &#x3D; ⌊offset ÷ 8⌋， byte值记录了offset偏移量指定的二进制位保存在位数组的哪个字节。</li><li>计算bit &#x3D; (offset mod 8) + 1，bit值记录了offset偏移量指定的二进制位是byte字节的第几个二进制位。</li><li>根据byte值和bit值，在bitarray键保存的位数组中定位offset偏移量指定的二进制位，首先将指定二进制位现在值保存在oldvalue变量，然后将新值value设置为这个二进制位的值。</li><li>向客户端返回oldvalue变量的值。</li></ol><p>因为SETBIT命令执行的所有操作都可以在常数时间内完成，所以该命令的时间复杂度为O(1)。</p><h4 id="带扩展操作的SETBIT命令示例"><a href="#带扩展操作的SETBIT命令示例" class="headerlink" title="带扩展操作的SETBIT命令示例"></a>带扩展操作的SETBIT命令示例</h4><p><img src="/..%5Cimg%5CRedis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%5C%E4%B8%80%E5%AD%97%E8%8A%82%E9%95%BF%E7%9A%84%E4%B8%BA%E6%95%B0%E7%BB%84%E7%9A%84SDS%E8%A1%A8%E7%A4%BA.png" alt="一字节长的为数组的SDS表示"><br>假设我们对上图所示的位数组执行命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SETBIT &lt;bitarray&gt; 12 1</span><br></pre></td></tr></table></figure><p>那么服务器将执行以下操作：</p><ol><li>计算⌊12 ÷ 8⌋ + 1，得出值2，这表示保存偏移量为12的二进制位至少需要2字节长的位数组。</li><li>对位数组的长度进行检查，得知位数组现在的长度为1字节，这比执行命令所需的最小长度2字节要小，所以程序会要求将位数组的长度扩展为2字节。不过，尽管程序只要求2字节长的位数组，但SDS的空间预分配策略会为SDS额外多分配2字节的未使用空间，再加上为保存空字符而额外分配的1字节，扩展之后buf数组的实际长度为5字节，如图22-8所示。</li><li>计算⌊12 ÷ 8⌋，得出值1，说明偏移量为12的二进制位位于buf[1]字节中。</li><li>计算(12 mod 8) + 1，得出值5，说明偏移量为12的二进制位是buf[1]字节的第5个二进制位。</li><li>定位到buf[1]字节的第5个二进制位，将二进制位现在的值0保存到oldvalue变量，然后将二进制位的值设置为1。</li><li>向客户端返回oldvalue变量的值0。</li></ol><p>图22-10则展示了SETBIT命令执行之后，位数组的样子。</p><p>注意，因为buf数组使用逆序来保存位数组，所以当程序对buf数组进行扩展之后，写入操作可以直接在新扩展的二进制位中完成，而不必改动位数组原来已有的二进制位。相反地，如果buf数组使用和书写位数组时一样的顺序来保存位数组，那么在每次扩展buf数组之后，程序都需要将位数组已有的位进行移动，然后才能执行写入操作，这比SETBIT命令目前的实现方式要复杂，并且移位带来的CPU时间消耗也会影响命令的执行速度。</p><p><img src="/..%5Cimg%5CRedis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%5C%E6%89%A9%E5%B1%95%E7%A9%BA%E9%97%B4%E4%B9%8B%E5%90%8E%E7%9A%84%E4%BD%8D%E6%95%B0%E7%BB%84.png" alt="扩展空间之后的位数组"></p><p><img src="/..%5Cimg%5CRedis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%5CSETBIT%E5%91%BD%E4%BB%A4%E4%B9%8B%E5%90%8E%E7%9A%84%E4%BD%8D%E6%95%B0%E7%BB%84.png" alt="SETBIT命令之后的位数组"></p><h3 id="BITCOUNT命令的实现"><a href="#BITCOUNT命令的实现" class="headerlink" title="BITCOUNT命令的实现"></a>BITCOUNT命令的实现</h3><p>BITCOUNT命令用于统计给定位数组中，值为1的二进制位的数量。</p><p>BITCOUNT命令要做的工作初看上去并不复杂，但实际上要高效地实现这个命令并不容易，需要用到一些精巧的算法。</p><p>接下来的几个小节将对BITCOUNT命令可能使用的几种算法进行介绍，并最终给出BITCOUNT命令的具体实现原理。</p><h4 id="二进制位统计算法（1）：遍历算法"><a href="#二进制位统计算法（1）：遍历算法" class="headerlink" title="二进制位统计算法（1）：遍历算法"></a>二进制位统计算法（1）：遍历算法</h4><p>实现BITCOUNT命令最简单直接的方法，就是遍历位数组中的每个二进制位，并在遇到值为1的二进制位时，将计数器的值增一。</p><p>遍历算法虽然实现起来简单，但效率非常低，因为这个算法在每次循环中只能检查一个二进制位的值是否为1，所以检查操作执行的次数将与位数组包含的二进制位的数量成正比。</p><p>例如，假设要检查的位数组的长度为100MB，那么按1MB &#x3D; 1 000 000 Byte &#x3D; 8 000 000bit来计算，使用遍历算法检查长度为100 MB的位数组将需要执行检查操作八亿次（100 * 8 000 000）！而对于长度为500MB的位数组来说，遍历算法将需要执行检查操作四十亿次！</p><p>尽管遍历算法对单个二进制位的检查可以在很短的时间内完成，但重复执行上亿次这种检查肯定不是一个高效程序应有的表现，为了让BITCOUNT命令的实现尽可能地高效，程序必须尽可能地增加每次检查所能处理的二进制位的数量，从而减少检查操作执行的次数。</p><h4 id="二进制位统计算法（2）：查表算法"><a href="#二进制位统计算法（2）：查表算法" class="headerlink" title="二进制位统计算法（2）：查表算法"></a>二进制位统计算法（2）：查表算法</h4><p>优化检查操作的一个办法是使用查表法：</p><ul><li>对于一个有限集合来说，集合元素的排列方式是有限的。</li><li>而对于一个有限长度的位数组来说，它能表示的二进制位排列也是有限的。</li></ul><p>根据这个原理，我们可以创建一个表，表的键为某种排列的位数组，而表的值则是相应位数组中，值为1的二进制位的数量。</p><p>创建了这种表之后，我们就可以根据输入的位数组进行查表，在无须对位数组的每个位进行检查的情况下，直接知道这个位数组包含了多少个值为1的二进制位。</p><p>举个例子，对于8位长的位数组来说，我们可以创建表格22-1，通过这个表格，我们可以一次从位数组中读入8个位，然后根据这8个位的值进行查表，直接知道这个值包含了多少个值为1的位。</p><p><img src="/..%5Cimg%5CRedis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%5C%E5%85%AB%E4%BD%8D%E4%BD%8D%E6%95%B0%E7%BB%84%E5%BB%BA%E8%A1%A8.png" alt="八位位数组建表"></p><p>通过使用表22-1，我们只需执行一次查表操作，就可以检查8个二进制位，和之前介绍的遍历算法相比,查表法的效率提升了8倍。</p><p>如果我们创建一个更大的表的话，那么每次查表所能处理的位就会更多，从而减少查表操作执行的次数。</p><p>初看起来，只要我们创建一个足够大的表，那么统计工作就可以轻易地完成，但这个问题实际上并没有那么简单，因为查表法的实际效果会受到内存和缓存两方面因素的限制：</p><ul><li>因为查表法是典型的空间换时间策略，算法在计算方面节约的时间是通过花费额外的内存换取而来的，节约的时间越多，花费的内存就越大。对于我们这里讨论的统计二进制位的问题来说，创建键长为8位的表仅需数百个字节，创建键长为16位的表也仅需数百个KB，但创建键长为32位的表却需要十多个GB。在实际中，服务器只可能接受数百个字节或者数百KB的内存消耗。</li><li>除了内存大小的问题之外，查表法的效果还会受到CPU缓存的限制：对于固定大小的CPU缓存来说，创建的表格越大，CPU缓存所能保存的内容相比整个表格的比例就越少，查表时出现缓存不命中（cache miss）的情况就会越高，缓存的换入和换出操作就会越频繁，最终影响查表法的实际效率。</li></ul><p>由于以上列举的两个原因，我们可以得出结论，查表法是一种比遍历算法更好的统计办法，但受限于查表法带来的内存压力，以及缓存不命中可能带来的影响，我们只能考虑创建键长为8位或者键长为16位的表，而这两种表带来的效率提升，对于处理非常长的位数组来说仍然远远不够。</p><p>为了高效地实现BITCOUNT命令，我们需要一种不会带来内存压力、并且可以在一次检查中统计多个二进制位的算法，接下来要介绍的variable-precision SWAR算法就是这样一种算法。</p><h4 id="二进制位统计算法（3）：variable-precision-SWAR算法"><a href="#二进制位统计算法（3）：variable-precision-SWAR算法" class="headerlink" title="二进制位统计算法（3）：variable-precision SWAR算法"></a>二进制位统计算法（3）：variable-precision SWAR算法</h4><p>BITCOUNT命令要解决的问题——统计一个位数组中非0二进制位的数量，在数学上被称为“计算汉明重量（Hamming Weight）”。</p><p>因为汉明重量经常被用于信息论、编码理论和密码学，所以研究人员针对计算汉明重量开发了多种不同的算法，一些处理器甚至直接带有计算汉明重量的指令，而对于不具备这种特殊指令的普通处理器来说，目前已知效率最好的通用算法为variable-precision SWAR算法，该算法通过一系列位移和位运算操作，可以在常数时间内计算多个字节的汉明重量，并且不需要使用任何额外的内存。</p><p>以下是一个处理32位长度位数组的variable-precision SWAR算法的实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">uint32_t</span> <span class="title function_">swar</span><span class="params">(<span class="type">uint32_t</span> i)</span> &#123;</span><br><span class="line"><span class="comment">//步骤1</span></span><br><span class="line">i = (i &amp; <span class="number">0x55555555</span>) + ((i &gt;&gt; <span class="number">1</span>) &amp; <span class="number">0x55555555</span>);</span><br><span class="line"><span class="comment">//步骤2</span></span><br><span class="line">i = (i &amp; <span class="number">0x33333333</span>) + ((i &gt;&gt; <span class="number">2</span>) &amp; <span class="number">0x33333333</span>);</span><br><span class="line"><span class="comment">//步骤3</span></span><br><span class="line">i = (i &amp; <span class="number">0x0F0F0F0F</span>) + ((i &gt;&gt; <span class="number">4</span>) &amp; <span class="number">0x0F0F0F0F</span>);</span><br><span class="line"><span class="comment">//步骤4</span></span><br><span class="line">i = (i * (<span class="number">0x01010101</span>) &gt;&gt; <span class="number">24</span>);</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下是调用swar (bitarray)的执行步骤：</p><ul><li>步骤1计算出的值i的二进制表示可以按每两个二进制位为一组进行分组，各组的十进制表示就是该组的汉明重量。</li><li>步骤2计算出的值i的二进制表示可以按每四个二进制位为一组进行分组，各组的十进制表示就是该组的汉明重量。</li><li>步骤3计算出的值i的二进制表示可以按每八个二进制位为一组进行分组，各组的十进制表示就是该组的汉明重量。</li><li>步骤4的i * 0x01010101语句计算出bitarray的汉明重量并记录在二进制位的最高八位，而&gt;&gt;24语句则通过右移运算，将bitarray的汉明重量移动到最低八位，得出的结果就是bitarray的汉明重量。</li></ul><p>举个例子，对于调用swar(0x3A70F21B)，程序在第一步将计算出值0x2560A116，这个值的每两个二进制位的十进制表示记录了0x3A70F21B每两个二进制位的汉明重量，如表22-2所示。</p><p><img src="/..%5Cimg%5CRedis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%5C%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%A4%E4%BD%8D%E5%88%86%E7%BB%84%E4%B8%8B%E7%9A%84%E6%B1%89%E6%98%8E%E9%87%8D%E9%87%8F.png" alt="二进制两位分组下的汉明重量.png"></p><p>之后，程序在第二步将计算出值0x22304113，这个值的每四个二进制位的十进制表示记录了0x3A70F21B每四个二进制位的汉明重量，如表22-3所示。</p><p><img src="/..%5Cimg%5CRedis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%5C%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%9B%9B%E4%BD%8D%E5%88%86%E7%BB%84%E4%B8%8B%E7%9A%84%E6%B1%89%E6%98%8E%E9%87%8D%E9%87%8F.png" alt="二进制四位分组下的汉明重量.png"></p><p>接下来，程序在第三步将计算出值0x4030504，这个值的每八个二进制位的十进制表示记录了0x3A70F21B每八个二进制位的汉明重量，如表22-4所示。</p><p><img src="/..%5Cimg%5CRedis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%5C%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%85%AB%E4%BD%8D%E5%88%86%E7%BB%84%E4%B8%8B%E7%9A%84%E6%B1%89%E6%98%8E%E9%87%8D%E9%87%8F.png" alt="二进制八位分组下的汉明重量.png"></p><p>在第四步，程序首先计算0x4030504 * 0x01010101 &#x3D; 0x100c0904，将汉明重量聚集到二进制位的最高八位。之后程序计算0x100c0904 &gt;&gt; 24，将汉明重量移动到低八位，最终得出值0x10，也即是十进制值16，这个值就是0x3A70F21B的汉明重量，如表22-6所示。</p><p><img src="/..%5Cimg%5CRedis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%5C%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%A7%BB%E4%BD%8D%E5%90%8E%E7%9A%84%E6%B1%89%E6%98%8E%E9%87%8D%E9%87%8F.png" alt="二进制移位后的汉明重量.png"></p><p>swar函数每次执行可以计算32个二进制位的汉明重量，它比之前介绍的遍历算法要快32倍，比键长为8位的查表法快4倍，比键长为16位的查表法快2倍，并且因为swar函数是单纯的计算操作，所以它无须像查表法那样，使用额外的内存。</p><p>另外，因为swar函数是一个常数复杂度的操作，所以我们可以按照自己的需要，在一次循环中多次执行swar，从而按倍数提升计算汉明重量的效率：</p><ul><li>例如，如果我们在一次循环中调用两次swar函数，那么计算汉明重量的效率就从之前的一次循环计算32位提升到了一次循环计算64位。</li><li>又例如，如果我们在一次循环中调用四次swar函数，那么一次循环就可以计算128个二进制位的汉明重量，这比每次循环只调用一次swar函数要快四倍！</li></ul><p>当然，在一个循环里执行多个swar调用这种优化方式是有极限的：一旦循环中处理的位数组的大小超过了缓存的大小，这种优化的效果就会降低并最终消失。</p><h4 id="二进制位统计算法（4）：Redis的实现"><a href="#二进制位统计算法（4）：Redis的实现" class="headerlink" title="二进制位统计算法（4）：Redis的实现"></a>二进制位统计算法（4）：Redis的实现</h4><p>BITCOUNT命令的实现用到了查表和variable-precision SWAR两种算法：</p><ul><li>查表算法使用键长为8位的表，表中记录了从0000 0000到1111 1111在内的所有二进制位的汉明重量。</li><li>至于variable-precision SWAR算法方面，BITCOUNT命令在每次循环中载入128个二进制位，然后调用四次32位variable-precision SWAR算法来计算这128个二进制位的汉明重量。</li></ul><p>在执行BITCOUNT命令时，程序会根据未处理的二进制位的数量来决定使用那种算法：</p><ul><li>如果未处理的二进制位的数量大于等于128位，那么程序使用variable-precision SWAR算法来计算二进制位的汉明重量。</li><li>如果未处理的二进制位的数量小于128位，那么程序使用查表算法来计算二进制位的汉明重量。</li></ul><p>以下伪代码展示了BITCOUNT命令的实现原理：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"># 一个表，记录了所有八位长位数组的汉明重量</span><br><span class="line"># 程序将8位长的位数组转换成无符号整数，并在表中进行索引</span><br><span class="line"># 例如，对于输入0000 0011，程序将二进制转换为无符号整数3</span><br><span class="line"># 然后取出weight_in_byte[3]的值2</span><br><span class="line"># 2就是0000 0011的汉明重量</span><br><span class="line">weight_in_byte = [0,1,1,2,1,2,2,/*...*/,7,7,8]</span><br><span class="line"></span><br><span class="line">def BITCOUNT(bits):</span><br><span class="line"># 计算位数组包含了多少个二进制位</span><br><span class="line">count = count_bit(bits)</span><br><span class="line"># 初始化汉明重量为零</span><br><span class="line">weight = 0</span><br><span class="line"># 如果未处理的二进制位大于等于128位</span><br><span class="line"># 那么使用variable-precision SWAR算法来处理</span><br><span class="line">while count &gt;= 128:</span><br><span class="line"># 四个swar调用，每个调用计算32个二进制位的汉明重量</span><br><span class="line"># 注意:bits[i:j]中的索引j是不包含在取值范围之内的</span><br><span class="line">weight += swar(bits[0:32])</span><br><span class="line">weight += swar(bits[32:64])</span><br><span class="line">weight += swar(bits[64:96])</span><br><span class="line">weight += swar(bits[96:128])</span><br><span class="line"></span><br><span class="line"># 移动指针，略过已处理的位，指向未处理的位</span><br><span class="line">bits = bits [128:]</span><br><span class="line"># 减少未处理位的长度</span><br><span class="line">count -= 128</span><br><span class="line"># 如果执行到这里,说明未处理的位数量不足128位</span><br><span class="line"># 那么使用查表法来计算汉明重量</span><br><span class="line">while count:</span><br><span class="line"># 将8个位转换成无符号整数，作为查表的索引(键)</span><br><span class="line">index = bits_to_unsigned_int(bits[0:8])</span><br><span class="line">weight += weight_in_byte[index]</span><br><span class="line"></span><br><span class="line"># 移动指针，略过已处理的位，指向未处理的位</span><br><span class="line">bits = bits[8:]</span><br><span class="line">#减少未处理位的长度</span><br><span class="line">count -= 8</span><br><span class="line"># 计算完毕，返回输入二进制位的汉明重量</span><br><span class="line">return weight</span><br></pre></td></tr></table></figure><p>这个BITCOUNT实现的算法复杂度为O(n)，其中n为输人二进制位的数量。</p><p>更具体一点，我们可以用以下公式来计算BITCOUNT命令在处理长度为n的二进制位输入时，命令中的两个循环需要执行的次数：</p><ul><li>第一个循环的执行次数可以用公式loop1 &#x3D; ⌊n ÷ 128⌋计算得出。</li><li>第二个循环的执行次数可以用公式loop2 &#x3D; n mod 128计算得出。</li></ul><p>以100 MB &#x3D; 800 000 000 bit来计算，BITCOUNT命令处理一个100 MB长的位数组共需要执行第一个循环六百二十五万次，第二个循环零次。以500 MB &#x3D; 4 000 000 000 bit来计算，BITCOUNT命令处理一个500 MB长的位数组共需要执行第一个循环三千一百二十五万次，第二个循环零次。</p><p>通过使用更好的算法，我们将计算100 MB和500 MB长的二进制位所需的循环次数从最开始使用遍历算法时的数亿甚至数十亿次减少到了数百万次和数千万次。</p><h3 id="BITOP命令的实现"><a href="#BITOP命令的实现" class="headerlink" title="BITOP命令的实现"></a>BITOP命令的实现</h3><p>因为C语言直接支持对字节执行逻辑与(&amp;)、逻辑或(|)、逻辑异或(^)和逻辑非(~)操作，所以BITOP命令的AND、OR、XOR和NOT四个操作都是直接基于这些逻辑操作实现的：</p><ul><li>在执行BITOP AND命令时，程序用&amp;操作计算出所有输人二进制位的逻辑与结果，然后保存在指定的键上面。</li><li>在执行BITOP OR命令时，程序用|操作计算出所有输入二进制位的逻辑或结果，然后保存在指定的键上面。</li><li>在执行BITOP XOR命令时，程序用^操作计算出所有输人二进制位的逻辑异或结果，然后保存在指定的键上面。</li><li>在执行BITOP NOT命令时，程序用～操作计算出输人二进制位的逻辑非结果，然后保存在指定的键上面。</li></ul><p>因为BITOP AND、BITOP OR、BITOP XOR三个命令可以接受多个位数组作为输人，程序需要遍历输人的每个位数组的每个字节来进行计算，所以这些命令的复杂度为o(n^2)；与此相反，因为BITOP NOT命令只接受一个位数组输入，所以它的复杂度为O(n)。</p><h2 id="慢查询日志"><a href="#慢查询日志" class="headerlink" title="慢查询日志"></a>慢查询日志</h2><p>Redis的慢查询日志功能用于记录执行时间超过给定时长的命令请求，用户可以通过这个功能产生的日志来监视和优化查询速度。</p><p>服务器配置有两个和慢查询日志相关的选项：</p><ul><li>slowlog-log-slower-than选项指定执行时间超过多少微秒（1秒等于1 000 000微秒）的命令请求会被记录到日志上。</li><li>slowlog-max-len选项指定服务器最多保存多少条慢查询日志。服务器使用先进先出的方式保存多条慢查询日志，当服务器存储的慢查询日志数量等于slowlog-max-len选项的值时，服务器在添加一条新的慢查询日志之前，会先将最旧的一条慢查询日志删除。</li></ul><h3 id="慢查询记录的保存"><a href="#慢查询记录的保存" class="headerlink" title="慢查询记录的保存"></a>慢查询记录的保存</h3><p>服务器状态中包含了几个和慢查询日志功能有关的属性：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span> &#123;</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//下一条慢查询日志的ID</span></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> slowlog_entry_id;</span><br><span class="line">    <span class="comment">//保存了所有慢查询日志的链表</span></span><br><span class="line">    <span class="built_in">list</span> *slowlog;</span><br><span class="line"><span class="comment">//服务器配置slowlog-log-slower-than选项的值</span></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> slowlog_log_slower_than;</span><br><span class="line"><span class="comment">//服务器配置slowlog-max-len选项的值</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> slowlog_max_len;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>slowlog_entry_id属性的初始值为0，每当创建一条新的慢查询日志时，这个属性的值就会用作新日志的id值，之后程序会对这个属性的值增一。</p><p>例如，在创建第一条慢查询日志时，slowlog_entry_id的值0会成为第一条慢查询日志的ID，而之后服务器会对这个属性的值增一；当服务器再创建新的慢查询日志的时候，slowlog_entry_id的值1就会成为第二条慢查润日志的ID，然石服务器再次对这个属性的值增一，以此类推。</p><p>slowlog链表保存了服务器中的所有慢查询日志，链表中的每个节点都保存了一个slowlogEntry结构，每个slowlogEntry结构代表一条慢查询日志：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">slowlogEntry</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//唯一标识符</span></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> id;</span><br><span class="line"><span class="comment">//命令执行时的时间，格式为UNIX时间戳</span></span><br><span class="line">    <span class="type">time_t</span> time;</span><br><span class="line"><span class="comment">//执行命令消耗的时间，以微秒为单位</span></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> duration;</span><br><span class="line"><span class="comment">//命令与命令参数</span></span><br><span class="line">robj **argv;</span><br><span class="line"><span class="comment">//命令与命令参数的数量</span></span><br><span class="line">    <span class="type">int</span> argc;</span><br><span class="line">    </span><br><span class="line">&#125; slowlogEntry;</span><br></pre></td></tr></table></figure><p><img src="/..%5Cimg%5CRedis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%5C%E6%85%A2%E6%9F%A5%E8%AF%A2%E6%97%A5%E5%BF%97%E7%BB%93%E6%9E%84%E7%A4%BA%E4%BE%8B.png" alt="慢查询日志结构示例"></p><h3 id="慢查询日志的阅览和删除"><a href="#慢查询日志的阅览和删除" class="headerlink" title="慢查询日志的阅览和删除"></a>慢查询日志的阅览和删除</h3><p>弄清楚了服务器状态的slowlog链表的作用之后，我们可以用以下伪代码来定义查看日志的SLOWLOG GET命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">def SLOWLOG_GET(number=None):</span><br><span class="line"></span><br><span class="line"># 用户没有给定number参数</span><br><span class="line"># 那么打印服务器包含的全部慢查询日志</span><br><span class="line">if number is None:</span><br><span class="line">number = SLOWLOG_LEN()</span><br><span class="line"></span><br><span class="line"># 遍历服务器中的慢查询日志</span><br><span class="line">for log in redisServer.slowlog:</span><br><span class="line">if number &lt;= 0:</span><br><span class="line"># 打印的日志数量已经足够，跳出循环</span><br><span class="line">break</span><br><span class="line">else:</span><br><span class="line"># 继续打印，将计数器的值减一</span><br><span class="line">number -= 1</span><br><span class="line"># 打印日志</span><br><span class="line">printLog(log)</span><br></pre></td></tr></table></figure><p>查看日志数量的SLOWLOG LEN命令可以用以下伪代码来定义：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">def SLOWLOG_LEN():</span><br><span class="line"># slowlog链表的长度就是慢查询日志的条目数量</span><br><span class="line">return len(redisServer.slowlog)</span><br></pre></td></tr></table></figure><p>另外，用于清除所有慢查询日志的SLOWLOG RESET命令可以用以下伪代码来定义：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def SLOWLOG_RESET():</span><br><span class="line"># 遍历服务器中的所有慢查询日志</span><br><span class="line">for log in redisServer.slowlog:</span><br><span class="line"># 删除日志</span><br><span class="line">deleteLog(log)</span><br></pre></td></tr></table></figure><h3 id="添加新日志"><a href="#添加新日志" class="headerlink" title="添加新日志"></a>添加新日志</h3><p>在每次执行命令的之前和之后，程序都会记录微秒格式的当前UNIX时间戳，这两个时间戳之间的差就是服务器执行命令所耗费的时长，服务器会将这个时长作为参数之一传给slowlogPushEntryIfNeeded函数，而slowlogPushEntryIfNeeded函数则负责检查是否需要为这次执行的命令创建慢查询日志，以下伪代码展示了这一过程：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 记录执行命令前的时间</span><br><span class="line">before = unixtime_now_in_us()</span><br><span class="line"># 执行命令</span><br><span class="line">execute_command(argv, argc, client)</span><br><span class="line"># 记录执行命令后的时间</span><br><span class="line">after = unixtime_now_in_us()</span><br><span class="line"># 检查是否需要创建新的慢查询日志</span><br><span class="line">slowlogPushEntryIfNeeded(argv, argc, before-after)</span><br></pre></td></tr></table></figure><p>slowlogPushEntryIfNeeded函数的作用有两个：</p><ol><li>检查命令的执行时长是否超过slowlog-log-slower-than选项所设置的时间，如果是的话，就为命令创建一个新的日志，并将新日志添加到slowlog链表的表头。</li><li>检查慢查询日志的长度是否超过slowlog-max-len选项所设置的长度，如果是的话，那么将多出来的日志从slowlog链表中删除掉。</li></ol><p>以下是slowlogPushEntryIfNeeded函数的实现代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">slowlogPushEntryIfNeeded</span><span class="params">(robj **argv, <span class="type">int</span> argc, <span class="type">long</span> <span class="type">long</span> duration)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//慢查询功能未开启，直接返回</span></span><br><span class="line"><span class="keyword">if</span> (server.slowlog_log_slower_than &lt; <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">//如果执行时间超过服务器设置的上限，那么将命令添加到慢查询日志</span></span><br><span class="line">    <span class="keyword">if</span> (duration &gt;= server.slowlog_log_slower_than)</span><br><span class="line"><span class="comment">//新日志添加到链表表头</span></span><br><span class="line">listAddNodeHead(server.slowlog, slowlogCreateEntry(argv, argc, duration));</span><br><span class="line"><span class="comment">//如果日志数量过多，那么进行删除</span></span><br><span class="line"><span class="keyword">while</span> (listLength(server.slowlog) &gt; server.slowlog_max_len)</span><br><span class="line">listDelNode(server.slowlog, listLast(server.slowlog));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="监视器"><a href="#监视器" class="headerlink" title="监视器"></a>监视器</h2><p>通过执行MONITOR命令，客户端可以将自己变为一个监视器，实时地接收并打印出服务器当前处理的命令请求的相关信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; MONITOR</span><br><span class="line">OK</span><br><span class="line">1378822099.421623 [0 127.0.0.1:56604] &quot;ING&quot;</span><br><span class="line">1378822105.089572 [0 127.0.0.1:56604] &quot;SET&quot; &quot;msg&quot; &quot;hello world&quot;</span><br><span class="line">1378822109.036925 [0 127.0.0.1:56604] &quot;SET&quot; &quot;number&quot; &quot;123&quot;</span><br><span class="line">1378822140.649496 [0 127.0.0.1:56604] &quot;SADD&quot; &quot;fruits&quot; &quot;Apple&quot; &quot;Banana&quot; &quot;Cherry&quot;</span><br><span class="line">1378822154.117160 [0 127.0.0.1:56604] &quot;EXPIRE&quot; &quot;msg&quot; &quot;10086&quot;</span><br><span class="line">1378822257.329412 [0 127.0.0.1:56604] &quot;KEYS&quot; &quot;*&quot;</span><br><span class="line">1378822258.690131 [0 127.0.0.1:56604] &quot;DBSIZE&quot;</span><br></pre></td></tr></table></figure><p>每当一个客户端向服务器发送一条命令请求时，服务器除了会处理这条命令请求之外，还会将关于这条命令请求的信息发送给所有监视器。</p><p><img src="/..%5Cimg%5CRedis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%5C%E5%8F%91%E9%80%81%E4%BF%A1%E6%81%AF%E7%BB%99%E7%9B%91%E8%A7%86%E5%99%A8.png" alt="发送信息给监视器"></p><h3 id="成为监视器"><a href="#成为监视器" class="headerlink" title="成为监视器"></a>成为监视器</h3><p>发送MONITOR命令可以让一个普通客户端变为一个监视器，该命令的实现原理可以用以下伪代码来实现：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def MONITOR()∶</span><br><span class="line"># 打开客户端的监视器标志</span><br><span class="line">client.flags |= REDIS_MONITOR</span><br><span class="line"># 将客户端添加到服务器状态的monitors链表的末尾</span><br><span class="line">server.monitors.append(client)</span><br><span class="line"># 向客户端返回OK</span><br><span class="line">send_reply(&quot;OK&quot;)</span><br></pre></td></tr></table></figure><h3 id="向监视器发送命令信息"><a href="#向监视器发送命令信息" class="headerlink" title="向监视器发送命令信息"></a>向监视器发送命令信息</h3><p>服务器在每次处理命令请求之前，都会调用replicationFeedMonitors函数，由这个函数将被处理的命令请求的相关信息发送给各个监视器。</p><p>以下是replicationFeedMonitors函数的伪代码定义，函数首先根据传入的参数创建信息，然后将信息发送给所有监视器：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">def replicationFeedMonitors(client, monitors, dbid, argv, argc):</span><br><span class="line"># 根据执行命令的客户端、当前数据库的号码、命令参数、命令参数个数等参数</span><br><span class="line"># 创建要发送给各个监视器的信息</span><br><span class="line">msg = create_message(client, dbid, argv, argc)</span><br><span class="line"># 遍历所有监视器</span><br><span class="line">for monitor in monitors:</span><br><span class="line"># 将信息发送给监视器</span><br><span class="line">send_message(monitor, msg)</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;Redis设计与实现&gt;第四部分，Redis相关独立功能的实现</summary>
    
    
    
    <category term="Redis设计与实现读书笔记" scheme="http://example.com/categories/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Redis" scheme="http://example.com/tags/Redis/"/>
    
    <category term="Redis设计与实现" scheme="http://example.com/tags/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/"/>
    
    <category term="独立功能的实现" scheme="http://example.com/tags/%E7%8B%AC%E7%AB%8B%E5%8A%9F%E8%83%BD%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    
    <category term="发布与订阅" scheme="http://example.com/tags/%E5%8F%91%E5%B8%83%E4%B8%8E%E8%AE%A2%E9%98%85/"/>
    
    <category term="事务" scheme="http://example.com/tags/%E4%BA%8B%E5%8A%A1/"/>
    
    <category term="Lua脚本" scheme="http://example.com/tags/Lua%E8%84%9A%E6%9C%AC/"/>
    
    <category term="排序" scheme="http://example.com/tags/%E6%8E%92%E5%BA%8F/"/>
    
    <category term="二进制位数组" scheme="http://example.com/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BD%8D%E6%95%B0%E7%BB%84/"/>
    
    <category term="慢查询日志" scheme="http://example.com/tags/%E6%85%A2%E6%9F%A5%E8%AF%A2%E6%97%A5%E5%BF%97/"/>
    
    <category term="监视器" scheme="http://example.com/tags/%E7%9B%91%E8%A7%86%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>&lt;Redis设计与实现&gt;第三部分</title>
    <link href="http://example.com/2022/08/28/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E7%AC%AC%E4%B8%89%E9%83%A8%E5%88%86/"/>
    <id>http://example.com/2022/08/28/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E7%AC%AC%E4%B8%89%E9%83%A8%E5%88%86/</id>
    <published>2022-08-27T16:00:00.000Z</published>
    <updated>2022-08-27T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="多机数据库的实现"><a href="#多机数据库的实现" class="headerlink" title="多机数据库的实现"></a>多机数据库的实现</h1><h2 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h2><p><img src="/..%5Cimg%5CRedis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%5C%E4%B8%BB%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%92%8C%E4%BB%8E%E6%9C%8D%E5%8A%A1%E5%99%A8.png" alt="主服务器和从服务器"></p><p>在Redis中，用户可以通过执行SLAVEOF命令或者设置slaveof选项，让一个服务器去复制（replicate）另一个服务器，我们称呼被复制的服务器为主服务器（master），而对主服务器进行复制的服务器则被称为从服务器（slave）。</p><p>进行复制中的主从服务器双方的数据库将保存相同的数据，概念上将这种现象称作“数据库状态一致”。</p><h3 id="旧版复制功能的实现"><a href="#旧版复制功能的实现" class="headerlink" title="旧版复制功能的实现"></a>旧版复制功能的实现</h3><p>Redis的复制功能分为同步（sync）和命令传播（command propagate）了两个操作：</p><ul><li>同步操作用于将从服务器的数据库状态更新至主服务器当前所处的数据库状态。</li><li>命令传播操作则用于在主服务器的数据库状态被修改，导致主从服务器的数据库状态出现不一致时，让主从服务器的数据库重新回到一致状态。</li></ul><h4 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h4><p>当客户端向从服务器发送SLAVEOF命令，要求从服务器复制主服务器时，从服务器首先需要执行同步操作。</p><p>从服务器对主服务器的同步操作需要通过向主服务器发送SYNC命令来完成，SYNC命令的执行步骤：</p><ol><li>从服务器向主服务器发送SYNC命令。</li><li>收到SYNC命令的主服务器执行BGSAVE命令，在后台生成一个RDB文件，并使用一个缓冲区记录从现在开始执行的所有写命令。</li><li>当主服务器的BGSAVE命令执行完毕时，主服务器会将BGSAVE命令生成的RDB文件发送给从服务器，从服务器接受并载入这个RDB文件，将自己的数据库状态更新至主服务器执行BGSAVE命令时的数据库状态。</li><li>主服务器将记录在缓冲区里面的所有写命令发送给从服务器，从服务器执行这些写命令，将自己的数据库状态更新至主服务器数据库当前所处的状态。</li></ol><p><img src="/..%5Cimg%5CRedis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%5C%E4%B8%BB%E4%BB%8E%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%89%A7%E8%A1%8CSYNC%E5%91%BD%E4%BB%A4%E6%97%B6%E7%9A%84%E9%80%9A%E4%BF%A1.png" alt="主从服务器执行SYNC命令时的通信"></p><h4 id="命令传播"><a href="#命令传播" class="headerlink" title="命令传播"></a>命令传播</h4><p>同步操作执行完毕之后，主从服务器两者的数据库达到一致状态，但这种一致并不是一成不变的，当主服务器上执行客户端发送的写命令时，主服务器数据库状态可能发生改变，因而导致主从服务器状态不一致。</p><p><img src="/..%5Cimg%5CRedis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%5C%E4%B8%BB%E4%BB%8E%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%80%E8%87%B4%E5%8F%98%E4%B8%8D%E4%B8%80%E8%87%B4.png" alt="主从服务器一致变不一致"></p><p>因此，为了让主从服务器再次回到一致状态，主服务器需要对从服务器执行命令传播操作：主服务器会将自己执行的写命令发送给从服务器执行，当从服务器执行了相同的写命令之后，主从服务器再次回到一致状态。</p><p><img src="/..%5Cimg%5CRedis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%5C%E5%91%BD%E4%BB%A4%E4%BC%A0%E6%92%AD.png" alt="命令传播"></p><h3 id="旧版复制功能的缺陷"><a href="#旧版复制功能的缺陷" class="headerlink" title="旧版复制功能的缺陷"></a>旧版复制功能的缺陷</h3><p>在Redis中，从服务器对主服务器的复制发生在以下两种情形中：</p><ul><li>初次复制：从服务器从前没有复制过任何主服务器，或者从服务器当前要复制的主服务器和上一次复制的主服务器不同。</li><li>断线后重复制：处于命令传播阶段的主从服务器因为网络原因而中断了复制，但从服务器通过自动重连接重新连上了主服务器，并继续复制主服务器。</li></ul><p>至于初次复制，旧版复制功能很好地完成了任务。但是对于断线后重复制，旧版复制功能的效率很低下：它本可以只将主服务器断连后所更新的那部分数据传输给从服务器即可重新完成一致，然而它却再次创建了整个主数据库的RDB文件传输给从数据库（即重新执行了一次SYNC命令）。</p><p>SYNC命令是一个非常耗费资源的操作：</p><p>每次执行SYNC命令，主从服务器需要执行以动作：</p><ol><li>主服务器需要执行BGSAVE命令来生成RDB文件，这个生成操作会耗费主服务器大量的 CPU、内存和磁盘I&#x2F;O资源。</li><li>主服务器需要将自己生成的RDB文件发送给从服务器，这个发送操作会耗费主从服务器大量的网络资源（带宽和流量），并对主服务器响应命令请求的时间产生影响。</li><li>接收到RDB文件的从服务器需要载入主服务器发来的RDB文件，并且在载入期间，从服务器会因为阻塞而没办法处理命令请求。</li></ol><p>因为SYNC命令是一个如此耗费资源的操作，所以Redis有必要保证在真正有需要时才执行SYNC命令。</p><h3 id="新版复制功能的实现"><a href="#新版复制功能的实现" class="headerlink" title="新版复制功能的实现"></a>新版复制功能的实现</h3><p>Redis从2.8版本开始，使用PSYNC命令代替SYNC命令来执行复制时的同步操作，以此解决旧版在处理断线重复制情况时的低效问题。</p><p>PSYNC命令在处理初次复制情况时和旧版一样，使用完整重同步（即主服务器创建并发送RDB文件，以及发送保存在缓冲区里的写命令）。而在处理断线后的重复制则使用更加有效率的重同步策略：如果条件允许，主服务器可以将主从服务奋连接断开期间执行的写命令发送给从服务器，从服务器只要接收并执行这些写命令，就可以将数据库更新至主服务器当前所处的状态。</p><p>PSYNC命令在处理断线重复制时显然比SYNC命令需要更少的资源：执行SYNC命令总是需要生成、传送和入整个RDB文件，而部分重同步只需要将从服务器缺少的写命令发送给从服务器执行就可以了。</p><p><img src="/..%5Cimg%5CRedis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%5C%E4%B8%BB%E4%BB%8E%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%89%A7%E8%A1%8C%E9%83%A8%E5%88%86%E9%87%8D%E5%90%8C%E6%AD%A5%E7%9A%84%E8%BF%87%E7%A8%8B.png" alt="主从服务器执行部分重同步的过程"></p><h3 id="部分重同步的实现"><a href="#部分重同步的实现" class="headerlink" title="部分重同步的实现"></a>部分重同步的实现</h3><p>部分重同步功能由以下三个部分构成：</p><ul><li>主服务器的复制偏移量和从服务器的复制偏移量（判断主从服务器是否一致以及从哪里开始恢复）。</li><li>主服务器的复制积压缓冲区（用于存放恢复所需的写命令）。</li><li>服务器的运行ID。</li></ul><h4 id="复制偏移量"><a href="#复制偏移量" class="headerlink" title="复制偏移量"></a>复制偏移量</h4><p>主从服务器会分别维护一个复制偏移量：</p><ul><li>主服务器每次向从服务器传播N个字节的数据时，就将自己的复制偏移量的值加上N。</li><li>从服务器每次收到主服务器传播来的N个字节的数据时，就将自己的复制偏移量的值加上N。</li></ul><p>因此，通过对比主从服务器的复制偏移量是否一致，程序可以很容易地直到主从服务器是否处于一致状态。</p><p>一致状态下的主从服务器偏移量状况：</p><p><img src="/..%5Cimg%5CRedis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%5C%E7%9B%B8%E5%90%8C%E5%81%8F%E7%A7%BB%E9%87%8F%E7%9A%84%E4%B8%BB%E4%BB%8E%E6%9C%8D%E5%8A%A1%E5%99%A8.png" alt="相同偏移量的主从服务器.png"></p><p>服务器A断线后的偏移量状况：</p><p><img src="/..%5Cimg%5CRedis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%5C%E6%9C%8D%E5%8A%A1%E5%99%A8A%E6%96%AD%E7%BA%BF%E5%90%8E%E7%9A%84%E5%81%8F%E7%A7%BB%E9%87%8F.png" alt="服务器A断线后的偏移量.png"></p><h4 id="复制积压缓冲区"><a href="#复制积压缓冲区" class="headerlink" title="复制积压缓冲区"></a>复制积压缓冲区</h4><p>复制积压缓冲区是由主服务器维护的一个固定长度先进先出队列，默认大小为1MB。</p><p>当主服务器进行命令传播时，它不仅会将写命令发送给所有从服务器，还会将写命令入队到复制积压缓冲区里。因此，主服务器地复制积压缓冲区内会保存着一部分最近传播的写命令，并且复制积压缓冲区会为队列中的每个字节记录相应的复制偏移量，如下图所示。</p><p><img src="/..%5Cimg%5CRedis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%5C%E5%A4%8D%E5%88%B6%E7%A7%AF%E5%8E%8B%E7%BC%93%E5%86%B2%E5%8C%BA%E7%9A%84%E6%9E%84%E9%80%A0.png" alt="复制积压缓冲区的构造.png"></p><p>当从服务器重新连上主服务器时，从服务器会通过PSYNC命令将自己的复制偏移量offset发送给主服务器，主服务器会根据这个复制偏移量来决定对从服务器执行何种同步操作：</p><ul><li>如果offset偏移量之后的数据（也即是偏移量offset+1开始的数据）仍然存在于复制积压缓冲区里面，那么主服务器将对从服务器执行部分重同步操作。</li><li>相反，如果offset偏移量之后的数据已经不存在于复制积压缓冲区，那么主服务器将对从服务器执行完整重同步操作。</li></ul><h5 id="复制积压缓冲区的大小需根据需要调整"><a href="#复制积压缓冲区的大小需根据需要调整" class="headerlink" title="复制积压缓冲区的大小需根据需要调整"></a>复制积压缓冲区的大小需根据需要调整</h5><p>Redis为复制积压缓冲区设置的默认大小为1MB，如果主服务器需要执行大量写命令，又或者主从服务器断线后重连接所需的时间比较长，那么这个大小也许并不合适。如果复制积压缓冲区的大小设置得不恰当，那么PSYNC命令的复制重同步模式就不能正常发挥作用，因此，正确估算和设置复制积压缓冲区的大小非常重要。</p><p>复制积压缓冲区的最小大小可以根据公式second * write_size_per_second来估算：</p><ul><li>其中second为从服务器断线后重新连接上主服务器所需的平均时间（以秒计算）。</li><li>而write_size_per_second则是主服务器平均每秒产生的写命令数据量（协议格式的写命令的长度总和）。</li></ul><h4 id="服务器运行ID"><a href="#服务器运行ID" class="headerlink" title="服务器运行ID"></a>服务器运行ID</h4><p>每个Redis服务器，不论主服务器还是从服务，都会有自己的运行ID（run ID）。运行ID在服务器启动时自动生成，由40个随机的十六进制字符组成，例如53b9b28df8042fdc9ab5e3fcbbbabff1d5dce2b3。</p><p>当从服务器对主服务器进行初次复制时，主服务器会将自己的运行ID传送给从服务器，而从服务器则会将这个运行ID保存起来。</p><p>当从服务器断线并重新连上一个主服务器时，从服务器将向当前连接的主服务器发送之前保存的运行ID：</p><ul><li>如果从服务器保存的运行ID和当前连接的主服务器的运行ID相同，那么说明从服务器断线之前复制的就是当前连接的这个主服务器，主服务器可以继续尝试执行部分重同步操作。</li><li>相反地，如果从服务器保存的运行ID和当前连接的主服务器的运行ID并不相同，那么说明从服务器断线之前复制的主服务器并不是当前连接的这个主服务器，主服务器将对从服务器执行完整重同步操作。</li></ul><h3 id="PSYNC命令的实现"><a href="#PSYNC命令的实现" class="headerlink" title="PSYNC命令的实现"></a>PSYNC命令的实现</h3><p><img src="/..%5Cimg%5CRedis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%5CPSYNC%E5%91%BD%E4%BB%A4%E7%9A%84%E6%89%A7%E8%A1%8C%E6%83%85%E5%86%B5.png" alt="PSYNC命令的执行情况.png"></p><h3 id="复制的实现（一次完整的例子）"><a href="#复制的实现（一次完整的例子）" class="headerlink" title="复制的实现（一次完整的例子）"></a>复制的实现（一次完整的例子）</h3><p>客户端通过向从服务器发送SLAVEOF命令，可以让一个从服务器去复制一个主服务器：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SLAVEOF <span class="operator">&lt;</span>master_ip<span class="operator">&gt;</span> <span class="operator">&lt;</span>master_port<span class="operator">&gt;</span></span><br></pre></td></tr></table></figure><p>以下以从服务器127.0.0.1:12345接收到命令：</p><p>SLAVEOF 127.0.0.1 6379</p><p>为例，讲解复制功能的详细实现。</p><h4 id="步骤1：设置主服务器的地址和端口"><a href="#步骤1：设置主服务器的地址和端口" class="headerlink" title="步骤1：设置主服务器的地址和端口"></a>步骤1：设置主服务器的地址和端口</h4><p>从服务器首先要做的是将客户端给定的主服务器的IP地址127.0.0.1以及端口6379保存到服务器状态的msterhost属性和msterport属性里面：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span> &#123;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 主服务器的地址</span></span><br><span class="line">    <span class="type">char</span> * masterhost;</span><br><span class="line">    <span class="comment">// 主服务器的端口</span></span><br><span class="line">    <span class="type">int</span> masterport;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SLAVEOF命令是一个异步命令，在完成masterhost属性和masterport属性的设置工作之后，从服务器将向发送SLAVEOF命令的客户端返回OK，表示复制指令已经被接收，而实际的复制工作将在OK返回之后才真正开始执行。</p><h4 id="步骤2：建立套接字连接"><a href="#步骤2：建立套接字连接" class="headerlink" title="步骤2：建立套接字连接"></a>步骤2：建立套接字连接</h4><p>在SLAVEOF命令执行之后，从服务器将根据命令所设置的IP地址和端口，创建连向主服务器的套接字连接。</p><p>如果从服务器创建的套接字能成功连接（connect）到主服务器，那么从服务器将为这个套接字关联一个专门用于处理复制工作的文件事件处理器，这个处理器将负责执行后续的复制工作，比如接收RDB文件，以及接收主服务器传播来的写命令，诸如此类。</p><p>而主服务器在接受（accept）从服务器的套接字连接之后，将为该套接字创建相应的客户端状态，并将从服务器看作是一个连接到主服务器的客户端来对待，这时从服务器将同时具有服务器（server）和客户端（client）两个身份：从服务奋可以向主服务器发送命令请求，而主服务器则会向从服务器返回命令回复。<strong>（从服务器是主服务器的客户端）</strong></p><h4 id="步骤3：发送PING命令"><a href="#步骤3：发送PING命令" class="headerlink" title="步骤3：发送PING命令"></a>步骤3：发送PING命令</h4><p>从服务器成为主服务器的客户端之后，做的第一件事就是向主服务器发送一个PING命令。</p><p>这个PING命令有两个作用：</p><ul><li>虽然主从服务器成功建立起了套接字连接，但双方并未使用该套接字进行过任何通信，通过发送PING命令可以检查套接字的读写状态是否正常。</li><li>因为复制工作接下来的几个步骤都必须在主服务器可以正常处理命令请求的状态下才能进行，通过发送PING命令可以检查主服务器能否正常处理命令请求。</li></ul><p><img src="/..%5Cimg%5CRedis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%5C%E4%BB%8E%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%8F%91%E9%80%81PING%E6%97%B6%E5%8F%AF%E8%83%BD%E9%81%87%E5%88%B0%E7%9A%84%E6%83%85%E5%86%B5.png" alt="从服务器发送PING时可能遇到的情况.png"></p><h4 id="步骤4：身份验证"><a href="#步骤4：身份验证" class="headerlink" title="步骤4：身份验证"></a>步骤4：身份验证</h4><p>从服务器在收到主服务器返回的”PONG”回复之后，下一步要做的就是决定是否进行身份验证：</p><ul><li>如果从服务器设置了masterauth选项，那么进行身份验证。</li><li>如果从服务器没有设置masterauth选项，那么不进行身份验证。</li></ul><p>在需要进行身份验证的情况下，从服务器将向主服务器发送一条AUTH命令，命令的参数为从服务器masterauth选项的值。（此时，主服务器也可能以requeirepass选项设置了密码）</p><p><img src="/..%5Cimg%5CRedis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%5C%E4%BB%8E%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%BA%AB%E4%BB%BD%E9%AA%8C%E8%AF%81%E5%8F%AF%E8%83%BD%E6%83%85%E5%86%B5.png" alt="从服务器身份验证可能情况.png"></p><h4 id="步骤5：发送端口信息"><a href="#步骤5：发送端口信息" class="headerlink" title="步骤5：发送端口信息"></a>步骤5：发送端口信息</h4><p>在身份验证步骤之后，从服务器将执行命令REPLCONF listening-port &lt;port-number&gt;，向主服务器发送从服务器的监听端口号。</p><p>主服务器在接收到这个命令之后，会将端口号记录在从服务器所对应的客户端状态的slave_listening_port属性中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisClient</span> &#123;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 从服务器的监听端口号</span></span><br><span class="line"><span class="type">int</span> slave_listening_port;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125; redisClient;</span><br></pre></td></tr></table></figure><h4 id="步骤6：同步"><a href="#步骤6：同步" class="headerlink" title="步骤6：同步"></a>步骤6：同步</h4><p>在这一步，从服务器将向主服务器发送PSYNC命令，执行同步操作，并将自己的数据库更新至主服务器数据库当前所处的状态。</p><p>值得一提的是，在同步操作执行之前，只有从服务器是主服务器的客户端，但是<strong>在执行同步操作之后，主服务器也会成为从服务器的客户端</strong>：</p><ul><li>如果PSYNC命令执行的是完整重同步操作，那么主服务器需要成为从服务器的客户端，才能将保存在缓冲区里面的写命令发送给从服务器执行。</li><li>如果PSYNC命令执行的是部分重同步操作，那么主服务器需要成为从服务器的客户端，才能向从服务器发送保存在复制积压缓冲区里面的写命令。</li></ul><p>因此，在同步操作执行之后，主从服务器双方都是对方的客户端，它们可以互相向对方发送命令请求，或者互相向对方返回命令回复。</p><p>正因为主服务器成为了从服务器的客户端，所以主服务器才可以通过发送写命令来改变从服务器的数据库状态，不仅同步操作需要用到这一点，这也是主服务器对从服务器执行命令传播操作的基础。</p><h4 id="步骤7：命令传播"><a href="#步骤7：命令传播" class="headerlink" title="步骤7：命令传播"></a>步骤7：命令传播</h4><p>当完成了同步之后，主从服务器就会进入命令传播阶段，这时主服务器只要一直将自己执行的写命令发送给从服务器，而从服务器只要一直接收并执行主服务器发来的写命令，就可以保证主从服务器一直保持一致了。</p><h3 id="心跳检测"><a href="#心跳检测" class="headerlink" title="心跳检测"></a>心跳检测</h3><p>在命令传播阶段，从服务器默认会以每秒一次的频率，向主服务器发送命令：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">REPLCONF ACK <span class="operator">&lt;</span>replication_offset<span class="operator">&gt;</span></span><br></pre></td></tr></table></figure><p>其中replication_offset是从服务器当前的复制偏移量。</p><p>发送 REPLCONF ACK命令对于主从服务器有三个作用：</p><ul><li>检测主从服务器的网络连接状态。</li><li>辅助实现min-slaves选项。</li><li>检测命令丢失。</li></ul><h4 id="检测主从服务器的网络连接状态"><a href="#检测主从服务器的网络连接状态" class="headerlink" title="检测主从服务器的网络连接状态"></a>检测主从服务器的网络连接状态</h4><p>主从服务器可以通过发送和接收REPLCONF ACK命令来检查两者之间的网络连接是否正常：如果主服务器超过一秒钟没有收到从服务器发来的REPLCONF ACK命令，那么主服务器就知道主从服务器之间的连接出现问题了。</p><h4 id="辅助实现min-slaves配置选项"><a href="#辅助实现min-slaves配置选项" class="headerlink" title="辅助实现min-slaves配置选项"></a>辅助实现min-slaves配置选项</h4><p>Redis 的min-slaves-to-write和min-slaves-max-lag两个选项可以防止主服务器在不安全的情况下执行写命令。</p><p>举个例子，如果我们向主服务器提供以下设置：</p><p>min-slaves-to-write 3<br>min-slaves-max-lag 10</p><p>那么在从服务器的数量少于3个，或者三个从服务器的延迟（lag）值都大于或等于10秒时，主服务器将拒绝执行写命令。</p><h4 id="检测命令丢失"><a href="#检测命令丢失" class="headerlink" title="检测命令丢失"></a>检测命令丢失</h4><p>如果因为网络故障，主服务器传播给从服务器的写命令在半路丢失，那么当从服务器向主服务器发送REPLCONF ACK命令时，主服务器将发觉从服务器当前的复制偏移量少于自己的复制偏移量，然后主服务器就会根据从服务器提交的复制偏移量，在复制积压缓冲区里面找到从服务器缺少的数据，并将这些数据重新发送给从服务器。</p><p>注意，主服务器向从服务器补发缺失数据这一操作的原理和部分重同步操作的原理非常相似，这两个操作的区别在于，补发缺失数据操作在主从服务器没有断线的情况下执行，而部分重同步操作则在主从服务器断线并重连之后执行。</p><h2 id="Sentinel"><a href="#Sentinel" class="headerlink" title="Sentinel"></a>Sentinel</h2><p>Sentinel（哨岗、哨兵）是Redis的高可用性解决方案：由一个或多个Sentinel实例（instance）组成的Sentinel系统可以监视任意多个主服务器，以及这些主服务器属下的所有从服务器，并在被监视的主服务器进入下线状态时，自动将下线主服务器属下的某个从服务器升级为新的主服务器，然后由新的主服务器代替已下线的主服务器继续处理命令请求。</p><h3 id="启动并初始化Sentinel"><a href="#启动并初始化Sentinel" class="headerlink" title="启动并初始化Sentinel"></a>启动并初始化Sentinel</h3><p>当一个Sentinel启动时，他需要执行以下步骤：</p><ol><li>初始化服务器</li><li>将普通Redis服务器使用的代码替换成Sentinel专用代码</li><li>初始化Sentinel状态</li><li>根据给定的配置文件，初始化Sentinel的监视主服务器列表</li><li>创建连向主服务器的网络连接</li></ol><h4 id="初始化服务器"><a href="#初始化服务器" class="headerlink" title="初始化服务器"></a>初始化服务器</h4><p>由于Sentinel本质上只是一个运行在特殊模式下的Redis服务器，所以启动Sentinel的第一步，就是初始化一个普通的Redis服务器。</p><p>不过，因为Sentinel执行的工作和普通Redis服务器执行的工作不同，所以Sentinel的初始化过程和普通Redis服务器的初始化过程并不完全相同。</p><p>Sentinel模式下Redis服务器主要功能的使用情况：</p><table><thead><tr><th>功能</th><th>使用情况</th></tr></thead><tbody><tr><td>数据库和键值对方面的命令，比如SET、DEL、FLUSHDB</td><td>不使用</td></tr><tr><td>事务命令，比如MULTI和WATCH</td><td>不使用</td></tr><tr><td>脚本命令，比如EVAL</td><td>不使用</td></tr><tr><td>RDB持久化命令，比如SAVE和BGSAVE</td><td>不使用</td></tr><tr><td>AOF持久化命令，比如BGREWRITEAOF</td><td>不使用</td></tr><tr><td>复制命令，比如SLAVEOF</td><td>Sentinel内部可以使用，但客户端不可以使用</td></tr><tr><td>发布与订阅命令，比如PUBLISH和SUBSCRIBE</td><td>SUBSCRIBE、PSUBSCRIBE、UNSUBSCRIBE、PUNSUBSCRIBE四个命令在Sentinel内部和客户端都可以使用，但PUBLISH命令只能在Sentinel内部使用</td></tr><tr><td>文件事件处理器（负责发送命令请求、处理命令回复）</td><td>Sentinel内部使用，但关联的文件事件处理器和普通Redis服务器不同</td></tr><tr><td>时间事件处理器（负责执行serverCron函数）</td><td>Sentinel内部使用，时间事件的处理器仍然是serverCron函数，serverCron函数会调用sentinel.c&#x2F;sentinelTimer函数，后者包含了Sentinel要执行的所有操作</td></tr></tbody></table><h4 id="使用Sentinel专用代码"><a href="#使用Sentinel专用代码" class="headerlink" title="使用Sentinel专用代码"></a>使用Sentinel专用代码</h4><p>启动Sentinel的第二个步骤就是将一部分普通Redis服务器使用的代码替换成Sentinel专用代码。比如说，普通Redis服务器使用redis.h&#x2F;REDIS_SERVERPORT常量的值作为服务器端口：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> REDIS_SERVERPORT 6379</span></span><br></pre></td></tr></table></figure><p>而Sentinel则使用sentinel.c&#x2F;REDIS_SENTINEL_PORT常量的值作为服务器端口：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> REDIS_SENTINEL_PORT 26379</span></span><br></pre></td></tr></table></figure><p>除此之外，普通Redis服务器使用redis.c&#x2F;redisCommandTable作为服务器的命令表：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisCommand</span> <span class="title">redisCommandTable</span>[] =</span> &#123;</span><br><span class="line">&#123; <span class="string">&quot;get&quot;</span>, getCommand, <span class="number">2</span>, <span class="string">&quot;r&quot;</span>, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">&#123; <span class="string">&quot;set&quot;</span>, setCommand, <span class="number">-3</span>, <span class="string">&quot;wm&quot;</span>, <span class="number">0</span>, noPreloadGetKeys, <span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;，</span><br><span class="line">&#123; <span class="string">&quot;setnx&quot;</span>, setnxCommand, <span class="number">3</span>, <span class="string">&quot;wm&quot;</span>, <span class="number">0</span>, noPreloadGetKeys, <span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#123; <span class="string">&quot;script&quot;</span>, scriptCommand, <span class="number">-2</span>, <span class="string">&quot;ras&quot;</span>, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">&#123; <span class="string">&quot;time&quot;</span>, timeCommand, <span class="number">1</span>, <span class="string">&quot;rR&quot;</span>, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">&#123; <span class="string">&quot;bitop&quot;</span>, bitopCommand, <span class="number">-4</span>, <span class="string">&quot;wm&quot;</span>, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="number">2</span>,<span class="number">-1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">&#123; <span class="string">&quot;bitcount&quot;</span>, bitcountCommand, <span class="number">-2</span>, <span class="string">&quot;r&quot;</span>, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而Sentinel则使用sentinel.c&#x2F;sentinelcmds作为服务器的命令表，并且其中的INFO命令会使用Sentinel模式下的专用实现sentinel.c&#x2F;sentinelInfoCommand函数，而不是普通Redis服务器使用的实现redis.c&#x2F;infoCommand函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisCommand</span> <span class="title">sentinelcmds</span> [] =</span> &#123;</span><br><span class="line">&#123;<span class="string">&quot;ping&quot;</span>, pingCommand, <span class="number">1</span>, <span class="string">&quot;&quot;</span>, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">&#123;<span class="string">&quot;sentinel&quot;</span>, sentinelCommand, <span class="number">-2</span>, <span class="string">&quot;&quot;</span>, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">&#123;<span class="string">&quot;subscribe&quot;</span>, subscribeCommand, <span class="number">-2</span>, <span class="string">&quot;&quot;</span>, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>),</span><br><span class="line">&#123;<span class="string">&quot;unsubscribe&quot;</span>, unsubscribeCommand, <span class="number">-1</span>, <span class="string">&quot;&quot;</span>, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">&#123;<span class="string">&quot;psubscribe&quot;</span>, psubscribeCommand, <span class="number">-2</span>, <span class="string">&quot;&quot;</span>, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">&#123;<span class="string">&quot;punsubscribe&quot;</span>, punsubscribeCommand, <span class="number">-1</span>, <span class="string">&quot;&quot;</span>, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">&#123;<span class="string">&quot;info&quot;</span>, sentinelInfoCommand, <span class="number">-1</span>, <span class="string">&quot;&quot;</span>, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>sentinelcmds命令表也解释了为什么在Sentinel模式下，Redis服务器不能执行诸如SET、DBSIZE、EVAL等等这些命令，因为服务器根本没有在命令表中载入这些命令。PING、SENTINEL、INFO、SUBSCRIBE、UNSUBSCRIBE、PSUBSCRIBE和 PUNSUBSCRIBE这七个命令就是客户端可以对Sentinel执行的全部命令了。</p><h4 id="初始化Sentinel状态"><a href="#初始化Sentinel状态" class="headerlink" title="初始化Sentinel状态"></a>初始化Sentinel状态</h4><p>在应用了Sentinel的专用代码之后，接下来，服务器会初始化一个sentinel.c&#x2F;sentinelstate结构（后面简称“Sentinel状态”)，这个结构保存了服务器中所有和Sentinel功能有关的状态（服务器的一般状态仍然由redis.h&#x2F;redisserver结构保存)：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sentinelState</span> &#123;</span></span><br><span class="line">    <span class="comment">//当前纪元，用于实现故障转移</span></span><br><span class="line"><span class="type">uint64_t</span> current_epoch;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//保存了所有被这个sentinel监视的主服务器</span></span><br><span class="line"><span class="comment">//字典的键是主服务器的名字</span></span><br><span class="line"><span class="comment">//字典的值则是一个指向sentinelRedisInstance结构的指针</span></span><br><span class="line">dict *masters;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//是否进入了TILT模式?</span></span><br><span class="line"><span class="type">int</span> tilt;</span><br><span class="line"><span class="comment">//目前正在执行的脚本的数量</span></span><br><span class="line"><span class="type">int</span> running_scripts;</span><br><span class="line"><span class="comment">//进入TILT模式的时间</span></span><br><span class="line"><span class="type">mstime_t</span> tilt_start_time;</span><br><span class="line">    <span class="comment">//最后一次执行时间处理器的时间</span></span><br><span class="line">    <span class="type">mstime_t</span> previous_time;</span><br><span class="line"><span class="comment">//一个FIFO队列，包含了所有需要执行的用户脚本</span></span><br><span class="line"><span class="built_in">list</span> *scripts_queue;    </span><br><span class="line">&#125; sentinel;</span><br></pre></td></tr></table></figure><h4 id="初始化Sentinel状态的masters属性"><a href="#初始化Sentinel状态的masters属性" class="headerlink" title="初始化Sentinel状态的masters属性"></a>初始化Sentinel状态的masters属性</h4><p>Sentinel状态中的master属性记录了所有被Sential监视的主服务器的相关信息，master是一个字典，其中：</p><ul><li>字典的键是被监视主服务器的名字。</li><li>字典的值则是呗监视主服务器对应的sentinel.c&#x2F;sentinelRedisInstance结构。</li></ul><p>每个sentinelRedisInstance结构代表一个被Sentinel监视的Redis服务器实例（instance），这个实例可以是主服务器、从服务器，或者另外一个Sentinel。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">sentinelRedisInstance</span> &#123;</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//标识值，记录了实例的类型，以及该实例的当前状态</span></span><br><span class="line"><span class="type">int</span> flags;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实例的名字</span></span><br><span class="line"><span class="comment">//主服务器的名字由用户在配置文件中设置</span></span><br><span class="line"><span class="comment">//从服务器以及Sentinel的名字由Sentinel自动设置</span></span><br><span class="line"><span class="comment">//格式为ip:port，例如&quot;127.0.0.1:26379&quot;</span></span><br><span class="line"><span class="type">char</span> *name;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实例的运行ID</span></span><br><span class="line"><span class="type">char</span> *runid;</span><br><span class="line"></span><br><span class="line"><span class="comment">//配置纪元，用于实现故障转移</span></span><br><span class="line"><span class="type">uint64_t</span> config_epoch;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实例的地址</span></span><br><span class="line">sentinelAddr *addr;</span><br><span class="line"></span><br><span class="line"><span class="comment">//SENTINEL down-after-milliseconds选项设定的值</span></span><br><span class="line"><span class="comment">//实例无响应多少毫秒之后才会被判断为主观下线(subjectively down)</span></span><br><span class="line"><span class="type">mstime_t</span> down_after_period;</span><br><span class="line"></span><br><span class="line"><span class="comment">//SENTINEL monitor &lt;master-name&gt;&lt;IP&gt;&lt;port&gt;&lt;quorum&gt;选项中的quorum参数</span></span><br><span class="line"><span class="comment">//判断这个实例为客观下线（objectively down）所需的支持投票数量</span></span><br><span class="line"><span class="type">int</span> quorum;</span><br><span class="line"></span><br><span class="line"><span class="comment">//SENTINEL parallel-syncs &lt;master-name&gt; &lt;number&gt;选项的值</span></span><br><span class="line"><span class="comment">//在执行故障转移操作时，可以同时对新的主服务器进行同步的从服务器数量</span></span><br><span class="line"><span class="type">int</span> parallel_syncs;</span><br><span class="line"></span><br><span class="line"><span class="comment">//SENTINEL failover-timeout &lt;master-name&gt; &lt;ms&gt;选项的值</span></span><br><span class="line"><span class="comment">//刷新故障迁移状态的最大时限</span></span><br><span class="line"><span class="type">mstime_t</span> failover_timeout;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125; sentinelRedisInstance;</span><br></pre></td></tr></table></figure><p>sentinelRedisInstance.addr属性是一个指向sentinel.c&#x2F;sentinelAddr结构的指针，这个结构保存着实例的IP地址和端口号：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">sentinelAddr</span> &#123;</span></span><br><span class="line"><span class="type">char</span> *ip;</span><br><span class="line"><span class="type">int</span> port;</span><br><span class="line">&#125; sentinelAddr;</span><br></pre></td></tr></table></figure><p>对Sentinel状态的初始化将引发对masters字典的初始化，而masters字典的初始化是根据被载入的Sentinel配置文件来进行的。</p><h4 id="创建连向主服务器的网络连接"><a href="#创建连向主服务器的网络连接" class="headerlink" title="创建连向主服务器的网络连接"></a>创建连向主服务器的网络连接</h4><p>初始化Sentinel的最后一步是创建连向被监视主服务器的网络连接，Sentinel将成为主服务器的客户端，它可以向主服务器发送命令，并从命令回复中获取相关的信息。</p><p>对于每个被Sentinel监视的主服务器来说，Sentinel会创建两个连向主服务器的异步网络连接：</p><ul><li>一个是命令连接，这个连接专门用于向主服务器发送命令，并接收命令回复。</li><li>另一个是订阅连接，这个连接专门用于订阅主服务器的__sentinel__: hello频道。</li></ul><h3 id="获取主服务器的信息"><a href="#获取主服务器的信息" class="headerlink" title="获取主服务器的信息"></a>获取主服务器的信息</h3><p>Sentinel默认会以每十秒一次的频率，通过命令连接向被监视的主服务器发送INFO命令，并通过分析INFO命令的回复来获取主服务器的当前信息。</p><p><img src="/..%5Cimg%5CRedis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%5CSentinel%E5%8F%91%E9%80%81INFO%E5%91%BD%E4%BB%A4.png" alt="Sentinel发送INFO命令"></p><p>通过分析主服务器返回的INFO命令回复，Sentinel可以获取以下两方面的信息：</p><ul><li>一方面是关于主服务器本身的信息，包括run_id域记录的服务器运行ID，以及role域记录的服务器角色；</li><li>另一方面是关于主服务器属下所有从服务器的信息，每个从服务器都由一个”slave”字符串开头的行记录，每行的ip&#x3D;域记录了从服务器的IP地址，而port&#x3D;域则记录了从服务器的端口号。根据这些IP地址和端口号，Sentinel无须用户提供从服务器的地址信息，就可以自动发现从服务器。</li></ul><p>主服务器回复的信息示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># Server</span><br><span class="line">...</span><br><span class="line">run_id:7611c59dc3a29aa6fa0609f841bb6a1019008a9c</span><br><span class="line">...</span><br><span class="line"># Replication</span><br><span class="line">role:master</span><br><span class="line">...</span><br><span class="line">slave0:ip=127.0.0.1,port=11111,state=online,offset=43,lag=0</span><br><span class="line">slave1:ip=127.0.0.1,port=22222,state=online,offset=43,lag=0</span><br><span class="line">slave2:ip=127.0.0.1,port=33333,state=online,offset=43,lag=0</span><br><span class="line">...</span><br><span class="line"># Other sections</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>根据run_id域和role域记录的信息，Sentinel将对主服务器的实例结构进行更新，例如，主服务器重启之后，它的运行ID就会和实例结构之前保存的运行ID不同，Sentinel检测到这一情况之后，就会对实例结构的运行ID进行更新。</p><p>至于主服务器返回的从服务器信息，则会被用于更新主服务器实例结构的slaves字典，这个字典记录了主服务器属下从服务器的名单：</p><ul><li>字典的键是由Sentinel自动设置的从服务器名字，格式为ip:port：如对于IP地址为127.0.0.1，端口号为11111的从服务器来说，Sentinel为它设置的名字就是127.0.0.1:11111。</li><li>至于字典的值则是从服务器对应的实例结构：比如说，如果键是127.0.0.1:11111，那么这个键的值就是IP地址为127.0.0.1，端口号为11111的从服务器的实例结构。</li></ul><p>Sentinel在分析INFO命令中包含的从服务器信息时，会检查从服务器对应的实例结构是否已经存在于slaves字典：</p><ul><li>如果从服务器对应的实例结构已经存在，那么Sentinel对从服务器的实例结构进行更新。</li><li>如果从服务器对应的实例结构不存在，那么说明这个从服务器是新发现的从服务器，Sentinel会在slaves字典中为这个从服务器新创建一个实例结构。</li></ul><h3 id="获取从服务器信息"><a href="#获取从服务器信息" class="headerlink" title="获取从服务器信息"></a>获取从服务器信息</h3><p>当Sentinel发现主服务器有新的从服务器出现时，Sentinel除了会为这个新的从服务器创建相应的实例结构之外，Sentinel还会创建连接到从服务器的命令连接和订阅连接。</p><p><img src="/..%5Cimg%5CRedis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%5CSentinel%E4%B8%8E%E4%BB%8E%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%88%9B%E5%BB%BA%E8%BF%9E%E6%8E%A5.png" alt="Sentinel与从服务器创建连接"></p><p>在创建命令连接之后，Sentinel在默认情况下，会以每十秒一次的频率通过命令连接向从服务器发送 INFO命令，并获得类似于以下内容的回复：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># Server</span><br><span class="line">...</span><br><span class="line">run_id:32be0699dd27b410f7c90dada3a6fab17f97899f</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"># Replication</span><br><span class="line">role:slave</span><br><span class="line">master_host:127.0.0</span><br><span class="line">master_port:6379</span><br><span class="line">master_link_status:up</span><br><span class="line">slave_repl_offset:11887</span><br><span class="line">slave_priority:100</span><br><span class="line"></span><br><span class="line"># Other sections</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>根据INFO命令的回复，Sentinel会提取出以下信息：</p><ul><li>从服务器的运行ID run_id。</li><li>从服务器的角色role。</li><li>主服务器的IP地址master_host，以及主服务器的端口号master_port。</li><li>主从服务器的连接状态master_link_status。</li><li>从服务器的优先级slave_priority。</li><li>从服务器的复制偏移量slave_repl_offset。</li></ul><p>根据这些信息，Sentinel会对从服务器的实例结构进行更新。</p><h3 id="向主服务器和从服务器发送信息"><a href="#向主服务器和从服务器发送信息" class="headerlink" title="向主服务器和从服务器发送信息"></a>向主服务器和从服务器发送信息</h3><p>在默认情况下，Sentinel会以每两秒一次的频率，通过命令连接向所有被监视的主服务器和从服务器发送以下格式的命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PUBLISH __sentinel__:hello &quot;&lt;s_ip&gt;,&lt;s_port&gt;,&lt;s_runid&gt;,&lt;s_epoch&gt;,&lt;m_name&gt;,&lt;m_</span><br><span class="line">ip&gt;,&lt;m_port&gt;,&lt;m_epoch&gt;&quot;</span><br></pre></td></tr></table></figure><p>这条命令向服务器的__sentinel__:hello频道发送了一条信息，信息的内容由多个参数组成：</p><ul><li>其中以s_开头的参数记录的是Sentinel本身的信息。</li><li>而m_开头的参数记录的则是主服务器的信息。如果Sentinel正在监视的是主服务器，那么这些参数记录的就是主服务器的信息；如果Sentinel正在监视的是从服务器，那么这些参数记录的就是从服务器正在复制的主服务器的信息。</li></ul><h3 id="接受来自主服务器和从服务器的频道信息"><a href="#接受来自主服务器和从服务器的频道信息" class="headerlink" title="接受来自主服务器和从服务器的频道信息"></a>接受来自主服务器和从服务器的频道信息</h3><p>当Sentinel与一个主服务器或者从服务器建立起订阅连接之后，Sentinel就会通过订阅连接，向服务器发送以下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SUBSCRIBE __sentinel__:hello</span><br></pre></td></tr></table></figure><p>Sentinel对__sentinel__:hello频道的订阅会一直持续到Sentinel与服务器的连接断开为止。这也就是说，对于每个与Sentinel连接的服务器，Sentinel既通过命令连接向服务器__sentinel__:hello频道发送信息，又通过订阅连接从服务器的__sentinel__:hello频道接收信息。</p><p><img src="/..%5Cimg%5CRedis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%5CSentinel%E5%90%8C%E6%97%B6%E5%90%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%8F%91%E9%80%81%E5%92%8C%E6%8E%A5%E6%94%B6%E4%BF%A1%E6%81%AF.png" alt="Sentinel同时向服务器发送和接收信息"></p><p>对于监视同一个服务器的多个Sentinel来说，一个Sentinel发送的信息会被其他Sentinel接收到，这些信息会被用于更新其他Sentinel对发送信息Sentinel的认知，也会被用于更新其他 Sentinel对被监视服务器的认知。</p><p><img src="/..%5Cimg%5CRedis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%5C%E5%A4%9A%E4%B8%AAsentinel%E7%9B%91%E8%A7%86%E5%90%8C%E4%B8%80%E4%B8%AA%E6%9C%8D%E5%8A%A1%E5%99%A8.png" alt="多个sentinel监视同一个服务器"></p><p>当一个Sentinel从__sentinel__:hello频道收到一条信息时，Sentinel会对这条信息进行分析，提取出信息中的Sentinel IP地址、Sentinel端口号、Sentinel运行ID等八个参数，并进行以下检查：</p><ul><li>如果信息中记录的Sentinel运行ID和接收信息的Sentinel的运行ID相同，那么说明这条信息是Sentinel自己发送的，Sentinel将丢弃这条信息，不做进一步处理。</li><li>相反地，如果信息中记录的Sentinel运行ID和接收信息的Sentinel的运行ID不相同，那么说明这条信息是监视同一个服务器的其他Sentinel发来的，接收信息的Sentinel将根据信息中的各个参数，对相应主服务器的实例结构进行更新。</li></ul><h4 id="更新sentinels字典"><a href="#更新sentinels字典" class="headerlink" title="更新sentinels字典"></a>更新sentinels字典</h4><p>Sentinel为主服务器创建的实例结构中的sentinels字典保存了除Sentinel本身之外，所有同样监视这个主服务器的其他Sentinel的资料：</p><ul><li>sentinels字典的键是其中一个Sentinel的名字，格式为ip:port，比如对于IP地址为127.0.0.1，端口号为26379的Sentinel来说，这个Sentinel在sentinels字典中的键就是”127.0.0.1:26379”。</li><li>sentinels字典的值则是键所对应Sentinel的实例结构，比如对于键”127.0.0.1:26379”来说，这个键在sentinels字典中的值就是IP为127.0.0.1，端口号为26379的Sentinel的实例结构。</li></ul><p>当一个Sentinel接收到其他Sentinel发来的信息时（我们称呼发送信息的Sentinel为源Sentinel，接收信息的Sentinel为目标Sentinel），目标Sentinel会从信息中分析并提取出以下两方面参数：</p><ul><li>与Sentinel有关的参数：源Sentinel的IP地址、端口号、运行ID和配置纪元。</li><li>与主服务器有关的参数：源Sentinel正在监视的主服务器的名字、IP地址、端口号和配置纪元。</li></ul><p>根据信息中提取出的主服务器参数，目标Sentinel会在自己的Sentinel状态的masters字典中查找相应的主服务器实例结构，然后根据提取出的Sentinel参数，检查主服务器实例结构的sentinels字典中，源Sentinel的实例结构是否存在：</p><ul><li>如果源Sentinel的实例结构已经存在，那么对源Sentinel的实例结构进行更新。</li><li>如果源Sentinel的实例结构不存在，那么说明源Sentinel是刚刚开始监视主服务器的新Sentinel，目标Sentinel会为源Sentinel创建一个新的实例结构，并将这个结构添加到sentinels字典里面。</li></ul><p><img src="/..%5Cimg%5CRedis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%5C%E4%B8%BB%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%9E%E4%BE%8B%E7%BB%93%E6%9E%84%E4%B8%AD%E7%9A%84sentinels%E5%AD%97%E5%85%B8.png" alt="主服务器实例结构中的sentinels字典"></p><p>同一个主服务器在不同sentinel内创建的实例中的sentinels字典中保存的Sentinel信息不同（保存其余的sentinel信息而不保存自己的）。</p><p>因为一个Sentinel可以通过分析接收到的频道信息来获知其他Sentinel的存在，并通过发送频道信息来让其他Sentinel知道自己的存在，所以用户在使用Sentinel的时候并不需要提供各个Sentinel的地址信息，监视同一个主服务器的多个Sentinel可以自动发现对方。</p><h4 id="创建连向其他Sentinel的命令连接"><a href="#创建连向其他Sentinel的命令连接" class="headerlink" title="创建连向其他Sentinel的命令连接"></a>创建连向其他Sentinel的命令连接</h4><p>当Sentinel通过频道信息发现一个新的Sentinel时，它不仅会为新Sentinel在sentinels字典中创建相应的实例结构，还会创建一个连向新Sentinel的命令连接，而新Sentinel也同样会创建连向这个Sentinel的命令连接，最终监视同一主服务器的多个Sentinel将形成相互连接的网络：Sentinel A有连向Sentinel B的命令连接，而Sentinel B也有连向Sentinel A的命令连接。</p><p>使用命令连接相连的各个Sentinel可以通过向其他Sentinel发送命令请求来进行信息交换。Sentinel实现主观下线检测和客观下线检测都会使用Sentinel之间的命令连接来进行通信。</p><p>Sentinel在连接主服务器或者从服务器时，会同时创建命令连接和订阅连接，但是在连接其他Sentinel时，却只会创建命令连接，而不创建订阅连接。这是因为Sentinel需要通过接收主服务器或者从服务器发来的频道信息来发现未知的新Sentinel，所以才需要建立订阅连接，而相互已知的Sentinel只要使用命令连接来进行通信就足够了。</p><h3 id="检测主观下线状态"><a href="#检测主观下线状态" class="headerlink" title="检测主观下线状态"></a>检测主观下线状态</h3><p>在默认情况下，Sentinel会以每秒一次的频率向所有与它创建了命令连接的实例（包括主服务器、从服务器、其他Sentinel在内）发送PING命令，并通过实例返回的PING命令回复来判断实例是否在线。</p><p>实例对PING命令的回复可以分为以下两种情况：</p><ul><li>有效回复：实例返回+PONG、-LOADING、-MASTERDOWN三种回复的其中一种。</li><li>无效回复：实例返回除+PONG、-LOADING、-MASTERDOWN三种回复之外的其他回复，或者在指定时限内没有返回任何回复。</li></ul><p>Sentinel配置文件中的down-after-milliseconds选项指定了Sentinel判断实例进入主观下线所需的时间长度：如果一个实例在down-after-milliseconds毫秒内，连续向Sentinel返回无效回复，那么Sentinel会修改这个实例所对应的实例结构，在结构的flags属性中打SRI_S_DOWN标识，以此来表示这个实例已经进入主观下线状态。</p><p><img src="/..%5Cimg%5CRedis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%5C%E4%B8%BB%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%A2%AB%E6%A0%87%E8%AE%B0%E4%B8%BA%E4%B8%BB%E8%A7%82%E4%B8%8B%E7%BA%BF.png" alt="主服务器被标记为主观下线"></p><h4 id="主观下线时长选项的作用范围"><a href="#主观下线时长选项的作用范围" class="headerlink" title="主观下线时长选项的作用范围"></a>主观下线时长选项的作用范围</h4><p>用户设置的down-after-milliseconds选项的值，不仅会被Sentinel用来判断主服务器的主观下线状态，还会被用于判断主服务器属下的所有从服务器，以及所有同样监视这个主服务器的其他Sentinel的主观下线状态。</p><h4 id="多个Sentinel设置的主观下线时长可能不同"><a href="#多个Sentinel设置的主观下线时长可能不同" class="headerlink" title="多个Sentinel设置的主观下线时长可能不同"></a>多个Sentinel设置的主观下线时长可能不同</h4><p>down-after-milliseconds选项另一个需要注意的地方是，对于监视同一个主服务器的多个Sentinel来说，这些Sentinel所设置的down-after-milliseconds选项的值也可能不同，因此，当一个Sentinel将主服务器判断为主观下线时，其他Sentinel可能仍然会认为主服务器处于在线状态。</p><h3 id="检查客观下线状态"><a href="#检查客观下线状态" class="headerlink" title="检查客观下线状态"></a>检查客观下线状态</h3><p>当Sentinel将一个主服务器判断为主观下线之后，为了确认这个主服务器是否真的下线了，它会向同样监视这一主服务器的其他Sentinel进行询问，看它们是否也认为主服务器已经进入了下线状态（可以是主观下线或者客观下线)。当Sentinel从其他Sentinel那里接收到足够数量的已下线判断之后，Sentinel就会将从服务器判定为客观下线，并对主服务器执行故障转移操作。</p><h4 id="发送SENTINEL-is-master-down-by-addr-命令"><a href="#发送SENTINEL-is-master-down-by-addr-命令" class="headerlink" title="发送SENTINEL is-master-down-by-addr 命令"></a>发送SENTINEL is-master-down-by-addr 命令</h4><p>Sentinel使用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SENTINEL is-master-down-by-addr &lt;ip&gt; &lt;port&gt; &lt;current_epoch&gt; &lt;runid&gt;</span><br></pre></td></tr></table></figure><p>命令询问其他Sentinel是否同意主服务器已下线。</p><table><thead><tr><th align="center">参数</th><th align="center">意义</th></tr></thead><tbody><tr><td align="center">ip</td><td align="center">被Sentinel判断为主观下线的主服务器的IP地址</td></tr><tr><td align="center">port</td><td align="center">被Sentinel判断为主观下线的主服务器的端口号</td></tr><tr><td align="center">current_epoch</td><td align="center">Sentinel当前的配置纪元，用于选举领头Sentinel，详细作用将在下一节说明</td></tr><tr><td align="center">runid</td><td align="center">可以是*符号或者Sentinel的运行ID：*符号代表命令仅仅用于检测主服务器的客观下线状态，而Sentinel的运行ID则用于选举领头Sentinel。</td></tr></tbody></table><h4 id="接收SENTINEL-is-master-down-by-addr-命令"><a href="#接收SENTINEL-is-master-down-by-addr-命令" class="headerlink" title="接收SENTINEL is-master-down-by-addr 命令"></a>接收SENTINEL is-master-down-by-addr 命令</h4><p>当一个Sentinel（目标Sentinel）接收到另一个Sentinel（源Sentinel）发来的SENTINEL is-master-down-by命令时，目标Sentinel会分析并取出命令请求中包含的各个参数，并根据其中的主服务器IP和端口号，检查主服务器是否已下线，然后向源Sentinel返回一条包含三个参数的Multi Bulk回复作为SENTINEL is-master-down-by命令的回复：</p><ol><li><down_state></li><li>&lt;leader runid&gt;</li><li>&lt;leader epoch&gt;</li></ol><table><thead><tr><th align="center">参数</th><th align="center">意义</th></tr></thead><tbody><tr><td align="center">down_state</td><td align="center">返回目标Sentinel对主服务器的检查结果，1代表主服务器已下线，0代表主服务器未下线</td></tr><tr><td align="center">leader_runid</td><td align="center">可以是*符号或者目标Sentinel的局部领头Sentinel的运行ID：*符号代表命令仅仅用于检测主服务器的下线状态，而局部领头Sentinel的运行ID则用于选举领头Sentinel</td></tr><tr><td align="center">leader_epoch</td><td align="center">目标Sentinel的局部领头的配置纪元，用于选举领头Sentinel。仅在leader_runid的值不为*时有效，如果leader_runid的值为*，那么leader_epoch总为0</td></tr></tbody></table><h4 id="接收SENTINEL-is-master-down-by-addr-命令的回复"><a href="#接收SENTINEL-is-master-down-by-addr-命令的回复" class="headerlink" title="接收SENTINEL is-master-down-by-addr 命令的回复"></a>接收SENTINEL is-master-down-by-addr 命令的回复</h4><p>根据其他Sentinel发回的SENTINEL is-master-down-by-addr命令回复，Sentinel将统计其他Sentinel同意主服务器已下线的数量，当这一数量达到配置指定的判断客观下线所需的数量时，Sentinel会将主服务器实例结构flags属性的SRI_O_DOWN标识打开，表示主服务器已经进入客观下线状态。</p><p><img src="/..%5Cimg%5CRedis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%5C%E4%B8%BB%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%A2%E8%A7%82%E4%B8%8B%E7%BA%BF.png" alt="主服务器客观下线"></p><h5 id="客观下线状态的判断条件"><a href="#客观下线状态的判断条件" class="headerlink" title="客观下线状态的判断条件"></a>客观下线状态的判断条件</h5><p>当认为主服务器已经进入下线状态的Sentinel的数量，超过Sentinel配置中设置的quorum参数的值，那么该Sentinel就会认为主服务器已经进入客观下线状态。比如说,如果Sentinel在启动时载入了以下配置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sentinel monitor master 127.0.0.1 6379 2</span><br></pre></td></tr></table></figure><p>那么包括当前Sentinel在内，只要总共有两个Sentinel认为主服务器已经进入下线状态，那么当前Sentinel就将主服务器判断为客观下线。</p><p><strong>不同Sentinel判断客观下线的条件可能不同。</strong>对于监视同一个主服务器的多个Sentinel来说，它们将主服务器标判断为客观下线的条件可能也不同：当一个Sentinel将主服务器判断为客观下线时，其他Sentinel 可能并不是那么认为的。比如说，对于监视同一个主服务器的五个Sentinel来说，如果Sentinel1在启动时载入了以下配置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sentinel rmonitor master 127.0.0.1 6379 2</span><br></pre></td></tr></table></figure><p>那么当五个Sentinel中有两个Sentinel认为主服务器已经下线时，Sentinel1就会将主服务器标判断为客观下线。<br>而对于载入了以下配置的Sentinel2来说：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sentinel monitor master 127.0.0.1 6379 5</span><br></pre></td></tr></table></figure><p>仅有两个Sentinel认为主服务器已下线，并不会令Sentinel2将主服务器判断为客观下线。</p><h3 id="选举领头Sentinel"><a href="#选举领头Sentinel" class="headerlink" title="选举领头Sentinel"></a>选举领头Sentinel</h3><p>当一个主服务器被判断为客观下线时，监视这个下线主服务器的各个Sentinel会进行协商，选举出一个领头Sentinel，并由领头Sentinel对下线主服务器执行故障转移操作。</p><p>以下是Redis选举领头Sentinel的规则和方法：</p><ul><li>所有在线的Sentinel都有被选为领头Sentinel的资格，换句话说，监视同一个主服务器的多个在线Sentinel中的任意一个都有可能成为领头Sentinel。</li><li>每次进行领头Sentinel选举之后，不论选举是否成功， 所有Sentinel的配置纪元（configuration epoch）的值都会自增一次。配置纪元实际上就是一个计数器，并没有什么特别的。</li><li>在一个配置纪元里面，所有Sentinel都有一次将某个Sentinel设置为局部领头Sentinel的机会，并且局部领头一旦设置，在这个配置纪元里面就不能再更改。</li><li>每个发现主服务器进入客观下线的Sentinel都会要求其他Sentinel将自己设置为局部领头 Sentinel。</li><li>当一个Sentinel（源Sentinel）向另一个 Sentinel（目标Sentinel）发送SENTINEL is-master-down-by-addr命令，并且命令中的runid参数不是*符号而是源Sentinel的运行ID时，这表示源Sentinel要求目标Sentinel将前者设置为后者的局部领头Sentinel。</li><li>Sentinel设置局部领头Sentinel的规则是先到先得：最先向目标Sentinel发送设置要求的源Sentinel将成为目标Sentinel的局部领头Sentinel，而之后接收到的所有设置要求都会被目标Sentinel拒绝。</li><li>目标Sentinel在接收到SENTINEL is-master-down-by-addr命令之后，将向源Sentinel返回一条命令回复，回复中的leader_runid参数和leader_epoch参数分别记录了目标Sentinel的局部领头Sentinel的运行ID和配置纪元。</li><li>源Sentinel在接收到目标Sentinel返回的命令回复之后，会检查回复中leader_epoch参数的值和自己的配置纪元是否相同，如果相同的话，那么源Sentinel继续取出回复中的                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      leader_runid参数，如果leader_runid参数的值和源Sentinel的运行ID一致，那么表示目标Sentinel将源Sentinel设置成了局部领头Sentinel。</li><li>如果有某个Sentinel被半数以上的Sentinel设置成了局部领头Sentinel，那么这个Sentinel成为领头Sentinel。举个例子，在一个由10个Sentinel组成的Sentinel系统里面，只要有大于等于10&#x2F;2+1&#x3D;6个Sentinel将某个Sentinel设置为局部领头Sentinel，那么被设置的那个Sentinel就会成为领头Sentinel。</li><li>因为领头Sentinel的产生需要半数以上Sentinel的支持，并且每个Sentinel在每个配置纪元里面只能设置一次局部领头Sentinel，所以在一个配置纪元里，只会出现一个领头 Sentinel。</li><li>如果在给定时限内，没有一个Sentinel被选举为领头Sentinel，那么各个Sentinel将在一段时间之后再次进行选举，直到选出领头Sentinel为止。</li></ul><h3 id="故障转移"><a href="#故障转移" class="headerlink" title="故障转移"></a>故障转移</h3><p>在选举产生出领头Sentinel之后，领头Sentinel将对已下线的主服务器执行故障转移操作，该操作包含以下三个步骤：</p><ol><li>在已下线主服务器属下的所有从服务器里面，挑选出一个从服务器，并将其转换为主服务器。</li><li>让已下线主服务器属下的所有从服务器改为复制新的主服务器。</li><li>将已下线主服务器设置为新的主服务器的从服务器，当这个旧的主服务器重新上线时，它就会成为新的主服务器的从服务器。</li></ol><h4 id="选出新的主服务器"><a href="#选出新的主服务器" class="headerlink" title="选出新的主服务器"></a>选出新的主服务器</h4><p>故障转移操作第一步要做的就是在已下线主服务器属下的所有从服务器中，挑选出一个状态良好、数据完整的从服务器，然后向这个从服务器发送SLAVEOF no one命令，将这个从服务器转换为主服务器。在发送SLAVEOF no one命令之后，领头Sentinel会以每秒一次的频率（平时是每十秒一次），向被升级的从服务器发送INFO命令，并观察命令回复中的角色（ role）信息，当被升级服务器的role从原来的slave变为master时，领头Sentinel就知道被选中的从服务器已经顺利升级为主服务器了。</p><h5 id="新的主服务器是怎样挑选出来的"><a href="#新的主服务器是怎样挑选出来的" class="headerlink" title="新的主服务器是怎样挑选出来的"></a>新的主服务器是怎样挑选出来的</h5><p>领头Sentinel会将已下线主服务器的所有从服务器保存到一个列表里面，然后按照以下规则，一项一项地对列表进行过滤：</p><ol><li>删除列表中所有处于下线或者断线状态的从服务器，这可以保证列表中剩余的从服务器都是正常在线的。</li><li>删除列表中所有最近五秒内没有回复过领头Sentinel的INFO命令的从服务器，这可以保证列表中剩余的从服务器都是最近成功进行过通信的。</li><li>删除所有与已下线主服务器连接断开超过down-after-milliseconds * 10毫秒的从服务器： down-after-milliseconds选项指定了判断主服务器下线所需的时间，而删除断开时长超过down-after-milliseconds * 10毫秒的从服务器，则可以保证列表中剩余的从服务器都没有过早地与主服务器断开连接，换句话说，列表中剩余的从服务器保存的数据都是比较新的。</li></ol><p>之后，领头Sentinel将根据从服务器的优先级，对列表中剩余的从服务器进行排序，并选出其中优先级最高的从服务器。</p><p>如果有多个具有相同最高优先级的从服务器，那么领头Sentinel将按照从服务器的复制偏移量，对具有相同最高优先级的所有从服务器进行排序，并选出其中偏移量最大的从服务器（复制偏移量最大的从服务器就是保存着最新数据的从服务器）。</p><p>最后，如果有多个优先级最高、复制偏移量最大的从服务器，那么领头Sentinel将按照运行ID对这些从服务器进行排序，并选出其中运行ID最小的从服务器。</p><h4 id="修改从服务器的复制目标"><a href="#修改从服务器的复制目标" class="headerlink" title="修改从服务器的复制目标"></a>修改从服务器的复制目标</h4><p>当新的主服务器出现之后，领头Sentinel下一步要做的就是，让已下线主服务器属下的所有从服务器去复制新的主服务器，这一动作可以通过向从服务器发送SLAVEOF命令来实现。</p><h4 id="将旧的主服务器变为从服务器"><a href="#将旧的主服务器变为从服务器" class="headerlink" title="将旧的主服务器变为从服务器"></a>将旧的主服务器变为从服务器</h4><p>故障转移操作最后要做的是，将已下线的主服务器设置为新的主服务器的从服务器。当下线主服务器重新上线时，Sentinel就会向它发送SLAVEOF命令，让它成为从服务器。</p><h2 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h2><p>Redis集群是Redis提供的分布式数据库方案，集群通过分片（sharding）来进行数据共享，并提供复制和故障转移功能。</p><h3 id="节点"><a href="#节点" class="headerlink" title="节点"></a>节点</h3><p>一个Redis集群通常由多个节点（node）组成，在刚开始的时候，每个节点都是相互独立的，它们都处于一个只包含自己的集群当中，要组建一个真正可工作的集群，我们必须将各个独立的节点连接起来，构成一个包含多个节点的集群。</p><p>连接各个节点的工作可以使用CLUSTER MEET命令来完成，该命令的格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CLUSTER MEET &lt;ip&gt; &lt;port&gt;</span><br></pre></td></tr></table></figure><p>向一个节点node发送CLUSTER MEET命令，可以让node节点与ip和port所指定的节点进行握手（handshake），当握手成功时，node节点就会将ip和port所指定的节点添加到node节点当前所在的集群中。</p><h4 id="启动节点"><a href="#启动节点" class="headerlink" title="启动节点"></a>启动节点</h4><p>一个节点就是一个运行在集群模式下的Redis服务器，Redis服务器在启动时会根据cluster-enabled配置选项是否为yes来决定是否开启服务器的集群模式。</p><p><img src="/..%5Cimg%5CRedis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%5C%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%98%AF%E5%90%A6%E5%BC%80%E5%90%AF%E9%9B%86%E7%BE%A4%E6%A8%A1%E5%BC%8F.png" alt="服务器是否开启集群模式"></p><p>节点（运行在集群模式下的Redis服务器）会继续使用所有在单机模式中使用的服务器组件，比如说：</p><ul><li>节点会继续使用文件事件处理器来处理命令请求和返回命令回复。</li><li>节点会继续使用时间事件处理器来执行serverCron函数，而serverCron函数又会调用集群模式特有的clusterCron函数。clusterCron函数负责执行在集群模式下需要执行的常规操作，例如向集群中的其他节点发送Gossip消息，检查节点是否断线，或者检查是否需要对下线节点进行自动故障转移等。</li><li>节点会继续使用数据库来保存键值对数据，键值对依然会是各种不同类型的对象。</li><li>节点会继续使用RDB持久化模块和AOF持久化模块来执行持久化工作。</li><li>节点会继续使用发布与订阅模块来执行PUBLISH、SUBSCRIBE等命令。</li><li>节点会继续使用复制模块来进行节点的复制工作。</li><li>节点会继续使用Lua脚本环境来执行客户端输入的Lua脚本。</li></ul><p>除此之外，节点会继续使用redisServer结构来保存服务器的状态，使用redisClient结构来保存客户端的状态，至于那些只有在集群模式下才会用到的数据，节点将它们保存到了cluster.h&#x2F;clusterNode结构、cluster.h&#x2F;clusterLink结构，以及cluster.h&#x2F;clusterState结构里面。</p><h4 id="集群数据结构"><a href="#集群数据结构" class="headerlink" title="集群数据结构"></a>集群数据结构</h4><p>clusterNode结构保存了一个节点的当前状态，比如节点的创建时间、节点的名字、节点当前的配置纪元、节点的IP地址和端口号等等。</p><p>每个节点都会使用一个clusterNode结构来记录自己的状态，并为集群中的所有其他节点（包括主节点和从节点）都创建一个相应的clusterNode结构，以此来记录其他节点的状态：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">clusterNode</span> &#123;</span></span><br><span class="line"><span class="comment">//创建节点的时间</span></span><br><span class="line">    <span class="type">mstime_t</span> ctime;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//节点的名字，由40个十六进制字符组成</span></span><br><span class="line"><span class="comment">//例如68eef66df23420a5862208ef5b1a7005b806f2ff</span></span><br><span class="line">    <span class="type">char</span> name[REDIS_CLUSTER_ NAMELEN];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//节点标识</span></span><br><span class="line"><span class="comment">//使用各种不同的标识值记录节点的角色（比如主节点或者从节点）,</span></span><br><span class="line">    <span class="comment">//以及节点目前所处的状态（比如在线或者下线）.</span></span><br><span class="line"><span class="type">int</span> flags;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//节点当前的配置纪元，用于实现故障转移</span></span><br><span class="line">    <span class="type">uint64_t</span> configEpoch;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//节点的IP地址</span></span><br><span class="line"><span class="type">char</span> ip[REDIS_IP_STR_LEN];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//节点的端口号</span></span><br><span class="line"><span class="type">int</span> port;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//保存连接节点所需的有关信息</span></span><br><span class="line">    clusterLink *link;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>clusterNode结构的link属性是一个clusterLink结构，该结构保存了连接节点所需的有关信息，比如套接字描述符，输入缓冲区和输出缓冲区：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">clusterLink</span> &#123;</span></span><br><span class="line"><span class="comment">//连接的创建时间</span></span><br><span class="line"><span class="type">mstime_t</span> ctime;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//TCP 套接字描述符</span></span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//输出缓冲区，保存着等待发送给其他节点的消息（message）。</span></span><br><span class="line">    sds sndbuf;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//输入缓冲区，保存着从其他节点接收到的消息。</span></span><br><span class="line">    sds rcvbuf;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//与这个连接相关联的节点，如果没有的话就为NULL</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">clusterNode</span> *<span class="title">node</span>;</span></span><br><span class="line">&#125; clusterLink;</span><br></pre></td></tr></table></figure><p><strong>redisClient结构和clusterLink结构的相同和不同之处</strong>：redisClient结构和clusterLink结构都有自己的套接字描述符和输入、输出缓冲区，这两个结构的区别在于，redisClient结构中的套接字和缓冲区是用于连接客户端的，而clusterLink结构中的套接字和缓冲区则是用于连接节点的。</p><p>最后，每个节点都保存着一个clusterState结构，这个结构记录了在当前节点的视角下，集群目前所处的状态，例如集群是在线还是下线，集群包含多少个节点，集群当前的配置纪元，诸如此类：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">clusterState</span> &#123;</span></span><br><span class="line"><span class="comment">//指向当前节点的指针</span></span><br><span class="line">clusterNode *myself;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//集群当前的配置纪元，用于实现故障转移</span></span><br><span class="line">    <span class="type">uint64_t</span> currentEpoch;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//集群当前的状态:是在线还是下线</span></span><br><span class="line">    <span class="type">int</span> state;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//集群中至少处理着一个槽的节点的数量</span></span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//集群节点名单（包括myself节点）</span></span><br><span class="line"><span class="comment">//字典的键为节点的名字，字典的值为节点对应的clusterNode结构</span></span><br><span class="line">    dict *nodes;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125; clusterState;</span><br></pre></td></tr></table></figure><p>集群数据结构示例：</p><p><img src="/..%5Cimg%5CRedis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%5CclusterState%E7%A4%BA%E4%BE%8B.png" alt="clusterState示例"></p><p>说明：</p><ul><li>结构的currentEpoch属性的值为0，表示集群当前的配置纪元为0。</li><li>结构的size属性的值为0，表示集群目前没有任何节点在处理槽，因此结构的state属性的值为REDIS_CLUSTER_FAIL，这表示集群目前处于下线状态。</li><li>结构的nodes字典记录了集群目前包含的三个节点，这三个节点分别由三个clusterNode结构表示，其中myself指针指向代表节点7000的clusterNode结构，而字典中的另外两个指针则分别指向代表节点7001和代表节点7002的clusterNode结构，这两个节点是节点7000已知的在集群中的其他节点。</li><li>三个节点的clusterNode结构的flags属性都是REDIS_NODE_MASTER，说明三个节点都是主节点。</li></ul><h4 id="CLUSTER-MEET命令的实现"><a href="#CLUSTER-MEET命令的实现" class="headerlink" title="CLUSTER MEET命令的实现"></a>CLUSTER MEET命令的实现</h4><p>通过向节点A发送CLUSTER MEET命令，客户端可以让接收命令的节点A将另一个节点B添加到节点A当前所在的集群里面：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CLUSTER MEET &lt;ip&gt; &lt;port&gt;</span><br></pre></td></tr></table></figure><p>收到命令的节点A将与节点B进行握手（handshake），以此来确认彼此的存在，并为将来的进一步通信打好基础：</p><ol><li>节点A会为节点B创建一个clusterNode结构，并将该结构添加到自己的clusterState.nodes字典里面。</li><li>之后，节点A将根据CLUSTER MEET命令给定的IP地址和端口号，向节点B发送一条MEET消息（message）。</li><li>如果一切顺利，节点B将接收到节点A发送的MEET消息，节点B会为节息A创建一个clusterNode结构，并将该结构添加到自己的clusterstate.nodes字典里面。</li><li>之后，节点B将向节点A返回一条PONG消息。</li><li>如果一切顺利，节点A将接收到节点B返回的PONG消息，通过这条PONG消息节点A可以知道节点B已经成功地接收到了自己发送的MEET消息。</li><li>之后，节点A将向节点B返回一条PING消息。</li><li>如果一切顺利，节点B将接收到节点A返回的PING消息，通过这条PING消息节点B可以知道节点A已经成功地接收到了自己返回的PONG消息，握手完成。</li></ol><p><img src="/..%5Cimg%5CRedis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%5C%E8%8A%82%E7%82%B9%E7%9A%84%E6%8F%A1%E6%89%8B%E8%BF%87%E7%A8%8B.png" alt="节点的握手过程"></p><p>之后，节点A会将节点B的信息通过Gossip协议传播给集群中的其他节点，让其他节点也与节点B进行握手，最终，经过一段时间之后，节点B会被集群中的所有节点认识。</p><h3 id="槽指派"><a href="#槽指派" class="headerlink" title="槽指派"></a>槽指派</h3><p>Redis集群通过分片的方式来保存数据库中的键值对：集群的整个数据库被分为16384个槽（slot），数据库中的每个键都属于这16384个槽的其中一个，集群中的每个节点可以处理0个或最多16384个槽。</p><p>当数据库中的16384个槽都有节点在处理时，集群处于上线状态（ok）；相反地，如果数据库中有任何一个槽没有得到处理,那么集群处于下线状态（fail）。为了让集群进入上线状态，需要让数据库的每个槽都有节点负责。</p><h4 id="记录节点的槽指派信息"><a href="#记录节点的槽指派信息" class="headerlink" title="记录节点的槽指派信息"></a>记录节点的槽指派信息</h4><p>clusterNode结构的slots属性和numslot属性记录了节点负责处理哪些槽：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">clusterNode</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> slots[<span class="number">16384</span>/<span class="number">8</span>];</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> numslots;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>slots属性是一个二进制位数组（bit array），这个数组的长度为16384&#x2F;8&#x3D;2048个字节，共包含16384个二进制位。</p><p>Redis以0为起始索引，16383为终止索引，对slots数组中的16384个二进制位进行编号，并根据索引i上的二进制位的值来判断节点是否负责处理槽i：</p><ul><li>如果slots数组在索引i上的二进制位的值为1，那么表示节点负责处理槽i。</li><li>如果slots数组在索引i上的二进制位的值为0，那么表示节点不负责处理槽i。</li></ul><p>下图展示了一个slots数组示例：这个数组索引0至索引7上的二进制位的值都为1，其余所有二进制位的值都为0，这表示节点负责处理槽0至槽7。</p><p><img src="/..%5Cimg%5CRedis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%5Cslots%E6%95%B0%E7%BB%84%E7%A4%BA%E4%BE%8B.png" alt="slots数组示例"></p><p>因为取出和设置slots数组中的任意一个二进制位的值的复杂度仅为O(1)，所以对于一个给定节点的slots数组来说，程序检查节点是否负责处理某个槽，又或者将某个槽指派给节点负责，这两个动作的复杂度都是O(1)。</p><p>至于numslots属性则记录节点负责处理的槽的数量，也即是slots数组中值为1的二进制位的数量。</p><h4 id="传播节点的槽指派信息"><a href="#传播节点的槽指派信息" class="headerlink" title="传播节点的槽指派信息"></a>传播节点的槽指派信息</h4><p>一个节点除了会将自己负责处理的槽记录在clusterNode结构的slots属性和numslots属性之外，它还会将自己的slots数组通过消息发送给集群中的其他节点，以此来告知其他节点自己目前负责处理哪些槽。</p><p>当节点A通过消息从节点B那里接收到节点B的slots数组时，节点A会在自己的clusterState.nodes字典中查找节点B对应的clusterNode结构，并对结构中的slots数组进行保存或者更新。</p><p>因为集群中的每个节点都会将自己的slots数组通过消息发送给集群中的其他节点，并且每个接收到slots数组的节点都会将数组保存到相应节点的clusterNode结构里面，因此，集群中的每个节点都会知道数据库中的16384个槽分别被指派给了集群中的哪些节点。</p><h4 id="记录集群所有槽的指派信息"><a href="#记录集群所有槽的指派信息" class="headerlink" title="记录集群所有槽的指派信息"></a>记录集群所有槽的指派信息</h4><p>clusterState结构中的slots数组记录了集群中所有16384个槽的指派信息：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">clusterState</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">    clusterNode *slots[<span class="number">16384</span>];</span><br><span class="line">    </span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125; clusterState;</span><br></pre></td></tr></table></figure><p>slots数组包含16384个项，每个数组项都是一个指向clusterNode结构的指针：</p><ul><li>如果slots[i]指针指向NULL，那么表示槽i尚未指派给任何节点。</li><li>如果slots[i]指针指向一个clusterNode结构的指针，那么表示槽i已经指派给了clusterNode结构所代表的节点。</li></ul><p><strong>为什么要单独用一个结构记录所有槽的指派信息呢？</strong></p><p>如果只将槽指派信息保存在各个节点的clusterNode.slots数组里，会出现一些无法高效地解决的问题，而clusterState.slots数组的存在解决了这些问题：</p><ul><li>如果节点只使用clusterNode.slots数组来记录槽的指派信息，那么为了知道槽i是否已经被指派，或者槽i被指派给了哪个节点，程序需要遍历clusterState.nodes字典中的所有clusterNode结构，检查这些结构的slots数组，直到找到负责处理槽i的节点为止，这个过程的复杂度为O(N)，其中N为clusterState.nodes字典保存的clusterNode结构的数量。</li><li>而通过将所有槽的指派信息保存在clusterState.slots数组里面，程序要检查槽i是否已经被指派，又或者取得负责处理槽i的节点，只需要访问clusterState.slots[i]的值即可，这个操作的复杂度仅为O(1)。</li></ul><p>要说明的一点是，虽然clusterState.slots数组记录了集群中所有槽的指派信息，但使用clusterNode结构的slots数组来记录单个节点的槽指派信息仍然是有必要的：</p><ul><li>因为当程序需要将某个节点的槽指派信息通过消息发送给其他节点时，程序只需要将相应节点的clusterNode.slots数组整个发送出去就可以了。</li><li>另一方面，如果Redis不使用clusterNode.slots数组，而单独使用clusterState.slots数组的话，那么每次要将节点A的槽指派信息传播给其他节点时，程序必须先遍历整个clusterState.slots数组，记录节点A负责处理哪些槽，然后才能发送节点A的槽指派信息，这比直接发送clusterNode.slots数组要麻烦和低效得多。</li></ul><p>clusterState.slots数组记录了集群中所有槽的指派信息，而clusterNode.slots数组只记录了clusterNode结构所代表的节点的槽指派信息，这是两个slots数组的关键区别所在。</p><h4 id="CLUSTER-ADDSLOTS命令的实现"><a href="#CLUSTER-ADDSLOTS命令的实现" class="headerlink" title="CLUSTER ADDSLOTS命令的实现"></a>CLUSTER ADDSLOTS命令的实现</h4><p>CLUSTER ADDSLOTS命令接受一个或多个槽作为参数，并将所有输入的槽指派给接收该命令的节点负责：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CLUSTER ADDSLOTs &lt;slot&gt; [slot ...]</span><br></pre></td></tr></table></figure><p>CLUSTER ADDSLOTS命令的实现可以用以下伪代码来表示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">def <span class="title function_">CLUSTER_ADDSLOTs</span><span class="params">(*all_input_slots)</span>:</span><br><span class="line"></span><br><span class="line"># 遍历所有输入槽，检查它们是否都是未指派槽</span><br><span class="line"><span class="keyword">for</span> i in all_input_slots:</span><br><span class="line"></span><br><span class="line">#如果有哪怕一个槽已经被指派给了某个节点</span><br><span class="line">#那么向客户端返回错误，并终止命令执行</span><br><span class="line"><span class="keyword">if</span> clusterState.slots[i] != <span class="literal">NULL</span>:</span><br><span class="line">reply_error()</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">                </span><br><span class="line">#如果所有输入槽都是未指派槽</span><br><span class="line">#那么再次遍历所有输入槽，将这些槽指派给当前节点</span><br><span class="line"><span class="keyword">for</span> i in all_input_slots:</span><br><span class="line"></span><br><span class="line">#设置clusterState结构的slots数组</span><br><span class="line">#将slots[i]的指针指向代表当前节点的clusterNode结构</span><br><span class="line">clusterState.slots[i] = clusterState.myself</span><br><span class="line"></span><br><span class="line">         #访问代表当前节点的clusterNode结构的slots数组</span><br><span class="line">#将数组在索引i上的二进制位设置为<span class="number">1</span></span><br><span class="line">setSlotBit(clusterState.myself.slots, i)</span><br></pre></td></tr></table></figure><h3 id="在集群中执行命令"><a href="#在集群中执行命令" class="headerlink" title="在集群中执行命令"></a>在集群中执行命令</h3><p>在对数据库中的16384个槽都进行了指派之后，集群就会进入上线状态，这时客户端就可以向集群中的节点发送数据命令了。</p><p>当客户端向节点发送与数据库键有关的命令时，接收命令的节点会计算出命令要处理的数据库键属于哪个槽，并检查这个槽是否指派给了自己：</p><ul><li>如果键所在的槽正好就指派给了当前节点，那么节点直接执行这个命令。</li><li>如果键所在的槽并没有指派给当前节点，那么节点会向客户端返回一个MOVED错误，指引客户端转向（redirect）至正确的节点，并再次发送之前想要执行的命令。</li></ul><p><img src="/..%5Cimg%5CRedis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%5C%E5%88%A4%E6%96%AD%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%98%AF%E5%90%A6%E9%9C%80%E8%A6%81%E8%BD%AC%E5%90%91.png" alt="判断客户端是否需要转向"></p><h4 id="计算键属于哪个槽"><a href="#计算键属于哪个槽" class="headerlink" title="计算键属于哪个槽"></a>计算键属于哪个槽</h4><p>节点使用以下算法来计算给定键key属于哪个槽：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">def <span class="title function_">slot_number</span><span class="params">(key)</span> :</span><br><span class="line"><span class="keyword">return</span> <span class="title function_">CRC16</span><span class="params">(key)</span> &amp; 16383</span><br></pre></td></tr></table></figure><p>其中CRC16(key)语句用于计算键key的CRC-16校验和，而&amp; 16383语句则用于计算出一个介于0至16383之间的整数作为键key的槽号。</p><p>CLUSTER KEYSLOT &lt;key&gt;命令可以查看一个给定键属于哪个槽。CLUSTER KEYSLOT命令就是通过调用上面给出的槽分配算法来实现的，以下是该命令的伪代码实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def <span class="title function_">CLUSTER_KEYSLOT</span> <span class="params">(key)</span>:</span><br><span class="line"></span><br><span class="line">#计算槽号</span><br><span class="line">slot= slot_number(key)</span><br><span class="line"></span><br><span class="line">#将槽号返回给客户端</span><br><span class="line">reply_client(slot)</span><br></pre></td></tr></table></figure><h4 id="判断槽是否由当前节点负责处理"><a href="#判断槽是否由当前节点负责处理" class="headerlink" title="判断槽是否由当前节点负责处理"></a>判断槽是否由当前节点负责处理</h4><p>当节点计算出键所属的槽i之后，节点就会检查自己在clusterState.slots数组中的项i，判断键所在的槽是否由自己负责：</p><ol><li>如果clusterState.slots[i]等于clusterState.myself，那么说明槽i由当前节点负责，节点可以执行客户端发送的命令。</li><li>如果clusterState.slots[i]不等于clusterState.myself，那么说明槽i并非由当前节点负责，节点会根据clusterState.slots[i]指向的clusterNode结构所记录的节点IP和端口号，向客户端返回MOVED错误，指引客户端转向至正在处理槽i的节点。</li></ol><h4 id="MOVED错误"><a href="#MOVED错误" class="headerlink" title="MOVED错误"></a>MOVED错误</h4><p>当节点发现键所在的槽并非由自己负责处理的时候，节点就会向客户端返回一个MOVED错误，指引客户端转向至正在负责槽的节点。</p><p>MOVED错误的格式为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MOVED &lt;slot&gt; &lt;ip&gt;:&lt;port&gt;</span><br></pre></td></tr></table></figure><p>其中slot为键所在的槽，而ip和port则是负责处理槽slot的节点的IP地址和端口号。</p><p>当客户端接收到节点返回的MOVED错误时，客户端会根据MOVED错误中提供的IP地址和端口号，转向至负责处理槽slot的节点，并向该节点重新发送之前想要执行的命令。</p><p>一个集群客户端通常会与集群中的多个节点创建套接字连接，而所谓的节点转向实际上就是换一个套接字来发送命令。</p><p>如果客户端尚未与想要转向的节点创建套接字连接，那么客户端会先根据MOVED错误提供的IP地址和端口号来连接节点，然后再进行转向。</p><h4 id="节点数据库的实现"><a href="#节点数据库的实现" class="headerlink" title="节点数据库的实现"></a>节点数据库的实现</h4><p>集群节点保存键值对以及键值对过期时间的方式，与单机Redis服务器保存键值对以及键值对过期时间的方式完全相同。</p><p>节点和单机服务器在数据库方面的一个区别是，节点只能使用0号数据库，而单机Redis服务器则没有这一限制。</p><p>另外，除了将键值对保存在数据库里面之外，节点还会用clusterState结构中的slots_to_keys跳跃表来保存槽和键之间的关系：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">clusterState</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">zskiplist *slots_to_keys;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    </span><br><span class="line">&#125; clusterState;</span><br></pre></td></tr></table></figure><p>slots_to_keys跳跃表每个节点的分值（score）都是一个槽号，而每个节点的成员（member）都是一个数据库键：</p><ul><li>每当节点往数据库中添加一个新的键值对时，节点就会将这个键以及键的槽号关联到slots_to_keys跳跃表。</li><li>当节点删除数据库中的某个键值对时，节点就会在slots_to_keys跳跃表解除被删除键与槽号的关联。</li></ul><p>通过在slots_to_keys跳跃表中记录各个数据库键所属的槽，节点可以很方便地对属于某个或某些槽的所有数据库键进行批量操作，例如命令CLUSTER GETKEYSINSLOT&lt;slot&gt;&lt;count&gt;命令可以返回最多count个属于槽slot的数据库键，而这个命令就是通过遍历slots_to_keys跳跃表来实现的。</p><h3 id="重新分片"><a href="#重新分片" class="headerlink" title="重新分片"></a>重新分片</h3><p>Redis集群的重新分片操作可以将任意数量已经指派给某个节点（源节点）的槽改为指派给另一个节点（目标节点），并且相关槽所属的键值对也会从源节点被移动到目标节点。</p><p>重新分片操作可以在线（online）进行，在重新分片的过程中，集群不需要下线，并且源节点和目标节点都可以继续处理命令请求。</p><h4 id="重新分片的实现原理"><a href="#重新分片的实现原理" class="headerlink" title="重新分片的实现原理"></a>重新分片的实现原理</h4><p>Redis集群的重新分片操作是由Redis的集群管理软件redis-trib负责执行的，Redis提供了进行重新分片所需的所有命令，而redis-trib则通过向源节点和目标节点发送命令来进行重新分片操作。</p><p>redis-trib对集群的单个槽slot进行重新分片的步骤如下：</p><ol><li>redis-trib对目标节点发送CLUSTER SETSLOT &lt;slot&gt; IMPORTING <source_id>命令，让目标节点准备好从源节点导入（import）属于槽slot的键值对。</li><li>redis-trib对源节点发送CLUSTER SETSLOT &lt;slot&gt; MIGRATING <target_id>命令，让源节点准备好将属于槽slot的键值对迁移（migrate）至目标节点。</li><li>redis-trib向源节点发送CLUSTER GETKEYSINSLOT &lt;slot&gt; &lt;count&gt;命令，获得最多count个属于槽slot的键值对的键名（key name）。</li><li>对于步骤3获得的每个键名，redis-trib都向源节点发送一个MIGRATE <target_ip> <target_port> <key_name> 0 &lt;timeout&gt;命令，将被选中的键原子地从源节点迁移至目标节点。</li><li>重复执行步骤3和步骤4，直到源节点保存的所有属于槽slot的键值对都被迁移至目标节点为止。</li><li>redis-trib向集群中的任意一个节点发送CLUSTER SETSLOT&lt;slot&gt; NODE <target_id>命令，将槽slot指派给目标节点，这一指派信息会通过消息发送至整个集群，最终集群中的所有节点都会知道槽slot已经指派给了目标节点。</li></ol><p><img src="/..%5Cimg%5CRedis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%5C%E8%BF%81%E7%A7%BB%E9%94%AE%E7%9A%84%E8%BF%87%E7%A8%8B.png" alt="迁移键的过程"></p><h3 id="ASK错误"><a href="#ASK错误" class="headerlink" title="ASK错误"></a>ASK错误</h3><p>在进行重新分片期间，源节点向目标节点迁移一个槽的过程中，可能会出现这样一种情况：属于被迁移槽的一部分键值对保存在源节点里面，而另一部分键值对则保存在目标节点里面。</p><p>当客户端向源节点发送一个与数据库键有关的命令，并且命令要处理的数据库键恰好就属于正在被迁移的槽时：</p><ul><li>源节点会先在自己的数据库里面查找指定的键，如果找到的话，就直接执行客户端发送的命令。</li><li>相反地，如果源节点没能在自己的数据库里面找到指定的键，那么这个键有可能已经被迁移到了目标节点，源节点将向客户端返回一个ASK错误，指引客户端转向正在导入槽的目标节点，并再次发送之前想要执行的命令。</li></ul><h4 id="CLUSTER-SETSLOT-IMPORTING命令的实现"><a href="#CLUSTER-SETSLOT-IMPORTING命令的实现" class="headerlink" title="CLUSTER SETSLOT IMPORTING命令的实现"></a>CLUSTER SETSLOT IMPORTING命令的实现</h4><p>clusterState结构的importing_slots_from数组记录了当前节点正在从其他节点导入的槽：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">clusterState</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">clusterNode *importing_slots_from[<span class="number">16384</span>];</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    </span><br><span class="line">&#125; clusterState;</span><br></pre></td></tr></table></figure><p>如果importing_slots_from[i]的值不为NULL，而是指向一个clusterNode结构，那么表示当前节点正在从clusterNode所代表的节点导入槽i。</p><p>在对集群进行重新分片的时候，向目标节点发送命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CLUSTER SETSLOT &lt;i&gt; IMPORTING &lt;source_id&gt;</span><br></pre></td></tr></table></figure><p>可以将目标节点clusterState.importing_slots_from[i]的值设置为source_id所代表节点的clusterNode结构。</p><h4 id="CLUSTER-SETSLOT-MIGRATING命令的实现"><a href="#CLUSTER-SETSLOT-MIGRATING命令的实现" class="headerlink" title="CLUSTER SETSLOT MIGRATING命令的实现"></a>CLUSTER SETSLOT MIGRATING命令的实现</h4><p>clusterState结构的migrating_slots_to数组记录了当前节点正在迁移至其他节点的槽：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">clusterState</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">clusterNode *migrating_slots_to[<span class="number">16384</span>];</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">&#125; clusterState;</span><br></pre></td></tr></table></figure><p>如果migrating_slots_to[i]的值不为NULL，而是指向一个clusterNode结构，那么表示当前节点正在将槽i迁移至clusterNode所代表的节点。</p><p>在对集群进行重新分片的时候，向源节点发送命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CLUSTER SETSLOT &lt;i&gt; MIGRATING &lt;target_id&gt;</span><br></pre></td></tr></table></figure><p>可以将源节点clusterState.migrating_slots_to[i]的值设置为target_id所代表节点的clusterNode结构。</p><h4 id="ASK错误-1"><a href="#ASK错误-1" class="headerlink" title="ASK错误"></a>ASK错误</h4><p>如果节点收到一个关于键key的命令请求，并且键key所属的槽i正好就指派给了这个节点，那么节点会尝试在自己的数据库里查找键key，如果找到了的话，节点就直接执行客户端发送的命令。</p><p>与此相反，如果节点没有在自己的数据库里找到键key，那么节点会检查自己的clusterState.migrating_slots_to[i]，看键key所属的槽i是否正在进行迁移，如果槽i的确在进行迁移的话，那节点会向客户端发送一个ASK错误，引导客户端到正在导入槽i的节点去查找键key。</p><p>接到ASK错误的客户端会根据错误提供的IP地址和端口号，转向至正在导入槽的目标节点，然后首先向目标节点发送一个ASKING命令，之后再重新发送原本想要执行的命令。</p><h4 id="ASKING命令"><a href="#ASKING命令" class="headerlink" title="ASKING命令"></a>ASKING命令</h4><p>ASKING命令唯一要做的就是打开发送该命令的客户端的REDIS_ASKING标识，以下是该命令的伪代码实现：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def ASKING():</span><br><span class="line"># 打开标识</span><br><span class="line">client.flags |= REDIS_ASKING</span><br><span class="line"># 向客户端返回OK回复</span><br><span class="line">reply(&quot;OK&quot;)</span><br></pre></td></tr></table></figure><p>在一般情况下，如果客户端向节点发送一个关于槽i的命令，而槽i又没有指派给这个节点的话，那么节点将向客户端返回一个MOVED错误；但是，如果节点的clusterState.importing_slots_from[i]显示节点正在导入槽i，并且发送命令的客户端带有REDIS_ASKING标识，那么节点将破例执行这个关于槽i的命令一次，下图展示了这个判断过程。</p><p><img src="/..%5Cimg%5CRedis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%5C%E8%8A%82%E7%82%B9%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E6%89%A7%E8%A1%8C%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%91%BD%E4%BB%A4%E7%9A%84%E8%BF%87%E7%A8%8B.png" alt="节点判断是否执行客户端命令的过程"></p><p>当客户端接收到ASK错误并转向至正在导入槽的节点时，客户端会先向节点发送一个ASKING命令，然后才重新发送想要执行的命令，这是因为如果客户端不发送ASKING命令，而直接发送想要执行的命令的话，那么客户端发送的命令将被节点拒绝执行，并返回MOVED错误。</p><p>另外要注意的是，客户端的REDIS_ASKING标识是一个一次性标识，当节点执行了一个带有REDIS_ASKING标识的客户端发送的命令之后，客户端的REDIS_ASKING标识就会被移除。</p><h4 id="ASK错误和MOVED错误的区别"><a href="#ASK错误和MOVED错误的区别" class="headerlink" title="ASK错误和MOVED错误的区别"></a>ASK错误和MOVED错误的区别</h4><p>ASK错误和MOVED错误都会导致客户端转向，它们的区别在于：</p><ul><li>MOVED错误代表槽的负责权已经从一个节点转移到了另一个节点：在客户端收到关于槽i的MOVED错误之后，客户端每次遇到关于槽i的命令请求时，都可以直接将命令请求发送至MOVED错误所指向的节点，因为该节点就是目前负责槽i的节点。</li><li>与此相反，ASK错误只是两个节点在迁移槽的过程中使用的一种临时措施：在客户<br>端收到关于槽i的ASK错误之后，客户端只会在接下来的一次命令请求中将关于槽i的命令请求发送至ASK错误所指示的节点，但这种转向不会对客户端今后发送关于槽i的命令请求产生任何影响，客户端仍然会将关于槽i的命令请求发送至目前负责处理槽i的节点，除非ASK错误再次出现。</li></ul><h3 id="复制与故障转移"><a href="#复制与故障转移" class="headerlink" title="复制与故障转移"></a>复制与故障转移</h3><p>Redis集群中的节点分为主节点（master）和从节点（slave），其中主节点用于处理槽，而从节点则用于复制某个主节点，并在被复制的主节点下线时，代替下线主节点继续处理命令请求。</p><h4 id="设置从节点"><a href="#设置从节点" class="headerlink" title="设置从节点"></a>设置从节点</h4><p>向一个节点发送命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CLUSTER REPLICATE &lt;node_id&gt;</span><br></pre></td></tr></table></figure><p>可以让接收命令的节点成为node_id所指定节点的从节点，并开始对主节点进行复制：</p><ul><li><p>接收到该命令的节点首先会在自己的clusterState.nodes字典中找到node_id所对应节点的clusterNode结构，并将自己的clusterState.myself.slaveof指针指向这个结构，以此来记录这个节点正在复制的主节点：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">clusterNode</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"><span class="comment">//如果这是一个从节点，那么指向主节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">clusterNode</span> *<span class="title">slaveof</span>;</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>然后节点会修改自己在clusterState.myself.flags中的属性，关闭原本的REDIS_NODE_MASTER标识，打开REDIS_NODE_SLAVE标识，表示这个节点已经由原来的主节点变成了从节点。</p></li><li><p>最后，节点会调用复制代码，并根据clusterState.myself.slaveof指向的clusterNode结构所保存的IP地址和端口号，对主节点进行复制。因为节点的复制功能和单机Redis服务器的复制功能使用了相同的代码，所以让从节点复制主节点相当于向从节点发送命令SLAVEOF <master_ip> <master_port>。</p></li></ul><p>一个节点成为从节点，并开始复制某个主节点这一信息会通过消息发送给集群中的其他节点，最终集群中的所有节点都会知道某个从节点正在复制某个主节点。</p><p>集群中的所有节点都会在代表主节点的clusterNode结构的slaves属性和numslaves属性中记录正在复制这个主节点的从节点名单：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">clusterNode</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"><span class="comment">//正在复制这个主节点的从节点数量</span></span><br><span class="line">    <span class="type">int</span> numslaves;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//一个数组</span></span><br><span class="line"><span class="comment">//每个数组项指向一个正在复制这个主节点的从节点的clusterNode结构</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">clusterNode</span> **<span class="title">slaves</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="故障检测"><a href="#故障检测" class="headerlink" title="故障检测"></a>故障检测</h4><p>集群中的每个节点都会定期地向集群中的其他节点发送PING消息，以此来检测对方是否在线，如果接收PING消息的节点没有在规定的时间内，向发送PING消息的节点返回PONG消息，那么发送PING消息的节点就会将接收PING消息的节点标记为疑似下线（probable fail，PFAIL)。</p><p>集群中的各个节点会通过互相发送消息的方式来交换集群中各个节点的状态信息，例如某个节点是处于在线状态、疑似下线状态（PFAIL），还是已下线状态（FAIL）。</p><p>当一个主节点A通过消息得知主节点B认为主节点C进入了疑似下线状态时，主节点A会在自己的clusterState.nodes字典中找到主节点C所对应的clusterNode结构，并将主节点B的下线报告（failure report）添加到clusterNode结构的fail_reports链表里面：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">clusterNode</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"><span class="comment">//一个链表，记录了所有其他节点对该节点的下线报告</span></span><br><span class="line">    <span class="built_in">list</span> *fail_reports;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>每个下线报告由一个clusterNodeFailReport结构表示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">clusterNodeFailReport</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//报告目标节点已经下线的节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">clusterNode</span> *<span class="title">node</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//最后一次从node节点收到下线报告的时间</span></span><br><span class="line">    <span class="comment">//程序使用这个时间戳来检查下线报告是否过期</span></span><br><span class="line">    <span class="comment">//（与当前时间相差太久的下线报告会被删除）</span></span><br><span class="line">    <span class="type">mstime_t</span> time;</span><br><span class="line">&#125; <span class="keyword">typedef</span> clusterNodeFailReport;</span><br></pre></td></tr></table></figure><p>下线报告示例：</p><p><img src="/..%5Cimg%5CRedis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%5C%E6%9C%89%E4%B8%8B%E7%BA%BF%E6%8A%A5%E5%91%8A%E8%8A%82%E7%82%B9%E7%9A%84%E7%A4%BA%E4%BE%8B.png" alt="有下线报告节点的示例"></p><p>如果在一个集群里面，半数以上负责处理槽的主节点都将某个主节点x报告为疑似下线，那么这个主节点x将被标记为已下线（FAIL），将主节点x标记为已下线的节点会向集群广播一条关于主节点x的FAIL消息，所有收到这条FAIL消息的节点都会立即将主节点x标记为已下线。</p><h4 id="故障转移-1"><a href="#故障转移-1" class="headerlink" title="故障转移"></a>故障转移</h4><p>当一个从节点发现自己正在复制的主节点进入了已下线状态时，从节点将开始对下线主节点进行故障转移，以下是故障转移的执行步骤：</p><ol><li>复制下线主节点的所有从节点里面，会有一个从节点被选中。</li><li>被选中的从节点会执行SLAVEOF no one命令，成为新的主节点。</li><li>新的主节点会撤销所有对已下线主节点的槽指派，并将这些槽全部指派给自己。</li><li>新的主节点向集群广播一条PONG消息，这条PONG消息可以让集群中的其他节点立即知道这个节点已经由从节点变成了主节点，并且这个主节点已经接管了原本由已下线节点负责处理的槽。</li><li>新的主节点开始接收和自己负责处理的槽有关的命令请求，故障转移完成。</li></ol><h4 id="选举新的主节点"><a href="#选举新的主节点" class="headerlink" title="选举新的主节点"></a>选举新的主节点</h4><p>新的主节点是通过选举产生的。<br>以下是集群选举新的主节点的方法：</p><ol><li>集群的配置纪元是一个自增计数器，它的初始值为0。</li><li>当集群里的某个节点开始一次故障转移操作时，集群配置纪元的值会被增一。</li><li>对于每个配置纪元，集群里每个负责处理槽的主节点都有一次投票的机会，而第一个向主节点要求投票的从节点将获得主节点的投票。</li><li>当从节点发现自己正在复制的主节点进入已下线状态时，从节点会向集群广播一条CLUSTERMSG_TYPE_FAILOVER_AUTH_REQUEST消息，要求所有收到这条消息、并且具有投票权的主节点向这个从节点投票。</li><li>如果一个主节点具有投票权（它正在负责处理槽），并且这个主节点尚未投票给其他从节点，那么主节点将向要求投票的从节点返回一条CLUSTERMSG_TYPE_FAILOVER_AUTH_ACK消息，表示这个主节点支持从节点成为新的主节点。</li><li>每个参与选举的从节点都会接收CLUSTERMSG_TYPE_FAILOVER_AUTH_ACK消息，并根据自己收到了多少条这种消息来统计自己获得了多少主节点的支持。</li><li>如果集群里有N个具有投票权的主节点，那么当一个从节点收集到大于等于N&#x2F;2+1张支持票时，这个从节点就会当选为新的主节点。</li><li>因为在每一个配置纪元里面，每个具有投票权的主节点只能投一次票，所以如果有N个主节点进行投票，那么具有大于等于N&#x2F;2+1张支持票的从节点只会有一个，这确保了新的主节点只会有一个。</li><li>如果在一个配置纪元里面没有从节点能收集到足够多的支持票，那么集群进入一个新的配置纪元，并再次进行选举，直到选出新的主节点为止。</li></ol><p>这个选举新主节点的方法和第16章介绍的选举领头Sentinel 的方法非常相似，因为两者都是基于Raft算法的领头选举（leader election）方法来实现的。</p><h3 id="消息"><a href="#消息" class="headerlink" title="消息"></a>消息</h3><p>集群中的各个节点通过发送和接收消息（message）来进行通信，我们称发送消息的节点为发送者（sender），接收消息的节点为接收者（receiver）。</p><p>节点发送的消息主要有以下五种：</p><ul><li>MEET消息：当发送者接到客户端发送的CLUSTER MEET命令时，发送者会向接收者发送MEET消息，请求接收者加入到发送者当前所处的集群里面。</li><li>PING消息：集群里的每个节点默认每隔一秒钟就会从已知节点列表中随机选出五个节点，然后对这五个节点中最长时间没有发送过PING消息的节点发送PING消息，以此来检测被选中的节点是否在线。除此之外，如果节点A最后一次收到节点B发送的PONG消息的时间，距离当前时间已经超过了节点A的cluster-node-timeout选项设置时长的一半，那么节点A也会向节点B发送PING消息，这可以防止节点A因为长时间没有随机选中节点B作为PING消息的发送对象而导致对节点B的信息更新滞后。</li><li>PONG消息：当接收者收到发送者发来的MEET消息或者PING消息时，为了向发送者确认这条MEET消息或者PING消息已到达，接收者会向发送者返回一条PONG消息。另外，一个节点也可以通过向集群广播自己的PONG消息来让集群中的其他节点立即刷新关于这个节点的认识，例如当一次故障转移操作成功执行之后，新的主节点会向集群广播一条PONG消息，以此来让集群中的其他节点立即知道这个节点已经变成了主节点，并且接管了已下线节点负责的槽。</li><li>FAIL消息：当一个主节点A判断另一个主节点B已经进人FAIL状态时，节点A会向集群广播一条关于节点B的FAIL消息，所有收到这条消息的节点都会立即将节点B标记为已下线。</li><li>PUBLISH消息：当节点接收到一个PUBLISH命令时，节点会执行这个命令，并向集群广播一条PUBLISH消息，所有接收到这条PUBLISH消息的节点都会执行相同的PUBLISH命令。</li></ul><p>一条消息由消息头（header）和消息正文（data）组成，接下来的内容将首先介绍消息头，然后再分别介绍上面提到的五种不同类型的消息正文。</p><h4 id="消息头"><a href="#消息头" class="headerlink" title="消息头"></a>消息头</h4><p>节点发送的所有消息都由一个消息头包裹，消息头除了包含消息正文之外，还记录了消息发送者自身的一些信息，因为这些信息也会被消息接收者用到，所以严格来讲，我们可以认为消息头本身也是消息的一部分。</p><p>每个消息头都由一个cluster.h&#x2F;clusterMsg结构表示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//消息的长度（包括这个消息头的长度和消息正文的长度）</span></span><br><span class="line">    <span class="type">uint32_t</span> totlen;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//消息的类型</span></span><br><span class="line"><span class="type">uint16_t</span> type;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//消息正文包含的节点信息数量</span></span><br><span class="line"><span class="comment">//只在发送MEET、PING、PONG这三种Gossip协议消息时使用</span></span><br><span class="line"><span class="type">uint16_t</span> count;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//发送者所处的配置纪元</span></span><br><span class="line">    <span class="type">uint64_t</span> currentEpoch;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//如果发送者是一个主节点，那么这里记录的是发送者的配置纪元</span></span><br><span class="line"><span class="comment">//如果发送者是一个从节点，那么这里记录的是发送者正在复制的主节点的配置纪元</span></span><br><span class="line">    <span class="type">uint64_t</span> configEpoch;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//发送者的名字（ID）</span></span><br><span class="line"><span class="type">char</span> sender[REDIS_CLUSTER_NAMELEN];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//发送者目前的槽指派信息</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> myslots[REDIS_CLUSTER_SLOTS/<span class="number">8</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果发送者是一个从节点，那么这里记录的是发送者正在复制的主节点的名字</span></span><br><span class="line">    <span class="comment">//如果发送者是一个主节点，那么这里记录的是REDIS_NODE_NULL_NAME</span></span><br><span class="line">    <span class="comment">//(一个40字节长，值全为0的字节数组)</span></span><br><span class="line"><span class="type">char</span> slaveof[REDIS_CLUSTER_NAMELEN];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//发送者的端口号</span></span><br><span class="line">    <span class="type">uint16_t</span> port;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//发送者的标识值</span></span><br><span class="line">    <span class="type">uint16_t</span> flags;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//发送者所处集群的状态</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> state;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//消息的正文（或者说，内容）</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> <span class="title">clusterMsgData</span> <span class="title">data</span>;</span></span><br><span class="line"></span><br><span class="line">&#125; clusterMsg;</span><br></pre></td></tr></table></figure><p>clusterMsg.data属性指向联合cluster.h&#x2F;clusterMsgData，这个联合就是消息的正文：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">clusterMsgData</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//MEET、PING、PONG消息的正文</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"><span class="comment">//每条MEET、PING、PONG消息都包含两个</span></span><br><span class="line">         <span class="comment">//clusterMsgDataGossip结构</span></span><br><span class="line">clusterMsgDataGossip gossip[<span class="number">1</span>];</span><br><span class="line">    &#125; ping;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//FAIL消息的正文</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">clusterMsgDataFail about;</span><br><span class="line">    &#125; fail;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//PUBLISH消息的正文</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">clusterMsgDataPublish msg;</span><br><span class="line">    &#125; publish;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//其他消息的正文...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>clusterMsg结构的currentEpoch、sender、myslots等属性记录了发送者自身的节点信息，接收者会根据这些信息，在自己的clusterState.nodes字典里找到发送者对应的clusterNode结构，并对结构进行更新。</p><p>举个例子，通过对比接收者为发送者记录的槽指派信息，以及发送者在消息头的myslots属性记录的槽指派信息，接收者可以知道发送者的槽指派信息是否发生了变化。</p><p>又或者说，通过对比接收者为发送者记录的标识值，以及发送者在消息头的flags属性记录的标识值，接收者可以知道发送者的状态和角色是否发生了变化，例如节点状态由原来的在线变成了下线，或者由主节点变成了从节点等等。</p><h4 id="MEET、PING、PONG消息的实现"><a href="#MEET、PING、PONG消息的实现" class="headerlink" title="MEET、PING、PONG消息的实现"></a>MEET、PING、PONG消息的实现</h4><p>Redis集群中的各个节点通过Gossip协议来交换各自关于不同节点的状态信息，其中Gossip协议由MEET、PING、PONG三种消息实现，这三种消息的正文都由两个cluster.h&#x2F;clusterMsgDataGossip结构组成：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">clusterMsgData</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"><span class="comment">//MEET、PING和PONG消息的正文</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"><span class="comment">//每条MEET、PING、PONG消息都包含两个</span></span><br><span class="line">        <span class="comment">//clusterMsgDataGossip结构</span></span><br><span class="line">clusterMsgDataGossip gossip[<span class="number">1</span>];</span><br><span class="line">&#125; ping;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//其他消息的正文...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>因为MEET、PING、PONG三种消息都使用相同的消息正文，所以节点通过消息头的type属性来判断一条消息是MEET消息、PING消息还是PONG消息。</p><p>每次发送MEET、PING、PONG消息时，发送者都<strong>从自己的已知节点列表中随机选出两个节点（可以是主节点或者从节点）</strong>，并将这两个被选中节点的信息分别保存到两个clusterMsgDataGossip结构里面。</p><p>clusterMsgDataGossip结构记录了被选中节点的名字，发送者与被选中节点最后一次发送和接收PING消息和PONG消息的时间戳，被选中节点的P地址和端口号，以及被选中节点的标识值：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//节点的名字</span></span><br><span class="line"><span class="type">char</span> nodename[REDIS_CLUSTER_NAMELEN];</span><br><span class="line">    </span><br><span class="line"><span class="comment">//最后一次向该节点发送PING消息的时间戳</span></span><br><span class="line">    <span class="type">uint32_t</span> ping_sent;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//最后一次从该节点接收到PONG消息的时间戳</span></span><br><span class="line">    <span class="type">uint32_t</span> pong_received;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//节点的IP地址</span></span><br><span class="line"><span class="type">char</span> ip[<span class="number">16</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//节点的端口号</span></span><br><span class="line">    <span class="type">uint16_t</span> port;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//节点的标识值</span></span><br><span class="line">    <span class="type">uint16_t</span> flags;</span><br><span class="line">&#125; clusterMsgDataGossip;</span><br></pre></td></tr></table></figure><p>当接收者收到MEET、PING、PONG消息时，接收者会访问消息正文中的两个clusterMsgDataGossip结构，并根据自己是否认识clusterMsgDataGossip结构中记录的被选中节点来选择进行哪种操作：</p><ul><li>如果被选中节点不存在于接收者的已知节点列表，那么说明接收者是第一次接触到被选中节点，接收者将根据结构中记录的IP地址和端口号等信息，与被选中节点进行握手。</li><li>如果被选中节点已经存在于接收者的已知节点列表，那么说明接收者之前已经与被选中节点进行过接触，接收者将根据clusterMsgDataGossip结构记录的信息，对被选中节点所对应的clusterNode结构进行更新。</li></ul><p>举个发送PING消息和返回PONG消息的例子，假设在一个包含A、B、C、D、E、F六个节点的集群里：</p><ul><li>节点A向节点D发送PING消息，并且消息里面包含了节点B和节点C的信息，当节点D收到这条PING消息时，它将更新自己对节点B和节点C的认识。</li><li>之后，节点D将向节点A返回一条PONG消息，并且消息里面包含了节点E和节点F的消息，当节点A收到这条PONG消息时，它将更新自己对节点E和节点F的认识。</li></ul><h4 id="FAIL消息的实现"><a href="#FAIL消息的实现" class="headerlink" title="FAIL消息的实现"></a>FAIL消息的实现</h4><p>当集群里的主节点A将主节点B标记为已下线（FAIL）时，主节点A将向集群广播一条关于主节点B的FAIL消息，所有接收到这条FAIL消息的节点都会将主节点B标记为已下线。</p><p>在集群的节点数量比较大的情况下，单纯使用Gossip协议来传播节点的已下线信息会给节点的信息更新带来一定延迟，因为Gossip协议消息通常需要一段时间才能传播至整个集群，而发送FAIL消息可以让集群里的所有节点立即知道某个主节点已下线，从而尽快判断是否需要将集群标记为下线，又或者对下线主节点进行故障转移。</p><p>FAIL消息的正文由cluster.h&#x2F;clusterMsgDataFail结构表示，这个结构只包含一个nodename属性。该属性记录了已下线节点的名字：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"><span class="type">char</span> nodename[REDIS_CLUSTER_NAMELEN];</span><br><span class="line">&#125; clusterMsgDataFail;</span><br></pre></td></tr></table></figure><p>因为集群里的所有节点都有一个独一无二的名字，所以FAIL消息里面只需要保存下线节点的名字，接收到消息的节点就可以根据这个名字来判断是哪个节点下线。</p><h4 id="PUBLISH消息的实现"><a href="#PUBLISH消息的实现" class="headerlink" title="PUBLISH消息的实现"></a>PUBLISH消息的实现</h4><p>当客户端向集群中的某个节点发送命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PUBLISH &lt;channel&gt; &lt;message&gt;</span><br></pre></td></tr></table></figure><p>的时候，接收到PUBLISH命令的节点不仅会向channel频道发送消息message，它还会向集群广播一条PUBLISH消息，所有接收到这条PUBLISH消息的节点都会向channel频道发送message消息。</p><p>换句话说，向集群中的某个节点发送命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PUBLISH &lt;channel&gt; &lt;message&gt;</span><br></pre></td></tr></table></figure><p>将导致集群中的所有节点都向channel频道发送message消息。</p><p>PUBLISH消息的正文由cluster.h&#x2F;clusterMsgDataPublish结构表示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="type">uint32_t</span> channel_len;</span><br><span class="line"><span class="type">uint32_t</span> message_len;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//定义为8字节只是为了对齐其他消息结构</span></span><br><span class="line">    <span class="comment">//实际的长度由保存的内容决定</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> bulk_data[<span class="number">8</span>];</span><br><span class="line"></span><br><span class="line">&#125; clusterMsgDataPublish;</span><br></pre></td></tr></table></figure><p>clusterMsgDataPublish结构的bulk_data属性是一个字节数组，这个字节数组保存了客户端通过PUBLISH命令发送给节点的channel参数和message参数，而结构的channel_len和message_len则分别保存了channel参数的长度和message参数的长度：</p><ul><li>其中bulk_data的0字节至channel_len-1字节保存的是channel参数。</li><li>而bulk_data的channel_len字节至channel_len+message_len-1字节保存的则是message参数。</li></ul><p>举个例子，如果节点收到的PUBLISH命令为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PUBLISH &quot;news.it&quot; &quot;hello&quot;</span><br></pre></td></tr></table></figure><p>那么该clusterMsgDataPublish的结构为：</p><p><img src="/..%5Cimg%5CRedis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%5CclusterMsgDataPublish%E7%BB%93%E6%9E%84%E7%A4%BA%E4%BE%8B.png" alt="clusterMsgDataPublish结构示例"></p><h5 id="为什么不直接向节点广播PUBLISH命令"><a href="#为什么不直接向节点广播PUBLISH命令" class="headerlink" title="为什么不直接向节点广播PUBLISH命令"></a>为什么不直接向节点广播PUBLISH命令</h5><p>实际上，要让集群的所有节点都执行相同的PUBLISH命令，最简单的方法就是向所有节点广播相同的PUBLISH命令，这也是Redis在复制PUBLISH命令时所使用的方法，不过因为这种做法并不符合Redis集群的“各个节点通过发送和接收消息来进行通信”这一规则，所以节点没有采取广播PUBLISH命令的做法。</p>]]></content>
    
    
    <summary type="html">&lt;Redis设计与实现&gt;第三部分，复制、Sentinel和集群</summary>
    
    
    
    <category term="Redis设计与实现读书笔记" scheme="http://example.com/categories/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Redis" scheme="http://example.com/tags/Redis/"/>
    
    <category term="Redis设计与实现" scheme="http://example.com/tags/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/"/>
    
    <category term="多机数据库的实现" scheme="http://example.com/tags/%E5%A4%9A%E6%9C%BA%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    
    <category term="复制" scheme="http://example.com/tags/%E5%A4%8D%E5%88%B6/"/>
    
    <category term="Sentinel" scheme="http://example.com/tags/Sentinel/"/>
    
    <category term="集群" scheme="http://example.com/tags/%E9%9B%86%E7%BE%A4/"/>
    
  </entry>
  
  <entry>
    <title>&lt;Redis设计与实现&gt;第二部分</title>
    <link href="http://example.com/2022/05/29/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86/"/>
    <id>http://example.com/2022/05/29/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86/</id>
    <published>2022-05-28T16:00:00.000Z</published>
    <updated>2022-05-28T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第二部分-单机数据库的实现"><a href="#第二部分-单机数据库的实现" class="headerlink" title="第二部分 单机数据库的实现"></a>第二部分 单机数据库的实现</h1><h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><p>本章将对Redis服务器的数据库实现进行详细介绍，说明服务器保存数据库的方法，客户端切换数据库的方法，数据库保存键值对的方法，以及针对数据库的添加、删除、查看、更新操作的实现方法等。除此之外，本章还会说明服务器保存键的过期时间的方法，以及服务器自动删除过期键的方法。最后，本章还会说明Redis2.8新引入的数据库通知功能的实现方法。</p><h3 id="服务器中的数据库"><a href="#服务器中的数据库" class="headerlink" title="服务器中的数据库"></a>服务器中的数据库</h3><p>Redis数据库将所有数据库都保存在服务器状态redis.h&#x2F;redisServer结构的db数组中，db数组的每个项都是一个redis.h&#x2F;redisDb结构，每个redisDb结构代表一个数据库：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span> &#123;</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">//一个数组，保存着服务器中的所有数据库</span></span><br><span class="line">    redisDb *db;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在初始化服务器时，程序会根据服务器状态的dbnum属性来决定应该创建多少个数据库：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span> &#123;</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">//服务器的数据库数量</span></span><br><span class="line">    <span class="type">int</span> dbnum;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="切换数据库"><a href="#切换数据库" class="headerlink" title="切换数据库"></a>切换数据库</h3><p>每个Redis客户端都有自己的目标数据库，每当客户端执行数据库写命令或者数据库读命令时，目标数据库就会成为这些命令的操作对象。</p><p>默认情况下，Redis客户端的目标数据库为0号数据库，但客户端可以通过执行SELECT命令来切换目标数据库。</p><p>在服务器内部，客户端状态redisClient结构的db属性记录了客户端当前的目标数据库，这个属性是一个指向redisDB结构的指针：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisClient</span> &#123;</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">//记录客户端当前正在使用的数据库</span></span><br><span class="line">    redisDb *db;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125; redisClient;</span><br></pre></td></tr></table></figure><p>redisClient.db指针指向redisServer.db数组的其中一个元素，而被指向的元素就是客户端的目标数据库。通过修改redisClient.db指针，让它指向服务器中的不同数据库，从而实现切换目标数据库的功能——这就是SELECT命令的原理。</p><p><img src="/../img/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%9A%84%E7%9B%AE%E6%A0%87%E6%95%B0%E6%8D%AE%E5%BA%93.png" alt="客户端的目标数据库"></p><h3 id="数据库键空间"><a href="#数据库键空间" class="headerlink" title="数据库键空间"></a>数据库键空间</h3><p>Redis是一个键值对（key-value pair）数据库服务器，服务器中的每个数据库都由一个redis.h&#x2F;redisDb结构表示，其中，redisDB结构的dict字典保存了数据库中的所有键值对，我们将这个字典称为键空间（key space）:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisDb</span> &#123;</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">//数据库键空间，保存着数据库中的所有键值对</span></span><br><span class="line">    dict *dict;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125; redisDb;</span><br></pre></td></tr></table></figure><p>键空间和用户所建的数据库是直接对应的：</p><ul><li>键空间的键也就是数据库的键，每个键都是一个字符串对象。</li><li>键空间的值也就是数据库的值，每个值可以是字符串对象、列表对象、哈希表对象、集合对象和有序集合对象中的任意一种Redis对象。</li></ul><p>以下为一个对空白数据库的键空间执行命令的例子：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">redis<span class="operator">&gt;</span> <span class="keyword">SET</span> message &quot;hello world&quot;</span><br><span class="line">OK</span><br><span class="line">redis<span class="operator">&gt;</span> RPUSH alphabet &quot;a&quot;&quot;b&quot;&quot;c&quot;</span><br><span class="line">(<span class="type">integer</span>)<span class="number">3</span></span><br><span class="line">redis<span class="operator">&gt;</span> HSET book name &quot;Redis in Action&quot;</span><br><span class="line">(<span class="type">integer</span>) <span class="number">1</span></span><br><span class="line">redis<span class="operator">&gt;</span> HSET book author &quot;Josiah L. Carlson&quot;</span><br><span class="line">(<span class="type">integer</span>) <span class="number">1</span></span><br><span class="line">redis<span class="operator">&gt;</span> HSET book publisher &quot;Manning&quot;</span><br><span class="line">(<span class="type">integer</span>) <span class="number">1</span></span><br></pre></td></tr></table></figure><p>当执行玩这些命令之后，数据库的键空间将会是下图的样子：</p><p><img src="/../img/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/%E6%95%B0%E6%8D%AE%E5%BA%93%E9%94%AE%E7%A9%BA%E9%97%B4%E4%BE%8B%E5%AD%90.png" alt="数据库键空间例子.png"></p><ul><li>alphabet是一个列表键，键的名字是一个包含字符串”alphabet”的字符串对象，键的值则是一个包含三个元素的列表对象。</li><li>book是一个哈希表键，键的名字是一个包含字符串”book”的字符串对象，键的值则是一个包含三个键值对的哈希表对象。</li><li>message是一个字符串键，键的名字是一个包含字符串”message”的字符串对象，键的值则是一个包含字符串”hello world”的字符串对象。</li></ul><p>因为数据库的键空间是一个字典，所以所有很对数据库的操作实际上都是通过对键空间字典进行操作来实现的。</p><h4 id="添加新键"><a href="#添加新键" class="headerlink" title="添加新键"></a>添加新键</h4><p>添加一个新键值对到数据库，实际上就是将一个新键值对添加到键空间字典里面，其中键为字符串对象，而值为任意一种类型的Redis对象。</p><h4 id="删除键"><a href="#删除键" class="headerlink" title="删除键"></a>删除键</h4><p>删除数据库中的一个键，实际上就是在键空间里面删除键所对应的键值对对象。</p><h4 id="更新键"><a href="#更新键" class="headerlink" title="更新键"></a>更新键</h4><p>对一个数据库键进行更新，实际上就是对键空间里面键所对应的值对象进行更新，根据值对象的类型不同，更新的具体方法也会有所不同。</p><h4 id="对键取值"><a href="#对键取值" class="headerlink" title="对键取值"></a>对键取值</h4><p>对一个数据库键进行取值，实际上就是在键空间中取出键所对应的值对象，根据值对象的类型不同，具体的取值方法也会有所不同。</p><h4 id="其他键空间操作"><a href="#其他键空间操作" class="headerlink" title="其他键空间操作"></a>其他键空间操作</h4><p>除了上面列出的添加、删除、更新、取值操作之外，还有很多针对数据库本身的Redis命令，也是通过对键空间进行处理来完成的。</p><p>比如说，用于清空整个数据库的FLUSHDB命令，就是通过删除键空间中的所有键值对来实现的。又比如说，用于随机返回数据库中某个键的RANDOMKEY命令，就是通过在键空间中随机返回一个键来实现的。</p><p>另外，用于返回数据库键数量的DBSIZE命令，就是通过返回键空间中包含的键值对的数量来实现的。类似的命令还有EXISTS、RENAME、KEYS等，这些命令都是通过对键空间进行操作来实现的。</p><h4 id="读写键空间时的维护操作"><a href="#读写键空间时的维护操作" class="headerlink" title="读写键空间时的维护操作"></a>读写键空间时的维护操作</h4><p>当使用Redis命令对数据库进行读写时，服务器不仅会对键空间执行指定的读写操作，还会执行一些额外的维护操作，其中包括：</p><ul><li>在读取一个键之后（读操作和写操作都要对键进行读取)，服务器会根据键是否存在来更新服务器的键空间命中（hit）次数或键空间不命中（miss）次数，这两个值可以在INFO stats命令的keyspace_hits属性和keyspace_misses属性中查看。</li><li>在读取一个键之后，服务器会更新键的LRU（最后一次使用）时间，这个值可以用于计算键的闲置时间，使用OBJECT idletime&lt;key&gt;命令可以查看键key的闲置时间。</li><li>如果服务器在读取一个键时发现该键已经过期，那么服务器会先删除这个过期键，然后才执行余下的其他操作。</li><li>如果有客户端使用WATCH命令监视了某个键，那么服务器在对被监视的键进行修改之后，会将这个键标记为脏（dirty），从而让事务程序注意到这个键已经被修改过。</li><li>服务器每次修改一个键之后，都会对脏（dirty）键计数器的值增1，这个计数器会触发服务器的持久化以及复制操作。</li><li>如果服务器开启了数据库通知功能，那么在对键进行修改之后，服务器将按配置发送相应的数据库通知。</li></ul><h3 id="设置建的生存时间或过期时间"><a href="#设置建的生存时间或过期时间" class="headerlink" title="设置建的生存时间或过期时间"></a>设置建的生存时间或过期时间</h3><p>通过EXPIRE命令或者PEXPIRE命令，客户端可以以秒或者毫秒精度为数据库中的某个键设置生存时间（TTL），在经过指定的秒数或者毫秒数之后，服务器就会自动删除生存时间为0的键。</p><p>与EXPIRE命令和PEXPIRE命令类似，客户端可以通过EXPIREAT命令或PEXPIREAT命令，以秒或者毫秒精度给数据库中的某个键设置过期时间（expire time）。过期时间是一个UNIX时间戳，当键的过期时间来临时，服务器就会自动从数据库中删除这个键。</p><p>TTL命令和PTTL命令接受一个带有生存时间或者过期时间的键，返回这个键的剩余生存时间，也就是，返回距离这个键被服务器自动删除还有多长时间。</p><h4 id="设置过期时间"><a href="#设置过期时间" class="headerlink" title="设置过期时间"></a>设置过期时间</h4><p>Redis有四个不同的命令可以用于设置键的生存时间（键可以存在多久）或过期时间（键什么时候会被删除）：</p><ul><li>EXPIRE&lt;key&gt; &lt;ttl&gt;命令用于将键key的生存时间设置为ttl秒。</li><li>PEXPIRE&lt;key&gt; &lt;ttl&gt;命令用于将键key的生存时间设置为ttl毫秒。</li><li>EXPIREAT&lt;key&gt; &lt;timestamp&gt;命令用于将键key的过期时间设置为timestamp所指定的秒数时间戳。</li><li>PEXPIREAT&lt;key&gt; &lt;timestamp&gt;命令用于将键key的过期时间设置为timestamp所指定的毫秒数时间戳。</li></ul><p>虽然形式上有四种不同的设置命令，但实际上EXPIRE、PEXPIRE、EXPIREAT三个命令都会转化成PEXPIREAT命令来执行：</p><p><img src="/../img/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/%E7%94%9F%E5%AD%98%E8%BF%87%E6%9C%9F%E6%97%B6%E9%97%B4%E7%9A%84%E8%BD%AC%E6%8D%A2.png" alt="生存过期时间的转换"></p><p>PEXPIREAT命令的伪代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">def <span class="title function_">PEXPIREAT</span><span class="params">(key, expire_time_in_ms)</span>:</span><br><span class="line">#如果给定的键不存在于键空间，那么不能设置过期时间</span><br><span class="line"><span class="keyword">if</span> key not in redisDb.dict:</span><br><span class="line"><span class="keyword">return</span> 0;</span><br><span class="line">#在过期字典中关联键和过期时间</span><br><span class="line">redisDb.expires(key) = expire_time_in_ms</span><br><span class="line">#过期时间设置成功</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><h4 id="保存过期时间"><a href="#保存过期时间" class="headerlink" title="保存过期时间"></a>保存过期时间</h4><p>redisDb结构的expires字典保存了数据库中所有键的过期时间，我们称这个字典为过期字典：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisDb</span> &#123;</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">//过期字典，保存着键的过期时间</span></span><br><span class="line">    dict *expires;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125; redisDb;</span><br></pre></td></tr></table></figure><ul><li>过期字典的键是一个指针，这个指针指向键空间中的某个键对象（也就是某个数据库键）。</li><li>过期字典的值是一个long long类型的整数，这个整数保存了键所指向的数据库键的过期时间——一个毫秒精度的UNIX时间戳。</li></ul><p><img src="/../img/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/%E8%BF%87%E6%9C%9F%E5%AD%97%E5%85%B8.png" alt="过期字典"></p><h4 id="移除过期时间"><a href="#移除过期时间" class="headerlink" title="移除过期时间"></a>移除过期时间</h4><p>PERSIST命令可以移除一个键的过期时间。PERSIST命令就是PEXPIREAT命令的反操作：PERSIST命令在过期字典中查找给定的键，并解除键和值（过期时间）在过期字典中的关联。</p><p>PERSIST命令的伪代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">def <span class="title function_">PERSIST</span><span class="params">(key)</span>:</span><br><span class="line">#如果键不存在，或者键没有设置过期时间，那么直接返回</span><br><span class="line"><span class="keyword">if</span> key not in redisDb.expires:</span><br><span class="line"><span class="keyword">return</span> 0</span><br><span class="line">#移除过期字典中给定键的键值对关联</span><br><span class="line">redisDb.expires.<span class="title function_">remove</span><span class="params">(key)</span></span><br><span class="line">#键的过期时间移除成功</span><br><span class="line"><span class="keyword">return</span> 1</span><br></pre></td></tr></table></figure><h4 id="计算并返回剩余生存时间"><a href="#计算并返回剩余生存时间" class="headerlink" title="计算并返回剩余生存时间"></a>计算并返回剩余生存时间</h4><p>TTL命令以秒为单位返回键的剩余生存时间，而PTTL命令则以毫秒为单位返回键的剩余生存时间。</p><p>TTL和PTTL两个命令都是通过计算键的过期时间和当前时间之间的差来实现的，以下是这两个命令的伪代码实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">def <span class="title function_">PTTL</span><span class="params">(key)</span>:</span><br><span class="line">#键不存在于数据库</span><br><span class="line"><span class="keyword">if</span> key not in redisDb.dict:</span><br><span class="line"><span class="keyword">return</span> -2</span><br><span class="line"></span><br><span class="line">#尝试取得键的过期时间</span><br><span class="line">#如果键没有设置过期时间，那么expire_time_in_ms将为None</span><br><span class="line">expire_time_in_ms = redisDb.expires.get(key)</span><br><span class="line"></span><br><span class="line">    #键没有设置过期时间</span><br><span class="line"><span class="keyword">if</span> expire_time_in_ms is None:</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line"></span><br><span class="line">#获得当前时间</span><br><span class="line">now_ms = get_current_unix_timestamp_in_ms()</span><br><span class="line">            </span><br><span class="line">#过期时间减去当前时间，得出的差就是键的剩余生存时间</span><br><span class="line"><span class="keyword">return</span>(expire_time_in_ms - now_ms)</span><br><span class="line"></span><br><span class="line">def TTL(key):</span><br><span class="line">#获取以毫秒为单位的剩余生存时间</span><br><span class="line">ttl_in_ms = PTTL(key)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ttl_in ms &lt; <span class="number">0</span>:</span><br><span class="line">#处理返回值为<span class="number">-2</span>和<span class="number">-1</span>的情况</span><br><span class="line"><span class="keyword">return</span> ttl_in_ms</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">#将毫秒转换为秒</span><br><span class="line"><span class="keyword">return</span> ms_to_sec(ttl_in_ms)</span><br></pre></td></tr></table></figure><h4 id="过期键的判定"><a href="#过期键的判定" class="headerlink" title="过期键的判定"></a>过期键的判定</h4><p>通过过期字典，程序可以用以下步骤检查一个给定键是否过期：</p><ol><li>检查给定键是否存在于过期字典：如果存在，那么取得键的过期时间。</li><li>检查当前UNIX时间戳是否大于键的过期时间：如果是的话，那么键已经过期；否则的话，键未过期。</li></ol><p>可以用伪代码来描述这一过程：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">def <span class="title function_">is_expired</span><span class="params">(key)</span>:</span><br><span class="line">#取得键的过期时间</span><br><span class="line">expire_time_in_ms = redisDb.expires.get(key)</span><br><span class="line">#键没有设置过期时间</span><br><span class="line"><span class="keyword">if</span> expire_time_in_ms is None:</span><br><span class="line"><span class="keyword">return</span> False</span><br><span class="line">#取得当前时间的UNIX时间戳</span><br><span class="line">now_ms = get_current_unix_timestamp_in_ms()</span><br><span class="line">#检查当前时间是否大于键的过期时间</span><br><span class="line"><span class="keyword">if</span> now_ms &gt; expire_time_in_ms:</span><br><span class="line">#是，键已经过期</span><br><span class="line"><span class="keyword">return</span> True</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">#否，键未过期</span><br><span class="line"><span class="keyword">return</span> False</span><br></pre></td></tr></table></figure><h3 id="过期键删除策略"><a href="#过期键删除策略" class="headerlink" title="过期键删除策略"></a>过期键删除策略</h3><p>下面讨论三种可能的删除过期键的策略：</p><ul><li>定时删除：在设置键的过期时间的同时，创建一个定时器（timer），让定时器在键的<br>过期时间来临时，立即执行对键的删除操作。</li><li>惰性删除：放任键过期不管，但是每次从键空间中获取键时，都检查取得的键是否<br>过期，如果过期的话，就删除该键；如果没有过期，就返回该键。</li><li>定期删除：每隔一段时间，程序就对数据库进行一次检查，删除里面的过期键。至<br>于要删除多少过期键，以及要检查多少个数据库，则由算法决定。</li></ul><p>在这三种策略中，第一种和第三种为主动删除策略，而第二种则为被动删除策略。</p><h4 id="定时删除"><a href="#定时删除" class="headerlink" title="定时删除"></a>定时删除</h4><p>定时删除策略对内存是最友好的，对CPU时间是最不友好的：</p><ul><li>内存友好，通过使用定时器，定时删除策略可以保证过期键会尽可能快地被删除，并释放过期键所占用的内存。</li><li>CPU时间不友好，在过期键比较多的情况下，删除过期键这一行为可能会占用相当一部分CPU时间，在内存不紧张但是CPU时间非常紧张的情况下，将CPU时间用在删除和当前任务无关的过期键上，无疑会对服务器的响应时间和吞吐量造成影响。</li></ul><p>除此之外，创建一个定时器需要用到Redis服务器中的时间事件，而当前时间事件的实现方式——无序链表，查找一个事件的时间复杂度为O(N)——并不能高效地处理大量时间事件。因此，要让服务器创建大量的定时器，从而实现定时删除策略，在现阶段来说并不现实。</p><h4 id="惰性删除"><a href="#惰性删除" class="headerlink" title="惰性删除"></a>惰性删除</h4><p>惰性删除策略对CPU时间是最友好的，对内存是最不友好的：</p><ul><li>CPU时间友好，程序只会在取出键时才对键进行过期检查，这可以保证删除过期键的操作只会在非做不可的情况下进行，并且删除的目标仅限于当前处理的键，这个策略不会在删除其他无关的过期键上花费任何CPU时间。</li><li>内存不友好，如果一个键已经过期，而这个键又仍然保留在数据库中，那么只要这个过期键不被删除，它所占用的内存就不会释放。</li></ul><p>在使用惰性删除策略时，如果数据库中有非常多的过期键，而这些过期键又恰好没有被访问到的话，那么它们也许永远也不会被删除（除非用户手动执行FLUSHDB），我们甚至可以将这种情况看作是一种内存泄漏——无用的垃圾数据占用了大量的内存，而服务器却不会自己去释放它们，这对于运行状态非常依赖于内存的Redis服务器来说，肯定不是一个好消息。</p><h4 id="定期删除"><a href="#定期删除" class="headerlink" title="定期删除"></a>定期删除</h4><p>从上面对定时删除和惰性删除的讨论来看，这两种删除方式在单一使用时都有明显的缺陷：</p><ul><li>定时删除占用太多CPU时间，影响服务器的响应时间和吞吐量。</li><li>惰性删除浪费太多内存，有内存泄漏的危险。</li></ul><p>定期删除策略是前两种策略的一种整合和折中：</p><ul><li>定期删除策略每隔一段时间执行一次删除过期键操作，并通过限制删除操作执行的时长和频率来减少删除操作对CPU时间的影响。</li><li>除此之外，通过定期删除过期键，定期删除策略有效地减少了因为过期键而带来的内存浪费。</li></ul><p>定期删除策略的难点是确定删除操作执行的时长和频率：</p><ul><li>如果删除操作执行得太频繁，或者执行的时间太长，定期删除策略就会退化成定时<br>删除策略，以至于将CPU时间过多地消耗在删除过期键上面。</li><li>如果删除操作执行得太少，或者执行的时间太短，定期删除策略又会和惰性删除策<br>略一样，出现浪费内存的情况。</li></ul><p>因此，如果采用定期删除策略的话，服务器必须根据情况，合理地设置删除操作的执行时长和执行频率。</p><h3 id="Redis的过期键删除策略"><a href="#Redis的过期键删除策略" class="headerlink" title="Redis的过期键删除策略"></a>Redis的过期键删除策略</h3><p>Redis服务器实际使用的是惰性删除和定期删除两种策略：通过配合使用这两种删除策略，服务器可以很好地在合理使用CPU时间和避免浪费内存空间之间取得平衡。</p><h4 id="惰性删除策略的实现"><a href="#惰性删除策略的实现" class="headerlink" title="惰性删除策略的实现"></a>惰性删除策略的实现</h4><p>过期键的惰性删除策略由db.c&#x2F;expireIfNeeded函数实现，所有读写数据库的Redis命令在执行之前都会调用expireIfNeeded函数对输入键进行检查：</p><ul><li>如果输入键已经过期，那么expireIfNeeded函数将输入键从数据库中删除</li><li>如果输入键未过期，那么expireIfNeeded函数不做动作。</li></ul><p>expireIfNeeded函数就像一个过滤器，它可以在命令真正执行之前，过滤掉过期的输入键，从而避免命令接触到过期键。</p><p>另外，因为每个被访问的键都可能因为过期而被expireIfNeeded函数删除，所以每个命令的实现函数都必须能同时处理键存在以及键不存在这两种情况：</p><ul><li>当键存在时，命令按照键存在的情况执行。</li><li>当键不存在或者键因为过期而被expireIfNeeded函数删除时，命令按照键不存在的情况执行。</li></ul><h4 id="定期删除策略的实现"><a href="#定期删除策略的实现" class="headerlink" title="定期删除策略的实现"></a>定期删除策略的实现</h4><p>过期键的定期删除策略由redis.c&#x2F;activeExpireCycle函数实现，每当Redis的服务器周期性操作redis.c&#x2F;ServerCron函数执行时，activeExpireCycle函数就会被调用，它在规定时间内，分多次遍历服务器中的各个数据库，从数据库的expires字典中随机检查一部分键的过期时间，并删除其中的过期键。</p><p>整个过程的伪代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">#默认每次检查的数据库数量</span><br><span class="line">DEFAULT_DB_NUMBERS = <span class="number">16</span></span><br><span class="line">#默认每个数据库检查的键数量</span><br><span class="line">DEFAULT_KEY_NUMBERS = <span class="number">20</span></span><br><span class="line">#全局变量，记录检查进度</span><br><span class="line">current_db = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">def activeExpireCycle():</span><br><span class="line">#初始化要检查的数据库数量</span><br><span class="line">#如果服务器的数据库数量比DEFAULT_DB_NUMBERS要小</span><br><span class="line">#那么以服务器的数据库数量为准</span><br><span class="line"><span class="keyword">if</span> server.dbnum &lt; DEFAULT_DB_NUMBERS:</span><br><span class="line">db_numbers= server.dbnum</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">db_numbers = DEFAULT_DB_NUMBERS</span><br><span class="line">#遍历各个数据库</span><br><span class="line"><span class="keyword">for</span> i in range(db_numbers):</span><br><span class="line">#如果current db的值等于服务器的数据库数量</span><br><span class="line">#这表示检查程序已经遍历了服务器的所有数据库一次</span><br><span class="line">#将current db重置为<span class="number">0</span>，开始新的一轮遍历</span><br><span class="line"><span class="keyword">if</span> current_db == server.dbnum:</span><br><span class="line">current_db = <span class="number">0</span></span><br><span class="line">#获取当前要处理的数据库</span><br><span class="line">redisDb = server.db[current_db]</span><br><span class="line">#将数据库索引增<span class="number">1</span>，指向下一个要处理的数据库</span><br><span class="line">current_db += <span class="number">1</span></span><br><span class="line">#检查数据库键</span><br><span class="line"><span class="keyword">for</span> j in range(DEFAULT_KEY_NUMBERS):</span><br><span class="line">#如果数据库中没有一个键带有过期时间，那么跳过这个数据库</span><br><span class="line"><span class="keyword">if</span> redisDb.expires.size() == <span class="number">0</span>: <span class="keyword">break</span></span><br><span class="line">#随机获取一个带有过期时间的键</span><br><span class="line">key_with_ttl = redisDb.expires.get_random_key()</span><br><span class="line">#检查键是否过期，如果过期就删除它</span><br><span class="line"><span class="keyword">if</span> is_expired(key_with_ttl):</span><br><span class="line">delete_key(key_with_ttl)</span><br><span class="line">#以达到时间上限，停职处理</span><br><span class="line"><span class="keyword">if</span> reach_time_limit(): <span class="keyword">return</span></span><br></pre></td></tr></table></figure><ul><li>函数每次运行时，都从一定数量的数据库中取出一定数量的随机键进行检查，并删除其中的过期键。</li><li>全局变量current_db会记录当前activeExpireCycle函数检查的进度，并在下一次activeExpireCycle函数调用时，接着上一次的进度进行处理。比如说，如果当前activeExpireCycle函数在遍历10号数据库时返回了，那么下次activeExpireCycle函数执行时，将从11号数据库开始查找并删除过期键。</li><li>随着activeExpireCycle函数的不断执行，服务器中的所有数据库都会被检查一遍，这时函数将current_db变量重置为0，然后再次开始新一轮的检查工作。</li></ul><h3 id="AOF、RDB和复制功能对过期键的处理"><a href="#AOF、RDB和复制功能对过期键的处理" class="headerlink" title="AOF、RDB和复制功能对过期键的处理"></a>AOF、RDB和复制功能对过期键的处理</h3><p>在这一节，我们将探讨过期键对Redis服务器中其他模块的影响，看看RDB持久化功能、AOF持久化功能以及复制功能是如何处理数据库中的过期键的。</p><h4 id="生成RDB文件"><a href="#生成RDB文件" class="headerlink" title="生成RDB文件"></a>生成RDB文件</h4><p>在执行SAVE命令或者BGSAVE命令创建一个新的RDB文件时，程序会对数据库中的键进行检查，已过期的键不会被保存到新创建的RDB文件中。因此，数据库中包含过期键不会对生成新的RDB文件造成影响。</p><h4 id="载入RDB文件"><a href="#载入RDB文件" class="headerlink" title="载入RDB文件"></a>载入RDB文件</h4><p>在启动Redis服务器时，如果服务器开启了RDB功能，那么服务器将对RDB文件进行载入：</p><ul><li>如果服务器以主服务器模式运行，那么在载人RDB文件时，程序会对文件中保存的键进行检查，未过期的键会被载入到数据库中，而过期键则会被忽略，所以过期键对载入RDB文件的主服务器不会造成影响。</li><li>如果服务器以从服务器模式运行，那么在载入RDB文件时，文件中保存的所有键，不论是否过期，都会被载人到数据库中。不过，因为主从服务器在进行数据同步的时候，从服务器的数据库就会被清空，所以一般来讲，过期键对载入RDB文件的从服务器也不会造成影响。</li></ul><h4 id="AOF文件写入"><a href="#AOF文件写入" class="headerlink" title="AOF文件写入"></a>AOF文件写入</h4><p>当服务器以AOF持久化模式运行时，如果数据库中的某个键已经过期，但它还没有被惰性删除或者定期删除，那么AOF 文件不会因为这个过期键而产生任何影响。</p><p>当过期键被惰性删除或者定期删除之后，程序会向AOF文件追加（append）一条DEL命令，来显式地记录该键已被删除。</p><p>举个例子，如果客户端使用GET message命令，试图访问过期的message键，那么服务器将执行以下三个动作：</p><ol><li>从数据库中删除message键。</li><li>追加一条DEL message命令到AOF文件。</li><li>向执行GET命令的客户端返回空回复。</li></ol><h4 id="AOF重写"><a href="#AOF重写" class="headerlink" title="AOF重写"></a>AOF重写</h4><p>和生成RDB文件时类似，在执行AOF重写的过程中，程序会对数据库中的键进行检查，已过期的键不会被保存到重写后的AOF文件中。</p><p>因此，数据库中包含过期键不会对AOF重写造成影响。</p><h4 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h4><p>当服务器运行在复制模式下时，从服务器的过期键删除动作由主服务器控制：</p><ul><li>主服务器在删除一个过期键之后，会显式地向所有从服务器发送一个DEL命令，告知从服务器删除这个过期键。</li><li>从服务器在执行客户端发送的读命令时，即使碰到过期键也不会将过期键删除，而是继续像处理未过期的键一样来处理过期键。</li><li>口从服务器只有在接到主服务器发来的DEL命令之后，才会删除过期键。</li></ul><p>通过由主服务器来控制从服务器统一地删除过期键，可以保证主从服务器数据的一致性，也正是因为这个原因，当一个过期键仍然存在于主服务器的数据库时，这个过期键在从服务器里的复制品也会继续存在。</p><h3 id="数据库通知"><a href="#数据库通知" class="headerlink" title="数据库通知"></a>数据库通知</h3><p>数据库通知功能可以让客户端通过订阅给定的频道或者模式，来获知数据库中键的变化，以及数据库中命令的执行情况。</p><p>关注“某个键执行了什么命令”的通知称为键空间通知（key-space notification），除此之外，还有另一类称为键事件通知（key-event notification）的通知，它们关注的是“某个命令被什么键执行了”。</p><h4 id="发送通知"><a href="#发送通知" class="headerlink" title="发送通知"></a>发送通知</h4><p>发送数据库通知的功能是由notify.c&#x2F;notifyKeyspaceEvent函数实现的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">notifyKeyspaceEvent</span><span class="params">(<span class="type">int</span> type, <span class="type">char</span> *event, robj *key, <span class="type">int</span> dbid)</span>;</span><br></pre></td></tr></table></figure><p>函数的type参数是当前想要发送的通知的类型，程序会根据这个值来判断通知是否就是服务器配置notify-keyspace-events选项所选定的通知类型，从而决定是否发送通知。</p><p>event、keys和dbid分别是事件的名称、产生事件的键，以及产生事件的数据库号码，函数会根据type参数以及这三个参数来构建事件通知的内容，以及接收通知的频道名。</p><p>每当一个Redis命令需要发送数据库通知的时候，该命令的实现函数就会调用notify-KeyspaceEvent函数，并向函数传递该命令所引发的事件的相关信息。</p><h4 id="发送通知的实现"><a href="#发送通知的实现" class="headerlink" title="发送通知的实现"></a>发送通知的实现</h4><p>以下是notifyKeyspaceEvent函数的伪代码实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">def <span class="title function_">notifyKeyspaceEvent</span><span class="params">(type, event, key, dbid)</span>:</span><br><span class="line">#如果给定的通知不是服务器允许发送的通知，那么直接返回</span><br><span class="line"><span class="keyword">if</span> <span class="title function_">not</span><span class="params">(server.notify_keyspace_events &amp; type)</span>:</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">#发送键空间通知</span><br><span class="line"><span class="keyword">if</span> server.notify_keyspace_events &amp; REDIS_NOTIFY_KEYSPACE:</span><br><span class="line">#将通知发送给频道__keyspace@&lt;dbid&gt;__:&lt;key&gt;</span><br><span class="line">#内容为键所发生的事件&lt;event&gt;</span><br><span class="line"></span><br><span class="line">#构建频道名字</span><br><span class="line">chan = <span class="string">&quot;__keyspace@&#123;dbid&#125;__:&#123;key&#125;&quot;</span>.format(dbid=dbid, key=key)</span><br><span class="line">#发送通知</span><br><span class="line">pubsubPublishMessage(chan, event)</span><br><span class="line">#发送键事件通知</span><br><span class="line"><span class="keyword">if</span> server.notify_keyspace_events &amp; REDIS_NOTIFY_KEYEVENT:</span><br><span class="line">#将通知发送给频道__keyevent@&lt;dbid&gt;__:&lt;event&gt;</span><br><span class="line">#内容为发生事件的键&lt;key&gt;</span><br><span class="line"></span><br><span class="line">#构建频道名字</span><br><span class="line">chan = <span class="string">&quot;__keyevent@&#123;dbid&#125;__:&#123;event&#125;&quot;</span>.format(dbid=dbid, event=event)</span><br><span class="line">#发送通知</span><br><span class="line">pubsubPublishMessage(chan, key)</span><br></pre></td></tr></table></figure><p>notifyKeyspaceEvent函数执行以下操作：</p><ol><li>server.notify_keyspace_events属性就是服务器配置notify-keyspace-events选项所设置的值，如果给定的通知类型type不是服务器允许发送的通知类型，那么函数会直接返回，不做任何动作。</li><li>如果给定的通知是服务器允许发送的通知，那么下一步函数会检测服务器是否允许发送键空间通知，如果允许的话，程序就会构建并发送事件通知。</li><li>最后，函数检测服务器是否允许发送键事件 通知，如果允许的话，程序就会构建并发送事件通知。</li></ol><p>另外，pubsubPublishMessage函数是PUBLISH命令的实现函数，执行这个函数等同于执行PUBLISH命令，订阅数据库通知的客户端收到的信息就是由这个函数发出的。</p><h2 id="RDB持久化"><a href="#RDB持久化" class="headerlink" title="RDB持久化"></a>RDB持久化</h2><p>Redis是一个键值对数据库服务器，服务器中通常包含着任意个非空数据库，而每个非空数据库中又可以包含任意个键值对，为了方便起见，我们将服务器中的非空数据库以及它们的键值对统称为<strong>数据库状态</strong>。</p><p>因为Redis是<strong>内存数据库</strong>，它将自己的数据库状态储存在内存里面，所以如果不想办法将储存在内存中的数据库状态保存到磁盘里面，那么一旦服务器进程退出，服务器中的数据库状态也会消失不见。</p><p>为了解决这个问题，Redis提供了RDB持久化功能，这个功能可以将Redis在内存中的数据库状态保存到磁盘里面，避免数据意外丢失。RDB持久化既可以手动执行，也可以根据服务器配置选项定期执行，该功能可以将某个时间点上的数据库状态保存到一个RDB文件中。</p><p>RDB持久化功能所生成的<strong>RDB文件</strong>是一个经过压缩的二进制文件，通过该文件可以还原生成RDB文件时的数据库状态。因为RDB文件是保存在硬盘里面的，所以即使Redis服务器进程退出，甚至运行Redis服务器的计算机停机，但只要RDB文件仍然存在，Redis服务器就可以用它来还原数据库状态。</p><h3 id="RDB文件的创建与载入"><a href="#RDB文件的创建与载入" class="headerlink" title="RDB文件的创建与载入"></a>RDB文件的创建与载入</h3><p>有两个Redis命令可以用于<strong>生成RDB文件</strong>，一个是SAVE，另一个是BGSAVE：</p><ul><li>SAVE命令会阻塞Redis服务器进程，直到RDB文件创建完毕为止，在服务器进程阻塞期间，服务器不能处理任何命令请求。</li><li>和SAVE命令直接阻塞服务器进程的做法不同，BGSAVE命令会派生出一个子进程，然后由子进程负责创建RDB文件，服务器进程（父进程）继续处理命令请求。</li></ul><p>创建RDB文件的实际工作由rdb.c&#x2F;rdbSave函数完成，SAVE命令和BGSAVE命令会以不同的方式调用这个函数，通过以下伪代码可以明显地看出这两个命令之间的区别：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">def <span class="title function_">SAVE</span><span class="params">()</span>:</span><br><span class="line">#创建RDB文件</span><br><span class="line"><span class="title function_">rdbSave</span><span class="params">()</span></span><br><span class="line"></span><br><span class="line">def <span class="title function_">BGSAVE</span><span class="params">()</span>:</span><br><span class="line">#创建子进程</span><br><span class="line">pid = fork()</span><br><span class="line">        </span><br><span class="line"><span class="keyword">if</span> pid == <span class="number">0</span>:</span><br><span class="line">#子进程负责创建RDB文件</span><br><span class="line">rdbSave()</span><br><span class="line">#完成之后向父进程发送信号</span><br><span class="line">signal_parent()</span><br><span class="line">elif pid &gt; <span class="number">0</span>:</span><br><span class="line">#父进程继续处理命令请求，并通过轮询等待子进程的信号</span><br><span class="line">handle_request_and_wait_signal()</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">#处理出错情况</span><br><span class="line">handle_fork_error()</span><br></pre></td></tr></table></figure><p>和使用SAVE命令或者BGSAVE命令创建RDB文件不同，RDB文件的<strong>载入工作</strong>是在服务器启动时自动执行的，所以Redis并没有专门用于载入RDB文件的命令，只要Redis服务器在启动时检测到RDB文件存在，它就会自动载入RDB文件。</p><p>另外值得一提的是，因为AOF文件的更新频率通常比RDB文件的更新频率高，所以：</p><ul><li>如果服务器开启了AOF持久化功能，那么服务器会优先使用AOF文件来还原数据库状态。</li><li>只有在AOF持久化功能处于关闭状态时，服务器才会使用RDB文件来还原数据库状态。</li></ul><p>载人RDB文件的实际工作由rdb.c&#x2F;rdbLoad函数完成，这个函数和rdbSave函数之间的关系如下图所示：</p><p><img src="/..%5Cimg%5CRedis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%5C%E5%88%9B%E5%BB%BA%E5%92%8C%E8%BD%BD%E5%85%A5RDB%E6%96%87%E4%BB%B6.png" alt="创建和载入RDB文件.png"></p><h4 id="SAVE命令执行时的服务器状态"><a href="#SAVE命令执行时的服务器状态" class="headerlink" title="SAVE命令执行时的服务器状态"></a>SAVE命令执行时的服务器状态</h4><p>当SAVE命令执行时，Redis服务器会被阻塞，所以当SAVE命令正在执行时，客户端发送的所有命令请求都会被拒绝。</p><p>只有在服务器执行完SAVE命令、重新开始接受命令请求之后，客户端发送的命令才会被处理。</p><h4 id="BGSAVE命令执行时的服务器状态"><a href="#BGSAVE命令执行时的服务器状态" class="headerlink" title="BGSAVE命令执行时的服务器状态"></a>BGSAVE命令执行时的服务器状态</h4><p>因为BGSAVE命令的保存工作是由子进程执行的，所以在子进程创建RDB文件的过程中，Redis服务器仍然可以继续处理客户端的命令请求，但是，在BGSAVE命令执行期间，服务器处理SAVE、BGSAVE、BGREWRITEAOF三个命令的方式会和平时有所不同：</p><ul><li><p>首先，在BGSAVE命令执行期间，客户端发送的SAVE命令会被服务器拒绝，服务器禁止SAVE命令和BGSAVE命令同时执行是为了避免父进程（服务器进程）和子进程同时执行两个rdbSave调用，防止产生竞争条件。</p></li><li><p>其次，在BGSAVE命令执行期间，客户端发送的BGSAVE命令会被服务器拒绝，因为同时执行两个BGSAVE命令也会产生竞争条件。</p></li><li><p>最后，BGREWRITEAOF和BGSAVE两个命令不能同时执行：如果BGSAVE命令正在执行，那么客户端发送的BGREWRITEAOF命令会被延迟到BGSAVE命令执行完毕之后执行；如果BGREWRITEAOF命令正在执行，那么客户端发送的BGSAVE命令会被服务器拒绝。</p></li></ul><p>因为BGREWRITEAOF和BGSAVE两个命令的实际工作都由子进程执行，所以这两个命令在操作方面并没有什么冲突的地方，不能同时执行它们只是一个性能方面的考虑——并发出两个子进程，并且这两个子进程都同时执行大量的磁盘写入操作，这怎么想都不会是一个好主意。</p><h4 id="RDB文件载入时的服务器状态"><a href="#RDB文件载入时的服务器状态" class="headerlink" title="RDB文件载入时的服务器状态"></a>RDB文件载入时的服务器状态</h4><p>服务器在载入RDB文件期间，会一直处于阻塞状态，直到载入工作完成为止。</p><h3 id="自动间隔性保存"><a href="#自动间隔性保存" class="headerlink" title="自动间隔性保存"></a>自动间隔性保存</h3><p>因为BGSAVE命令可以在不阻塞服务器进程的情况下执行，所以Redis允许用户通过设置服务器配置的save选项，让服务器每隔一段时间自动执行一次BGSAVE命令。</p><p>用户可以通过save选项设置多个保存条件，但只要其中任意一个条件被满足，服务器就会执行BGSAVE命令。</p><h4 id="设置保存条件"><a href="#设置保存条件" class="headerlink" title="设置保存条件"></a>设置保存条件</h4><p>当Redis服务器启动时，用户可以通过指定配置文件或者传入启动参数的方式设置save选项，如果用户没有主动设置save选项，那么服务器会为save选项设置默认条件：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">save <span class="number">900</span> <span class="number">1</span></span><br><span class="line">save <span class="number">300</span> <span class="number">10</span></span><br><span class="line">save <span class="number">60</span> <span class="number">10000</span></span><br></pre></td></tr></table></figure><p>这些参数意味着：</p><p>只要满足以下三个条件中的任意一个，BGSAVE命令就会被执行：</p><ul><li>服务器在900秒之内，对数据库进行了至少1次修改。</li><li>服务器在300秒之内，对数据库进行了至少10次修改。</li><li>服务器在60秒之内，对数据库进行了至少10000次修改。</li></ul><p>接着，服务器程序会根据save选项所设置的保存条件，设置服务器状态redisServer结构的saveparams属性：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span> &#123;</span></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="comment">//记录了保存条件的数组</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">saveparam</span> *<span class="title">saveparams</span>;</span></span><br><span class="line">     <span class="comment">//...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>saveparams属性是一个数组，数组中的每个元素都是一个saveparam结构，每个saveparam结构都保存了一个save选项设置的保存条件：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">saveparam</span> &#123;</span></span><br><span class="line"><span class="comment">//秒数</span></span><br><span class="line"><span class="type">time_t</span> seconds;</span><br><span class="line"><span class="comment">//修改数</span></span><br><span class="line"><span class="type">int</span> changes;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="dirty计数器和lastsave属性"><a href="#dirty计数器和lastsave属性" class="headerlink" title="dirty计数器和lastsave属性"></a>dirty计数器和lastsave属性</h4><p>除了saveparams数组之外，服务器状态还维持着一个dirty计数器，以及一个lastsave属性：</p><ul><li>dirty计数器记录距离上一次成功执行SAVE命令或者BGSAVE命令之后，服务器对数据库状态（服务器中的所有数据库）进行了多少次修改（包括写入、删除、更新等操作)。</li><li>lastsave属性是一个UNIX时间戳，记录了服务器上一次成功执行SAVE命令或者BGSAVE命令的时间。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span> &#123;</span></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="comment">//修改计数器</span></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> dirty;</span><br><span class="line"><span class="comment">//上一次执行保存的时间</span></span><br><span class="line"><span class="type">time_t</span> lastsave;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="检查保存条件是否满足"><a href="#检查保存条件是否满足" class="headerlink" title="检查保存条件是否满足"></a>检查保存条件是否满足</h4><p>Redis的服务器周期性操作函数servercron默认每隔100毫秒就会执行一次，该函数用于对正在运行的服务器进行维护，它的其中一项工作就是检查save选项所设置的保存条件是否已经满足，如果满足的话，就执行BGSAVE命令。</p><p>以下伪代码展示了serverCron函数检查保存条件的过程：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">def <span class="title function_">serverCron</span><span class="params">()</span>:</span><br><span class="line">#...</span><br><span class="line">#遍历所有保存条件</span><br><span class="line"><span class="keyword">for</span> saveparam in server.saveparams:</span><br><span class="line">#计算距离上次执行保存操作有多少秒</span><br><span class="line">save_interval = unixtime_now() - server.lastsave</span><br><span class="line">#如果数据库状态的修改次数超过条件所设置的次数</span><br><span class="line">#并且距离上次保存的时间超过条件所设置的时间</span><br><span class="line">#那么执行保存操作</span><br><span class="line"><span class="keyword">if</span> server.dirty &gt;= saveparam.changes and \</span><br><span class="line">save_interval &gt; saveparam.seconds:</span><br><span class="line">BGSAVE()</span><br><span class="line">#...</span><br></pre></td></tr></table></figure><p>程序会遍历并检查saveparams数组中的所有保存条件，只要有任意一个条件被满足，那么服务器就会执行BGSAVE命令，并更新dirty和lastsave属性。</p><h3 id="RDB文件结构"><a href="#RDB文件结构" class="headerlink" title="RDB文件结构"></a>RDB文件结构</h3><p>RDB文件所包含的各个部分：</p><p><img src="/..%5Cimg%5CRedis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%5CRDB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84.png" alt="RDB文件结构.png"></p><p>RDB文件的最开头是REDIS部分，这个部分的长度为5字节，保存着“REDIS”五个字符。通过这五个字符，程序可以在载入文件时，快速检查所载入的文件是否RDB文件。</p><p>db_version长度为4字节，它的值是一个字符串表示的整数，这个整数记录了RDB文件的版本号。</p><p>databases部分包含着零个或任意多个数据库，以及各个数据库中的键值对数据：</p><ul><li>如果服务器的数据库状态为空（所有数据库都是空的），那么这个部分为空，长度为0字节。</li><li>如果服务器的数据库状态为非空（有至少一个数据库非空），那么这个部分也为非空，根据数据库所保存键值对的数量、类型和内容不同，这个部分的长度也会有所不同。</li></ul><p>EOF常量的长度为1字节，这个常量标志着RDB文件正文内容的结束，当读入程序遇到这个值的时候，它知道所有数据库的所有键值对都已经载入完毕了。</p><p>check_sum是一个8字节长的无符号整数，保存着一个校验和，这个校验和是程序通过对REDIS、db_version、databases、EOF四个部分的内容计算得出的。服务器在载入RDB文件时，会将载入数据所计算出的校验和与check_sum所记录的校验和进行对比，一次来检查RDB文件是否有出错或者损坏的情况出现。</p><h4 id="databases部分"><a href="#databases部分" class="headerlink" title="databases部分"></a>databases部分</h4><p>一个RDB文件的databases部分可以保存任意多个非空数据库。</p><p>例如，如果服务器的0号数据库和3号数据库非空，那么服务器将创建一个如下图所示的RDB文件，图中的database 0代表0号数据库中的所有键值对数据，而database 3则代表3号数据库中的所有键值对数据。</p><p><img src="/..%5Cimg%5CRedis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%5C%E4%B8%A4%E4%B8%AA%E9%9D%9E%E7%A9%BA%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84RDB%E6%96%87%E4%BB%B6%E7%A4%BA%E4%BE%8B.png" alt="两个非空数据库的RDB文件示例.png"></p><p>每个非空数据库在RDB文件中都可以保存为SELECTDB、db_number、key_value_pairs三个部分,如下图所示：</p><p><img src="/..%5Cimg%5CRedis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%5CRDB%E6%96%87%E4%BB%B6%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E5%BA%93%E7%BB%93%E6%9E%84.png" alt="RDB文件中的数据库结构.png"></p><p>SELECTDB常量的长度为1字节，当读人程序遇到这个值的时候，它知道接下来要读入的将是一个数据库号码。</p><p>db_number保存着一个数据库号码，根据号码的大小不同，这个部分的长度可以是1字节、2字节或者5字节。当程序读入db_number部分之后，服务器会调用SELECT命令，根据读入的数据库号码进行数据库切换，使得之后读入的键值对可以载入到正确的数据库中。</p><p>key_value_pairs部分保存了数据库中的所有键值对数据，如果键值对带有过期时间，那么过期时间也会和键值对保存在一起。根据键值对的数量、类型、内容以及是否有过期时间等条件的不同，key_value_pairs部分的长度也会有所不同。</p><h4 id="key-value-pairs部分"><a href="#key-value-pairs部分" class="headerlink" title="key_value_pairs部分"></a>key_value_pairs部分</h4><p>RDB文件中的每个key_value_pairs部分都保存了一个或以上数量的键值对，如果键值对带有过期时间的话，那么键值对的过期时间也会被保存在内。</p><p>不带过期时间的键值对在RDB文件中由TYPE、key、value三部分组成，如下图所示：</p><p><img src="/..%5Cimg%5CRedis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%5C%E4%B8%8D%E5%B8%A6%E8%BF%87%E6%9C%9F%E6%97%B6%E9%97%B4%E7%9A%84%E9%94%AE%E5%80%BC%E5%AF%B9.png" alt="不带过期时间的键值对.png"></p><p>TYPE记录了value的类型，长度为1字节，值可以是以下常量的其中一个：</p><ul><li>REDIS_RDB_TYPE_STRING</li><li>REDIS_RDB_TYPE_LIST</li><li>REDIS_RDB_TYPE_SET</li><li>REDIS_RDB_TYPE_ZSET</li><li>REDIS_RDB_TYPE_HASH</li><li>REDIS_RDB_TYPE_LIST_ZIPLIST</li><li>REDIS_RDB_TYPE_SET_INTSET</li><li>REDIS_RDB_TYPE_ZSET_ZIPLIST</li><li>REDIS_RDB_TYPE_ HASH_ZIPLIST</li></ul><p>以上列出的每个TYPE常量都代表了一种对象类型或者底层编码，当服务器读入RDB文件中的键值对数据时，程序会根据TYPE的值来决定如何读入和解释value数据。key和value分别保存了键值对的键对象和值对象：</p><ul><li>其中key总是一个字符串对象，它的编码方式和REDIS_RDB_TYPE_STRING类型的value一样。根据内容长度的不同，key的长度也会有所不同。</li><li>根据TYPE类型的不同，以及保存内容长度的不同，保存value的结构和长度也会有所不同。</li></ul><p>带有过期时间的键值对在RDB文件中的结构如下图所示：</p><p><img src="/..%5Cimg%5CRedis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%5C%E5%B8%A6%E6%9C%89%E8%BF%87%E6%9C%9F%E6%97%B6%E9%97%B4%E7%9A%84%E9%94%AE%E5%80%BC%E5%AF%B9.png" alt="带有过期时间的键值对.png"></p><p>带有过期时间的键值对中的TYPE、key、value三个部分的意义，和前面介绍的不带过期时间的键值对的TYPE、key、value三个部分的意义完全相同，至于新增的EXPIRETIME_MS和ms，它们的意义如下：</p><ul><li>EXPIRETIME_MS常量的长度为1字节，它告知读入程序，接下来要读人的将是一个以毫秒为单位的过期时间。</li><li>ms是一个8字节长的带符号整数，记录着一个以毫秒为单位的UNIX时间戳，这个时间戳就是键值对的过期时间。</li></ul><h4 id="value的编码"><a href="#value的编码" class="headerlink" title="value的编码"></a>value的编码</h4><p>RDB文件中的每个value部分都保存了一个值对象，每个值对象的类型都由与之对应的TYPE记录，根据类型的不同，value部分的结构、长度也会有所不同。</p><h5 id="字符串对象"><a href="#字符串对象" class="headerlink" title="字符串对象"></a>字符串对象</h5><p>如果TYPE的值为REDIS_RDB_TYPE_STRING，那么value保存的就是一个字符串对象，字符串对象的编码可以是REDIS_ENCODING_INT或者REDIS_ENCODING_RAW。</p><p>如果字符串对象的编码为REDIS_ENCODING_INT，那么说明对象中保存的是长度不超过32位的整数，这种编码的对象将以下图的结构保存。</p><p><img src="/../img/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/INT%E7%BC%96%E7%A0%81%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%BF%9D%E5%AD%98%E7%BB%93%E6%9E%84.png" alt="INT编码字符串对象的保存结构.png"></p><p>其中，ENCODING的值可以是REDIS_RDB_ENC_INT8、REDIS_RDB_ENC_INT16或者REDIS_RDB_ENC_INT32三个常量的其中一个，它们分别代表RDB文件使用8位( bit )、16位或者32位来保存整数值integer。</p><p>如果字符串对象的编码为REDIS_ENCODING_RAW，那么说明对象所保存的是一个字符串值，根据字符串长度的不同，有压缩和不压缩两种方法来保存这个字符串：</p><ul><li>如果字符串的长度小于等于20字节，那么这个字符串会直接被原样保存。</li><li>如果字符串的长度大于20字节，那么这个字符串会被压缩之后再保存。</li></ul><p>对于没有被压缩的字符串，RDB程序会以下图所示的结构来保存该字符串。</p><p><img src="/../img/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/%E6%97%A0%E5%8E%8B%E7%BC%A9%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E4%BF%9D%E5%AD%98%E7%BB%93%E6%9E%84.png" alt="无压缩字符串的保存结构.png"></p><p>其中，string部分保存了字符串值本身，而len保存了字符串值的长度。</p><p>对于压缩后的字符串，RDB程序会以下图所示的结构来保存该字符串。</p><p><img src="/../img/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/%E5%8E%8B%E7%BC%A9%E5%90%8E%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E4%BF%9D%E5%AD%98%E7%BB%93%E6%9E%84.png" alt="压缩后字符串的保存结构.png"></p><p>其中，REDIS_RDB_ENC_LZF常量标志着字符串已经被LZF算法压缩过了，读入程序在碰到这个常量时，会根据之后的compressed_len、origin_len和compressed_string三部分，对字符串进行解压缩：其中compressed_len记录的是字符串被压缩之后的长度，而origin_len记录的是字符串原来的长度，compressed_string记录的则是被压缩之后的字符串。</p><h5 id="列表对象"><a href="#列表对象" class="headerlink" title="列表对象"></a>列表对象</h5><p>如果TYPE的值为REDIS_RDB_TYPE_LIST，那么value保存的就是一个REDIS_ENCODING_LINKEDLIST编码的列表对象，RDB文件保存这种对象的结构如下图所示。</p><p><img src="/../img/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/LINKEDLIST%E7%BC%96%E7%A0%81%E5%88%97%E8%A1%A8%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%BF%9D%E5%AD%98%E7%BB%93%E6%9E%84.png" alt="LINKEDLIST编码列表对象的保存结构.png"></p><p>list_length记录了列表的长度，它记录列表保存了多少个项（item），读入程序可以通过这个长度知道自己应该读入多少个列表项。</p><p>图中以item开头的部分代表列表的项，因为每个列表项都是一个字符串对象，所以程序会以处理字符串对象的方式来保存和读入列表项。</p><h5 id="集合对象"><a href="#集合对象" class="headerlink" title="集合对象"></a>集合对象</h5><p>如果TYPE的值为REDIS_RDB_TYPE_SET，那么value保存的就是一个REDIS_ENCODING_HT编码的集合对象，RDB文件保存这种对象的结构如下图所示。</p><p><img src="/../img/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/HT%E7%BC%96%E7%A0%81%E9%9B%86%E5%90%88%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%BF%9D%E5%AD%98%E7%BB%93%E6%9E%84.png" alt="HT编码集合对象的保存结构.png"></p><p>其中，set_size是集合的大小，它记录集合保存了多少个元素，读入程序可以通过这个大小知道自己应该读入多少个集合元素。</p><p>图中以elem开头的部分代表集合的元素，因为每个集合元素都是一个字符串对象，所以程序会以处理字符串对象的方式来保存和读入集合元素。</p><h5 id="哈希表对象"><a href="#哈希表对象" class="headerlink" title="哈希表对象"></a>哈希表对象</h5><p>如果TYPE的值为REDIS_RDB_TYPE_HASH，那么value保存的就是一个REDIS_ENCODING_HT编码的集合对象，RDB文件保存这种对象的结构如下图所示：</p><ul><li>hash_size记录了哈希表的大小，也即是这个哈希表保存了多少键值对，读入程序可以通过这个大小知道自己应该读入多少个键值对。</li><li>以key_value_pair开头的部分代表哈希表中的键值对，键值对的键和值都是字符串对象，所以程序会以处理字符串对象的方式来保存和读入键值对。</li></ul><h5 id="有序集合对象"><a href="#有序集合对象" class="headerlink" title="有序集合对象"></a>有序集合对象</h5><p>如果TYPE的值为REDIS_RDB_TYPE_ZSET，那么value保存的就是一个REDIS_ENCODING_SKIPLIST编码的有序集合对象，RDB文件保存这种对象的结构如下图所示：</p><p><img src="/../img/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/SKIPLIST%E7%BC%96%E7%A0%81%E6%9C%89%E5%BA%8F%E9%9B%86%E5%90%88%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%BF%9D%E5%AD%98%E7%BB%93%E6%9E%84.png" alt="SKIPLIST编码有序集合对象的保存结构.png"></p><p>sorted_set_size记录了有序集合的大小，也即是这个有序集合保存了多少元素，读入程序需要根据这个值来决定应该读入多少有序集合元素。<br>以element开头的部分代表有序集合中的元素，每个元素又分为成员（member）和分值（ score）两部分，成员是一个字符串对象，分值则是一个double类型的浮点数，程序在保存RDB文件时会先将分值转换成字符串对象，然后再用保存字符串对象的方法将分值保存起来。</p><h5 id="INTSET编码的集合"><a href="#INTSET编码的集合" class="headerlink" title="INTSET编码的集合"></a>INTSET编码的集合</h5><p>如果TYPE的值为REDIS_RDB_TYPE_SET_INTSET，那么value保存的就是一个整数集合对象，RDB文件保存这种对象的方法是，先将整数集合转换为字符串对象，然后将这个字符串对象保存到RDB文件里面。</p><p>如果程序在读入RDB文件的过程中，碰到由整数集合对象转换成的字符串对象，那么程序会根据TYPE值的指示，先读人字符串对象，再将这个字符串对象转换成原来的整数集合对象。</p><h5 id="ZIPLIST编码的列表、哈希表或者有序集合"><a href="#ZIPLIST编码的列表、哈希表或者有序集合" class="headerlink" title="ZIPLIST编码的列表、哈希表或者有序集合"></a>ZIPLIST编码的列表、哈希表或者有序集合</h5><p>如果TYPE的值为REDIS_RDB_TYPE_LIST_ZIPLIST、REDIS_RDB_TYPE_HASH_ZIPLIST或者REDIS_RDB_TYPE_ZSET_ZIPLIST，那么value保存的就是一个压缩列表，RDB文件保存这种对象的方法是：</p><ol><li>将压缩列表转换成一个字符串对象。</li><li>将转换所得的字符串对象保存到RDB文件。</li></ol><p>如果程序在读人RDB文件的过程中，碰到由压缩列表对象转换成的字符串对象，那么程序会根据TYPE值的指示，执行以下操作：</p><ol><li>读人字符串对象，并将它转换成原来的压缩列表对象。</li><li>根据TYPE的值，设置压缩列表对象的类型：如果TYPE的值为REDIS_RDB_TYPE_LIST_ZIPLIST，那么压缩列表对象的类型为列表；如果TYPE的值为REDIS_RDB_TYPE_HASH_ZIPLIST，那么压缩列表对象的类型为哈希表；如果TYPE的值为REDIS_RDB_TYPE_ZSET_ZIPLIST，那么压缩列表对象的类型为有序集合。</li></ol><h2 id="AOF持久化"><a href="#AOF持久化" class="headerlink" title="AOF持久化"></a>AOF持久化</h2><p>除了RDB持久化功能之外，Redis还提供了AOF（Append Only File）持久化功能。与RDB持久化通过保存数据库中的键值对来记录数据库状态不同，AOF持久化是通过保存Redis服务器所执行的写命令来记录数据库状态的。</p><p><img src="/../img/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/AOF%E6%8C%81%E4%B9%85%E5%8C%96.png" alt="AOF持久化.png"></p><h3 id="AOF持久化的实现"><a href="#AOF持久化的实现" class="headerlink" title="AOF持久化的实现"></a>AOF持久化的实现</h3><p>AOF持久化功能的实现可以分为追加（append）、文件写入、文件同步（sync）三个步骤。</p><h4 id="命令追加"><a href="#命令追加" class="headerlink" title="命令追加"></a>命令追加</h4><p>当AOF持久化功能处于打开状态时，服务器在执行完一个写命令之后，会以协议格式将被执行的写命令追加到服务器状态的aof_buf缓冲区的末尾：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span> &#123;</span></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="comment">//AOF缓冲区</span></span><br><span class="line">sds aof_buf;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>举个例子，如果客户端向服务器发送以下命令：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis&gt;SET KEY VALUE</span><br><span class="line">OK</span><br></pre></td></tr></table></figure><p>那么服务器在执行这个SET命令之后，会将以下协议内容追加到aof_buf缓冲区的末尾：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*<span class="number">3</span>\r\n$<span class="number">3</span>\r\nSET\r\n$<span class="number">3</span>\r\nKEY\r\n$<span class="number">5</span>\r\nVALUE\r\n</span><br></pre></td></tr></table></figure><h4 id="AOF文件的写入与同步"><a href="#AOF文件的写入与同步" class="headerlink" title="AOF文件的写入与同步"></a>AOF文件的写入与同步</h4><p>Redis的服务器进程就是一个事件循环（loop），这个循环中的文件事件负责接收客户端的命令请求，以及向客户端发送命令回复，而时间事件则负责执行像serverCron函数这样需要定时运行的函数。</p><p>因为服务器在处理文件事件时可能会执行写命令，使得一些内容被追加到aof_buf缓冲区里面，所以在服务器每次结束一个事件循环之前，它都会调用flushAppendOnlyFile函数，考虑是否需要将aof_buf缓冲区中的内容写入和保存到AOF文件里面，这个过程可以用以下伪代码表示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">def <span class="title function_">eventLoop</span><span class="params">()</span>:</span><br><span class="line"><span class="keyword">while</span> True:</span><br><span class="line">#处理文件事件，接收命令请求以及发送命令回复</span><br><span class="line">#处理命令请求时可能会有新内容被追加到aof_buf缓冲区中</span><br><span class="line"><span class="title function_">processFileEvents</span><span class="params">()</span></span><br><span class="line">#处理时间事件</span><br><span class="line"><span class="title function_">processTimeEvents</span><span class="params">()</span></span><br><span class="line">#考虑是否要将aof_buf中的内容写入和保存到AOF文件里面</span><br><span class="line">         <span class="title function_">flushAppendOnlyFile</span><span class="params">()</span></span><br></pre></td></tr></table></figure><p>flushAppendOnlyFile函数的行为由服务器配置的appendfsync选项的值来决定，各个不同值产生的行为如下表所示。</p><table><thead><tr><th align="center">appendfsync选项的值</th><th align="center">flushAppendOnlyFile函数的行为</th></tr></thead><tbody><tr><td align="center">always</td><td align="center">将aof_buf缓冲区中的所有内容写入并同步到AOF文件</td></tr><tr><td align="center">everysec</td><td align="center">将aof_buf缓冲区中的所有内容写人到AOF文件，如果上次同步AOF文件的时间距离现在超过一秒钟，那么再次对AOF文件进行同步，并且这个同步操作是由一个线程专门负责执行的</td></tr><tr><td align="center">no</td><td align="center">将aof_buf缓冲区中的所有内容写入到AOF文件，但并不对AOF文件进行同步，何时同步由操作系统来决定</td></tr></tbody></table><h5 id="文件的写入和同步"><a href="#文件的写入和同步" class="headerlink" title="文件的写入和同步"></a>文件的写入和同步</h5><p>为了提高文件的写入效率，在现代操作系统中，当用户调用write函数，将一些数据写入到文件的时候，操作系统通常会将写入数据暂时保存在一个内存缓冲区里面，等到缓冲区的空间被填满、或者超过了指定的时限之后，才真正地将缓冲区中的数据写入到磁盘里面。</p><p>这种做法虽然提高了效率，但也为写入数据带来了安全问题，因为如果计算机发生停机，那么保存在内存缓冲区里面的写入数据将会丢失。</p><p>为此，系统提供了fsync和fdatasync两个同步函数，它们可以强制让操作系统立即将缓冲区中的数据写入到硬盘里面，从而确保写入数据的安全性。</p><h3 id="AOF文件的载入与数据还原"><a href="#AOF文件的载入与数据还原" class="headerlink" title="AOF文件的载入与数据还原"></a>AOF文件的载入与数据还原</h3><p>因为AOF文件里面包含了重建数据库状态所需的所有写命令，所以服务器只要读入并重新执行一遍AOF文件里面保存的写命令，就可以还原服务器关闭之前的数据库状态。</p><p>Redis读取AOF文件并还原数据库状态的详细步骤如下：</p><ol><li>创建一个不带网络连接的伪客户端（fake client）：因为Redis的命令只能在客户端上下文中执行，而载入AOF文件时所使用的命令直接来源于AOF文件而不是网络连接，所以服务器使用了一个没有网络连接的伪客户端来执行AOF文件保存的写命令，伪客户端执行命令的效果和带网络连接的客户端执行命令的效果完全一样。</li><li>从AOF文件中分析并读取出一条写命令。</li><li>使用伪客户端执行被读出的写命令。</li><li>一直执行步骤⒉和步骤3，直到AOF文件中的所有写命令都被处理完毕为止。</li></ol><h3 id="AOF重写-1"><a href="#AOF重写-1" class="headerlink" title="AOF重写"></a>AOF重写</h3><p>因为AOF持久化是通过保存被执行的写命令来记录数据库状态的，所以随着服务器运行时间的流逝，AOF文件中的内容会越来越多，文件的体积也会越来越大，如果不加以控制的话，体积过大的AOF文件很可能对Redis服务器、甚至整个宿主计算机造成影响，并且AOF文件的体积越大，使用AOF文件来进行数据还原所需的时间就越多。</p><p>为了解决AOF文件体积膨胀的问题，Redis提供了AOF文件重写（rewrite）功能。通过该功能，Redis服务器可以创建一个新的AOF文件来替代现有的AOF文件，新旧两个AOF文件所保存的数据库状态相同，但新AOF文件不会包含任何浪费空间的冗余命令，所以新AOF文件的体积通常会比旧AOF文件的体积要小得多。</p><h4 id="AOF文件重写的实现"><a href="#AOF文件重写的实现" class="headerlink" title="AOF文件重写的实现"></a>AOF文件重写的实现</h4><p>虽然Redis将生成新AOF文件替换旧AOF文件的功能命名为“AOF文件重写”，但实际上，AOF文件重写并不需要对现有的AOF文件进行任何读取、分析或者写入操作，这个功能是通过读取服务器当前的数据库状态来实现的（读取数据库状态并用最简短的写命令来重现数据库状态）。</p><p>考虑这样一个情况，如果服务器对list键执行了以下命令：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; RPUSH <span class="built_in">list</span> <span class="string">&quot;A&quot;</span> <span class="string">&quot;B&quot;</span><span class="comment">//[&quot;A&quot;, &quot;B&quot;]</span></span><br><span class="line">(integer) <span class="number">2</span></span><br><span class="line"></span><br><span class="line">redis&gt; RPUSH <span class="built_in">list</span> <span class="string">&quot;C&quot;</span><span class="comment">//[&quot;A&quot;, &quot;B&quot;, &quot;C&quot;]</span></span><br><span class="line">(integer) <span class="number">3</span></span><br><span class="line"></span><br><span class="line">redis&gt; RPUSH <span class="built_in">list</span> <span class="string">&quot;D&quot;</span> <span class="string">&quot;E&quot;</span> <span class="comment">//[&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;E&quot;]</span></span><br><span class="line">(integer) <span class="number">5</span></span><br><span class="line"></span><br><span class="line">redis&gt; LPOP <span class="built_in">list</span><span class="comment">//[&quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;E&quot;]</span></span><br><span class="line"><span class="string">&quot;A&quot;</span></span><br><span class="line">    </span><br><span class="line">redis&gt; LPOP <span class="built_in">list</span><span class="comment">//[&quot;C&quot;, &quot;D&quot;, &quot;E&quot;]</span></span><br><span class="line"><span class="string">&quot;B&quot;</span></span><br><span class="line"></span><br><span class="line">redis&gt; RPUSH <span class="built_in">list</span> <span class="string">&quot;F&quot;</span> <span class="string">&quot;G&quot;</span> <span class="comment">//[&quot;C&quot;, &quot;D&quot;, &quot;E&quot;, &quot;F&quot;, &quot;G&quot;]</span></span><br><span class="line">(integer) <span class="number">5</span></span><br></pre></td></tr></table></figure><p>那么服务器为了保存当前list键的状态，必须在AOF文件中写人六条命令。</p><p>如果服务器想要用尽量少的命令来记录list键的状态，那么最简单高效的办法不是去读取和分析现有AOF文件的内容，而是直接从数据库中读取键list的值，然后用一条RPUSH list “C” “D” “E” “F” “G”命令来代替保存在AOF文件中的六条命令，这样就可以将保存list键所需的命令从六条减少为一条了。</p><p>重写过程的伪代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">def <span class="title function_">aof_rewrite</span><span class="params">(new_aof_file_name)</span>:</span><br><span class="line">#创建新AOF文件</span><br><span class="line">f = create_file(new_aof_file_name)</span><br><span class="line">#遍历数据库</span><br><span class="line"><span class="keyword">for</span> db in redisServer.db:</span><br><span class="line">#忽略空数据库</span><br><span class="line"><span class="keyword">if</span> db.is_empty(): <span class="keyword">continue</span></span><br><span class="line">#写入SELECT命令，指定数据库号码</span><br><span class="line">f.write_command(<span class="string">&quot;SELECT&quot;</span> + db.id)</span><br><span class="line">#遍历数据库中的所有键</span><br><span class="line"><span class="keyword">for</span> key in db:</span><br><span class="line">#忽略已过期的键</span><br><span class="line"><span class="keyword">if</span> key.is_expired(): <span class="keyword">continue</span></span><br><span class="line">#根据键的类型对键进行重写</span><br><span class="line"><span class="keyword">if</span> key.type == String:</span><br><span class="line">rewrite_string(key)</span><br><span class="line">elif key.type == List:</span><br><span class="line">rewrite_list(key)</span><br><span class="line">elif key.type == Hash:</span><br><span class="line">rewrite_hash(key)</span><br><span class="line">elif key.type == Set:</span><br><span class="line">rewrite_set(key)</span><br><span class="line">elif key.type == SortedSet:</span><br><span class="line">rewrite_sorted_set(key)</span><br><span class="line">#如果键带有过期时间，那么过期时间也要被重写</span><br><span class="line"><span class="keyword">if</span> key.have_expire_time():</span><br><span class="line">rewrite_expire_time(key)</span><br><span class="line"></span><br><span class="line">#写入完毕，关闭文件</span><br><span class="line">f.close()</span><br><span class="line"></span><br><span class="line">def rewrite_string(key):</span><br><span class="line">#使用GET命令获取字符串键的值</span><br><span class="line">value = GET(key)</span><br><span class="line">#使用SET命令重写字符串键</span><br><span class="line">f.write_command(SET, key, value)</span><br><span class="line"></span><br><span class="line">def rewrite_list(key):</span><br><span class="line">#使用LRANGE命令获取列表键包含的所有元素</span><br><span class="line">item1, item2, ..., itemN = LRANGE(key, <span class="number">0</span>, <span class="number">-1</span>)</span><br><span class="line">#使用RPUSH命令重写列表键</span><br><span class="line">f.write_command(RPUSH, key, item1, item2, ..., itemN)</span><br><span class="line"></span><br><span class="line">def rewrite_hash(key):</span><br><span class="line">#使用HGETALL命令获取哈希键包含的所有键值对</span><br><span class="line">field1, value1, field2, value2, ..., fieldN, valueN = HGETALL(key)</span><br><span class="line">#使用HMSET命令重写哈希键</span><br><span class="line">f.write_command(HMSET, key, field1, value1, field2, value2, ..., fieldN, valueN)</span><br><span class="line">        </span><br><span class="line">def rewrite_set(key):</span><br><span class="line">#使用SMEMBERS命令获取集合键包含的所有元素</span><br><span class="line">eleml, elem2, ..., elemN = SMEMBERS(key)</span><br><span class="line">#使用SADD命令重写集合键</span><br><span class="line">f.write_command(SADD, key, elem1, elem2, ..., elemN)</span><br><span class="line"></span><br><span class="line">def rewrite_sorted_set(key):</span><br><span class="line">#使用ZRANGE命令获取有序集合键包含的所有元素</span><br><span class="line">member1, score1, member2, score2, ..., memberN, scoreN = ZRANGE(key, <span class="number">0</span>, <span class="number">-1</span>, <span class="string">&quot;WITHSCORES&quot;</span>)</span><br><span class="line">#使用ZADD命令重写有序集合键</span><br><span class="line">f.write_command(ZADD, key, score1, member1, score2, member2, ..., scoreN, memberN)</span><br><span class="line"></span><br><span class="line">def rewrite_expire_time(key):</span><br><span class="line">#获取毫秒精度的键过期时间戳</span><br><span class="line">timestamp = get_expire_time_in_unixstamp(key)</span><br><span class="line">#使用PEXPIREAT命令重写键的过期时间</span><br><span class="line">f.write_command(PEXPIREAT, key, timestamp)</span><br></pre></td></tr></table></figure><p>因为aof_rewrite函数生成的新AOF文件只包含还原当前数据库状态所必须的命令，所以新AOF文件不会浪费任何硬盘空间。</p><p>在实际中，为了避免在执行命令时造成客户端输入缓冲区溢出，重写程序在处理列表、哈希表、集合、有序集合这四种可能会带有多个元素的键时，会先检查键所包含的元素数量，如果元素的数量超过了redis.h&#x2F;REDIS_AOF_REWRITE_ITEMS_PER_CMD常量的值，那么重写程序将使用多条命令来记录键的值，而不单单使用一条命令。</p><h4 id="AOF后台重写"><a href="#AOF后台重写" class="headerlink" title="AOF后台重写"></a>AOF后台重写</h4><p>上面介绍的AOF重写程序aof_rewrite函数可以很好地完成创建一个新AOF文件的任务，但是，因为这个函数会进行大量的写入操作，所以调用这个函数的线程将被长时间阻塞，因为Redis服务器使用单个线程来处理命令请求，所以如果由服务器直接调用aof_rewrite函数的话，那么在重写AOF文件期间，服务期将无法处理客户端发来的命令请求。</p><p>很明显，作为一种辅佐性的维护手段，Redis不希望AOF重写造成服务器无法处理请求，所以 Redis决定将AOF重写程序放到子进程里执行，这样做可以同时达到两个目的：</p><ul><li>子进程进行AOF重写期间，服务器进程（父进程）可以继续处理命令请求。</li><li>子进程带有服务器进程的数据副本，使用子进程而不是线程，可以在避免使用锁的情况下，保证数据的安全性。</li></ul><p>不过，使用子进程也有一个问题需要解决，因为子进程在进行AOF重写期间，服务器进程还需要继续处理命令请求，而新的命令可能会对现有的数据库状态进行修改，从而使得服务器当前的数据库状态和重写后的AOF文件所保存的数据库状态不一致。</p><p>为了解决这种数据不一致问题，Redis服务器设置了一个AOF重写缓冲区，这个缓冲区在服务器创建子进程之后开始使用，当Redis服务器执行完一个写命令之后，它会同时将这个写命令发送给AOF缓冲区和AOF重写缓冲区。</p><p>这也就是说，在子进程执行AOF重写期间，服务器进程需要执行以下三个工作：</p><ol><li>执行客户端发来的命令。</li><li>将执行后的写命令追加到AOF缓冲区。</li><li>将执行后的写命令追加到AOF重写缓冲区。</li></ol><p>这样一来可以保证：</p><ul><li>AOF缓冲区的内容会定期被写入和同步到AOF文件，对现有AOF文件的处理工作会如常进行。</li><li>从创建子进程开始，服务器执行的所有写命令都会被记录到AOF重写缓冲区里面。</li></ul><p>当子进程完成AOF重写工作之后，它会向父进程发送一个信号，父进程在接到该信号之后，会调用一个信号处理函数，并执行以下工作：</p><ol><li>将AOF重写缓冲区中的所有内容写入到新AOF文件中，这时新AOF文件所保存的数据库状态将和服务器当前的数据库状态一致。</li><li>对新的AOF文件进行改名，原子地（atomic）覆盖现有的AOF文件，完成新旧两个AOF文件的替换。</li></ol><p>这个信号处理函数执行完毕之后，父进程就可以继续像往常一样接受命令请求了。</p><p>在整个AOF后台重写过程中，只有信号处理函数执行时会对服务器进程（父进程）造成阻塞，在其他时候，AOF后台重写都不会阻塞父进程，这将AOF重写对服务器性能造成的影响降到了最低。</p><h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><p>Redis服务器是一个事件驱动程序，服务器需要处理以下两类事件：</p><ul><li>文件事件（file event）：Redis服务器通过套接字与客户端（或者其他Redis服务器）进行连接，而文件事件就是服务器对套接字操作的抽象。服务器与客户端（或者其他服务器）的通信会产生相应的文件事件，而服务器则通过监听并处理这些事件来完成一系列网络通信操作。</li><li>时间事件（time event）：Redis服务器中的一些操作（比如serverCron函数）需要在给定的时间点执行，而时间事件就是服务器对这类定时操作的抽象。</li></ul><h3 id="文件事件"><a href="#文件事件" class="headerlink" title="文件事件"></a>文件事件</h3><p>Redis基于Reactor模式开发了自己的网络事件处理器：这个处理器被称为文件事件处理器（file event handler）：</p><ul><li>文件事件处理器使用I&#x2F;O多路复用（multiplexing）程序来同时监听多个套接字，并根据套接字目前执行的任务来为套接字关联不同的事件处理器。</li><li>当被监听的套接字准备好执行连接应答（accept）、读取（read）、写人（write）、关<br>闭（close）等操作时，与操作相对应的文件事件就会产生，这时文件事件处理器就会调用套接字之前关联好的事件处理器来处理这些事件。</li></ul><p>虽然文件事件处理器以单线程方式运行，但通过使用I&#x2F;O多路复用程序来监听多个套接字，文件事件处理器既实现了高性能的网络通信模型，又可以很好地与Redis服务器中其他同样以单线程方式运行的模块进行对接，这保持了Redis内部单线程设计的简单性。</p><h4 id="文件事件处理器的构成"><a href="#文件事件处理器的构成" class="headerlink" title="文件事件处理器的构成"></a>文件事件处理器的构成</h4><p>下图展示了文件事件处理器的四个组成部分，它们分别是套接字、I&#x2F;O多路复用程序、文件事件分派器（dispatcher），以及事件处理器。</p><p><img src="/../img/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/%E6%96%87%E4%BB%B6%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E5%9B%9B%E4%B8%AA%E7%BB%84%E6%88%90%E9%83%A8%E5%88%86.png" alt="文件事件处理器的四个组成部分.png"></p><p>文件事件是对套接字操作的抽象，每当一个套接字准备好执行连接应答（accept）、写人、读取、关闭等操作时，就会产生一个文件事件。因为一个服务器通常会连接多个套接字，所以多个文件事件有可能会并发地出现。</p><p>I&#x2F;O多路复用程序负责监听多个套接字，并向文件事件分派器传送那些产生了事件的套接字。<br>尽管多个文件事件可能会并发地出现，但I&#x2F;O多路复用程序总是会将所有产生事件的套接字都放到一个队列里面，然后通过这个队列，以有序（sequentially）、同步（synchronously）、每次一个套接字的方式向文件事件分派器传送套接字。当上一个套接字产生的事件被处理完毕之后（该套接字为事件所关联的事件处理器执行完毕），I&#x2F;O多路复用程序才会继续向文件事件分派器传送下一个套接字。</p><p><img src="/../img/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E9%80%9A%E8%BF%87%E9%98%9F%E5%88%97%E5%90%91%E6%96%87%E4%BB%B6%E4%BA%8B%E4%BB%B6%E5%88%86%E6%B4%BE%E5%99%A8%E4%BC%A0%E9%80%81%E5%A5%97%E6%8E%A5%E5%AD%97.png" alt="IO多路复用通过队列向文件事件分派器传送套接字.png"></p><p>文件事件分派器接收I&#x2F;O多路复用程序传来的套接字，并根据套接字产生的事件的类型，调用相应的事件处理器。</p><p>服务器会为执行不同任务的套接字关联不同的事件处理器，这些处理器是一个个函数，它们定义了某个事件发生时，服务器应该执行的动作。</p><h4 id="I-x2F-O多路复用程序的实现"><a href="#I-x2F-O多路复用程序的实现" class="headerlink" title="I&#x2F;O多路复用程序的实现"></a>I&#x2F;O多路复用程序的实现</h4><p>Redis的I&#x2F;O多路复用程序的所有功能都是通过包装常见的select、epoll、evport和kqueue这些I&#x2F;O多路复用函数库来实现的，每个I&#x2F;O多路复用函数库在Redis源码中都对应一个单独的文件，比如ae_select.c、ae_epoll.c、ae_kqueue.c，诸如此类。</p><p>因为Redis为每个I&#x2F;O多路复用函数库都实现了相同的API，所以I&#x2F;O多路复用程序的底层实现是可以互换的。</p><p><img src="/../img/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E7%A8%8B%E5%BA%8F%E5%8F%AF%E6%9C%89%E5%A4%9A%E4%B8%AA%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E5%BA%93%E5%AE%9E%E7%8E%B0.png" alt="多路复用程序可有多个多路复用库实现.png"></p><p>Redis在I&#x2F;O多路复用程序的实现源码中用#include宏定义了相应的规则，程序会在编译时自动选择系统中性能最高的I&#x2F;O多路复用函数库来作为Redis的I&#x2F;O多路复用程序的底层实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Include the best multiplexing layer supported by this system.</span></span><br><span class="line"><span class="comment"> * The following should be ordered by performances, descending. */</span></span><br><span class="line"><span class="meta"># <span class="keyword">ifdef</span> HAVE_EVPORT</span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&quot;ae_evport.c&quot;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">else</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">ifdef</span> HAVE_EPOLL</span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&quot;ae_epoll.c&quot;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">else</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">ifdef</span> HAVE_KQUEUE</span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&quot;ae_kqueue.c&quot;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">else</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&quot;ae_select.c&quot;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">endif</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">endif</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><h4 id="事件的类型"><a href="#事件的类型" class="headerlink" title="事件的类型"></a>事件的类型</h4><p>I&#x2F;O多路复用程序可以监听多个套接字的ae.h&#x2F;AE_READABLE事件和ae.h&#x2F;AEWRITABLE事件，这两类事件和套接字操作之间的对应关系如下：</p><ul><li>当套接字变得可读时（客户端对套接字执行write操作，或者执行close操作)，或者有新的可应答（acceptable）套接字出现时（客户端对服务器的监听套接字执行connect操作)，套接字产生AE_READABLE事件。</li><li>当套接字变得可写时（客户端对套接字执行read操作），套接字产生AE_WRITABLE事件。</li></ul><p>I&#x2F;O多路复用程序允许服务器同时监听套接字的AE_READABLE事件和AE_WRITABLE事件，如果一个套接字同时产生了这两种事件，那么文件事件分派器会优先处理AE_READABLE事件，等到AE_READABLE事件处理完之后，才处理AE_WRITABLE事件。</p><p>这也就是说，如果一个套接字又可读又可写的话，那么服务器将先读套接字，后写套接字。</p><h4 id="API"><a href="#API" class="headerlink" title="API"></a>API</h4><p>ae.c&#x2F;aeCreateFileEvent函数接受一个套接字描述符、一个事件类型，以及一个事件处理器作为参数，将给定套接字的给定事件加入到I&#x2F;O多路复用程序的监听范围之内，并对事件和事件处理器进行关联。</p><p>ae.c&#x2F;aeDeleteFileEvent函数接受一个套接字描述符和一个监听事件类型作为参数，让I&#x2F;O多路复用程序取消对给定套接字的给定事件的监听，并取消事件和事件处理器之间的关联。</p><p>ae.c&#x2F;aeGetFileEvents函数接受一个套接字描述符，返回该套接字正在被监听的事件类型：</p><ul><li>如果套接字没有任何事件被监听，那么函数返回AE_NONE。</li><li>如果套接字的读事件正在被监听，那么函数返回AE_READABLE。</li><li>如果套接字的写事件正在被监听，那么函数返回AE_WRITABLE。</li><li>如果套接字的读事件和写事件正在被监听，那么函数返回AE_READABLE | AE_WRITABLE。</li></ul><p>ae.c&#x2F;aeWait函数接受一个套接字描述符、一个事件类型和一个毫秒数为参数，在给定的时间内阻塞并等待套接字的给定类型事件产生，当事件成功产生，或者等待超时之后，函数返回。</p><p>ae.c&#x2F;aeApiPoll函数接受一个sys&#x2F;time.h&#x2F;struct timeval结构为参数，并在指定的时间内，阻塞并等待所有被aecreateFileEvent函数设置为监听状态的套接字产生文件事件，当有至少一个事件产生，或者等待超时后，函数返回。</p><p>ae.c&#x2F;aeProcessEvents函数是文件事件分派器，它先调用aeApiPoll函数来等待事件产生，然后遍历所有已产生的事件，并调用相应的事件处理器来处理这些事件。</p><p>ae.c&#x2F;aeGetApiName函数返回I&#x2F;O多路复用程序底层所使用的IO多路复用函数库的名称：返回”epoll”表示底层为epoll函数库，返回”select”表示底层为select函数库，诸如此类。</p><h4 id="文件事件的处理器"><a href="#文件事件的处理器" class="headerlink" title="文件事件的处理器"></a>文件事件的处理器</h4><p>Redis为文件事件编写了多个处理器，这些事件处理器分别用于实现不同的网络通信需求，比如说：</p><ul><li>为了对连接服务器的各个客户端进行应答，服务器要为监听套接字关联连接应答处理器。</li><li>为了接收客户端传来的命令请求，服务器要为客户端套接字关联命令请求处理器。</li><li>为了向客户端返回命令的执行结果，服务器要为客户端套接字关联命令回复处理器。</li><li>当主服务器和从服务器进行复制操作时，主从服务器都需要关联特别为复制功能编写的复制处理器。</li></ul><p>在这些事件处理器里面，服务器最常用的要数与客户端进行通信的连接应答处理器、命令请求处理器和命令回复处理器。</p><h5 id="连接应答处理器"><a href="#连接应答处理器" class="headerlink" title="连接应答处理器"></a>连接应答处理器</h5><p>networking.c&#x2F;acceptTcpHandler函数是Redis的连接应答处理器，这个处理器用于对连接服务器监听套接字的客户端进行应答，具体实现为sys&#x2F;socket.h&#x2F;accept函数的包装。</p><p>当Redis服务器进行初始化的时候，程序会将这个连接应答处理器和服务器监听套接字的AE_READABLE事件关联起来，当有客户端用sys&#x2F;socket.h&#x2F;connect函数连接服务器监听套接字的时候，套接字就会产生AE_READABLE事件，引发连接应答处理器执行，并执行相应的套接字应答操作。</p><p><img src="/../img/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AF%B9%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%9A%84%E8%BF%9E%E6%8E%A5%E8%AF%B7%E6%B1%82%E8%BF%9B%E8%A1%8C%E5%BA%94%E7%AD%94.png" alt="服务器对客户端的连接请求进行应答.png"></p><h5 id="命令请求处理器"><a href="#命令请求处理器" class="headerlink" title="命令请求处理器"></a>命令请求处理器</h5><p>networking.c&#x2F;readQueryFromClient函数是Redis的命令请求处理器，这个处理器负责从套接字中读入客户端发送的命令请求内容，具体实现为unistd.h&#x2F;read函数的包装。</p><p>当一个客户端通过连接应答处理器成功连接到服务器之后，服务器会将客户端套接字的AE_READABLE事件和命令请求处理器关联起来，当客户端向服务器发送命令请求的时候，套接字就会产生AE_READABLE事件，引发命令请求处理器执行，并执行相应的套接字读入操作。<br>在客户端连接服务器的整个过程中，服务器都会一直为客户端套接字的AE_READABLE事件关联命令请求处理器。</p><p><img src="/../img/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%8E%A5%E6%94%B6%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%8F%91%E6%9D%A5%E7%9A%84%E5%91%BD%E4%BB%A4%E8%AF%B7%E6%B1%82.png" alt="服务器接收客户端发来的命令请求.png"></p><h5 id="命令回复处理器"><a href="#命令回复处理器" class="headerlink" title="命令回复处理器"></a>命令回复处理器</h5><p>networking.c&#x2F;sendReplyToClient函数是Redis的命令回复处理器，这个处理器负责将服务器执行命令后得到的命令回复通过套接字返回给客户端，具体实现为unistd.h&#x2F;write函数的包装。</p><p>当服务器有命令回复需要传送给客户端的时候，服务器会将客户端套接字的AE_WRITABLE事件和命令回复处理器关联起来，当客户端准备好接收服务器传回的命令回复时，就会产生AE_WRITABLE事件，引发命令回复处理器执行，并执行相应的套接字写人操作。</p><p>当命令回复发送完毕之后，服务器就会解除命令回复处理器与客户端套接字的AE_WRITABLE事件之间的关联。</p><p><img src="/../img/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%90%91%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%8F%91%E9%80%81%E5%91%BD%E4%BB%A4%E5%9B%9E%E5%A4%8D.png" alt="服务器向客户端发送命令回复.png"></p><h5 id="一次完整的客户端与服务器连接事件示例"><a href="#一次完整的客户端与服务器连接事件示例" class="headerlink" title="一次完整的客户端与服务器连接事件示例"></a>一次完整的客户端与服务器连接事件示例</h5><p>让我们来追踪一次Redis客户端与服务器进行连接并发送命令的整个过程，看看在过程中会产生什么事件，而这些事件又是如何被处理的。</p><p>假设一个Redis服务器正在运作，那么这个服务器的监听套接字的AE_READABLE事件应该正处于监听状态之下，而该事件所对应的处理器为连接应答处理器。</p><p>如果这时有一个Redis客户端向服务器发起连接，那么监听套接字将产生AE_READABLE事件，触发连接应答处理器执行。处理器会对客户端的连接请求进行应答，然后创建客户端套接字，以及客户端状态，并将客户端套接字的AE_READABLE事件与命令请求处理器进行关联，使得客户端可以向主服务器发送命令请求。</p><p>之后，假设客户端向主服务器发送一个命令请求，那么客户端套接字将产生AE_READABLE事件，引发命令请求处理器执行，处理器读取客户端的命令内容，然后传给相关程序去执行。</p><p>执行命令将产生相应的命令回复，为了将这些命令回复传送回客户端，服务器会将客户端套接字的AE_WRITABLE事件与命令回复处理器进行关联。当客户端尝试读取命令回复的时候，客户端套接字将产生AE_WRITABLE事件，触发命令回复处理器执行，当命令回复处理器将命令回复全部写入到套接字之后，服务器就会解除客户端套接字的AE_WRITABLE事件与命令回复处理器之间的关联。</p><h3 id="时间事件"><a href="#时间事件" class="headerlink" title="时间事件"></a>时间事件</h3><p>Redis的时间事件分为以下两类：</p><ul><li>定时事件：让一段程序在指定的时间之后执行一次。比如说，让程序X在当前时间的30毫秒之后执行一次。</li><li>周期性事件：让一段程序每隔指定时间就执行一次。比如说，让程序Y每隔30毫秒就执行一次。</li></ul><p>一个时间事件主要由以下三个属性组成：</p><ul><li>id：服务器为时间事件创建的全局唯一ID（标识号）。ID号按从小到大的顺序递增，新事件的ID号比旧事件的ID号要大。</li><li>when：毫秒精度的UNIX时间戳，记录了时间事件的到达（arrive）时间。</li><li>timeProc：时间事件处理器，一个函数。当时间事件到达时，服务器就会调用相应的处理器来处理事件。</li></ul><p>一个时间事件是定时事件还是周期性事件取决于时间事件处理器的返回值：</p><ul><li>如果事件处理器返回ae.h&#x2F;AE_NOMORE，那么这个事件为定时事件：该事件在达到一次之后就会被删除，之后不再到达。</li><li>如果事件处理器返回一个非AE_NOMORE的整数值，那么这个事件为周期性时间：当一个时间事件到达之后，服务器会根据事件处理器返回的值，对时间事件的when属性进行更新，让这个事件在一段时间之后再次到达，并以这种方式一直更新并运行下去。比如说，如果一个时间事件的处理器返回整数值30，那么服务器应该对这个时间事件进行更新，让这个事件在30毫秒之后再次到达。</li></ul><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><p>服务器将所有时间事件都放在一个无序链表中，每当时间事件执行器运行时，它就遍历整个链表，查找所有已到达的时间事件，并调用相应的事件处理器。</p><p>下图展示了一个保存时间事件的链表的例子，链表中包含了三个不同的时间事件：因为新的时间事件总是插入到链表的表头，所以三个时间事件分别按ID逆序排序，表头事件的ID为3，中间事件的ID为2，表尾事件的ID为1。</p><p><img src="/../img/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/%E7%94%A8%E9%93%BE%E8%A1%A8%E8%BF%9E%E6%8E%A5%E8%B5%B7%E6%9D%A5%E7%9A%84%E4%B8%89%E4%B8%AA%E6%97%B6%E9%97%B4%E4%BA%8B%E4%BB%B6.png" alt="用链表连接起来的三个时间事件.png"></p><p>注意，我们说保存时间事件的链表为无序链表，指的不是链表不按ID排序，而是说，该链表不按when属性的大小排序。正因为链表没有按when属性进行排序，所以当时间事件执行器运行的时候，它必须遍历链表中的所有时间事件，这样才能确保服务器中所有已到达的时间事件都会被处理。</p><p>无序链表并不影响时间事件处理器的性能：在目前版本中，正常模式下的Redis服务器只使用serverCron一个时间事件，而在benchmark模式下，服务器也只使用两个时间事件。在这种情况下，服务器几乎是将无序链表退化成一个指针来使用，所以使用无序链表来保存时间事件，并不影响事件执行的性能。</p><h4 id="API-1"><a href="#API-1" class="headerlink" title="API"></a>API</h4><p>ae.c&#x2F;aeCreateTimeEvent函数接受一个毫秒数milliseconds和一个时间事件处理器proc作为参数，将一个新的时间事件添加到服务器，这个新的时间事件将在当前时间的milliseconds毫秒之后到达，而事件的处理器为proco。</p><p>ae.c&#x2F;aeDeleteFileEvent函数接受一个时间事件ID作为参数，然后从服务器中删除该ID所对应的时间事件。</p><p>ae.c&#x2F;aeSearchNearestTimer函数返回到达时间距离当前时间最接近的那个时间事件。</p><p>ae.c&#x2F;processTimeEvents函数是时间事件的执行器，这个函数会遍历所有已到达的时间事件，并调用这些事件的处理器。已到达指的是，时间事件的when属性记录的UNIX时间戳等于或小于当前时间的UNIX时间戳。</p><p>processTimeEvents函数的定义可以用以下伪代码来描述：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">def <span class="title function_">processTimeEvents</span><span class="params">()</span>:</span><br><span class="line">#遍历服务器中的所有时间事件</span><br><span class="line"><span class="keyword">for</span> time_event in <span class="title function_">all_time_event</span><span class="params">()</span>:</span><br><span class="line">#检查事件是否已经到达</span><br><span class="line"><span class="keyword">if</span> time_event.when &lt;= unix_ts_now():</span><br><span class="line">#事件已到达</span><br><span class="line">#执行事件处理器，并获取返回值</span><br><span class="line">retval = time_event.timeProc()</span><br><span class="line">#如果这是一个定时事件</span><br><span class="line"><span class="keyword">if</span> retval == AE_NOMORE:</span><br><span class="line">#那么将该事件从服务器中删除</span><br><span class="line">delete_time_event_from_server(time_event)</span><br><span class="line">#如果这是一个周期性事件</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">#那么按照事件处理器的返回值更新时间事件的when属性</span><br><span class="line">#让这个事件在指定的时间之后再次到达</span><br><span class="line">update_when(time_event, retval)</span><br></pre></td></tr></table></figure><h4 id="时间事件应用实例：serverCron函数"><a href="#时间事件应用实例：serverCron函数" class="headerlink" title="时间事件应用实例：serverCron函数"></a>时间事件应用实例：serverCron函数</h4><p>持续运行的Redis服务器需要定期对自身的资源和状态进行检查和调整，从而确保服务器可以长期、稳定地运行，这些定期操作由redis.c&#x2F;serverCron函数负责执行，它的主要工作包括：</p><ul><li>更新服务器的各类统计信息，比如时间、内存占用、数据库占用情况等。</li><li>清理数据库中的过期键值对。</li><li>关闭和清理连接失效的客户端。</li><li>尝试进行AOF或RDB持久化操作。</li><li>如果服务器是主服务器，那么对从服务器进行定期同步。</li><li>如果处于集群模式，对集群进行定期同步和连接测试。</li></ul><p>Redis服务器以周期性事件的方式来运行serverCron函数，在服务器运行期间，每隔一段时间，serverCron就会执行一次，直到服务器关闭为止。</p><h3 id="事件的调度与执行"><a href="#事件的调度与执行" class="headerlink" title="事件的调度与执行"></a>事件的调度与执行</h3><p>因为服务器中同时存在文件事件和时间事件两种事件类型，所以服务器必须对这两种事件进行调度，决定何时应该处理文件事件，何时又应该处理时间事件，以及花多少时间来处理它们等等。</p><p>事件的调度和执行由ae.c&#x2F;aeProcessEvents函数负责，以下是该函数的伪代码表示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">def <span class="title function_">aeProcessEvents</span><span class="params">()</span>:</span><br><span class="line">#获取到达时间离当前时间最接近的时间事件</span><br><span class="line">time_event = aeSearchNearestTimer()</span><br><span class="line">#计算最接近的时间事件距离到达还有多少毫秒</span><br><span class="line">remaind_ms = time_event.when - unix_ts_now()</span><br><span class="line">#如果事件已到达，那么remaind_ms的值可能为负数，将它设定为<span class="number">0</span></span><br><span class="line"><span class="keyword">if</span> remaind_ms &lt; <span class="number">0</span>:</span><br><span class="line">remaind_ms = <span class="number">0</span></span><br><span class="line">#根据remaind_ms的值，创建timeval结构</span><br><span class="line">timeval = create_timeval_with_ms(remaind_ms)</span><br><span class="line">#阻塞并等待文件事件产生，最大阻塞时间由传入的timeval结构决定</span><br><span class="line">#如果remaind_ms的值为<span class="number">0</span>，那么aeApiPoll调用之后马上返回，不阻塞</span><br><span class="line">aeApiPoll(timeval)</span><br><span class="line">    #处理所有已产生的文件事件</span><br><span class="line">processFileEvents()</span><br><span class="line">#处理所有已到达的时间事件</span><br><span class="line"> processTimeEvents()</span><br></pre></td></tr></table></figure><p>将aeProcessEvents函数置于一个循环里面，加上初始化和清理函数，这就构成了Redis服务器的主函数，以下是该函数的伪代码表示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">def <span class="title function_">main</span><span class="params">()</span>:</span><br><span class="line">#初始化服务器</span><br><span class="line"><span class="title function_">init_server</span><span class="params">()</span></span><br><span class="line">#一直处理事件，直到服务器关闭为止</span><br><span class="line"><span class="keyword">while</span> <span class="title function_">server_is_not_shutdown</span><span class="params">()</span>:</span><br><span class="line"><span class="title function_">aeProcessEvents</span><span class="params">()</span></span><br><span class="line">#服务器关闭，执行清理操作</span><br><span class="line"><span class="title function_">clean_server</span><span class="params">()</span></span><br></pre></td></tr></table></figure><p><img src="/../img/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%BF%90%E8%A1%8C%E6%B5%81%E7%A8%8B.png" alt="服务器运行流程.png"></p><p>以下是事件的调度和执行规则：</p><ol><li>aeApiPoll函数的最大阻塞时间由到达时间最接近当前时间的时间事件决定，这个方法既可以避免服务器对时间事件进行频繁的轮询（忙等待），也可以确保aeApiPoll函数不会阻塞过长时间。</li><li>因为文件事件是随机出现的，如果等待并处理完一次文件事件之后仍未有任何时间事件到达，那么服务器将再次等待并处理文件事件。随着文件事件的不断执行，时间会逐渐向时间事件所设置的到达时间逼近，并最终来到到达时间，这时服务器就可以开始处理到达的时间事件了。</li><li>对文件事件和时间事件的处理都是同步、有序、原子地执行的，服务器不会中途中断事件处理，也不会对事件进行抢占，因此，不管是文件事件的处理器，还是时间事件的处理器，它们都会尽可地减少程序的阻塞时间，并在有需要时主动让出执行权，从而降低造成事件饥饿的可能性。比如说，在命令回复处理器将一个命令回复写人到客户端套接字时，如果写入字节数超过了一个预设常量的话，命令回复处理器就会主动用break跳出写入循环，将余下的数据留到下次再写；另外，时间事件也会将非常耗时的持久化操作放到子线程或者子进程执行。</li><li>因为时间事件在文件事件之后执行，并且事件之间不会出现抢占，所以时间事件的实际处理时间，通常会比时间事件设定的到达时间稍晚一些。</li></ol><h2 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h2><p>Redis服务器是典型的一对多服务器程序：一个服务器可以与多个客户端建立网络连接，每个客户端可以向服务器发送命令请求，而服务器则接收并处理客户端发送的命令请求，并向客户端返回命令回复。</p><p>通过使用由I&#x2F;O多路复用技术实现的文件事件处理器，Redis服务器使用单线程单进程的方式来处理命令请求，并与多个客户端进行网络通信。</p><p>对于每个与服务器进行连接的客户端，服务器都为这些客户端建立了相应redis.h&#x2F;redisClient结构（客户端状态），这个结构保存了客户端当前的状态信息，以及执行相关功能时需要用到的数据结构，其中包括：</p><ul><li>客户端的套接字描述符。</li><li>客户端的名字。</li><li>客户端的标志值（flag）。</li><li>指向客户端正在使用的数据库的指针，以及该数据库的号码。</li><li>客户端当前要执行的命令、命令的参数、命令参数的个数，以及指向命令实现函数的指针。</li><li>客户端的输入缓冲区和输出缓冲区。</li><li>客户端的复制状态信息，以及进行复制所需的数据结构。</li><li>客户端执行BRPOP、BLPOP等列表阻塞命令时使用的数据结构。</li><li>客户端的事务状态，以及执行WATCH命令时用到的数据结构。</li><li>客户端执行发布与订阅功能时用到的数据结构。</li><li>客户端的身份验证标志。</li><li>客户端的创建时间，客户端和服务器最后一次通信的时间，以及客户端的输出缓冲区大小超出软性限制（soft limit）的时间。</li></ul><p>Redis服务器状态结构的clients属性是一个链表，这个链表保存了所有与服务器连接的客户端的状态结构，对客户端执行批量操作，或者查找某个指定的客户端，都可以通过遍历clients链表来完成：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span> &#123;</span></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="comment">//一个链表，保存了所有客户端状态</span></span><br><span class="line"><span class="built_in">list</span> *clients;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="客户端属性"><a href="#客户端属性" class="headerlink" title="客户端属性"></a>客户端属性</h3><p>客户端状态包含的属性可以分为两类：</p><ul><li>一类是比较通用的属性，这些属性很少与特定功能相关，无论客户端执行的是什么工作，它们都要用到这些属性。</li><li>另外一类是和特定功能相关的属性，比如操作数据库时需要用到的db属性和dictid属性，执行事务时需要用到的mstate属性，以及执行WATCH命令时需要用到的watched_keys属性等等。</li></ul><h4 id="套接字描述符"><a href="#套接字描述符" class="headerlink" title="套接字描述符"></a>套接字描述符</h4><p>客户端状态的fd属性记录了客户端正在使用的套接字描述符：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisClient</span> &#123;</span></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="type">int</span> fd;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;redisClient;</span><br></pre></td></tr></table></figure><p>根据客户端类型的不同，fd属性的值可以是-1或者是大于-1的整数：</p><ul><li>伪客户端（fake client）的fd属性的值为-1：伪客户端处理的命令请求来源于AOF文件或者Lua脚本，而不是网络，所以这种客户端不需要套接字连接，自然也不需要记录套接字描述符。目前Redis服务器会在两个地方用到伪客户端，一个用于载入AOF文件并还原数据库状态，而另一个则用于执行Lua脚本中包含的Redis命令。</li><li>普通客户端的fd属性的值为大于-1的整数：普通客户端使用套接字来与服务器进行通信，所以服务器会用fd属性来记录客户端套接字的描述符。因为合法的套接字描述符不能是-1，所以普通客户端的套接字描述符的值必然是大于-1的整数。</li></ul><h4 id="名字"><a href="#名字" class="headerlink" title="名字"></a>名字</h4><p>在默认情况下，一个连接到服务器的客户端是没有名字的。</p><p>客户端的名字记录在客户端状态的name属性里面：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisClient</span> &#123;</span></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">robj *name;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125; redisClient;</span><br></pre></td></tr></table></figure><p>如果客户端没有为自己设置名字，那么相应客户端状态的name属性指向NULL指针；相反地，如果客户端为自己设置了名字，那么name属性将指向一个字符串对象，而该对象就保存着客户端的名字。</p><h4 id="标志"><a href="#标志" class="headerlink" title="标志"></a>标志</h4><p>客户端的标志属性flags记录了客户端的角色（role），以及客户端目前所处的状态：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisClient</span> &#123;</span></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="type">int</span> flags;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125; redisClient;</span><br></pre></td></tr></table></figure><p>flags属性的值可以是单个标志：</p><p>flags &#x3D; &lt;flag&gt;</p><p>也可以是多个标志的二进制或，比如：</p><p>flags &#x3D;  &lt;flag&gt; | &lt;flag2&gt; I …</p><p>每个标志使用一个常量表示，一部分标志记录了客户端的角色：</p><ul><li>在主从服务器进行复制操作时，主服务器会成为从服务器的客户端，而从服务器也会成为主服务器的客户端。REDIS_MASTER标志表示客户端代表的是一个主服务器，REDIS_SLAVE标志表示客户端代表的是一个从服务器。</li><li>REDIS_PRE_PSYNC标志表示客户端代表的是一个版本低于Redis2.8的从服务器，主服务器不能使用PSYNC命令与这个从服务器进行同步。这个标志只能在REDIS_SLAVE标志处于打开状态时使用。</li><li>REDIS_LUA_CLIENT标识表示客户端是专门用于处理Lua脚本里面包含的Redis命令的伪客户端。</li></ul><p>而另外一部分标志则记录了客户端目前所处的状态：</p><ul><li>REDIS_MONITOR标志表示客户端正在执行MONITOR命令。</li><li>REDIS_UNIX_SOCKET标志表示服务器使用UNIX套接字来连接客户端。</li><li>REDIS_BLOCKED标志表示客户端正在被BRPOP、BLPOP等命令阻塞。</li><li>REDIS_UNBLOCKED标志表示客户端已经从REDIS_BLOCKED标志所表示的阻塞状态中脱离出来，不再阻塞。REDIS_UNBLOCKED标志只能在REDIS_BLOCKED标志已经打开的情况下使用。</li><li>REDIS_MULTI标志表示客户端正在执行事务。</li><li>REDIS_DIRTY_CAS标志表示事务使用WATCH命令监视的数据库键已经被修改，REDIS_DIRTY_EXEC标志表示事务在命令入队时出现了错误，以上两个标志都表示事务的安全性已经被破坏，只要这两个标记中的任意一个被打开，EXEC命令必然会执行失败。这两个标志只能在客户端打开了REDIS_MULTI标志的情况下使用。</li><li>REDIS_CLOSE_ASAP标志表示客户端的输出缓冲区大小超出了服务器允许的范围，服务器会在下一次执行serverCron函数时关闭这个客户端，以免服务器的稳定性受到这个客户端影响。积存在输出缓冲区中的所有内容会直接被释放，不会返回给客户端。</li><li>REDIS_CLOSE_AFTER_REPLY标志表示有用户对这个客户端执行了CLIENT KILL命令，或者客户端发送给服务器的命令请求中包含了错误的协议内容。服务器会将客户端积存在输出缓冲区中的所有内容发送给客户端，然后关闭客户端。</li><li>REDIS_ASKING标志表示客户端向集群节点（运行在集群模式下的服务器）发送了ASKING命令。</li><li>REDIS_FORCE_AOF标志强制服务器将当前执行的命令写人到AOF文件里面，REDIS_FORCE_REPL标志强制主服务器将当前执行的命令复制给所有从服务器。执行PUBSUB命令会使客户端打开REDIS_FORCE_AOF标志，执行SCRIPT LOAD命令会使客户端打开REDIS_FORCE_AOF标志和REDIS_FORCE_REPL标志。</li><li>在主从服务器进行命令传播期间，从服务器需要向主服务器发送REPLICATION ACK命令，在发送这个命令之前，从服务器必须打开主服务器对应的客户端的REDIS_MASTER_FORCE_REPLY标志，否则发送操作会被拒绝执行。</li></ul><h5 id="PUBSUB命令和SCRIPT-LOAD命令的特殊性"><a href="#PUBSUB命令和SCRIPT-LOAD命令的特殊性" class="headerlink" title="PUBSUB命令和SCRIPT LOAD命令的特殊性"></a>PUBSUB命令和SCRIPT LOAD命令的特殊性</h5><p>通常情况下，Redis只会将那些对数据库进行了修改的命令写入到AOF文件，并复制到各个从服务器。如果一个命令没有对数据库进行任何修改，那么它就会被认为是只读命令，这个命令不会被写入到AOF文件，也不会被复制到从服务器。</p><p>以上规则适用于绝大部分Redis命令，但PUBSUB命令和SCRIPT LOAD命令是其中的例外。PUBSUB命令虽然没有修改数据库，但PUBSUB命令向频道的所有订阅者发送消息这一行为带有副作用，接收到消息的所有客户端的状态都会因为这个命令而改变。因此，服务器需要使用REDIS_FORCE_AOF标志，强制将这个命令写入AOF文件，这样在将来载入AOF文件时，服务器就可以再次执行相同的PUBSUB命令，并产生相同的副作用。SCRIPT LOAD命令的情况与PUBSUB命令类似：虽然SCRIPT LOAD命令没有修改数据库，但它修改了服务器状态，所以它是一个带有副作用的命令，服务器需要使用REDIS_FORCE_AOF标志，强制将这个命令写入AOF文件，使得将来在载入AOF文件时，服务器可以产生相同的副作用。</p><p>另外，为了让主服务器和从服务器都可以正确地载入SCRIPT LOAD命令指定的脚本，服务器需要使用REDIS_FORCE_REPL标志，强制将SCRIPT LOAD命令复制给所有从服务器。</p><h4 id="输入缓冲区"><a href="#输入缓冲区" class="headerlink" title="输入缓冲区"></a>输入缓冲区</h4><p>客户端状态的输入缓冲区用于保存客户端发送的命令请求：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisClient</span> &#123;</span></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">sds querybuf;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125; redisClient;</span><br></pre></td></tr></table></figure><p>举个例子，如果客户端向服务器发送了以下命令请求：</p><p>SET key value</p><p>那么客户端状态的querybuf属性将是一个包含以下内容的SDS值：</p><p>*3\r\n$3\r\nSET\r\n$3\r\nkey\r\n$5\r\nvalue\r\n</p><p>输人缓冲区的大小会根据输人内容动态地缩小或者扩大，但它的最大大小不能超过1GB，否则服务器将关闭这个客户端。</p><h4 id="命令与命令参数"><a href="#命令与命令参数" class="headerlink" title="命令与命令参数"></a>命令与命令参数</h4><p>在服务器将客户端发送的命令请求保存到客户端状态的querybuf属性之后，服务器将对命令请求的内容进行分析，并将得出的命令参数以及命令参数的个数分别保存到客户端状态的argv属性和argc属性：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisClient</span> &#123;</span></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">robj **argv;</span><br><span class="line"><span class="type">int</span> argc;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125; redisClient;</span><br></pre></td></tr></table></figure><p>argv属性是一个数组，数组中的每个项都是一个字符串对象，其中argv[0]是要执行的命令，而之后的其他项则是传给命令的参数；argc属性则负责记录argv数组的长度。</p><p>举个例子，对于 SET key value 这条命令，服务器将分析并创建如下图所示的argv属性和argc属性。</p><p><img src="/../img/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/argv%E5%B1%9E%E6%80%A7%E5%92%8Cargc%E5%B1%9E%E6%80%A7%E7%A4%BA%E4%BE%8B.png" alt="argv属性和argc属性示例.png"></p><h4 id="命令的实现函数"><a href="#命令的实现函数" class="headerlink" title="命令的实现函数"></a>命令的实现函数</h4><p>当服务器从协议内容中分析并得出argv属性和argc属性的值之后，服务器将根据项argv[0]的值，在命令表中查找命令所对应的命令实现函数。</p><p>下图展示了一个命令表示例，该表是一个字典，字典的键是一个SDS结构，保存了命令的名字，字典的值是命令所对应的redisCommand结构，这个结构保存了命令的实现函数、命令的标志、命令应该给定的参数个数、命令的总执行次数和总消耗时长等统计信息。</p><p><img src="/../img/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/%E5%91%BD%E4%BB%A4%E8%A1%A8.png" alt="命令表.png"></p><p>当程序在命令表中成功找到argv[0]所对应的redisCommand结构时，它会将客户端状态的cmd指针指向这个结构：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisClient</span> &#123;</span></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisCommand</span> *<span class="title">cmd</span>;</span></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125; redisClient;</span><br></pre></td></tr></table></figure><p>之后，服务器就可以使用cmd属性所指向的redisCommand结构，以及argv、argc属性中保存的命令参数信息，调用命令实现函数，执行客户端指定的命令。(针对命令表的查找操作不区分输入字母的大小写)</p><h4 id="输出缓冲区"><a href="#输出缓冲区" class="headerlink" title="输出缓冲区"></a>输出缓冲区</h4><p>执行命令所得的命令回复会被保存在客户端状态的输出缓冲区里面，每个客户端都有两个输出缓冲区可用，一个缓冲区的大小是固定的，另一个缓冲区的大小是可变的：</p><ul><li>固定大小的缓冲区用于保存那些长度比较小的回复，比如OK、简短的字符串值、整数值、错误回复等等。</li><li>可变大小的缓冲区用于保存那些长度比较大的回复，比如一个非常长的字符串值，一个由很多项组成的列表，一个包含了很多元素的集合等等。</li></ul><p>客户端的固定大小缓冲区由buf和bufpos两个属性组成：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisClient</span> &#123;</span></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="type">char</span> buf[REDIS_REPLY_CHUNK_BYTES];</span><br><span class="line"><span class="type">int</span> bufpos;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125; redisClient;</span><br></pre></td></tr></table></figure><p>buf是一个大小为REDIS_REPLY_CHUNK_BYTES字节的字节数组，而bufpos属性则记录了buf数组目前已使用的字节数量。</p><p>REDIS_REPLY_CHUNK_BYTES常量目前的默认值为16*1024，也即是说，buf数组的默认大小为16KB。</p><p>当buf数组的空间已经用完，或者回复因为太大而没办法放进buf数组里面时，服务器就会开始使用可变大小缓冲区。</p><p>可变大小缓冲区由reply链表和一个或多个字符串对象组成：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisClient</span> &#123;</span></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="built_in">list</span> *reply;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125; redisClient;</span><br></pre></td></tr></table></figure><p>通过使用链表来连接多个字符串对象，服务器可以为客户端保存一个非常长的命令回复，而不必受到固定大小缓冲区16 KB大小的限制。</p><h4 id="身份验证"><a href="#身份验证" class="headerlink" title="身份验证"></a>身份验证</h4><p>客户端状态的authenticated属性用于记录客户端是否通过了身份验证：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisClient</span> &#123;</span></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="type">int</span> authenticated;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125; redisClient;</span><br></pre></td></tr></table></figure><p>如果authenticated的值为0，那么表示客户端未通过身份验证；如果authenticated的值为1，那么表示客户端已经通过了身份验证。当客户端authenticated属性的值为0时，除了AUTH命令之外，客户端发送的所有其他命令都会被服务器拒绝执行。</p><p>authenticated属性仅在服务器启用了身份验证功能时使用。如果服务器没有启用身份验证功能的话，那么即使authenticated属性的值为0（这是默认值），服务器也不会拒绝执行客户端发送的命令请求。</p><h4 id="时间"><a href="#时间" class="headerlink" title="时间"></a>时间</h4><p>客户端还有几个和时间有关的属性：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisClient</span> &#123;</span></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="type">time_t</span> ctime;</span><br><span class="line"><span class="type">time_t</span> lastinteraction;</span><br><span class="line"><span class="type">time_t</span> obuf_soft_limit_reached_time;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125; redisClient;</span><br></pre></td></tr></table></figure><p>ctime属性记录了创建客户端的时间，这个时间可以用来计算客户端与服务器已经连接了多少秒。</p><p>lastinteraction属性记录了客户端与服务器最后一次进行互动（interaction）的时间，这里的互动可以是客户端向服务器发送命令请求，也可以是服务器向客户端发送命令回复。</p><p>lastinteraction属性可以用来计算客户端的空转（idle）时间，也即是，距离客户端与服务器最后一次进行互动以来，已经过去了多少秒。</p><p>obuf_soft_limit_reached_time属性记录了输出缓冲区第一次到达软性限制（soft limit）的时间。</p><h3 id="客户端的创建与关闭"><a href="#客户端的创建与关闭" class="headerlink" title="客户端的创建与关闭"></a>客户端的创建与关闭</h3><p>服务器使用不同的方式创建和关闭不同类型的客户端。</p><h4 id="创建普通客户端"><a href="#创建普通客户端" class="headerlink" title="创建普通客户端"></a>创建普通客户端</h4><p>如果客户端是通过网络连接与服务器进行连接的普通客户端，那么在客户端使用connect函数连接到服务器时，服务器就会调用连接事件处理器，为客户端创建相应的客户端状态，并将这个新的客户端状态添加到服务器状态结构clients链表的末尾。</p><h4 id="关闭普通客户端"><a href="#关闭普通客户端" class="headerlink" title="关闭普通客户端"></a>关闭普通客户端</h4><p>一个普通客户端可以因为多种原因而被关闭：</p><ul><li>如果客户端进程退出或者被杀死，那么客户端与服务器之间的网络连接将被关闭，从而造成客户端被关闭。</li><li>如果客户端向服务器发送了带有不符合协议格式的命令请求，那么这个客户端也会<br>被服务器关闭。</li><li>如果客户端成为了CLIENT KILL命令的目标，那么它也会被关闭。</li><li>如果用户为服务器设置了timeout配置选项，那么当客户端的空转时间超过timeout选项设置的值时，客户端将被关闭。不过timeout选项有一些例外情况：如果客户端是主服务器(打开了REDIS_MASTER标志)，从服务器（打开了REDIS_SLAVE标志），正在被BLPOP等命令阻塞（打开了REDIS_BLOCKED标志），或者正在执行SUBSCRIBE、PSUBSCRIBE等订阅命令，那么即使客户端的空转时间超过了timeout选项的值，客户端也不会被服务器关闭。</li><li>如果客户端发送的命令请求的大小超过了输人缓冲区的限制大小（默认为1GB），那么这个客户端会被服务器关闭。</li><li>如果要发送给客户端的命令回复的大小超过了输出缓冲区的限制大小，那么这个客户端会被服务器关闭。</li></ul><p>前面介绍输出缓冲区的时候提到过，可变大小缓冲区由一个链表和任意多个字符串对象组成，理论上来说，这个缓冲区可以保存任意长的命令回复。</p><p>但是，为了避免客户端的回复过大，占用过多的服务器资源，服务器会时刻检查客户端的输出缓冲区的大小，并在缓冲区的大小超出范围时，执行相应的限制操作。</p><p>服务器使用两种模式来限制客户端输出缓冲区的大小：</p><ul><li>硬性限制（hard limit）：如果输出缓冲区的大小超过了硬性限制所设置的大小，那么服务器立即关闭客户端。</li><li>软性限制（soft limit）：如果输出缓冲区的大小超过了软性限制所设置的大小，但还没超过硬性限制，那么服务器将使用客户端状态结构的obuf_soft_limit_reached_time属性记录下客户端到达软性限制的起始时间；之后服务器会继续监视客户端，如果输出缓冲区的大小一直超出软性限制，并且持续时间超过服务器设定的时长，那么服务器将关闭客户端；相反地，如果输出缓冲区的大小在指定时间之内，不再超出软性限制，那么客户端就不会被关闭，并且 obuf_soft_limit_reached _time属性的值也会被清零。</li></ul><h4 id="Lua脚本的伪客户端"><a href="#Lua脚本的伪客户端" class="headerlink" title="Lua脚本的伪客户端"></a>Lua脚本的伪客户端</h4><p>服务器会在初始化时创建负责执行Lua脚本中包含的Redis命令的伪客户端，并将这个伪客户端关联在服务器状态结构的lua_client属性中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span> &#123;</span></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">redisClient *lua_client;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>lua_client伪客户端在服务器运行的整个生命期中会一直存在，只有服务器被关闭时，这个客户端才会被关闭。</p><h4 id="AOF文件的伪客户端"><a href="#AOF文件的伪客户端" class="headerlink" title="AOF文件的伪客户端"></a>AOF文件的伪客户端</h4><p>服务器在载入AOF文件时，会创建用于执行AOF文件包含的Redis命令的伪客户端，并在载入完成之后，关闭这个伪客户端。</p><h2 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h2><p>Redis服务器负责与多个客户端建立网络连接，处理客户端发送的命令请求，在数据库中保存客户端执行命令所产生的数据，并通过资源管理来维持服务器自身的运转。</p><h3 id="命令请求的执行过程"><a href="#命令请求的执行过程" class="headerlink" title="命令请求的执行过程"></a>命令请求的执行过程</h3><p>一个命令请求从发送到获得回复的过程中，客户端和服务器需要完成一系列操作。举个例子，如果我们使用客户端执行以下命令：</p><p>redis&gt; SET KEY VALUE<br>OK</p><p>那么从客户端发送SET KEY VALUE命令到获得回复OK期间，客户端和服务器共需要执行以下操作：</p><ol><li>客户端向服务器发送命令请求SET KEY VALUE。</li><li>服务器接收并处理客户端发来的命令请求SET KEY VALUE，在数据库中进行设置操作，并产生命令回复OK。</li><li>服务器将命令回复OK发送给客户端。</li><li>客户端接收服务器返回的命令回复OK，并将这个回复打印给用户观看。</li></ol><h4 id="发送命令请求"><a href="#发送命令请求" class="headerlink" title="发送命令请求"></a>发送命令请求</h4><p>Redis服务器的命令请求来自Redis客户端，当用户在客户端中键入一个命令请求时，客户端会将这个命令请求转换成协议格式，然后通过连接到服务器的套接字，将协议格式的命令请求发送给服务器。</p><p><img src="/../img/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%8E%A5%E6%94%B6%E5%B9%B6%E5%8F%91%E9%80%81%E5%91%BD%E4%BB%A4%E8%AF%B7%E6%B1%82%E7%9A%84%E8%BF%87%E7%A8%8B.png" alt="客户端接收并发送命令请求的过程.png"></p><h4 id="读取命令请求"><a href="#读取命令请求" class="headerlink" title="读取命令请求"></a>读取命令请求</h4><p>当客户端与服务器之间的连接套接字因为客户端的写入而变得可读时，服务器将调用命令请求处理器来执行以下操作：</p><ol><li>读取套接字中协议格式的命令请求，并将其保存到客户端状态的输人缓冲区里面。</li><li>对输人缓冲区中的命令请求进行分析，提取出命令请求中包含的命令参数，以及命令参数的个数，然后分别将参数和参数个数保存到客户端状态的argv属性和argc属性里面。</li><li>调用命令执行器，执行客户端指定的命令。</li></ol><p>继续用上一个小节的SET命令为例子，下图展示了程序将命令请求保存到客户端状态的输入缓冲区之后，客户端状态的样子。</p><p><img src="/../img/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%8A%B6%E6%80%81%E4%B8%AD%E7%9A%84%E5%91%BD%E4%BB%A4%E8%AF%B7%E6%B1%82.png" alt="客户端状态中的命令请求.png"></p><p>之后，分析程序将对输入缓冲区中的协议进行分析：</p><p>*3\r\n$3\r\nSET\r\n$3\r\nKEY\r\n$5\r\nVALUE\r\n</p><p>并将得出的分析结果保存到客户端状态的argv属性和argc属性里面，如下图所示。</p><p><img src="/../img/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%8A%B6%E6%80%81%E7%9A%84argv%E5%B1%9E%E6%80%A7%E5%92%8Cargc%E5%B1%9E%E6%80%A7.png" alt="客户端状态的argv属性和argc属性.png"></p><p>之后，服务器将通过调用命令执行器来完成执行命令所需的余下步骤。</p><h4 id="命令执行器（1）：查找命令实现"><a href="#命令执行器（1）：查找命令实现" class="headerlink" title="命令执行器（1）：查找命令实现"></a>命令执行器（1）：查找命令实现</h4><p>命令执行器要做的第一件事就是根据客户端状态的argv[0]参数，在命令表（command table）中查找参数所指定的命令，并将找到的命令保存到客户端状态的cmd属性里面。</p><p>命令表是一个字典，字典的键是一个个命令名字，比如”set”、”get”、”del”等等；而字典的值则是一个个redisCommand结构，每个redisCommand结构记录了一个Redis命令的实现信息，下表记录了这个结构的各个主要属性的类型和作用。</p><table><thead><tr><th>属性名</th><th>类型</th><th>作用</th></tr></thead><tbody><tr><td>name</td><td>char *</td><td>命令的名字，比如“set”</td></tr><tr><td>proc</td><td>redisCommandProc *</td><td>函数指针，指向命令的实现函数，比如setCommand。redisCommandProc类型的定义为typedef void redisCommandProc(redisClient *c)</td></tr><tr><td>arity</td><td>int</td><td>命令参数的个数，用于检查命令请求的格式是否正确。如果这个值为负数-N，那么表示参数的数量大于等于N。（注意，命令的名字本身也是一个参数）</td></tr><tr><td>sflags</td><td>char *</td><td>字符串形式的标识值，这个值记录了命令的属性。</td></tr><tr><td>flags</td><td>int</td><td>对sflags标识进行分析得出的二进制标识，由程序自动生成。服务器对命令标识进行检查时使用的都是flags属性而不是sflags属性，因为对二进制标识的检查可以方便地通过&amp;、^、~等操作来完成</td></tr><tr><td>calls</td><td>long long</td><td>服务器总共执行了多少次命令</td></tr><tr><td>milliseconds</td><td>long long</td><td>服务器执行这个命令所耗费的总时长</td></tr></tbody></table><p>下表列出了sflags属性可以使用的标识值，以及这些标识地意义。</p><table><thead><tr><th>标识</th><th>意义</th><th>带有这个标识的命令</th></tr></thead><tbody><tr><td>w</td><td>这是一个写入命令，可能会修改数据库</td><td>SET、RPUSH、DEL等等</td></tr><tr><td>r</td><td>这是一个只读命令，不会修改数据库</td><td>GET、STRLEN、EXISTS等等</td></tr><tr><td>m</td><td>这个命令可能会占用大量内存，执行之前需要先检查服务器的内存使用情况，如果内存紧缺的话就禁止执行这个命令</td><td>SET、APPEND、RPUSH、LPUSH、SADD、SINTERSTORE等等</td></tr><tr><td>a</td><td>这是一个管理命令</td><td>SAVE、BGSAVE、SHUTDOWN等等</td></tr><tr><td>p</td><td>这是一个发布与订阅功能方面的命令</td><td>PUBLISH、SUBSCRIBE、PUBSUB等等</td></tr><tr><td>s</td><td>这个命令不可以在 Lua脚本中使用</td><td>BRPOP、BLPOP、BRPOPLPUSH、SPOP等等</td></tr><tr><td>R</td><td>这是一个随机命令，对于相同的数据集和相同的参数，命令返回的结果可能不同</td><td>SPOP、SRANDMEMBER、SSCAN、RANDOMKEY等等</td></tr><tr><td>S</td><td>当在Lua脚本中使用这个命令时，对这个命令的输出结果进行一次排序，使得命令的结果有序</td><td>SINTER、SUNION、SDIFF、SMEMBERS、KEYS等等</td></tr><tr><td>l</td><td>这个命令可以在服务器载入数据的过程中使用</td><td>INFO、SHUTDOWN、PUBLISH等等</td></tr><tr><td>t</td><td>这是一个允许从服务器在带有过期数据时使用的命令</td><td>SLAVEOF、PING、INFO等等</td></tr><tr><td>M</td><td>这个命令在监视器（monitor）模式下不会自动被传播（propagate）</td><td>EXEC</td></tr></tbody></table><p>下图为cmd指针示例：</p><p><img src="/../img/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/%E8%AE%BE%E7%BD%AE%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%8A%B6%E6%80%81%E7%9A%84cmd%E6%8C%87%E9%92%88.png" alt="设置客户端状态的cmd指针.png"></p><h4 id="命令执行器（2）：执行预备操作"><a href="#命令执行器（2）：执行预备操作" class="headerlink" title="命令执行器（2）：执行预备操作"></a>命令执行器（2）：执行预备操作</h4><p>到目前为止，服务器已经将执行命令所需的命令实现函数（保存在客户端状态的cmd属性）、参数（保存在客户端状态的argv属性）、参数个数（保存在客户端状态的argc属性）都收集齐了，但是在真正执行命令之前，程序还需要进行一些预备操作，从而确保命令可以正确、顺利地被执行，这些操作包括：</p><ul><li>检查客户端状态的cmd指针是否指向NULL，如果是的话，那么说明用户输入的命令名字找不到相应的命令实现，服务器不再执行后续步骤，并向客户端返回一个错误。</li><li>根据客户端cmd属性指向的redisCommand结构的arity属性，检查命令请求所给定的参数个数是否正确，当参数个数不正确时，不再执行后续步骤，直接向客户端返回一个错误。比如说，如果redisCommand结构的arity属性的值为-3，那么用户输入的命令参数个数必须大于等于3个才行。</li><li>检查客户端是否已经通过了身份验证，未通过身份验证的客户端只能执行AUTH命令，如果未通过身份验证的客户端试图执行除AUTH命令之外的其他命令，那么服务器将向客户端返回一个错误。</li><li>如果服务器打开了maxmemory功能，那么在执行命令之前，先检查服务器的内存占用情况，并在有需要时进行内存回收，从而使得接下来的命令可以顺利执行。如果内存回收失败，那么不再执行后续步骤，向客户端返回一个错误。</li><li>如果服务器上一次执行BGSAVE命令时出错，并且服务器打开了stop-writes-on-bgsave-error功能，而且服务器即将要执行的命令是一个写命令，那么服务器将拒绝执行这个命令，并向客户端返回一个错误。</li><li>如果客户端当前正在用SUBSCRIBE命令订阅频道，或者正在用PSUBSCRIBE命令订阅模式，那么服务器只会执行客户端发来的SUBSCRIBE、PSUBSCRIBE、UNSUBSCRIBE、PUNSUBSCRIBE四个命令，其他命令都会被服务器拒绝。</li><li>如果服务器正在进行数据载入，那么客户端发送的命令必须带有l标识（比如INFO、SHUTDOWN、PUBLISH等等）才会被服务器执行，其他命令都会被服务器拒绝。</li><li>如果服务器因为执行Lua脚本而超时并进入阻塞状态，那么服务器只会执行客户端发来的SHUTDOWN nosave命令和SCRIPT KILL命令，其他命令都会被服务器拒绝。</li><li>如果客户端正在执行事务，那么服务器只会执行客户端发来的EXEC、DISCARD、MULTI、WATCH 四个命令，其他命令都会被放进事务队列中。</li><li>如果服务器打开了监视器功能，那么服务器会将要执行的命令和参数等信息发送给监视器。当完成了以上预备操作之后，服务器就可以开始真正执行命令了。</li></ul><h4 id="命令执行器（3）：调用命令的实现函数"><a href="#命令执行器（3）：调用命令的实现函数" class="headerlink" title="命令执行器（3）：调用命令的实现函数"></a>命令执行器（3）：调用命令的实现函数</h4><p>在前面的操作中，服务器已经将要执行命令的实现保存到了客户端状态的cmd属性里面，并将命令的参数和参数个数分别保存到了客户端状态的argv属性和argc属性里面，当服务器决定要执行命令时，它只要执行以下语句就可以了：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// client是指向客户端状态的指针</span></span><br><span class="line">client-&gt;cmd-&gt;proc(client);</span><br></pre></td></tr></table></figure><p>因为执行命令所需的实际参数都已经保存到客户端状态的argv属性里面了，所以命令的实现函数只需要一个指向客户端状态的指针作为参数即可。</p><p>被调用的命令实现函数会执行指定的操作，并产生相应的命令回复，这些回复会被保存在客户端状态的输出缓冲区里面（buf属性和reply属性），之后实现函数还会为客户端的套接字关联命令回复处理器，这个处理器负责将命令回复返回给客户端。</p><h4 id="命令执行器（4）：执行后续工作"><a href="#命令执行器（4）：执行后续工作" class="headerlink" title="命令执行器（4）：执行后续工作"></a>命令执行器（4）：执行后续工作</h4><p>在执行完实现函数之后，服务器还需要执行一些后续工作：</p><ul><li>如果服务器开启了慢查询日志功能，那么慢查询日志模块会检查是否需要为刚刚执行完的命令请求添加一条新的慢查询日志。</li><li>根据刚刚执行命令所耗费的时长，更新被执行命令的redisCommand结构的milliseconds属性，并将命令的redisCommand结构的calls计数器的值增一。</li><li>如果服务器开启了AOF持久化功能，那么AOF持久化模块会将刚刚执行的命令请求写入到AOF缓冲区里面。</li><li>如果有其他从服务器正在复制当前这个服务器，那么服务器会将刚刚执行的命令传播给所有从服务器。</li></ul><p>当以上操作都执行完了之后，服务器对于当前命令的执行到此就告一段落了，之后服务器就可以继续从文件事件处理器中取出并处理下一个命令请求了。</p><h4 id="将命令回复发送给客户端"><a href="#将命令回复发送给客户端" class="headerlink" title="将命令回复发送给客户端"></a>将命令回复发送给客户端</h4><p>前面说过，命令实现函数会将命令回复保存到客户端的输出缓冲区里面，并为客户端的套接字关联命令回复处理器，当客户端套接字变为可写状态时，服务器就会执行命令回复处理器，将保存在客户端输出缓冲区中的命令回复发送给客户端。</p><p>当命令回复发送完毕之后，回复处理器会清空客户端状态的输出缓冲区，为处理下一个命令请求做好准备。</p><h4 id="客户端接收并打印命令回复"><a href="#客户端接收并打印命令回复" class="headerlink" title="客户端接收并打印命令回复"></a>客户端接收并打印命令回复</h4><p>当客户端接收到协议格式的命令回复之后，它会将这些回复转换成人类可读的格式，并打印给用户观看。</p><h3 id="serverCron函数"><a href="#serverCron函数" class="headerlink" title="serverCron函数"></a>serverCron函数</h3><p>Redis服务器中的serverCron函数默认每隔100毫秒执行一次，这个函数负责管理服务器的资源，并保持服务器自身的良好运转。</p><h4 id="更新服务器时间缓存"><a href="#更新服务器时间缓存" class="headerlink" title="更新服务器时间缓存"></a>更新服务器时间缓存</h4><p>Redis服务器中有不少功能需要获取系统的当前时间，而每次获取系统的当前时间都需要执行一次系统调用，为了减少系统调用的执行次数，服务器状态中的unixtime属性和mstime属性被用作当前时间的缓存：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span> &#123;</span></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="comment">//保存了秒级精度的系统当前UNIX时间戳</span></span><br><span class="line"><span class="type">time_t</span> unixtime;</span><br><span class="line"><span class="comment">//保存了毫秒级精度的系统当前UNIX时间戳</span></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> mstime;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>因为serverCron函数默认会以每100毫秒一次的频率更新unixtime属性和mstime属性，所以这两个属性记录的时间的精确度并不高：</p><ul><li>服务器只会在打印日志、更新服务器的LRU时钟、决定是否执行持久化任务、计算服务器上线时间（uptime）这类对时间精确度要求不高的功能上。</li><li>对于为键设置过期时间、添加慢查询日志这种需要高精确度时间的功能来说，服务器还是会再次执行系统调用，从而获得最准确的系统当前时间。</li></ul><h4 id="更新LRU时钟"><a href="#更新LRU时钟" class="headerlink" title="更新LRU时钟"></a>更新LRU时钟</h4><p>服务器状态中的lruclock属性保存了服务器的LRU时钟，这个属性和上面介绍的unixtime属性、mstime属性一样，都是服务器时间缓存的一种：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span> &#123;</span></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="comment">//默认每10秒更新一次的时钟缓存，</span></span><br><span class="line"><span class="comment">//用于计算键的空转（idle）时长。</span></span><br><span class="line"><span class="type">unsigned</span> lruclock:<span class="number">22</span>;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>每个Redis对象都会有一个lru属性，这个lru属性保存了对象最后一次被命令访问的时间：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisObject</span> &#123;</span></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="type">unsigned</span> lru:<span class="number">22</span>;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125; robj;</span><br></pre></td></tr></table></figure><p>当服务器要计算一个数据库键的空转时间（也即是数据库键对应的值对象的空转时间），程序会用服务器的lruclock属性记录的时间减去对象的lru属性记录的时间，得出的计算结果就是这个对象的空转时间。</p><p>serverCron函数默认会以每10秒一次的频率更新lruclock属性的值，因为这个时钟不是实时的，所以根据这个属性计算出来的LRU时间实际上只是一个模糊的估算值。</p><h4 id="更新服务器每秒执行命令次数"><a href="#更新服务器每秒执行命令次数" class="headerlink" title="更新服务器每秒执行命令次数"></a>更新服务器每秒执行命令次数</h4><p>serverCron函数中的trackOperationsPerSecond函数会以每100毫秒一次的频率执行，这个函数的功能是以抽样计算的方式，估算并记录服务器在最近一秒钟处理的命令请求数量。</p><p>trackOperationsPerSecond函数和服务器状态中四个ops_sec_开头的属性有关：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span> &#123;</span></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="comment">//上一次进行抽样的时间</span></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> ops_sec_last_sample_time;</span><br><span class="line"></span><br><span class="line"><span class="comment">//上一次抽样时，服务器已执行命令的数量</span></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> ops_sec_last_sample_ops;</span><br><span class="line"><span class="comment">//REDIS_OPS_SEC_SAMPLES大小（默认值为16）的环形数组,</span></span><br><span class="line"><span class="comment">//数组中的每个项都记录了一次抽样结果。</span></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> ops_sec_samples[REDIS_OPS_SEC_SAMPLES];</span><br><span class="line"><span class="comment">//ops_sec_samples数组的索引值,</span></span><br><span class="line"><span class="comment">//每次抽样后将值自增一,</span></span><br><span class="line"><span class="comment">//在值等于16时重置为0,</span></span><br><span class="line"><span class="comment">//让ops_sec_samples数组构成一个环形数组。</span></span><br><span class="line"><span class="type">int</span> ops_sec_idx;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;;/</span><br></pre></td></tr></table></figure><p>trackOperationsPerSecond函数每次运行，都会根据ops_sec_last_sample_time记录的上一次抽样时间和服务器的当前时间，以及ops_sec_last_sample_ops记录的上一次抽样的已执行命令数量和服务器当前的已执行命令数量，计算出两次trackOperationsPerSecond调用之间，服务器平均每一毫秒处理了多少个命令请求，然后将这个平均值乘以1000，这就得到了服务器在一秒钟内能处理多少个命令请求的估计值，这个估计值会被作为一个新的数组项被放进ops_sec_samples环形数组里面。</p><p>当客户端执行INFO命令时，服务器就会调用getOperationsPerSecond函数，根据ops_sec_samples环形数组中的抽样结果，计算出instantaneous_ops_per_sec属性的值，以下是getOperationsPerSecond函数的实现代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="type">long</span> <span class="title function_">getOperationsPerSecond</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line"><span class="type">int</span> j;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//计算所有取样值的总和</span></span><br><span class="line"><span class="keyword">for</span> (j= <span class="number">0</span>; j &lt; REDIS_OPS_SEC_SAMPLES; j++)</span><br><span class="line">sum += server.ops_sec_samples[j];</span><br><span class="line"><span class="comment">//计算取样的平均值</span></span><br><span class="line"><span class="keyword">return</span> sum / REDIS_OPS_SEC_SAMPLES;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据get0perationsPerSecond函数的定义可以看出，instantaneous_ops_per_sec属性的值是通过计算最近REDIS_OPS_SEC_SAMPLES次取样的平均值来计算得出的，它只是一个估算值。</p><h4 id="更新服务器内峰值记录"><a href="#更新服务器内峰值记录" class="headerlink" title="更新服务器内峰值记录"></a>更新服务器内峰值记录</h4><p>服务器状态中的stat_peak_memory属性记录了服务器的内存峰值大小：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span> &#123;</span></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="comment">//已使用内存峰值</span></span><br><span class="line"><span class="type">size_t</span> stat_peak_memory;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>每次serverCron函数执行时，程序都会查看服务器当前使用的内存数量，并与stat_peak_memory保存的数值进行比较，如果当前使用的内存数量比stat_peak_memory属性记录的值要大，那么程序就将当前使用的内存数量记录到stat_peak_memory属性里面。</p><h4 id="处理SIGTERM信号"><a href="#处理SIGTERM信号" class="headerlink" title="处理SIGTERM信号"></a>处理SIGTERM信号</h4><p> 在启动服务器时，Redis会为服务器进程的SIGTERM信号关联处理器sigtermHandler函数，这个信号处理器负责在服务器接到SIGTERM信号时，打开服务器状态的shutdown_asap标识：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//SIGTERM信号的处理器</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">sigtermHandler</span><span class="params">(<span class="type">int</span> sig)</span> &#123;</span><br><span class="line"><span class="comment">//打印日志</span></span><br><span class="line">redisLogFromHandler(REDIS_WARNING, <span class="string">&quot;Received SIGTERM, scheduling shutdown...&quot;</span>);</span><br><span class="line"><span class="comment">//打开关闭标识</span></span><br><span class="line">server.shutdown_asap = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每次serverCron函数运行时，程序都会对服务器状态的shutdown_asap属性进行检查，并根据属性的值决定是否关闭服务器：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span> &#123;</span></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="comment">//关闭服务器的标识:</span></span><br><span class="line"><span class="comment">//值为1时，关闭服务器，</span></span><br><span class="line"><span class="comment">//值为0时，不做动作。</span></span><br><span class="line"><span class="type">int</span> shutdown_asap;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="管理客户端资源"><a href="#管理客户端资源" class="headerlink" title="管理客户端资源"></a>管理客户端资源</h4><p>serverCron函数每次执行都会调用clientsCron函数，clientsCron函数会对一定数量的客户端进行以下两个检查：</p><ul><li>如果客户端与服务器之间的连接已经超时（很长一段时间里客户端和服务器都没有互动），那么程序释放这个客户端。</li><li>如果客户端在上一次执行命令请求之后，输入缓冲区的大小超过了一定的长度，那么程序会释放客户端当前的输入缓冲区，并重新创建一个默认大小的输入缓冲区，从而防止客户端的输入缓冲区耗费了过多的内存。</li></ul><h4 id="管理数据库资源"><a href="#管理数据库资源" class="headerlink" title="管理数据库资源"></a>管理数据库资源</h4><p>serverCron函数每次执行都会调用databasesCron函数，这个函数会对服务器中的一部分数据库进行检查，删除其中的过期键，并在有需要时，对字典进行收缩操作。</p><h4 id="执行被延迟的BGREWRITEAOF"><a href="#执行被延迟的BGREWRITEAOF" class="headerlink" title="执行被延迟的BGREWRITEAOF"></a>执行被延迟的BGREWRITEAOF</h4><p>在服务器执行BGSAVE命令的期间，如果客户端向服务器发来BGREWRITEAOF命令，那么服务器会将BGREWRITEAOF命令的执行时间延迟到BGSAVE命令执行完毕之后。</p><p>服务器的aof_rewrite_scheduled标识记录了服务器是否延迟了BGREWRITEAOF命令：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span> &#123;</span></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="comment">//如果值为1，那么表示有BGREWRITEAOF命令被延迟了。</span></span><br><span class="line"><span class="type">int</span> aof_rewrite_scheduled;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>每次serverCron函数执行时，函数都会检查BGSAVE命令或者BGREWRITEAOF命令是否正在执行，如果这两个命令都没在执行，并且aof_rewrite_scheduled属性的值为1，那么服务器就会执行之前被推延的BGREWRITEAOF命令。</p><h4 id="检查持久化操作的运行状态"><a href="#检查持久化操作的运行状态" class="headerlink" title="检查持久化操作的运行状态"></a>检查持久化操作的运行状态</h4><p>服务器状态使用rdb_child_pid属性和aof_child_pid属性记录执行BGSAVE命令和BGREWRITEAOF命令的子进程的ID，这两个属性也可以用于检查BGSAVE命令或者BGREWRITEAOF命令是否正在执行：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span> &#123;</span></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="comment">//记录执行BGSAVE命令的子进程的ID:</span></span><br><span class="line"><span class="comment">//如果服务器没有在执行BGSAVE，</span></span><br><span class="line"><span class="comment">//那么这个属性的值为-1。</span></span><br><span class="line"><span class="type">pid_t</span> rdb_child_pid;<span class="comment">/* PID of RDB saving child */</span></span><br><span class="line"><span class="comment">//记录执行BGREWRITEAOF命令的子进程的ID:</span></span><br><span class="line"><span class="comment">//如果服务器没有在执行BGREWRITEAOF,</span></span><br><span class="line"><span class="comment">//那么这个属性的值为-1。</span></span><br><span class="line"><span class="type">pid_t</span> aof_child_pid;<span class="comment">/* PID if rewriting process */</span></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>每次serverCron函数执行时，程序都会检查rdb_child_pid和aof_child_pid两个属性的值，只要其中一个属性的值不为-1，程序就会执行一次wait3函数，检查子进程是否有信号发来服务器进程：</p><ul><li>如果有信号到达，那么表示新的RDB文件已经生成完毕（对于BGSAVE命令来说），<br>或者AOF文件已经重写完毕（对于BGREWRITEAOF命令来说），服务器需要进行相应命令的后续操作，比如用新的RDB文件替换现有的RDB文件，或者用重写后的AOF文件替换现有的AOF文件。</li><li>如果没有信号到达，那么表示持久化操作未完成，程序不做动作。</li></ul><p>另一方面，如果rdb_child_pid和aof_child_pid两个属性的值都为-1，那么表示服务器没有在进行持久化操作，在这种情况下，程序执行以下三个检查：</p><ol><li>查看是否有BGREWRITEAOF被延迟了，如果有的话，那么开始一次新的BGREWRITEAOF操作（这就是上一个小节我们说到的检查）</li><li>检查服务器的自动保存条件是否已经被满足，如果条件满足，并且服务器没有在执行其他持久化操作，那么服务器开始一次新的BGSAVE操作（因为条件1可能会引发一次BGREWRITEAOF，所以在这个检查中，程序会再次确认服务器是否已经在执行持久化操作了)。</li><li>检查服务器设置的AOF重写条件是否满足，如果条件满足，并且服务器没有在执行其他持久化操作，那么服务器将开始一次新的BGREWRITEAOF操作（因为条件1和条件2都可能会引起新的持久化操作，所以在这个检查中，我们要再次确认服务器是否已经在执行持久化操作了）</li></ol><p><img src="/../img/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E9%9C%80%E8%A6%81%E6%89%A7%E8%A1%8C%E6%8C%81%E4%B9%85%E5%8C%96%E6%93%8D%E4%BD%9C.png" alt="判断是否需要执行持久化操作.png"></p><h4 id="将AOF缓冲区中的内容写入AOF文件"><a href="#将AOF缓冲区中的内容写入AOF文件" class="headerlink" title="将AOF缓冲区中的内容写入AOF文件"></a>将AOF缓冲区中的内容写入AOF文件</h4><p>如果服务器开启了AOF持久化功能，并且AOF缓冲区里面还有待写入的数据，那么serverCron函数会调用相应的程序，将AOF缓冲区中的内容写入到AOF文件里面。</p><h4 id="关闭异步客户端"><a href="#关闭异步客户端" class="headerlink" title="关闭异步客户端"></a>关闭异步客户端</h4><p>在这一步，服务器会关闭那些输出缓冲区大小超出限制的客户端。</p><h4 id="增加cronloops计数器的值"><a href="#增加cronloops计数器的值" class="headerlink" title="增加cronloops计数器的值"></a>增加cronloops计数器的值</h4><p>服务器状态的cronloops属性记录了serverCron函数执行的次数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span> &#123;</span></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="comment">//serverCron函数的运行次数计数器</span></span><br><span class="line"><span class="comment">//serverCron函数每执行一次，这个属性的值就增一。</span></span><br><span class="line"><span class="type">int</span> cronloops;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>cronloops属性目前在服务器中的唯一作用，就是在复制模块中实现“每执行serverCron函数N次就执行一次指定代码”的功能，方法如以下伪代码所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> cronloops % N == <span class="number">0</span>:</span><br><span class="line">#执行指定代码...</span><br></pre></td></tr></table></figure><h3 id="初始化服务器"><a href="#初始化服务器" class="headerlink" title="初始化服务器"></a>初始化服务器</h3><p>一个Redis服务器从启动到能够接受客户端的命令请求，需要经过一系列的初始化和设置过程，比如初始化服务器状态，接受用户指定的服务器配置，创建相应的数据结构和网络连接等等。</p><h4 id="初始化服务器状态结构"><a href="#初始化服务器状态结构" class="headerlink" title="初始化服务器状态结构"></a>初始化服务器状态结构</h4><p>初始化服务器的第一步就是创建一个struct redisServer类型的实例变量server作为服务器的状态，并为结构中的各个属性设置默认值。</p><p>初始化server变量的工作由redis.c&#x2F;initServerConfig函数完成，以下是这个函数最开头的一部分代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">initServerConfig</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line"><span class="comment">//设置服务器的运行id</span></span><br><span class="line">getRandomHexChars(server.runid, REDIS_RUN_ID_SIZE);</span><br><span class="line"><span class="comment">//为运行id加上结尾字符</span></span><br><span class="line">server.runid[REDIS_RUN_ID_SIZE] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"><span class="comment">//设置默认配置文件路径</span></span><br><span class="line">server.configfile = <span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">//设置默认服务器频率</span></span><br><span class="line">server.hz = REDIS_DEFAULT_HZ;</span><br><span class="line"><span class="comment">//设置服务器的运行架构</span></span><br><span class="line">server.arch_bits = (<span class="keyword">sizeof</span>(<span class="type">long</span>) == <span class="number">8</span>) ? <span class="number">64</span> : <span class="number">32</span>;</span><br><span class="line"><span class="comment">//设置默认服务器端口号</span></span><br><span class="line">server.port = REDIS_SERVERPORT;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下是initServerConfig函数完成的主要工作：</p><ul><li>设置服务器的运行ID。</li><li>设置服务器的默认运行频率。</li><li>设置服务器的默认配置文件路径。</li><li>设置服务器的运行架构。</li><li>设置服务器的默认端口号。</li><li>设置服务器的默认RDB持久化条件和AOF持久化条件。</li><li>初始化服务器的LRU时钟。</li><li>创建命令表。</li></ul><p>initServerConfig函数设置的服务器状态属性基本都是一些整数、浮点数、或者字符串属性，除了命令表之外，initServerConfig函数没有创建服务器状态的其他数据结构，数据库、慢查询日志、Lua环境、共享对象这些数据结构在之后的步骤才会被创建出来。</p><p>当initServerConfig函数执行完毕之后，服务器就可以进入初始化的第二个阶段——载入配置选项。</p><h4 id="载入配置选项"><a href="#载入配置选项" class="headerlink" title="载入配置选项"></a>载入配置选项</h4><p>在启动服务器时，用户可以通过给定配置参数或者指定配置文件来修改服务器的默认配置。</p><p>服务器在用initServerConfig函数初始化完server变量之后，就会开始载入用户给定的配置参数和配置文件，并根据用户设定的配置，对server变量相关属性的值进行修改。</p><p>例如，在初始化server变量时，程序会为决定服务器端口号的port属性设置默认值：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">initServerConfig</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="comment">//默认值为6379</span></span><br><span class="line">server.port = REDIS_SERVERPORT;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不过，如果用户在启动服务器时为配置选项port指定了新值10086，那么server.port属性的值就会被更新为10086，这将使得服务器的端口号从默认的6379变为用户指定的10086。</p><p>其他配置选项相关的服务器状态属性的情况与上面列举的port属性一样：</p><ul><li>如果用户为这些属性的相应选项指定了新的值，那么服务器就使用用户指定的值来更新相应的属性。</li><li>如果用户没有为属性的相应选项设置新的值，那么服务器就沿用之前initServerConfig函数为属性设置的默认值。</li></ul><p>服务器在载入用户指定的配置选项，并对server状态进行更新之后，服务器就可以进入初始化的第三个阶段——初始化服务器数据结构。</p><h4 id="初始化服务器数据结构"><a href="#初始化服务器数据结构" class="headerlink" title="初始化服务器数据结构"></a>初始化服务器数据结构</h4><p>在之前执行initServerConfig函数初始化server状态时，程序只创建了命令表一个数据结构，不过除了命令表之外，服务器状态还包含其他数据结构，比如：</p><ul><li>server.clients链表，这个链表记录了所有与服务器相连的客户端的状态结构，链表的每个节点都包含了一个redisclient结构实例。</li><li>server.db数组，数组中包含了服务器的所有数据库。</li><li>用于保存频道订阅信息的server.pubsub_channels字典，以及用于保存模式订阅信息的server.pubsub_patterns链表。</li><li>用于执行Lua脚本的Lua环境server.lua。</li><li>用于保存慢查询日志的server.slowlog属性。</li></ul><p>当初始化服务器进行到这一步，服务器将调用initServer函数，为以上提到的数据结构分配内存，并在有需要时，为这些数据结构设置或者关联初始化值。</p><p>服务器到现在才初始化数据结构的原因在于，服务器必须先载入用户指定的配置选项，然后才能正确地对数据结构进行初始化。如果在执行initServerConfig函数时就对数据结构进行初始化，那么一旦用户通过配置选项修改了和数据结构有关的服务器状态属性，服务器就要重新调整和修改已创建的数据结构。为了避免出现这种麻烦的情况，服务器选择了将server状态的初始化分为两步进行，initServerConfig函数主要负责初始化一般属性，而initServer函数主要负责初始化数据结构。</p><p>除了初始化数据结构之外，initServer还进行了一些非常重要的设置操作，其中包括：</p><ul><li>为服务器设置进程信号处理器。</li><li>创建共享对象：这些对象包含Redis服务器经常用到的一些值，比如包含”OK”回复的字符串对象，包含”ERR”回复的字符串对象，包含整数1到10000的字符串对象等等，服务器通过重用这些共享对象来避免反复创建相同的对象。</li><li>打开服务器的监听端口，并为监听套接字关联连接应答事件处理器，等待服务器正式运行时接受客户端的连接。</li><li>为serverCron函数创建时间事件，等待服务器正式运行时执行servercron函数。</li><li>如果AOF持久化功能已经打开，那么打开现有的AOF文件，如果AOF文件不存在，那么创建并打开一个新的AOF文件，为AOF写入做好准备。</li><li>初始化服务器的后台I&#x2F;O模块（bio），为将来的I&#x2F;O操作做好准备。</li></ul><p>当initServer函数执行完毕之后，服务器将用ASCII字符在日志中打印出Redis的图标，以及Redis的版本号信息。</p><h4 id="还原数据库状态"><a href="#还原数据库状态" class="headerlink" title="还原数据库状态"></a>还原数据库状态</h4><p>在完成了对服务器状态server变量的初始化之后，服务器需要载入RDB文件或者AOF文件，并根据文件记录的内容来还原服务器的数据库状态。</p><p>根据服务器是否启用了AOF持久化功能，服务器载入数据时所使用的目标文件会有所不同：</p><ul><li>如果服务器启用了AOF持久化功能，那么服务器使用AOF文件来还原数据库状态。</li><li>相反地，如果服务器没有启用AOF持久化功能，那么服务器使用RDB文件来还原数据库状态。</li></ul><h4 id="执行事件循环"><a href="#执行事件循环" class="headerlink" title="执行事件循环"></a>执行事件循环</h4><p>在初始化的最后一步，服务器将打印出以下日志：</p><p>[5244] 2l Nov 22:43:49.084 * The server is now ready to accept connections on port 6379</p><p>并开始执行服务器的事件循环（loop）。</p><p>至此，服务器的初始化工作圆满完成，服务器现在开始可以接受客户端的连接请求，并处理客户端发来的命令请求了。</p>]]></content>
    
    
    <summary type="html">&lt;Redis设计与实现&gt;第二部分，关于单机数据库的各种内部实现</summary>
    
    
    
    <category term="Redis设计与实现读书笔记" scheme="http://example.com/categories/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Redis" scheme="http://example.com/tags/Redis/"/>
    
    <category term="Redis设计与实现" scheme="http://example.com/tags/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/"/>
    
    <category term="单机数据库的实现" scheme="http://example.com/tags/%E5%8D%95%E6%9C%BA%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    
  </entry>
  
  <entry>
    <title>&lt;Redis设计与实现&gt;第一部分</title>
    <link href="http://example.com/2022/05/13/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86/"/>
    <id>http://example.com/2022/05/13/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86/</id>
    <published>2022-05-12T16:00:00.000Z</published>
    <updated>2022-05-12T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第一部分-数据结构与对象"><a href="#第一部分-数据结构与对象" class="headerlink" title="第一部分 数据结构与对象"></a>第一部分 数据结构与对象</h1><h2 id="简单动态字符串"><a href="#简单动态字符串" class="headerlink" title="简单动态字符串"></a>简单动态字符串</h2><p>Redis没有直接使用C语言传统的字符串表示（以空字符结尾的字符数组，以下简称C字符串），而是自己构建了一种名为简单动态字符串（ simple dynamic string，SDS ）的抽象类型，并将SDS用作Redis的默认字符串表示。</p><p>在Redis里面，C字符串只会作为字符串字面量（ string literal ）用在一些无须对字符串值进行修改的地方。当Redis需要的不仅仅是一个字符串字面量，而是一个可以被修改的字符串值时，Redis就会使用SDS来表示字符串值，比如在Redis 的数据库里面，包含字符串值的键值对在底层都是由SDS实现的。</p><h3 id="SDS的定义"><a href="#SDS的定义" class="headerlink" title="SDS的定义"></a>SDS的定义</h3><p>每个sds.h&#x2F;sdshdr结构表示一个SDS值：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span>&#123;</span></span><br><span class="line"><span class="comment">// 记录buf数组中已使用字节的数量</span></span><br><span class="line">    <span class="comment">// 等于SDS所保存字符串的长度</span></span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 记录buf数组中未使用字节的数量</span></span><br><span class="line">    <span class="type">int</span> <span class="built_in">free</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 字节数组，用于保存字符串</span></span><br><span class="line">    <span class="type">char</span> buf[];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="/../img/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/SDS%E7%A4%BA%E4%BE%8B.png" alt="SDS示例"></p><p>上图展示了一个SDS示例：</p><ul><li>free属性的值为5，表示这个SDS为buf数组分配了五字节未使用空间。</li><li>len属性的值为5，表示这个SDS保存了一个五字节长的字符串。</li><li>buf属性是一个char类型的数组，数组的前五个字节分别保存了’R’、’e ‘、’d’、’i’、 ‘s ‘五个字符，而最后一个字节则保存了空字符 ‘\0 ‘。</li></ul><p>可以看见SDS和C字符串一样，保留了以空字符串结尾的惯例，这样的好处在于SDS可以直接重用一部分C字符串函数库里的函数，该空字符对于SDS的使用者是可以忽略的（完全透明的）。</p><h3 id="SDS与C字符串的区别"><a href="#SDS与C字符串的区别" class="headerlink" title="SDS与C字符串的区别"></a>SDS与C字符串的区别</h3><table><thead><tr><th align="center">C字符串</th><th align="center">SDS</th></tr></thead><tbody><tr><td align="center">获取字符串长度的复杂度为O(N)</td><td align="center">获取字符串长度的复杂度为O(1)</td></tr><tr><td align="center">API是不安全的，可能会造成缓冲区溢出</td><td align="center">API是安全的，不会造成缓冲区溢出</td></tr><tr><td align="center">修改字符串长度N次必然需要执行N次内存重分配</td><td align="center">修改字符串长度N次最多需要执行N次内存重分配</td></tr><tr><td align="center">只能保存文本数据</td><td align="center">可以保存文本或者二进制数据</td></tr><tr><td align="center">可以使用所有&lt;string.h&gt;库中的函数</td><td align="center">可以使用一部分&lt;string.h&gt;库中的函数</td></tr></tbody></table><p>各个区别细节如下：</p><h4 id="常熟复杂度获取字符串长度"><a href="#常熟复杂度获取字符串长度" class="headerlink" title="常熟复杂度获取字符串长度"></a>常熟复杂度获取字符串长度</h4><p>由于C字符串并不记录自身的长度信息，所以获取一个C字符串的长度的操作复杂度为O(N)；而由于SDS使用len记录了字符串的长度信息，该操作的复杂度降低到了O(1)。这确保了获取字符串长度的工作不会成为Redis的性能瓶颈。</p><p>注意，设置和更新SDS长度的工作是由SDS的API在执行时自动完成的，使用SDS无须进行任何手动修改长度的工作。</p><h4 id="杜绝缓冲区溢出"><a href="#杜绝缓冲区溢出" class="headerlink" title="杜绝缓冲区溢出"></a>杜绝缓冲区溢出</h4><p>由于C字符串不记录自身的长度信息，所以容易造成缓冲区溢出（buffer overflow）。</p><p>举例来说，&lt;string.h&gt;&#x2F;strcat函数可以将src字符串中的内容拼接到dest字符串的末尾：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">strcat</span><span class="params">(<span class="type">char</span> *dest, <span class="type">const</span> <span class="type">char</span> *src)</span>;</span><br></pre></td></tr></table></figure><p>该函数并不保证dest有足够的空间容纳src中的内容（即该函数假设用户已经为dest分配了足够多的内存）。</p><p>与C字符串不同，SDS的空间分配策略完全杜绝了发生缓冲区溢出的可能性：当SDS API需要对SDS进行修改时，API会先检查SDS的空间是否满足修改所需的要求，如果不满足的话，API会自动将SDS的空间扩展至执行修改所需的大小，然后才执行实际的修改操作，所以使用SDS既不需要手动修改SDS的空间大小，也不会出现前面所说的缓冲区溢出问题。</p><p>同样举例来说，SDS的API内也有一个用于执行拼接操作的sdscat函数，它可以将一个C字符串拼接到给定SDS所保存的字符串的后面，但是在执行拼接操作之前，sdscat会先检查给定SDS的空间是否足够，如果不够的话，sdscat就会先扩展SDS的空间，然后才执行拼接操作。</p><h4 id="减少修改字符串时带来的内存重分配次数"><a href="#减少修改字符串时带来的内存重分配次数" class="headerlink" title="减少修改字符串时带来的内存重分配次数"></a>减少修改字符串时带来的内存重分配次数</h4><p>由于C字符串的底层实现总是一个N+1个字符长的数组（额外的一个字符空间用于保存空字符）。所以每次增长或缩短一个C字符串，程序都总是要对保存这个C字符串的数组进行一次内存重分配操作。</p><p>在一般程序中，如果修改字符串长度的情况不太常出现，那么每次修改都执行一次内存重分配是可以接受的。但是Redis作为数据库，是数据会被频繁修改并且速度要求严苛的场合，如果频繁执行内存重分配的话，会对性能造成影响。</p><p>为了避免C字符串的这种缺陷，SDS通过未使用空间解除了字符串长度和底层数组长度之间的关联：在SDS中，buf数组的长度不一定就是字符数量加一，数组里面可以包含未使用的字节，而这些字节的数量就由SDS的free属性记录。</p><p>通过未使用空间，SDS 实现了空间预分配和惰性空间释放两种优化策略。</p><h5 id="空间预分配"><a href="#空间预分配" class="headerlink" title="空间预分配"></a>空间预分配</h5><p>空间预分配用于优化SDS的字符串增长操作：当SDS的API对一个SDS进行修改，并且需要对SDS进行空间扩展的时候，程序不仅会为SDS分配修改所需要的空间，还会为SDS分配额外的为使用空间。</p><p>额外分配的未使用空间数量由以下公式决定：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">free</span> = len &lt; <span class="number">1</span>MB ? len : <span class="number">1</span>MB;</span><br></pre></td></tr></table></figure><p>即，取决于对SDS修改之后，SDS的长度。如果该长度小于1MB，那么程序分配和len属性同样大小的未使用空间；否则，SDS将之会分配1MB的未使用空间。</p><p>通过这种预分配策略，SDS将连续增长N次字符串所需的内存重分配次数从必定N次降低为最多N次。</p><h5 id="惰性空间释放"><a href="#惰性空间释放" class="headerlink" title="惰性空间释放"></a>惰性空间释放</h5><p>惰性空间释放用于优化SDS的字符串缩短操作：当SDS的API需要缩短SDS保存的字符串时，程序并不立即使用内存重分配来回收缩短后多出来的字节，而是使用free属性将这些字节的数量记录起来，并等待将来使用。</p><p>通过惰性空间释放策略，SDS避免了缩短字符串时所需的内存重分配操作，并为将来可能有的增长操作提供了优化。</p><p>与此同时，SDS也提供了相应的API，让我们可以在有需要时，真正地释放SDS的未使用空间，所以不用担心惰性空间释放策略会造成内存浪费。</p><h4 id="二进制安全"><a href="#二进制安全" class="headerlink" title="二进制安全"></a>二进制安全</h4><p>C字符串中的字符必须符合某种编码（比如ASCII），并且除了字符串的末尾之外，字符串里面不能包含空字符，否则最先被程序读入的空字符将被误认为是字符串结尾，这些限制使得C字符串只能保存文本数据，而不能保存像图片、音频、视频、压缩文件这样的二进制据。</p><p>而由于SDS使用len属性的值而不是空字符来判断字符串是否结束，因此SDS的API都是二进制安全的（binary-safe），所有SDS API都会以处理二进制的方式来处理SDS存放在buf数组里的数据，程序不会对其中的数据做任何限制、过滤、或者假设，数据在写入时是什么样的，它被读取时就是什么样。</p><p>通过使用二进制安全的SDS，而不是C字符串，使得Redis不仅可以保存文本数据，还可以保存任意格式的二进制数据。</p><h4 id="兼容部分C字符串函数"><a href="#兼容部分C字符串函数" class="headerlink" title="兼容部分C字符串函数"></a>兼容部分C字符串函数</h4><p>虽然SDS的API都是二进制安全的，但它们一样遵循C字符串以空字符结尾的惯例：这些API总会将SDS保存的数据的末尾设置为空字符，并且总会在为buf数组分配空间时多分配一个字节来容纳这个空字符，这是为了让那些保存文本数据的SDS可以重用一部分&lt;string.h&gt;库定义的函数。</p><p>通过遵循C字符串以空字符结尾的惯例，SDS可以在有需要时重用&lt;string.h&gt;函数库，从而避免了不必要的代码重复。</p><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><p>链表提供了高效的节点重排能力，以及顺序性的节点访问方式，并且可以通过增删节点来灵活地调整链表的长度。由于C语言中没有内置这种数据结构，因此Redis构建了自己的链表实现。</p><p>链表在Redis中的应用非常广泛，除了列表键之外，发布与订阅、慢查询、监视器等功能也用到了链表，Redis服务器本身还使用链表来保存多个客户端的状态信息，以及使用链表来构建客户端输出缓冲区（output buffer）。</p><h4 id="链表和链表节点的实现"><a href="#链表和链表节点的实现" class="headerlink" title="链表和链表节点的实现"></a>链表和链表节点的实现</h4><p>每个链表节点使用一个adlist.h&#x2F;listNode结构来表示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> &#123;</span></span><br><span class="line"><span class="comment">//前置节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">prev</span>;</span></span><br><span class="line">    <span class="comment">//后置节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="comment">//节点的值</span></span><br><span class="line">    <span class="type">void</span> *value;</span><br><span class="line">&#125; listNode;</span><br></pre></td></tr></table></figure><p>每个链表使用adlist.h&#x2F;list来表示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">list</span> &#123;</span></span><br><span class="line"><span class="comment">//表头结点（头节点前置指向NULL）</span></span><br><span class="line">    listNode *head;</span><br><span class="line">    <span class="comment">//表尾节点（尾节点后置指向NULL）</span></span><br><span class="line">    listNode *tail;</span><br><span class="line">    <span class="comment">//链表所包含的节点数量</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> len;</span><br><span class="line">    <span class="comment">//节点值复制函数</span></span><br><span class="line">    <span class="type">void</span> *(*dup)(<span class="type">void</span> *ptr);</span><br><span class="line">    <span class="comment">//节点值释放函数</span></span><br><span class="line">    <span class="type">void</span> (*<span class="built_in">free</span>)(<span class="type">void</span> *ptr);</span><br><span class="line">    <span class="comment">//节点值对比函数</span></span><br><span class="line">    <span class="type">int</span> (*match)(<span class="type">void</span> *ptr, <span class="type">void</span> *key);</span><br><span class="line">&#125; <span class="built_in">list</span>;</span><br></pre></td></tr></table></figure><p>list结构为链表提供了表头指针head、表尾指针tail以及链表长度计数器len，而dup、free和match成员则是用于实现多态链表所需的类型特定函数：</p><ul><li>dup函数用于复制链表节点所保存的值；</li><li>free函数用于释放链表节点所保存的值；</li><li>match函数用于对比链表节点所保存的值和另一个输入值是否相等。</li></ul><p>Redis中的一个链表示例：</p><p><img src="/../img/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/%E9%93%BE%E8%A1%A8%E7%A4%BA%E4%BE%8B.png" alt="链表示例"></p><p>Redis的链表实现的特性可以总结如下：</p><ul><li>双端：链表节点带有prev和next指针，获取某个节点的前置节点和后置节点的复杂度都是O(1)。</li><li>无环：表头节点的prev指针和表尾节点的next指针都指向NULL，对链表的访问以NULL为终点。</li><li>带表头指针和表尾指针：通过list结构的head指针和tail指针，程序获取链表的表头节点和表尾节点的复杂度为O(1)。</li><li>带链表长度计数器：程序使用list结构的len属性来对list持有的链表节点进行计数，程序获取链表中节点数量的复杂度为O(1)。</li><li>多态：链表节点使用void*指针来保存节点值，并且可以通过list结构的dup、free、match 三个属性为节点值设置类型特定函数，所以链表可以用于保存各种不同类型的值。</li></ul><h2 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h2><p>字典是一种用于保存键值对（key-value pair）的抽象数据结构。由于Redis所使用的C语言并没有内置这种数据结构，因此Redis构建了自己的字典实现。</p><p>字典在Redis中的应用相当广泛，比如Redis的数据库就是使用字典来作为底层实现的，对数据库的增、删、查、改操作也是构建在对字典的操作之上的。字典也是哈希键的底层实现之一，当一个哈希键包含的键值对比较多，又或者键值对中的元素都是比较长的字符串时，Redis就会使用字典作为哈希键的底层实现。除了用来实现数据库和哈希键之外，Redis的不少功能也用到了字典。</p><h3 id="字典的实现"><a href="#字典的实现" class="headerlink" title="字典的实现"></a>字典的实现</h3><p>Redis的字典用哈希表作为底层实现，一个哈希表里面可以有多个哈希表节点。而每个哈希表节点就保存了字典中的一个键值对。</p><h4 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h4><p>Redis字典使用的哈希表由dict.h&#x2F;dictht结构定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictht</span> &#123;</span></span><br><span class="line">    <span class="comment">//哈希表数组</span></span><br><span class="line">    dictEntry **table;</span><br><span class="line">    <span class="comment">//哈希表大小</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> size;</span><br><span class="line">    <span class="comment">//哈希表大小掩码，用于计算索引值</span></span><br><span class="line">    <span class="comment">//总是等于size - 1</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> sizemask;</span><br><span class="line">    <span class="comment">//该哈希表已有节点的数量</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> used;</span><br><span class="line">&#125; dictht;</span><br></pre></td></tr></table></figure><p>各属性的解释：</p><ul><li>table属性是一个数组，数组中的每个元素都是一个指向dict.h&#x2F;dictEntry结构的指针，每个dictEntry结构保存着一个键值对。</li><li>size属性记录了哈希表的大小，即table数组的大小。</li><li>used属性记录了哈希表目前已有节点的数量。</li><li>sizemask属性的值总是等于size - 1，这个属性和哈希值一起决定一个键应该被放到table数组的哪个索引上面。</li></ul><p>Redis中的一个空哈希表示例：</p><p><img src="/../img/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/%E5%93%88%E5%B8%8C%E8%A1%A8%E7%A4%BA%E4%BE%8B.png" alt="哈希表示例"></p><h4 id="哈希表节点"><a href="#哈希表节点" class="headerlink" title="哈希表节点"></a>哈希表节点</h4><p>哈希表节点使用dictEntry结构表示，每个dictEntry结构都保存着一个键值对：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> &#123;</span></span><br><span class="line"><span class="comment">//键</span></span><br><span class="line">    <span class="type">void</span> *key;</span><br><span class="line">    <span class="comment">//值</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span>&#123;</span></span><br><span class="line">        <span class="type">void</span> *val;</span><br><span class="line">        <span class="type">uint64_t</span> u64;</span><br><span class="line">        <span class="type">int64_t</span> s64;</span><br><span class="line">    &#125; v; </span><br><span class="line">    <span class="comment">//指向下个哈希表节点，形成链表</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; dictEntry;</span><br></pre></td></tr></table></figure><p>各属性的解释：</p><ul><li>key属性保存着键值对中的键。</li><li>v属性则保存着键值对中的值，其中键值对的值可以是一个指针，或者时一个uint64_t整数，又或者是一个int64_t整数。</li><li>next属性是指向一个哈希表节点的指针，这个指针可以将多个哈希值相同的键值对连接在一起，以此来解决冲突（collision）的问题。</li></ul><h4 id="字典-1"><a href="#字典-1" class="headerlink" title="字典"></a>字典</h4><p>Redis中的字典由dict.h&#x2F;dict结构表示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dict</span> &#123;</span></span><br><span class="line">    <span class="comment">//类型特定函数</span></span><br><span class="line">    dictType *type;</span><br><span class="line">    <span class="comment">//私有数据</span></span><br><span class="line">    <span class="type">void</span> *privdata;</span><br><span class="line">    <span class="comment">//哈希表</span></span><br><span class="line">    dictht ht[<span class="number">2</span>];</span><br><span class="line">    <span class="comment">//rehash索引</span></span><br><span class="line">    <span class="comment">//当rehash不在进行时，值为-1</span></span><br><span class="line">    <span class="type">int</span> rehashidx;</span><br><span class="line">&#125; dict;</span><br></pre></td></tr></table></figure><ul><li>type属性是一个指向dictType结构的指针，每个dictType结构保存了一簇用于操作特定类型键值对的函数，Redis会为用途不同的字典设置不同的类型特定函数。</li><li>privdata属性则保存了需要传给那些类型特定函数的可选参数。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictType</span> &#123;</span></span><br><span class="line">    <span class="comment">//计算哈希值的函数</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="title function_">int</span> <span class="params">(*hashFunction)</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *key)</span>;</span><br><span class="line">    <span class="comment">//复制键的函数</span></span><br><span class="line">    <span class="type">void</span> *(*valDup)(<span class="type">void</span> *privdata, <span class="type">const</span> <span class="type">void</span>* key);</span><br><span class="line">    <span class="comment">//复制值的函数</span></span><br><span class="line"><span class="type">void</span> *(*valDup)(<span class="type">void</span> *privdata, <span class="type">const</span> <span class="type">void</span> *obj);</span><br><span class="line"><span class="comment">//对比键的函数</span></span><br><span class="line"><span class="type">int</span> (*keyCompare)(<span class="type">void</span> *privdata, <span class="type">const</span> <span class="type">void</span> *key1, <span class="type">const</span> <span class="type">void</span> *key2);</span><br><span class="line"><span class="comment">//销毁键的函数</span></span><br><span class="line"><span class="type">void</span> (*keyDestructor)(<span class="type">void</span> *privdata, <span class="type">void</span> *key);</span><br><span class="line"><span class="comment">//销毁值的函数</span></span><br><span class="line"><span class="type">void</span> (*valDestructor)(<span class="type">void</span> *privdata, <span class="type">void</span> *obj);</span><br><span class="line">&#125; dictType;</span><br></pre></td></tr></table></figure><ul><li>ht属性是一个包含两个项的数组，数组中的每个项是一个dictht哈希表，一般情况下，字典只是用ht[0]哈希表，ht[1]哈希表只会在对ht[0]哈希表进行rehash时使用。</li><li>另一个和rehash有关的属性时rehashidx，它记录了rehash目前的进度，如果目前没有在进行rehash，那么它的值为-1。</li></ul><p><img src="/../img/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/%E5%AD%97%E5%85%B8%E7%A4%BA%E4%BE%8B.png" alt="字典示例"></p><h3 id="哈希算法"><a href="#哈希算法" class="headerlink" title="哈希算法"></a>哈希算法</h3><p>当需要将一个新的键值对添加到字典里面时，程序需要先根据键值对的键计算出哈希值和索引值，然后再根据索引值，将包含新键值对的哈希表节点放到哈希表数组的指定索引上面。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用字典设置的哈希函数，计算键key的哈希值</span></span><br><span class="line">hash = dict -&gt; type -&gt; hashFunction(key);</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用哈希表的sizemask属性和哈希值，计算出索引值</span></span><br><span class="line"><span class="comment">//根据情况不同，ht[x]可以是ht[0]或者ht[1]</span></span><br><span class="line">index = hash &amp; dict -&gt; ht[x].sizemask;</span><br></pre></td></tr></table></figure><h3 id="解决键冲突"><a href="#解决键冲突" class="headerlink" title="解决键冲突"></a>解决键冲突</h3><p>Redis的哈希表使用链地址法（separate chaining）来解决键冲突，每个哈希表节点都有一个next指针，多个哈希表节点可以用next指针构成一个单向链表，被分配到同一个索引上的多个节点可以用这个单向链表连接起来，这就解决了键冲突的问题。</p><p>另外，由于dictEntry节点组成的链表没有指向链表表尾的指针，所以为了速度考虑，程序总是将新节点添加到链表的表头位置（复杂度为O(1)），排在其他已有节点的前面。</p><h3 id="rehash"><a href="#rehash" class="headerlink" title="rehash"></a>rehash</h3><p>随着操作的不断执行，哈希表保存的键值对会逐渐地增多或者减少，为了让哈希表的负载因子（load factor）维持在一个合理的范围之内，当哈希表保存的键值对数量太多或者太少时,程序需要对哈希表的大小进行相应的扩展或者收缩。</p><p>扩展和收缩哈希表的工作可以通过执行rehash（重新散列）操作来完成，Redis对字典的哈希表执行rehash的步骤如下：</p><ol><li><p>为字典的ht[1]哈希表分配空间，这个哈希表的空间大小取决于要执行的操作，以及ht[0]当前包含的键值对数量（也即是ht[0].used属性的值）：</p><ul><li><p>如果执行的是扩展操作，那么ht[1]的大小为第一个大于等于ht[0]，used*2的2”（2的n次方幂）；</p></li><li><p>如果执行的是收缩操作，那么ht[1]的大小为第一个大于等于ht[0].used的2”。</p></li></ul></li><li><p>将保存在ht[0]中的所有键值对rehash到ht[1]上面：rehash指的是重新计算键的哈希值和索引值，然后将键值对放置到ht[1]哈希表的指定位置上。</p></li><li><p>当ht[0]包含的所有键值对都迁移到了ht[1]之后（ht[0]变为空表），释放ht[0]，将ht[1]设置为ht [0]，并在ht[1]新创建一个空白哈希表，为下一次rehash做准备。</p></li></ol><h5 id="哈希表的扩展与收缩"><a href="#哈希表的扩展与收缩" class="headerlink" title="哈希表的扩展与收缩"></a>哈希表的扩展与收缩</h5><p>当以下条件中的任意一个被满足时，程序会自动开始对哈希表执行扩展操作：</p><ol><li>服务器目前没有在执行BGSAVE命令或者BGREWRITEAOF命令，并且哈希表的负载因子大于等于1。</li><li>服务器目前正在执行BGSAVE命令或者BGREWRITEAOF命令，并且哈希表的负载因子大于等于5。</li></ol><p>其中哈希表的负载因子可以通过公式计算得出：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">load_factor = ht[<span class="number">0</span>].used / ht[<span class="number">0</span>].size</span><br></pre></td></tr></table></figure><p>根据BGSAVE命令或BGREWRITEAOF命令是否正在执行，服务器执行扩展操作所需的负载因子并不相同，这是因为在执行BGSAVE命令或BGREWRITEAOF命令的过程中，Redis需要创建当前服务器进程的子进程，而大多数操作系统都采用写时复制（copy-on-write）技术来优化子进程的使用效率，所以在子进程存在期间，服务器会提高执行扩展操作所需的负载因子，从而尽可能地避免在子进程存在期间进行哈希表扩展操作，这可以避免不必要的内存写入操作，最大限度地节约内存。</p><p>另一方面，当哈希表的负载因子小于0.1时，程序自动开始对哈希表执行收缩操作。</p><h3 id="渐进式rehash"><a href="#渐进式rehash" class="headerlink" title="渐进式rehash"></a>渐进式rehash</h3><p>上一节提到，扩展或收缩哈希表需要将ht[0]里面的所有键值对rehash到ht[1]里面。但是这个rehash动作并不是一次性、集中式地完成的、而是分多次、渐进式地完成的。这么做的原因是，当ht[0]中的键值对足够多时，一次性移动会对服务器造成性能影响。因此，为了避免rehash对服务器性能造成影响，服务器不是一次性将ht[0]里面的所有键值对全部rehash到ht[1]，而是分多次、渐进式地rehash。</p><p>以下是哈希表渐进式rehash的详细步骤：</p><ol><li>为ht[1]分配空间，让字典同时持有ht[0]和ht[1]两个哈希表。</li><li>在字典中维持一个索引计数器变量rehashidx，并将它的值设置为0，表示rehash工作正式开始。</li><li>在rehash进行期间，每次对字典执行添加、删除、查找或者更新操作时，程序除了执行指定的操作以外，还会顺带将ht[0]哈希表在rehashidx索引上的所有键值对rehash到ht[1]，当rehash工作完成之后，程序将rehashidx属性的值增一。</li><li>随着字典操作的不断执行，最终在某个时间点上，ht[0]的所有键值对都会被rehash至ht[1]，这时程序将rehashidx属性的值设为–1，表示rehash操作已完成。</li></ol><p>渐进式rehash 的好处在于它采取分而治之的方式，将rehash键值对所需的计算工作均摊到对字典的每个添加、删除、查找和更新操作上，从而避免了集中式rehash而带来的庞大计算量。</p><h5 id="渐进式rehash执行期间地哈希表操作"><a href="#渐进式rehash执行期间地哈希表操作" class="headerlink" title="渐进式rehash执行期间地哈希表操作"></a>渐进式rehash执行期间地哈希表操作</h5><p>在进行渐进式rehash的过程中，字典会同时使用ht[0]和ht[1]两个哈希表，所以此时字典的删除、查找、更新等操作会在两个哈希表上进行。例如，查找一个键时，程序会现在ht[0]内查找，没找到再去ht[1]里面查找。</p><p>另外，在渐进式rehash执行期间，新添加到字典内的键值对一律保存到ht[1]内，从而保证了ht[0]内的键值对只减不增。</p><h2 id="跳跃表"><a href="#跳跃表" class="headerlink" title="跳跃表"></a>跳跃表</h2><p>跳跃表（skiplist）是一种有序数据结构，它通过在每个节点中维持多个指向其他节点的指针，从而达到快速访问节点的目的。跳跃表支持平均O(logN)、最坏O(N)复杂度的节点查找，还可以通过顺序性操作来批量处理节点，在大部分情况下，跳跃表的效率可以和平衡表媲美。</p><p>Redis使用跳跃表来作为有序集合键的底层实现之一，除此之外，还在集群节点中使用跳跃表作为内部数据结构。</p><h3 id="跳跃表的实现"><a href="#跳跃表的实现" class="headerlink" title="跳跃表的实现"></a>跳跃表的实现</h3><p>Redis的跳跃表由redis.h&#x2F;zskiplistNode和redis.h&#x2F;zskiplist两个结构定义，其中zskiplistNode结构用于表示跳跃表节点，而zskiplist结构则用于保存跳跃表节点的相关信息。</p><p><img src="/../img/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/%E8%B7%B3%E8%B7%83%E8%A1%A8%E7%A4%BA%E4%BE%8B.png" alt="跳跃表示例"></p><p>上图展示了一个跳跃表示例，图左的zskiplist结构包含以下属性：</p><ul><li>header : 指向跳跃表的表头结点</li><li>tail : 指向跳跃表的表尾节点</li><li>level : 记录目前跳跃表内，层数最大的那个节点的层数（表头节点的层数不计算在内）</li><li>length : 记录跳跃表的长度，即跳跃表目前包含的节点数量（表头结点不计算在内）</li></ul><p>图中位于zskiplist结构右边的是四个zskiplistNode的结构，包含以下属性：</p><ul><li>层（level）：节点中用L1、L2、L3等字样标记节点中的各个层，L1代表第一层，L2代表第二层，以此类推。每个层都有两个属性：前进指针和跨度。前进指针用于访问位于表尾方向的其他节点，而跨度则记录了前进指针所指向节点和当前节点的距离。</li><li>后退（backward）指针：节点中用BW字样标记节点的后退指针，它指向位于当前节点的前一个节点。后退指针在程序从表尾向表头遍历时使用。</li><li>分值（score）：各个节点中的1.0、2.0和3.0是节点所保存的分值。在跳跃表中，节点按各自所保存的分值从小到大排列。</li><li>成员对象（obj）：各个节点中的o1、o2和o3是节点所保存的成员对象。</li></ul><p>表头结点虽然结构和其他节点是一样的，但表头结点不会用到后退指针、分值和成员对象，因此图中忽略了这些部分。</p><h4 id="跳跃表节点"><a href="#跳跃表节点" class="headerlink" title="跳跃表节点"></a>跳跃表节点</h4><p>跳跃表节点的实现由redis.h&#x2F;zskiplistNode结构定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> &#123;</span></span><br><span class="line">    <span class="comment">//层</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistLevel</span> &#123;</span></span><br><span class="line">        <span class="comment">//前进指针</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">forward</span>;</span></span><br><span class="line">        <span class="comment">//跨度</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> span;</span><br><span class="line">    &#125; level[];</span><br><span class="line">    <span class="comment">//后退指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">backward</span>;</span></span><br><span class="line">    <span class="comment">//分值</span></span><br><span class="line">    <span class="type">double</span> score;</span><br><span class="line">    <span class="comment">//成员对象</span></span><br><span class="line">    robj *obj;</span><br><span class="line">&#125; zskiplistNode;</span><br></pre></td></tr></table></figure><h5 id="层"><a href="#层" class="headerlink" title="层"></a>层</h5><p>跳跃表节点的level数组可以包含多个元素，每个元素都包含一个指向其他节点的指针，程序可以通过这些层来加快访问其他节点的速度，一般来说，层的数量越多，访问其他节点的速度越快。</p><p>每次创建一个新跳跃表节点的时候，程序都根据幂次定律（power lar，越大的数出现的概率越小）随机生成一个介于1和32之间的值作为level数组的大小，这个大小就是层的“高度”。</p><h5 id="前进指针"><a href="#前进指针" class="headerlink" title="前进指针"></a>前进指针</h5><p>每个层都有一个指向表尾方向的前进指针（level[i].forward属性），用于从表头向表尾方向访问节点。</p><h5 id="跨度"><a href="#跨度" class="headerlink" title="跨度"></a>跨度</h5><p>层的跨度（level[i].span属性）用于记录两个节点之间的距离：</p><ul><li>两个节点之间的跨度越大，它们相距得就越远。</li><li>指向NULL的所有前进指针的跨度都为0，因为它们没有连向任何节点。</li></ul><p>跨度只是用来计算排位（rank）的，与遍历操作无关（遍历操作只使用前进指针）：在查找某个节点的过程中，将沿途访问过的所有曾的跨度累计起来，得到的结果就是目标节点在跳跃表中的排位。</p><p>举个例子，下图用虚线标记了在跳跃表中查找分值为3.0、成员对象为o3的节点时，沿途经历的层：查找的过程只经过了一个层，并且层的跨度为3，所以目标节点在跳跃表中的排位为3。</p><p><img src="/../img/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/%E8%B7%B3%E8%B7%83%E8%A1%A8%E8%AE%A1%E7%AE%97%E8%8A%82%E7%82%B9%E6%8E%92%E4%BD%8D.png" alt="跳跃表计算节点排位"></p><h5 id="后退指针"><a href="#后退指针" class="headerlink" title="后退指针"></a>后退指针</h5><p>节点的后退指针（backward属性）用于从表尾向表头方向访问节点：跟可以一次跳过多个节点的前进指针不同，因为每个节点只有一个后退指针，所以每次只能后退至前一个节点。</p><h5 id="分值和成员"><a href="#分值和成员" class="headerlink" title="分值和成员"></a>分值和成员</h5><p>节点的分值（score属性）是一个double类型的浮点数，跳跃表中的所有节点都按分值从小到大来排序。</p><p>节点的成员对象（obj属性）是一个指针，它指向一个字符串对象，而字符串对象则保存着一个SDS值。</p><p>在同一个跳跃表中，各个节点保存的成员对象必须是唯一的，但是多个节点保存的分值却可以是相同的：分值相同的节点将按照成员对象在字典序中的大小来排序，成员对象较小的节点会排在前面（靠近表头的方向），而成员对象较大的节点则会排在后面（靠近表尾的方向）。</p><h4 id="跳跃表-1"><a href="#跳跃表-1" class="headerlink" title="跳跃表"></a>跳跃表</h4><p>多个跳跃表节点就可以组成一个跳跃表，但zskiplist结构不但持有这些节点，还持有表头结点和表尾节点以及跳跃表节点的数量等信息来达到快速访问的目的。</p><p>zskiplist结构的定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplist</span> &#123;</span></span><br><span class="line"><span class="comment">//表头结点和表尾节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">header</span>, *<span class="title">tail</span>;</span></span><br><span class="line">    <span class="comment">//表中节点的数量</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> length;</span><br><span class="line">    <span class="comment">//表中层数最大的节点的层数</span></span><br><span class="line">    <span class="type">int</span> level;</span><br><span class="line">&#125; zskiplist;</span><br></pre></td></tr></table></figure><ul><li>header和tail指针分别指向跳跃表的表头和表尾节点，通过这两个指针，程序定位表头节点和表尾节点的复杂度为O(1)。</li><li>通过使用length属性来记录节点的数量，程序可以在O(1)复杂度内返回跳跃表的长度。</li><li>level属性则用于在O(1)复杂度内获取跳跃表中层高最大的那个节点的层数量，注意表头节点的层高并不计算在内。</li></ul><h2 id="整数集合"><a href="#整数集合" class="headerlink" title="整数集合"></a>整数集合</h2><p>整数集合（intset）是集合键的底层实现之一，当一个集合只包含整数值元素，并且整个集合的元素数量不多时，Redis就会使用整数集合作为集合键的底层实现。</p><h3 id="整数集合的实现"><a href="#整数集合的实现" class="headerlink" title="整数集合的实现"></a>整数集合的实现</h3><p>整数集合（intset）是Redis用于保存整数值的集合抽象数据结构，它可以保存类型为int16_t、int32_t或者int64_t的整数值，并且保证集合中不会出现重复元素。</p><p>每个intset.h&#x2F;intset结构表示一个整数集合：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">intset</span> &#123;</span></span><br><span class="line">    <span class="comment">//编码方式</span></span><br><span class="line">    <span class="type">uint32_t</span> encoding;</span><br><span class="line">    <span class="comment">//集合包含的元素数量</span></span><br><span class="line">    <span class="type">uint32_t</span> length;</span><br><span class="line">    <span class="comment">//保存元素的数组</span></span><br><span class="line">    <span class="type">int8_t</span> contents[];</span><br><span class="line">&#125; intset;</span><br></pre></td></tr></table></figure><ul><li>contents数组是整数集合的底层实现：整数集合的每个元素都是contents数组的一个数组项（item），各个项在数组中按值的大小从小到大有序地排列，并且在数组中不包含任何重复项。</li><li>length属性记录了整数集合包含的元素数量，即contents数组的长度。</li><li>contents数组虽然被声明为int8_t类型的数组，但实际上contents数组真正的类型取决于encoding属性的值。</li></ul><p>如果encoding属性的值为INTSET_ENC_INT16，那么contents就是一个int16_t类型的数组，数组里的每个项都是一个int16_t类型的整数值（最小值为-32768，最大值为32767)。</p><p>如果encoding属性的值为INTSET_ENC_INT32，那么contents就是一个int32_t类型的数组，数组里的每个项都是一个int32_t类型的整数值（最小值为-2147483648，最大值为2147483647)。</p><p>如果encoding属性的值为INTSET_ENC_INT64，那么contents就是一个int64_t类型的数组，数组里的每个项都是一个int64_t类型的整数值（最小值为-9223372036854775808，最大值为9223372036854775807）。</p><h3 id="升级"><a href="#升级" class="headerlink" title="升级"></a>升级</h3><p>每当我们要将一个新元素添加到整数集合里面，并且新元素的类型比整数集合现有所有元素的类型都要长时，整数集合需要先升级（upgrade），然后才能将新元素添加到整数集合里面。</p><p>升级整数集合并添加新元素共分为三步进行：</p><ol><li>根据新元素的类型，扩展整数集合底层数组的空间大小，并为新元素分配空间。</li><li>将底层数组现有的所有元素都转换成与新元素相同的类型，并将类型转换后的元素放置到正确的位置上，而且在放置元素的过程中，需要继续维持底层数组的有序性质不变。</li><li>将新元素添加到底层数组里面。</li></ol><p>因为每次向整数集合添加新元素都可能会引起升级，而每次升级都需要对底层数组中已有的所有元素进行类型转换，所以向整数集合添加新元素的时间复杂度为O(N)。</p><h4 id="升级之后新元素的摆放位置"><a href="#升级之后新元素的摆放位置" class="headerlink" title="升级之后新元素的摆放位置"></a>升级之后新元素的摆放位置</h4><p>因为引发升级的新元素的长度总是比整数集合现有所有元素的长度都大，所以这个新元素的值要么就大于所有现有元素，要么就小于所有现有元素：</p><ul><li>在新元素小于所有现有元素的情况下，新元素会被放置在底层数组的最开头（索引0）；</li><li>在新元素大于所有现有元素的情况下，新元素会被放置在底层数组的最末尾（索引length-1）。</li></ul><h3 id="升级的好处"><a href="#升级的好处" class="headerlink" title="升级的好处"></a>升级的好处</h3><h4 id="提升灵活性"><a href="#提升灵活性" class="headerlink" title="提升灵活性"></a>提升灵活性</h4><p>C语言由于自身静态类型语言的特性，无法将不同类型的值放在同一个数据结构里面。但是，整数集合可以通过自动升级底层数组来适应新元素。</p><h4 id="节约内存"><a href="#节约内存" class="headerlink" title="节约内存"></a>节约内存</h4><p>为了使底层数组可以同时保存int16_t、int32_t、int64_t三种类型的值，最简单的做法就是直接使用int64_t类型的数组作为整数集合的底层实现（一步到位）。但升级的做法可以尽量节省内存，又确保在需要的时候能同时保存三种不同类型的值。</p><h3 id="降级"><a href="#降级" class="headerlink" title="降级"></a>降级</h3><p>整数集合不支持降级操作，一旦对数组进行了升级，编码就会一直保持升级后的状态。</p><h2 id="压缩列表"><a href="#压缩列表" class="headerlink" title="压缩列表"></a>压缩列表</h2><p>压缩列表（ziplist）是列表键和哈希键的底层实现之一。当一个列表键只包含少量列表项，并且每个列表项要么就是小整数值，要么就是长度比较短的字符串，那么Redis就会使用压缩列表来做列表键的底层实现。另外，当一个哈希键只包含少量键值对，比且每个键值对的键和值要么就是小整数值，要么就是长度比较短的字符串，那么Redis就会使用压缩列表来做哈希键的底层实现。</p><h3 id="压缩列表的构成"><a href="#压缩列表的构成" class="headerlink" title="压缩列表的构成"></a>压缩列表的构成</h3><p>压缩列表使Redis为了节约内存而开发的，是由一系列特殊编码的连续内存快组成的顺序型数据结构，一个压缩列表可以包含任意多个节点（entry），每个节点可以保存一个字节数组或者一个整数值。</p><p>压缩列表的组成部分如图所示：</p><p><img src="/../img/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8%E7%BB%84%E6%88%90%E9%83%A8%E5%88%86.png" alt="压缩列表组成部分"></p><p>各个部分的组成部分详细说明：</p><table><thead><tr><th align="center">属性</th><th align="center">类型</th><th align="center">长度</th><th align="center">用途</th></tr></thead><tbody><tr><td align="center">zlbytes</td><td align="center">uint32_t</td><td align="center">4字节</td><td align="center">记录整个压缩列表占用的内存字节数：在对压缩列表进行重分配，或者计算zlend的位置时使用</td></tr><tr><td align="center">zltail</td><td align="center">uint32_t</td><td align="center">4字节</td><td align="center">记录压缩列表表尾节点距离压缩列表的起始地址有多少字节：通过整个偏移量，程序无须遍历整个压缩列表就可以确定表尾节点的地址</td></tr><tr><td align="center">zllen</td><td align="center">uint16_t</td><td align="center">2字节</td><td align="center">记录了压缩列表包含的节点数量：当这个属性的值小于UINT16_MAX（65535）时，这个属性的值就是压缩列表包含节点的数量；当这个值等于UINT16_MAX时，节点的真实数量需要遍历整个压缩列表才能计算得出</td></tr><tr><td align="center">entryX</td><td align="center">列表节点</td><td align="center">不定</td><td align="center">压缩列表包含的各个节点，节点的长度由节点保存的内容决定</td></tr><tr><td align="center">zlend</td><td align="center">uint8_t</td><td align="center">1字节</td><td align="center">特殊值0xFF（十进制255），用于标记压缩列表的末端</td></tr></tbody></table><p>一个压缩列表示例：</p><p><img src="/../img/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8%E7%A4%BA%E4%BE%8B.png" alt="压缩列表示例"></p><ul><li>列表zlbytes属性的值为0x50（十进制80），表示压缩列表的总长为80字节。</li><li>列表zltail属性的值为0x3c（十进制60），这表示如果我们有一个指向压缩列表起始地址的指针为p，那么只要用指针p加上偏移量60，就可以计算出表尾节点entry3的地址。</li><li>列表zllen属性的值为0x3（十进制3），表示压缩列表包含三个节点。</li></ul><h3 id="压缩列表节点的构成"><a href="#压缩列表节点的构成" class="headerlink" title="压缩列表节点的构成"></a>压缩列表节点的构成</h3><p>每个压缩列表节点可以保存一个字节数组或者一个整数值。</p><p>其中，字节数组可以是以下三种长度的其中一种：</p><ul><li>长度小于等于63（2^6 - 1）字节的字节数组；</li><li>长度小于等于16383（2^14 - 1）字节的字节数组；</li><li>长度小于等于4294967295（2^32 - 1）字节的字节数组；</li></ul><p>整数值则可以是以下六种长度的其中一种：</p><ul><li>4位长，介于0至12之间的无符号整数；</li><li>1字节长的有符号整数；</li><li>3字节长的有符号整数；</li><li>int16_t类型整数；</li><li>int32_t类型整数；</li><li>int64_t类型整数。</li></ul><p>每个压缩列表节点都由previous_entry_length、encoding、content三个部分组成。</p><h4 id="previous-entry-length"><a href="#previous-entry-length" class="headerlink" title="previous_entry_length"></a>previous_entry_length</h4><p>节点的previous_entry_length属性以字节为单位，记录了压缩列表中前一个节点的长度。previous_entry_length属性的长度可以是1字节或者5字节：</p><ul><li>如果前一节点的长度小于254字节，那么previous_entry_length属性的长度为1字节：前一节点的长度就保存在这一个字节里面。</li><li>如果前一节点的长度大于等于254字节，那么previous_entry_length属性的长度为5字节：其中属性的第一字节会被设置为0xFE（十进制值254），而之后的四个字节则用于保存前一节点的长度。</li></ul><p>因为节点的previous_entry_length属性记录了前一个节点的长度，所以程序可以通过指针运算，根据当前节点的起始地址来计算出前一个节点的起始地址。压缩列表的从表尾到表头遍历操作就是使用这一原理实现的，只要我们拥有了一个指向某个节点起始地址的指针，那么通过这个指针以及这个节点的previous_entry_length属性，程序就可以一直向前一个节点回溯，最终到达压缩列表的表头节点。</p><h4 id="encoding"><a href="#encoding" class="headerlink" title="encoding"></a>encoding</h4><p>节点的encoding属性记录了节点的content属性所保存数据的类型以及长度：</p><ul><li>一字节、两字节或者五字节长，值的最高位00、01或者10的是字节数组编码：这种编码表示节点的content属性保存着字节数组，数组的长度由编码出去最高两位之后的其他位记录；</li><li>一字节长，值的最高位以11开头的是整数编码：这种编码表示节点的content属性保存着整数值，整数值的类型和长度由编码除去最高两位之后的其他位记录。</li></ul><p>下表记录了所有可用的字节数组编码（“_”表示留空，b、x等变量代表实际的二进制数据）：</p><table><thead><tr><th align="left">编码</th><th>编码长度</th><th>content属性保存的值</th></tr></thead><tbody><tr><td align="left">00bbbbbb</td><td>1字节</td><td>长度小于等于63的字节数组</td></tr><tr><td align="left">01bbbbbb xxxxxxxx</td><td>2字节</td><td>长度小于等于16383的字节数组</td></tr><tr><td align="left">10______ aaaaaaaa bbbbbbbb<br> cccccccc dddddddd</td><td>5字节</td><td>长度小于等于4294967295的字节数组</td></tr></tbody></table><p>下表记录了所有可用的整数编码：</p><table><thead><tr><th>编码</th><th>编码长度</th><th>content属性保存的值</th></tr></thead><tbody><tr><td>11000000</td><td>1字节</td><td>int16_t类型的整数</td></tr><tr><td>11010000</td><td>1字节</td><td>int32_t类型的整数</td></tr><tr><td>11100000</td><td>1字节</td><td>int64_t类型的整数</td></tr><tr><td>11110000</td><td>1字节</td><td>24位有符号整数</td></tr><tr><td>11111110</td><td>1字节</td><td>8位有符号整数</td></tr><tr><td>1111xxxx</td><td>1字节</td><td>使用这一编码的节点没有相应的content属性，因为编码本身的xxxx四个位已经保存了一个介于0和12之间的值，所以它无须content属性。</td></tr></tbody></table><h4 id="content"><a href="#content" class="headerlink" title="content"></a>content</h4><p>节点的content属性负责保存节点的值，节点值可以是一个字节数组或者整数，值的类型和长度由节点的encoding属性决定。</p><p>下图是一个字节数组的示例：</p><p><img src="/../img/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/%E4%BF%9D%E5%AD%98%E5%AD%97%E8%8A%82%E6%95%B0%E7%BB%84%E7%9A%84%E8%8A%82%E7%82%B9.png" alt="保存字节数组的节点"></p><ul><li>编码的最高两位00表示节点保存的是一个字节数组；</li><li>编码的后六位001011记录了字节数组的长度11；</li><li>content属性保存着节点的值“hello world”。</li></ul><h3 id="连锁更新"><a href="#连锁更新" class="headerlink" title="连锁更新"></a>连锁更新</h3><p>连锁更新是一种在少数特殊情况下可能发生的坏情况。</p><p>首先回忆一下，每个节点的previous_entry_length属性都记录了前一个节点的长度：</p><ul><li>如果前一节点的长度小于254字节，那么previous_entry_length属性需要用1字节长的空间来保存这个长度值。</li><li>如果前一节点的长度大于等于254字节，那么previous_entry_length属性需要用5字节长的空间来保存这个长度值。</li></ul><p>现在，考虑这种坏情况发生的场景：在一个压缩列表中，有多个连续的、长度介于250字节到253字节之间的节点e1至eN，如下图所示。</p><p><img src="/../img/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/e1%E5%88%B0eN%E7%9A%84%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8.png" alt="e1到eN的压缩列表"></p><p>由于这些节点长度都小于254字节，所以记录这些节点的长度都只需要1字节长的previous_entry_length属性。</p><p>此时，如果我们将一个长度大于等于254字节的新节点new设置为压缩列表的表头结点，new将成为e1的前置节点，如下图所示。</p><p><img src="/../img/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/%E6%B7%BB%E5%8A%A0%E6%96%B0%E8%8A%82%E7%82%B9%E5%88%B0%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8.png" alt="添加新节点到压缩列表"></p><p>此时e1的previous_entry_length属性只有一字节，需要扩展为五字节才足以保存new节点的长度，所以程序将对压缩列表执行空间重分配操作，并将e1节点的previous_entry_length属性扩展为五字节。</p><p>但此时麻烦的事来了，e1节点扩展后，e2中的previous_entry_length属性（一字节）也不足够记录e1的长度（五字节）了，所以同样需要扩展e2。正如e1的扩展引发了e2的扩展，e2的扩展还会引发e3的扩展……以此类推，程序需要不断地进行空间重分配操作，直到eN为止。</p><p>Redis将这种在特殊情况下产生的连续多次空间扩展操作称之为“连锁更新”（cascade update）。</p><p>除了添加新节点会引发连锁更新之外，删除节点也可能会引发连锁更新。</p><p>考虑下图，如果e1至eN都是大小介于250字节至253字节的节点，big节点的长度大于等于254字节（需要5字节的previous_entry_length来保存），而small节点的长度小于254字节（只需要1字节的previous_entry_length来保存），那么当我们将small节点从压缩列表中删除之后，为了让e1的previous_entry_length属性可以记录big节点的长度，程序将扩展e1的空间，并由此引发之后的连锁更新。</p><p><img src="/../img/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/%E5%88%A0%E9%99%A4%E8%8A%82%E7%82%B9%E5%BC%95%E8%B5%B7%E5%9C%B0%E8%BF%9E%E9%94%81%E6%9B%B4%E6%96%B0.png" alt="删除节点引起地连锁更新"></p><h4 id="连锁更新造成的影响"><a href="#连锁更新造成的影响" class="headerlink" title="连锁更新造成的影响"></a>连锁更新造成的影响</h4><p>因为连锁更新在最坏情况下需要对压缩列表执行N次空间重分配操作，而每次空间重分配的最坏复杂度为O(N)，所以连锁更新的最坏复杂度为O(N^2)。</p><p>要注意的是，尽管连锁更新的复杂度较高，但它真正造成性能问题的几率是很低的：</p><ul><li>首先，压缩列表里要恰好有多个连续的、长度介于250字节至253字节之间的节点，连锁更新才有可能被引发，在实际中，这种情况并不多见；</li><li>其次，即使出现连锁更新，但只要被更新的节点数量不多，就不会对性能造成任何影响：比如说，对三五个节点进行连锁更新是绝对不会影响性能的。</li></ul><p>因为以上原因，ziplistPush等命令的平均复杂度仅为O(N)，在实际中，我们可以放心地使用这些函数，而不必担心连锁更新会影响压缩列表的性能。</p><h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><p>前面的数个章节里陆续介绍了Redis用到的所有主要数据结构，比如简单动态字符串（SDS）、双端链表、字典、压缩列表、整数集合等等。</p><p>Redis并没有直接使用这些数据结构来实现键值对数据库，而是基于这些数据结构创建了一个对象系统，这个系统包含<strong>字符串对象、列表对象、哈希对象、集合对象和有序集合</strong>对象这五种类型的对象，每种对象都用到了<strong>至少一种</strong>我们前面所介绍的数据结构。</p><p><strong>使用对象系统的好处：</strong></p><ul><li>通过这五种不同类型的对象，Redis可以在执行命令之前，根据对象的类型来判断一个对象是否可以执行给定的命令。</li><li>使用对象的另一个好处是，我们可以针对不同的使用场景，为对象设置多种不同的数据结构实现，从而优化对象在不同场景下的使用效率。</li><li>除此之外，Redis 的对象系统还实现了基于引用计数技术的内存回收机制，当程序不再使用某个对象的时候，这个对象所占用的内存就会被自动释放；另外，Redis还通过引用计数技术实现了对象共享机制，这一机制可以在适当的条件下，通过让多个数据库键共享同一个对象来节约内存。</li><li>最后，Redis的对象带有访问时间记录信息，该信息可以用于计算数据库键的空转时长，在服务器启用了maxmemory功能的情况下，空转时长较大的那些键可能会优先被服务器删除。</li></ul><h3 id="对象的类型与编码"><a href="#对象的类型与编码" class="headerlink" title="对象的类型与编码"></a>对象的类型与编码</h3><p>Redis使用对象来表示数据库中的键和值，每次当我们在Redis的数据库中新创建一个键值对时，我们至少会创建两个对象，一个对象用作键值对的键（键对象），另一个对象用作键值对的值（值对象）。</p><p>Redis中的每个对象都由一个redisObject结构表示，该结构中和保存数据有关的三个属性分别是type属性、encoding属性和ptr属性：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisObject</span> &#123;</span></span><br><span class="line">    <span class="comment">//类型</span></span><br><span class="line">    <span class="type">unsigned</span> type:<span class="number">4</span>;</span><br><span class="line">    <span class="comment">//编码</span></span><br><span class="line">    <span class="type">unsigned</span> encoding:<span class="number">4</span>;</span><br><span class="line">    <span class="comment">//指向底层实现数据结构的指针</span></span><br><span class="line">    <span class="type">void</span> *ptr;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125; robj;</span><br></pre></td></tr></table></figure><h4 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h4><p>对象的type属性记录了对象的类型，这个属性的值可以是下表所列出的常量中的一个。</p><table><thead><tr><th>类型常量</th><th>对象的名称</th></tr></thead><tbody><tr><td>REDIS_STRING</td><td>字符串对象</td></tr><tr><td>REDIS_LIST</td><td>列表对象</td></tr><tr><td>REDIS_HASH</td><td>哈希对象</td></tr><tr><td>REDIS_SET</td><td>集合对象</td></tr><tr><td>REDIS_ZSET</td><td>有序集合对象</td></tr></tbody></table><p>对于Redis数据库保存的键值对来说，键总是一个字符串对象，而值则可以是字符串对象、列表对象、哈希对象、集合对象或者有序集合对象的其中一种，因此：</p><ul><li>当我们称呼一个数据库键为“字符串键”时，我们指的是“这个数据库键所对应的值为字符串对象”；</li><li>当我们称呼一个键为“列表键”时，我们指的是“这个数据库键所对应的值为列表对象”。</li></ul><h4 id="编码和底层实现"><a href="#编码和底层实现" class="headerlink" title="编码和底层实现"></a>编码和底层实现</h4><p>对象的ptr指针指向对象的底层实现数据结构，而这些数据结构由对象的encoding属性决定。</p><p>encoding属性记录了对象所使用的编码，也即是说这个对象使用了什么数据结构作为对象的底层实现，这个属性的值可以是下表列出的常量的其中一个。</p><table><thead><tr><th>编码常量</th><th>编码所对应的底层数据结构</th></tr></thead><tbody><tr><td>REDIS_ENCODING_INT</td><td>long类型的整数</td></tr><tr><td>REDIS_ENCODING_EMBSTR</td><td>embstr编码的简单动态字符串</td></tr><tr><td>REDIS_ENCODING_RAW</td><td>简单动态字符串</td></tr><tr><td>REDIS_ENCODING_HT</td><td>字典</td></tr><tr><td>REDIS_ENCODING_LINKEDLIST</td><td>双端链表</td></tr><tr><td>REDIS_ENCODING_ZIPLIST</td><td>压缩列表</td></tr><tr><td>REDIS_ENCODING_ INTSET</td><td>整数集合</td></tr><tr><td>REDIS_ENCODING_SKIPLIST</td><td>跳跃表和字典</td></tr></tbody></table><p>每种类型的向都至少使用了两种不同的编码（底层数据结构），下表列出了每种类型的对象可以使用的编码。</p><table><thead><tr><th>类型</th><th>编码</th><th>对象</th></tr></thead><tbody><tr><td>REDIS_STRING</td><td>REDIS_ENCODING_INT</td><td>使用整数值实现的字符串对象</td></tr><tr><td>REDIS_STRING</td><td>REDIS_ENCODING_EMBSTR</td><td>使用embstr编码的简单动态字符串实现的字符串对象</td></tr><tr><td>REDIS_STRING</td><td>REDIS_ENCODING_RAW</td><td>使用简单动态字符串实现的字符串对象</td></tr><tr><td>REDIS_LIST</td><td>REDIS_ENCODING_ZIPLIST</td><td>使用压缩列表实现的列表对象</td></tr><tr><td>REDIS_LIST</td><td>REDIS_ENCODING_LINKEDLIST</td><td>使用双端链表实现的列表对象</td></tr><tr><td>REDIS_HASH</td><td>REDIS_ENCODING_ZIPLIST</td><td>使用压缩列表实现的哈希对象</td></tr><tr><td>REDIS_HASH</td><td>REDIS_ENCODING_HT</td><td>使用字典实现的哈希对象</td></tr><tr><td>REDIS_SET</td><td>REDIS_ENCODING_ INTSET</td><td>使用整数集合实现的集合对象</td></tr><tr><td>REDIS_SET</td><td>REDIS_ENCODING_HT</td><td>使用字典实现的集合对象</td></tr><tr><td>REDIS_ZSET</td><td>REDIS_ENCODING_ZIPLIST</td><td>使用压缩列表实现的有序集合对象</td></tr><tr><td>REDIS_ZSET</td><td>REDIS_ENCODING_SKIPLIST</td><td>使用跳跃表和字典实现的有序集合对象</td></tr></tbody></table><p>通过encoding属性来设定对象所使用的编码，而不是为特定类型的对象关联一种固定的编码，极大地提升了Redis的灵活性和效率，因为Redis可以根据不同的使用场景来为一个对象设置不同的编码，从而优化对象在某一场景下的效率。</p><h3 id="字符串对象"><a href="#字符串对象" class="headerlink" title="字符串对象"></a>字符串对象</h3><p>字符串对象的编码可以是int、raw或者embstr。</p><p>如果一个字符串对象保存的是整数值，并且这个整数值可以用long类型来表示，那么字符串对象会将整数值保存在字符串对象结构的ptr属性里面（将void*转换成long），并将字符串对象的编码设置为int。</p><p>如果字符串对象保存的是一个字符串值，并且这个字符串值的长度大于32字节，那么字符串对象将使用一个简单动态字符串（SDS）来保存这个字符串值，并将对象的编码设置为raw。</p><p>如果字符串对象保存的是一个字符串值，并且这个字符串值的长度小于等于32字节，那么字符串对象将使用embstr编码的方式来保存这个字符串值。</p><p>embstr编码和raw编码的区别：</p><p>这两种编码都使用redisObject结构和sdshdr结构来表示字符串对象，但raw编码会调用两次内存分配函数来分别创建redisObject结构和sdshdr结构，而embstr编码则通过调用一次内存分配函数来分配一块连续的空间，空间中依次包含redisObject和sdshdr两个结构。</p><p>当执行命令时，这两种编码的字符串的效果是相同的，但使用embstr编码的字符串对象来保存短字符串值有以下好处：</p><ul><li>embstr编码将创建字符串对象所需的内存分配次数从raw编码的两次降低为一次。</li><li>释放embstr编码的字符串对象只需要调用一次内存释放函数，而释放raw编码的字符串对象需要调用两次内存释放函数。</li><li>因为embstr编码的字符串对象的所有数据都保存在一块连续的内存里面，所以这种编码的字符串对象比起raw编码的字符串对象能够更好地利用缓存带来的优势。</li></ul><p>字符串对象还用来保存浮点数：</p><p>可以用long double类型表示的浮点数在Redis中也是作为字符串值来保存的。如果我们要保存一个浮点数到字符串对象里面，那么程序会先将这个浮点数转换成字符串值，然后再保存转换所得的字符串值。</p><p>在有需要的时候，程序会将保存在字符串对象里面的字符串值转换回浮点数值，执行某些操作，然后再将执行操作所得的浮点数值转换回字符串值，并继续保存在字符串对象里面。</p><p>下表列出了字符串对象保存各种不同类型的值所使用的编码方式。</p><table><thead><tr><th>值</th><th>编码</th></tr></thead><tbody><tr><td>可以用long类型保存的整数</td><td>int</td></tr><tr><td>可以用long double类型保存的浮点数</td><td>embstr或者raw</td></tr><tr><td>字符串值，或者因为长度太大而没办法用long类型表示的整数，又或者因为长度太大而没办法用long double类型表示的浮点数</td><td>embstr或者raw</td></tr></tbody></table><h4 id="编码的转换"><a href="#编码的转换" class="headerlink" title="编码的转换"></a>编码的转换</h4><p>int编码的字符串对象和embstr编码的字符串对象在条件满足的情况下，会被转换为raw编码的字符串对象。</p><ul><li>当i我们向nt编码的字符串对象执行了一些命令，使得这个对象保存的不再是整数值，而是一个字符串值，那么字符串对象的编码将从int变为raw。</li><li>另外，由于Redis没有为embstr编码的字符串对象编写任何相应的修改程序（即embstr编码的字符串对象实际上是只读的）。当我们对embstr编码的字符串对象执行任何修改命令时，程序会先将对象的编码从embstr转换成raw，然后再执行修改命令。</li></ul><h3 id="列表对象"><a href="#列表对象" class="headerlink" title="列表对象"></a>列表对象</h3><p>列表编码的对象可以是ziplist或者linkedlist。</p><p>ziplist编码的列表对象使用压缩列表作为底层实现，每个压缩列表节点（entry）保存了一个列表元素。</p><p>linkedlist编码的列表对象使用双端链表作为底层实现，每个双端链表节点（node）都保存了一个字符串对象，而每个字符串对象都保存了一个列表元素。</p><p><strong>注意</strong>，linkedlist编码的列表对象在底层的双端链表结构中包含了多个字符串对象，这种嵌套字符串对象的行为在稍后介绍的哈希对象、集合对象和有序集合对象中都会出现，字符串对象是Redis五种类型的对象中唯一一种会被其他四种类型对象嵌套的对象。</p><h4 id="编码转换"><a href="#编码转换" class="headerlink" title="编码转换"></a>编码转换</h4><p>当列表对象可以同时满足以下两个条件时，列表对象使用ziplist编码：</p><ul><li>列表对象保存的所有字符串元素的长度都小于64字节；</li><li>列表对象保存的元素数量小于512个。</li></ul><p>不能满足这两个条件的列表对象需要使用linkedlist编码。转换发生在使用ziplist编码所需的两个条件的任意一个不能被满足时，对象的编码转换操作就会被执行，原本保存在压缩列表里的所有列表元素都会被转移并保存到双端列表里面，对象的编码也会从ziplist变为linkedlist。</p><h3 id="哈希对象"><a href="#哈希对象" class="headerlink" title="哈希对象"></a>哈希对象</h3><p>哈希对象的编码可以是ziplist或者hashtable。</p><p>ziplist编码的哈希对象使用压缩列表作为底层实现，每当有新的键值对要加入到哈希对象时，程序会先将保存了键的压缩列表节点推入到压缩列表表尾，然后再将保存了值的压缩列表节点推入到压缩列表表尾，因此：</p><ul><li>保存了同一键值对的两个节点总是紧挨在一起，保存键的节点在前，保存值的节点在后；</li><li>先添加到哈希对象中的键值对会被放在压缩列表的表头方向，而后来添加到哈希对象中的键值对会被放在压缩列表的表尾方向。</li></ul><p>另一方面，hashtable编码的哈希对象使用字典作为底层实现，哈希对象中的每个键值对都使用一个字典键值对来保存：</p><ul><li>字典的每个键都是一个字符串对象，对象中保存了键值对的键；</li><li>字典的每个值都是一个字符串对象，对象中保存了键值对的值。</li></ul><h4 id="编码转换-1"><a href="#编码转换-1" class="headerlink" title="编码转换"></a>编码转换</h4><p>当哈希对象可以同时满足以下两个条件时，哈希对象使用ziplist编码：</p><ul><li>哈希对象保存的所有键值对的键和值的字符串长度都小于64字节；</li><li>哈希对象保存的键值对数量小于512个。</li></ul><p>不能满足这两个条件的哈希对象需要使用hashtable编码。转换发生在使用ziplist编码所需的两个条件的任意一个不能被满足时，对象的编码转换操作就会被执行，原本保存在压缩列表里的所有列表元素都会被转移并保存到字典里面，对象的编码也会从ziplist变为hashtable。</p><h3 id="集合对象"><a href="#集合对象" class="headerlink" title="集合对象"></a>集合对象</h3><p>集合对象的编码可以是intset或者hashtable。</p><p>intset编码的集合对象使用整数集合作为底层实现，集合对象包含的所有元素都被保存在整数集合里面。</p><p>另一方面，hashtable编码的集合对象使用字典作为底层实现，字典的每个键都是一个字符串对象，每个字符串对象包含了一个集合元素，而字典的值则全部被设置为NULL。</p><h4 id="编码的转换-1"><a href="#编码的转换-1" class="headerlink" title="编码的转换"></a>编码的转换</h4><p>当集合对象可以同时满足以下两个条件时，对象使用intset编码：</p><ul><li>集合对象保存的所有元素都是整数值；</li><li>集合对象保存的元素数量不超过512个。</li></ul><p>不能满足这两个条件的集合对象需要使用hashtable编码。转换发生在使用intset编码所需的两个条件的任意一个不能被满足时，对象的编码转换操作就会被执行，原本保存在整数集合里的所有元素都会被转移并保存到字典里面，对象的编码也会从intset变为hashtable。</p><h3 id="有序集合对象"><a href="#有序集合对象" class="headerlink" title="有序集合对象"></a>有序集合对象</h3><p>有序集合的编码可以是ziplist或者skiplist。</p><p>ziplist编码的压缩列表对象使用压缩列表作为底层实现，每个集合元素使用两个紧挨在一起的压缩列表节点来保存，第一个节点保存元素的成员（member），而第二个元素则保存元素的分值（score）。压缩列表内的集合元素按分值从小到大进行排序，分值较小的元素被放置在靠近表头的方向，而分值较大的元素则被放置在靠近表尾的方向。</p><p>skiplist编码的有序集合对象使用zset结构作为底层实现，一个zset结构同时包含一个字典和一个跳跃表：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zset</span> &#123;</span></span><br><span class="line">    zskiplist *zsl;</span><br><span class="line">    dict *dict;</span><br><span class="line">&#125; zset;</span><br></pre></td></tr></table></figure><p>zset结构中的zsl跳跃表按分值从小到大保存了所有集合元素，每个跳跃表节点都保存了一个集合元素：跳跃表节点的object属性保存了元素的成员，而跳跃表节点的score属性则保存了元素的分值。通过这个跳跃表，程序可以对有序集合进行范围型操作。</p><p>zset结构中的dict字典为有序集合创建了一个从成员到分值的映射，字典中的每个键值对都保存了一个集合元素：字典的键保存了元素的成员，而字典的值则保存了元素的分值。通过这个字典，程序可以用O(1)的复杂度查找给定成员的分值。</p><p>有序集合的每个元素的成员都是一个字符串对象，而每个元素的分值都是一个double类型的浮点数。</p><p>虽然这种结构同时使用了跳跃表和字典来保存有序集合元素，但得益于这两种数据结构会通过指针来共享对象，所以不会因此产生额外成员而浪费额外的内存。</p><h4 id="编码的转换-2"><a href="#编码的转换-2" class="headerlink" title="编码的转换"></a>编码的转换</h4><p>当有序集合对象可以同时满足以下两个条件时，对象使用ziplist编码：</p><ul><li>有序集合保存的元素数量小于128个；</li><li>有序集合保存的所有元素成员的长度都小于64字节。</li></ul><p>不能满足以上两个条件的有序集合对象使用skiplist编码。对于使用ziplist编码的有序集合对象来说，当使用ziplist编码所需的两个条件中的任意一个不能被满足时，就会执行对象的编码转换操作，原本保存在压缩列表里的所有集合元素都会被转移并保存到zset结构里面，对象的编码也会从ziplist变为skiplist。</p><h3 id="类型检查与命令多态"><a href="#类型检查与命令多态" class="headerlink" title="类型检查与命令多态"></a>类型检查与命令多态</h3><p>Redis中用于操作键的命令基本上可以分为两种类型。</p><p>其中一种命令可以对任何类型的键执行，比如说DEL命令、EXPIRE命令、RENAME命令、TYPE命令、OBJECT命令等。</p><p>而另一种命令只能对特定类型的键执行，比如说：</p><ul><li>SET、GET、APPEND、STRLEN等命令只能对字符串键执行；</li><li>HDEL、HSET、HGET、HLEN等命令只能对哈希键执行；</li><li>RPUSH、LPOP、LINSERT、LLEN等命令只能对列表键执行；</li><li>SADD、SPOP、SINTER、SCARD等命令只能对集合键执行；</li><li>ZADD、ZCARD、ZRANK、ZSCORE等命令只能对有序集合键执行。</li></ul><h4 id="类型检查的实现"><a href="#类型检查的实现" class="headerlink" title="类型检查的实现"></a>类型检查的实现</h4><p>为了确保只有指定类型的键可以执行某些特定的命令，在执行一个类型特定的命令之前，Redis会先检查输入键的类型是否正确，然后再决定是否执行给定的命令。</p><p>类型特定命令所进行的类型检查是通过redisObject结构的type属性来实现的：</p><ul><li>在执行一个类型特定命令之前，服务器会先检查输入数据库键的值对象是否为执行命令所需的类型，如果是的话，服务器就对键执行指定的命令；</li><li>否则，服务器将拒绝执行命令，并向客户端返回一个类型错误。</li></ul><h4 id="多态命令的实现"><a href="#多态命令的实现" class="headerlink" title="多态命令的实现"></a>多态命令的实现</h4><p>Redis除了会根据值对象的类型来判断是否能够执行指定命令之外，还会根据值对象的编码方式，选择正确的命令实现代码来执行命令。因此，我们可以认为这些命令是多态的。</p><h3 id="内存回收"><a href="#内存回收" class="headerlink" title="内存回收"></a>内存回收</h3><p>因为C语言并不具备自动内存回收功能，所以Redis在自己的对象系统中构建了一个引用计数（reference counting）技术实现的内存回收机制，通过这一机制，程序可以通过跟踪对象的引用计数信息，在适当的时候自动释放对象并进行内存回收。</p><p>每个对象的引用计数信息由redisObject结构的refcount属性记录：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisObject</span> &#123;</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">//引用计数</span></span><br><span class="line">    <span class="type">int</span> refcount;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125; robj;</span><br></pre></td></tr></table></figure><p>对象的引用计数信息会随着对象的使用状态而不断变化：</p><ul><li>在创建一个新对象时，引用计数的值会被初始化为1；</li><li>当对象被一个新程序使用时，它的引用计数会被增一；</li><li>当对象不再被一个程序使用时，它的引用计数值会被减一；</li><li>当对象的引用计数值变为0时，对象所占用的内存会被释放。</li></ul><h3 id="对象共享"><a href="#对象共享" class="headerlink" title="对象共享"></a>对象共享</h3><p>除了用于实现引用计数内存回收机制之外，对象的引用计数属性还带有对象共享的作用。共享内存显然比创建一个新的对象更节约内存，且共享的越多，就能节约越多的内存。</p><p>在Redis中，让多个键共享同一个值对象需要执行以下两个步骤：</p><ol><li>将数据库键的值指针指向一个现有的值对象；</li><li>将被共享的值对象的引用计数增一。</li></ol><h4 id="为什么Redis只共享包含整数值的字符串对象？"><a href="#为什么Redis只共享包含整数值的字符串对象？" class="headerlink" title="为什么Redis只共享包含整数值的字符串对象？"></a>为什么Redis只共享包含整数值的字符串对象？</h4><p>当服务器考虑将一个共享对象设置为键的值对象时，程序需要先检查给定的共享对象和键想创建的目标对象是否完全相同，只有在共享对象和目标对象完全相同的情况下，程序才会将共享对象用作键的值对象，而一个共享对象保存的值越复杂，验证共享对象和目标对象是否相同所需的复杂度就会越高，消耗的CPU时间也会越多：</p><ul><li>如果共享对象是保存整数值的字符串对象，那么验证操作的复杂度为O(1)；</li><li>如果共享对象是保存字符串值的字符串对象，那么验证操作的复杂度为O(N)；</li><li>如果共享对象是包含了多个值（或者对象的）对象，比如列表对象或者哈希对象，那么验证操作的复杂度将会是O(N^2)。</li></ul><p>因此，尽管共享过呢更复杂的对象可以节约更多的内存，但受到CPU时间的限制，Redis只对包含整数值的字符串对象进行共享。</p><h3 id="对象的空转时长"><a href="#对象的空转时长" class="headerlink" title="对象的空转时长"></a>对象的空转时长</h3><p>除了前面介绍过的type、encoding、ptr和refcount四个属性之外，redisObject结构包含的最后一个属性为lru属性，该属性记录了对象最后一次被命令程序访问的时间：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisObject</span> &#123;</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="type">unsigned</span> lru:<span class="number">22</span>;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125; robj;</span><br></pre></td></tr></table></figure><p>OBJECT IDLETIME命令可以打印出给定键的空转时长，这一空转时长就是通过将当前时间减去键的值对象的lru时间计算得出的：除了可以被OBJECT IDLETIME命令打印出来之外，键的空转时长还有另外一项作用：如果服务器打开了maxmemory选项，并且服务器用于回收内存的算法为volatile-lru或者allkeys-lru，那么当服务器占用的内存数超过了maxmemory选项所设置的上限值时，空转时长较高的那部分键会优先被服务器释放，从而回收内存。</p>]]></content>
    
    
    <summary type="html">&lt;Redis设计与实现&gt;第一部分，Redis中的数据结构与对象</summary>
    
    
    
    <category term="Redis设计与实现读书笔记" scheme="http://example.com/categories/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Redis" scheme="http://example.com/tags/Redis/"/>
    
    <category term="Redis设计与实现" scheme="http://example.com/tags/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/"/>
    
    <category term="数据结构与对象" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E5%AF%B9%E8%B1%A1/"/>
    
    <category term="SDS" scheme="http://example.com/tags/SDS/"/>
    
    <category term="链表" scheme="http://example.com/tags/%E9%93%BE%E8%A1%A8/"/>
    
    <category term="字典" scheme="http://example.com/tags/%E5%AD%97%E5%85%B8/"/>
    
    <category term="跳跃表" scheme="http://example.com/tags/%E8%B7%B3%E8%B7%83%E8%A1%A8/"/>
    
    <category term="整数集合" scheme="http://example.com/tags/%E6%95%B4%E6%95%B0%E9%9B%86%E5%90%88/"/>
    
    <category term="压缩列表" scheme="http://example.com/tags/%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>&lt;STL源码剖析&gt;第七章</title>
    <link href="http://example.com/2022/05/09/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E7%AC%AC%E4%B8%83%E7%AB%A0/"/>
    <id>http://example.com/2022/05/09/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E7%AC%AC%E4%B8%83%E7%AB%A0/</id>
    <published>2022-05-08T16:00:00.000Z</published>
    <updated>2022-05-08T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="仿函数"><a href="#仿函数" class="headerlink" title="仿函数"></a>仿函数</h2><p>这一章所探索的东西，在STL历史上有两个不同的名称。仿函数（functors）是早期的命名，C++标准规格定案后所采用的新名称是函数对象( function objects )。</p><p>就实现意义而言，“函数对象”比较贴切：一种具有函数特质的对象。不过，就其行为而言，以及就中文用词的清晰漂亮与独特性而言，“仿函数”一词比较突出。因此，本书绝大部分时候采用“仿函数”一词。这种东西在调用者可以像函数一样地被调用（调用），在被调用者则以对象所定义的function call operator扮演函数的实质角色。</p><p>就实现观点而言，仿函数其实上就是一个“行为类似函数”的对象。为了能够“行为类似函数”，其类别定义中必须自定义（或说改写、重载）function call运算子（operator()）。拥有这样的运算子后，我们就可以在仿函数的对象后面加上一对小括号，以此调用仿函数所定义的operator() ，像这样：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">greater&lt;<span class="type">int</span>&gt; ig;</span><br><span class="line">cout &lt;&lt; boolalpha &lt;&lt; <span class="built_in">ig</span>(<span class="number">4</span>, <span class="number">6</span>); <span class="comment">// (A) false</span></span><br><span class="line">cout &lt;&lt; <span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;()(<span class="number">6</span>, <span class="number">4</span>);  <span class="comment">// (B) true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>STL仿函数和STL算法之间的关系：</p><p><img src="/../img/STL%E4%BB%BF%E5%87%BD%E6%95%B0%E5%92%8CSTL%E7%AE%97%E6%B3%95%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB.png" alt="STL仿函数和STL算法之间的关系"></p><p>STL仿函数的分类，若以操作数（operand）的个数划分，可分为一元和二元仿函数，若以功能划分，可分为算术运算(Arithmetic)、关系运算(Rational) 、逻辑运算（Logical）三大类。任何应用程序欲使用STL内建的仿函数，都必须含人&lt;functional&gt;头文件，SGI则将它们实际定义于&lt;stl_function.h&gt;文件中。以下分别描述。</p><h3 id="可配接（Adaptable）的关键"><a href="#可配接（Adaptable）的关键" class="headerlink" title="可配接（Adaptable）的关键"></a>可配接（Adaptable）的关键</h3><p>仿函数可以让STL算法有更灵活的作用。而更灵活的关键，在于STL仿函数的可配接性（adaptability）。</p><p>为了拥有配接能力，每一个仿函数必须定义自己应型别（associative types），就像迭代器如果要融入整个STL大家庭，也必须依照规定定义自己的5个相应型别一样。这些相应型别是为了让配接器能够取出，获得仿函数的某些信息。相应型别都只是一些typedef，所有必要操作在编译期就全部完成了，对程序的执行效率没有任何影响，不带来任何额外负担。</p><p>仿函数的相应型别主要用来表现函数参数型别和传回值型别。为了方便起见，&lt;stl_function.h&gt;定义了两个classes，分别代表一元仿函数和二元仿函数(STL不支持三元仿函数），其中没有任何 data members 或 member functions，唯有一些型别定义。任何仿函数，只要依个人需求选择继承其中一个class，便自动拥有了那些相应型别，也就自动拥有了配接能力。</p><h4 id="unary-function"><a href="#unary-function" class="headerlink" title="unary_function"></a>unary_function</h4><p>unary_function用来呈现一元函数的参数型别和返回值型别。其定义：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// STL规定，每一个Adaptable Unary Function 都应该继承此类别</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Arg</span>, <span class="keyword">class</span> <span class="title class_">Result</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">unary_function</span> &#123;</span><br><span class="line"><span class="keyword">typedef</span> Arg argument_type;</span><br><span class="line"><span class="keyword">typedef</span> Result result_type;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>一旦某个仿函数继承了unary_function，其用户便可以这样取得该仿函数的参数型别，并以相同手法取得其返回值型别：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//以下仿函数继承了unary_function.</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">negate</span> : <span class="keyword">public</span> unary_function&lt;T, T&gt; &#123;</span><br><span class="line"><span class="function">T <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> T&amp; x)</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> -x; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//以下配接器(adapter)用来表示某个仿函数的逻辑负值(logical negation)</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Predicate</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">unary_negate</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> <span class="keyword">typename</span> Predicate::argument_type&amp; x)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="binary-function"><a href="#binary-function" class="headerlink" title="binary_function"></a>binary_function</h4><p>binary_function用来呈现二元函数的第一参数型别、第二参数性别，以及返回值性别。其定义：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// STL规定，每一个Adaptable Binary Function都应该继承此类别</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Arg1</span>, <span class="keyword">class</span> <span class="title class_">Arg2</span>, <span class="keyword">class</span> <span class="title class_">Result</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">binary_function</span> &#123;</span><br><span class="line"><span class="keyword">typedef</span> Arg1 first_argument_type;</span><br><span class="line"><span class="keyword">typedef</span> Arg2 second_argument_type;</span><br><span class="line"><span class="keyword">typedef</span> Result result_type;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>一旦某个仿函数继承了binary_function，其用户便可以这样取得该仿函数的各种相应型别：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//以下仿函数继承了binary_function.</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">plus</span> : <span class="keyword">public</span> binary_function&lt;T, T, T&gt; &#123;</span><br><span class="line"><span class="function">T <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> T&amp; x, <span class="type">const</span> T&amp; y)</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> x + y; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//以下配接器(adapter)用来将某个二元仿函数转化为一元仿函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Operation</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">binder1st</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">Operation op;</span><br><span class="line"><span class="keyword">typename</span> Operation::first_argument_type value;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">typename</span> Operation::result_type</span></span><br><span class="line"><span class="function"><span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> <span class="keyword">typename</span> Operation::second_argument_type&amp; x)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="算术类（Arithmetic）仿函数"><a href="#算术类（Arithmetic）仿函数" class="headerlink" title="算术类（Arithmetic）仿函数"></a>算术类（Arithmetic）仿函数</h3><p>STL内建的“算术类仿函数”，支持加法、减法、乘法、除法、模数（余数，modulus）和否定（negation）运算。除了“否定”运算为一元运算，其它都是二元运算。</p><ul><li>加法: plus&lt;T&gt;</li><li>减法: minus&lt;T&gt;</li><li>乘法: multiplies&lt;T&gt;</li><li>除法: divides&lt;T&gt;</li><li>模取(modulus) : modulus&lt;T&gt;</li><li>否定(negation) : negate&lt;T&gt;</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//以下6个为算术类(Arithmetic)仿函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">plus</span> : <span class="keyword">public</span> binary_function&lt;T, T, T&gt; &#123;</span><br><span class="line"><span class="function">T <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> T&amp; x, <span class="type">const</span> T&amp; y)</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> x + y; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">minus</span> : <span class="keyword">public</span> binary_function&lt;T, T, T&gt; &#123;</span><br><span class="line"><span class="function">T <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> T&amp; x, <span class="type">const</span> T&amp; y)</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> x - y; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">multiplies</span> : <span class="keyword">public</span> binary_function&lt;T, T, T&gt; &#123;</span><br><span class="line"><span class="function">T <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> T&amp; x, <span class="type">const</span> T&amp; y)</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> x * y; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">divides</span> : <span class="keyword">public</span> binary_function&lt;T, T, T&gt; &#123;</span><br><span class="line"><span class="function">T <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> T&amp; x, <span class="type">const</span> T&amp; y)</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> x / y; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">modulus</span> : <span class="keyword">public</span> binary_function&lt;T, T, T&gt; &#123;</span><br><span class="line"><span class="function">T <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> T&amp; x, <span class="type">const</span> T&amp; y)</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> x % y; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">negate</span> : <span class="keyword">public</span> unary_function&lt;T, T&gt; &#123;</span><br><span class="line"><span class="function">T <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> T&amp; x)</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> -x; &#125; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="证同元素（identity-element）"><a href="#证同元素（identity-element）" class="headerlink" title="证同元素（identity element）"></a>证同元素（identity element）</h4><p>所谓“运算 op 的证同元素（identity element）”，意思是数值A若与该元素做op运算，会得到A自己。加法的证同元素为0，因为任何元素加上0仍为自己。乘法的证同元素为1，因为任何元素乘以1仍为自己。</p><p>请注意，这些函数并非STL标准规格中的一员，但许多STL实现都有它们。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span></span></span><br><span class="line"><span class="function">T <span class="title">identity_element</span><span class="params">(plus&lt;T&gt;)</span> </span></span><br><span class="line"><span class="function"></span>&#123; <span class="keyword">return</span> <span class="built_in">T</span>(<span class="number">0</span>); &#125;</span><br><span class="line"><span class="comment">// SGI STL并未实际运用这个函数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span></span></span><br><span class="line"><span class="function">T <span class="title">identity_element</span><span class="params">(multiplies&lt;T&gt;)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="keyword">return</span> <span class="built_in">T</span>(<span class="number">1</span>); &#125;</span><br><span class="line"><span class="comment">//乘法的证同元素应用于&lt;stl_numerics.h&gt;的power()</span></span><br></pre></td></tr></table></figure><h3 id="关系运算类（Relational）仿函数"><a href="#关系运算类（Relational）仿函数" class="headerlink" title="关系运算类（Relational）仿函数"></a>关系运算类（Relational）仿函数</h3><p>STL内建的“关系运算类仿函数”支持了等于、不等于、大于、大于等于、小于、小于等于六种运算。每一个都是二元运算。</p><ul><li>等于(equality) : equal_to&lt;T&gt;</li><li>不等于(inequality) : not_equal_to&lt;T&gt;</li><li>大于(greater than) : greater&lt;T&gt;</li><li>大于或等于(greater than or equal) : greater_equal&lt;T&gt;</li><li>小于(less than) : less&lt;T&gt;</li><li>小于或等于(less than or equal) : less_equal&lt;T&gt;</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//以下6个为关系运算类（Relational）仿函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">equal_to</span> : <span class="keyword">public</span> binary_function&lt;T, T, <span class="type">bool</span>&gt; &#123;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> T&amp; x, <span class="type">const</span> T&amp; y)</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> x == y; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">not_equal_to</span> : <span class="keyword">public</span> binary_function&lt;T, T, <span class="type">bool</span>&gt; &#123;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> T&amp; x, <span class="type">const</span> T&amp; y)</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> x != y; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">greater</span> : <span class="keyword">public</span> binary_function&lt;T, T, <span class="type">bool</span>&gt; &#123;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> T&amp; x, <span class="type">const</span> T&amp; y)</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> x &gt; y; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">less</span> : <span class="keyword">public</span> binary_function&lt;T, T, <span class="type">bool</span>&gt; &#123;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> T&amp; x, <span class="type">const</span> T&amp; y)</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> x &lt; y; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">greater_equal</span> : <span class="keyword">public</span> binary_function&lt;T, T, <span class="type">bool</span>&gt; &#123;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> T&amp; x, <span class="type">const</span> T&amp; y)</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> x &gt;= y; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">less_equal</span> : <span class="keyword">public</span> binary_function&lt;T, T, <span class="type">bool</span>&gt; &#123;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> T&amp; x, <span class="type">const</span> T&amp; y)</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> x &lt;= y; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="逻辑运算类（Logical）仿函数"><a href="#逻辑运算类（Logical）仿函数" class="headerlink" title="逻辑运算类（Logical）仿函数"></a>逻辑运算类（Logical）仿函数</h3><p>STL内建的“逻辑运算类仿函数”支持了逻辑运算中的And、Or、Not三种运算，其中And和Or为二元运算，Not为一元运算。</p><ul><li>逻辑运算 And : logical_and&lt;T&gt;</li><li>逻辑运算 Or : logical_or&lt;T&gt;</li><li>逻辑运算 Not : logical_not&lt;T&gt;</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//以下3个为逻辑运算类(Logical)仿函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">logical_and</span> : <span class="keyword">public</span> binary_function&lt;T, T, <span class="type">bool</span>&gt; &#123;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> T&amp; x, <span class="type">const</span> T&amp; y)</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> x &amp;&amp; y; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">logical_or</span> : <span class="keyword">public</span> binary_function&lt;T, T, <span class="type">bool</span>&gt; &#123;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> T&amp; x, <span class="type">const</span> T&amp; y)</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> x || y; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">logical_not</span> : <span class="keyword">public</span> unary_function&lt;T, <span class="type">bool</span>&gt; &#123;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> T&amp; x)</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> !x; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="证同（identity）、选择（select）、投射（project）"><a href="#证同（identity）、选择（select）、投射（project）" class="headerlink" title="证同（identity）、选择（select）、投射（project）"></a>证同（identity）、选择（select）、投射（project）</h3><p>这一节介绍的仿函数，都只是将其参数原封不动地传回。其中某些仿函数对传回的参数有刻意的选择，或是刻意的忽略。之所以不直接在程序设计过程中使用这些及其简短的identity,  project, select等操作，而要单独划分一层出来，是为了以间接性完成抽象化。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//证同函数(identity function)。任何数值通过此函数后，不会有任何改变</span></span><br><span class="line"><span class="comment">//此式运用于&lt;stl_set.h&gt;，用来指定RB-tree所需的 Keyofvalue op</span></span><br><span class="line"><span class="comment">//那是因为set元素的键值即实值，所以采用identity</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">identity</span> : <span class="keyword">public</span> unary_function&lt;T, T&gt; &#123;</span><br><span class="line"><span class="function"><span class="type">const</span> T&amp; <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> T&amp; x)</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> x; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//选择函数(selection function) : 接受一个pair，传回其第一元素</span></span><br><span class="line"><span class="comment">//此式运用于&lt;stl_map.h&gt;，用来指定RB-tree 所需的 Keyofvalue op</span></span><br><span class="line"><span class="comment">//由于map 系以 pair元素的第一元素为其键值，所以采用select1st</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Pair</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">select1st</span> : <span class="keyword">public</span> unary_function&lt;Pair, <span class="keyword">typename</span> Pair::first_type&gt;</span><br><span class="line">&#123;    </span><br><span class="line"><span class="function"><span class="type">const</span> <span class="keyword">typename</span> Pair::first_type&amp; <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> Pair&amp; x)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"><span class="keyword">return</span> x.first;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//选择函数:接受一个pair，传回其第二元素</span></span><br><span class="line"><span class="comment">// SGI STL并未运用此式</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Pair</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">select2nd</span> : <span class="keyword">public</span> unary_function&lt;Pair, <span class="keyword">typename</span> Pair::second_type&gt;</span><br><span class="line">&#123;    </span><br><span class="line"><span class="function"><span class="type">const</span> <span class="keyword">typename</span> Pair::second_type&amp; <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> Pair&amp; x)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"><span class="keyword">return</span> x.second;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//投射函数:传回第一参数，忽略第二参数</span></span><br><span class="line"><span class="comment">// SGI STL并未运用此式</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Arg1</span>, <span class="keyword">class</span> <span class="title class_">Arg2</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">project1st</span> : <span class="keyword">public</span> binary_function&lt;Arg1, Arg2, Arg1&gt; &#123;</span><br><span class="line"><span class="function">Arg1 <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> Argl&amp; x, <span class="type">const</span> Arg2&amp;)</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> x; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//投射函数:传回第二参数，忽略第一参数</span></span><br><span class="line"><span class="comment">// SGI STL并未运用此式</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Arg1</span>, <span class="keyword">class</span> <span class="title class_">Arg2</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">project2nd</span> : <span class="keyword">public</span> binary_function&lt;Arg1, Arg2, Arg2&gt; &#123;</span><br><span class="line"><span class="function">Arg1 <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> Argl&amp;, <span class="type">const</span> Arg2&amp; y)</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> y; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;STL源码剖析&gt;第七章读书笔记，函数对象（仿函数）</summary>
    
    
    
    <category term="STL源码剖析读书笔记" scheme="http://example.com/categories/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="STL" scheme="http://example.com/tags/STL/"/>
    
    <category term="STL源码剖析" scheme="http://example.com/tags/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"/>
    
    <category term="仿函数" scheme="http://example.com/tags/%E4%BB%BF%E5%87%BD%E6%95%B0/"/>
    
    <category term="函数对象" scheme="http://example.com/tags/%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>&lt;STL源码剖析&gt;第八章</title>
    <link href="http://example.com/2022/05/09/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E7%AC%AC%E5%85%AB%E7%AB%A0/"/>
    <id>http://example.com/2022/05/09/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E7%AC%AC%E5%85%AB%E7%AB%A0/</id>
    <published>2022-05-08T16:00:00.000Z</published>
    <updated>2022-05-10T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="配接器"><a href="#配接器" class="headerlink" title="配接器"></a>配接器</h2><p> 配接器（adapter）在STL组建的灵活组合运用功能上，扮演着轴承、转换器的角色。</p><p>STL所提供的各种配接器中，改变仿函数（functors）接口者，我们称为function adapter，改变容器（containers）接口者，我们称为container adapter，改变迭代器（iterators）接口者，我们称为iterator adapter。</p><h3 id="container-adapters"><a href="#container-adapters" class="headerlink" title="container adapters"></a>container adapters</h3><p>STL提供的两个容器queue和stack，其实都只不过是一种配接器。他们修饰deque的接口而成就出另一种容器风貌。</p><h4 id="stack"><a href="#stack" class="headerlink" title="stack"></a>stack</h4><p>stack的底层由 deque 构成。从以下接口可清楚看出 stack 与 deque 的关系：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Sequence</span> = deque&lt;T&gt;&gt;</span><br><span class="line"><span class="keyword">class</span> stack &#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">Sequence c;<span class="comment">//底层容器</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>C++ Standard规定客户端必须能够从&lt;stack&gt;中获得stack的接口，SGI STL则把所有的实现细节定义于的&lt;stl_stack.h&gt;内。class stack 封住了所有的 deque 对外接口，只开放符合stack 原则的几个函数，所以我们说stack是一个配接器，一个作用于容器之上的配接器。</p><h4 id="queue"><a href="#queue" class="headerlink" title="queue"></a>queue</h4><p>queue的底层由 deque 构成。从以下接口可清楚看出 queue 与 deque 的关系：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">sequence</span> = deque&lt;T&gt;&gt;</span><br><span class="line"><span class="keyword">class</span> queue &#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">Sequence c;<span class="comment">//底层容器</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>C++ Standard规定客户端必须能够从&lt;queue&gt;中获得queue的接口，SGI STL则把所有的实现细节定义于&lt;stl_queue.h&gt;内。class queue封住了所有的 deque对外接口，只开放符合queue原则的几个函数，所以我们说queue是一个配接器，一个作用于容器之上的配接器。</p><h3 id="iterator-adapters"><a href="#iterator-adapters" class="headerlink" title="iterator adapters"></a>iterator adapters</h3><p>STL 提供了许多应用于迭代器身上的配接器，包括insert iterators，reverse iterators，iostream iterators。C++ Standard规定它们的接口可以藉由&lt;iterator&gt;获得，SGI STL 则将它们实际定义于&lt;stl_iterator.h&gt;。</p><h4 id="Insert-Iterators"><a href="#Insert-Iterators" class="headerlink" title="Insert Iterators"></a>Insert Iterators</h4><p>所谓 insert iterators，可以将一般迭代器的赋值（assign）操作转变为插人（insert）操作。这样的迭代器包括专司尾端插人操作的 back_insert_iterator，专司头端插入操作的 front_insert_iterator，以及可从任意位置执行插入操作的insert_iterator。由于这三个iterator adapters的使用接口不是十分直观，给一般用户带来困扰，因此，STL更提供三个相应函数：back_inserter() 、front_inserter()、 inserter()，提升使用时的便利性。</p><table><thead><tr><th>辅助函数</th><th>实际产生的对象</th></tr></thead><tbody><tr><td>Back_inserter<br>   (Container&amp; x);</td><td>back_insert_iterator&lt;Container&gt;(x);</td></tr><tr><td>front_inserter<br>   (Container&amp; x);</td><td>front_insert_iterator&lt;Container&gt;(x);</td></tr><tr><td>Inserter(Container&amp; x,<br>    Iterator i);</td><td>insert_iterator&lt;Container&gt;<br>(x, Container::iterator(i));</td></tr></tbody></table><p>三种insert iterators实现的主要观念是，每一个insert iterators内部都维护有一个容器（必须由用户指定）：容器当然有自己的迭代器，于是，当客户端对insert iterators做赋值（assign）操作时，就在insert iterators中被转为对该容器的迭代器做插人（insert）操作，也就是说，在 insert iterators的operator&#x3D;操作符中调用底层容器的push_front()或push_back()或insert()操作函数。至于其它的迭代器惯常行为如operator++, operator++(int), 或operator*都被关闭功能，更没有提供operator–(int)或operator–或operator-&gt;等功能（因此被类型被定义为output_iterator_tag)。换句话说，insert iterators的前进、后退、取值、成员取用等操作都是没有意义的，甚至是不允许的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这是一个迭代器配接器（iterator adapter)，用来将某个迭代器的赋值（assign）</span></span><br><span class="line"><span class="comment">//操作修改为插入（insert）操作————从容器的尾端插人进去（所以称为 back_insert）</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Container</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">back_insert_iterator</span> &#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">Container* container;<span class="comment">//底层容器</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">typedef</span> output_iterator_tag iterator_category;<span class="comment">//注意类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">void</span>   value_type;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">void</span>   difference_type;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">void</span>   pointer;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">void</span>   reference;</span><br><span class="line"></span><br><span class="line"><span class="comment">//下面这个ctor使back_insert_iterator与容器绑定起来</span></span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">back_insert_iterator</span><span class="params">(Container&amp; x)</span> : container (&amp;x) &#123;</span>&#125;</span><br><span class="line">back_insert_iterator&lt;Container&gt;&amp;</span><br><span class="line"><span class="keyword">operator</span>=(<span class="type">const</span> <span class="keyword">typename</span> Container::value__type&amp; value) &#123;</span><br><span class="line">container-&gt;<span class="built_in">push_back</span>(value);<span class="comment">//这里是关键，转而调用push_back()</span></span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//以下三个操作符对back_insert_iterator不起作用（关闭功能）</span></span><br><span class="line"><span class="comment">//三个操作符返回的都是back_insert_iterator自己</span></span><br><span class="line">back_insert_iterator&lt;Container&gt;&amp; <span class="keyword">operator</span>*() &#123; <span class="keyword">return</span> *<span class="keyword">this</span>; &#125;</span><br><span class="line">back_insert_iterator&lt;Container&gt;&amp; <span class="keyword">operator</span>++() &#123; <span class="keyword">return</span> *<span class="keyword">this</span>; &#125;</span><br><span class="line">back_insert_iterator&lt;Container&gt;&amp; <span class="keyword">operator</span>++(<span class="type">int</span>) &#123; <span class="keyword">return</span> *<span class="keyword">this</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这是一个辅助函数，帮助我们方便使用back_insert_iterator</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Container</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> back_insert_iterator&lt;Container&gt; <span class="title">back_inserter</span><span class="params">(Container&amp; x)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">back_insert_iterator</span>&lt;Container&gt;(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//---------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">//这是一个迭代器配接器（iterator adapter），用来将某个迭代器的赋值（assign）</span></span><br><span class="line"><span class="comment">//操作修改为插人(insert）操作————从容器的头端插人进去（所以称为front_insert）</span></span><br><span class="line"><span class="comment">//注意，该迭代器不适用于vector，因为 vector 没有提供push_front函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">container</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">front_insert_iterator</span> &#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">Container* container;<span class="comment">//底层容器</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">typedef</span> output_iterator_tagiterator_category;<span class="comment">//注意类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">void</span>   value_type;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">void</span>   difference_type;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">void</span>   pointer;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">void</span>   reference;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">front_insert_iterator</span><span class="params">(Container&amp; x)</span> : container (&amp;x) &#123;</span>&#125;</span><br><span class="line">front_insert_iterator&lt;Container&gt;&amp;</span><br><span class="line"><span class="keyword">operator</span>=(<span class="type">const</span> <span class="keyword">typename</span> Container::value_type&amp; value) &#123;</span><br><span class="line">container-&gt;<span class="built_in">push_front</span>(value);<span class="comment">//这里是关键，转而调用push_front()</span></span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//以下三个操作符对front_insert_iterator不起作用（关闭功能）</span></span><br><span class="line"><span class="comment">//三个操作符返回的都是front_insert_iterator自己。</span></span><br><span class="line">front_insert_iterator&lt;Container&gt;&amp; <span class="keyword">operator</span>*() &#123; <span class="keyword">return</span> *<span class="keyword">this</span>; &#125;</span><br><span class="line">front_insert_iterator&lt;Container&gt;&amp; <span class="keyword">operator</span>++() &#123; <span class="keyword">return</span> *<span class="keyword">this</span>; &#125;</span><br><span class="line">front_insert_iterator&lt;Container&gt;&amp; <span class="keyword">operator</span>++(<span class="type">int</span>) &#123; <span class="keyword">return</span> *<span class="keyword">this</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这是一个辅助函数，帮助我们方便使用front_insert_iterator</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Container</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> front_insert_iterator&lt;Container&gt; <span class="title">front_inserter</span><span class="params">(Container&amp; x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">front_insert_iterator</span>&lt;Container&gt;(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//---------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">//这是一个迭代器配接器（iterator adapter），用来将某个迭代器的复制（assign）</span></span><br><span class="line"><span class="comment">//操作修改为插入（insert）操作，在指定的位置上进行，并将迭代器右移一个位置</span></span><br><span class="line"><span class="comment">//————如此便可很方便地连续执行“表面上是赋值（覆写）而实际上是插人”的操作</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Container</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">insert_iterator</span> &#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">Container* container;<span class="comment">//底层容器</span></span><br><span class="line"><span class="keyword">typename</span> Container::iterator iter;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">typedef</span> output_iterator_tagiterator_category;<span class="comment">//注意类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">void</span>   value_type;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">void</span>   difference_type;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">void</span>   pointer;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">void</span>   reference;</span><br><span class="line"></span><br><span class="line"><span class="built_in">insert_iterator</span>(Container&amp; x, <span class="keyword">typename</span> Container::iterator i)</span><br><span class="line">: <span class="built_in">container</span>(&amp;x), <span class="built_in">iter</span>(i) &#123;&#125;</span><br><span class="line">insert_iterator&lt;Container&gt;&amp;</span><br><span class="line"><span class="keyword">operator</span>=(<span class="type">const</span> <span class="keyword">typename</span> Container::value_type&amp; value) &#123;</span><br><span class="line">iter = container-&gt;<span class="built_in">insert</span>(iter, value); <span class="comment">//这里是关键，转调用insert()</span></span><br><span class="line"> ++iter;<span class="comment">//注意这个，使 insert iterator 永远随其目标贴身移动</span></span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 以下三个操作符对 insert_iterator 不起作用（关闭功能）</span></span><br><span class="line"><span class="comment">// 三个操作符返回的都是 insert_iterator 自己</span></span><br><span class="line">insert_iterator&lt;Container&gt;&amp; <span class="keyword">operator</span>* () &#123; <span class="keyword">return</span> *<span class="keyword">this</span>; &#125;</span><br><span class="line">insert_iterator&lt;Container&gt;&amp; <span class="keyword">operator</span>++() &#123; <span class="keyword">return</span> *<span class="keyword">this</span>; &#125;</span><br><span class="line">insert_iterator&lt;Container&gt;&amp; <span class="keyword">operator</span>++(<span class="type">int</span>) &#123; <span class="keyword">return</span> *<span class="keyword">this</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这是一个辅助函数，帮助我们方便使用insert_iterator</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Container</span>, <span class="keyword">class</span> <span class="title class_">Iterator</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> insert_iterator&lt;Container&gt; <span class="title">inserter</span> <span class="params">(Container&amp; x, Iterator i)</span> </span>&#123; <span class="keyword">typedef</span> <span class="keyword">typename</span> Container::iterator iter;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">insert_iterator</span>&lt;Container&gt;(x, <span class="built_in">iter</span>(i));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Reverse-Iterators"><a href="#Reverse-Iterators" class="headerlink" title="Reverse Iterators"></a>Reverse Iterators</h4><p>所谓reverse iterators，可以将一般迭代器的行进方向逆转，使原本应该前进的operator++变成了后退操作，使原本应该后退的operator–变成了前进操作。如果STL算法接受的不是一般正常的迭代器，而是这种逆向迭代器，它就会以从尾到头的方向来处理序列中的元素。</p><p>首先来看rbegin()和rend()。任何双向序列容器都提供有这两个操作且都是同一形式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;...&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">vactor</span> / list / deque &#123;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">typedef</span> reverse_iterator&lt;iterator&gt; reverse_iterator;</span><br><span class="line"><span class="function">reverse_iterator <span class="title">rbegin</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">reverse_iterator</span>(<span class="built_in">end</span>()); &#125;</span><br><span class="line"><span class="function">reverse_iterator <span class="title">rend</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">reverse_iterator</span>(<span class="built_in">begin</span>()); &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可见，序列容器中的reverse iterator皆由普通的iterator转化而来。但是该转换会使“这两个相应的迭代器”取出不同的元素，可以看一个例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//假设有一个deque&lt;int&gt;id，当前的内容是:32 26 99 1 0 1 2 3 4 0 1 2 5 3</span></span><br><span class="line"><span class="comment">//执行以下操作:</span></span><br><span class="line">cout &lt;&lt; *(id.<span class="built_in">begin</span>()) &lt;&lt; endl;<span class="comment">// 32</span></span><br><span class="line">cout &lt;&lt; *(id.<span class="built_in">rbegin</span>()) &lt;&lt; endl; <span class="comment">// 3</span></span><br><span class="line">cout &lt;&lt; *(id.<span class="built_in">end</span>()) &lt;&lt; endl;<span class="comment">// 0 dangerous!</span></span><br><span class="line">cout &lt;&lt; *(id.<span class="built_in">rend</span>()) &lt;&lt; endl;<span class="comment">// 0 dangerous!</span></span><br><span class="line"></span><br><span class="line">deque&lt;<span class="type">int</span>&gt;::iterator ite = <span class="built_in">find</span>(id.<span class="built_in">begin</span>(), id.<span class="built_in">end</span>(), <span class="number">99</span>);</span><br><span class="line">reverse_iterator&lt;deque&lt;<span class="type">int</span>&gt;::iterator&gt; <span class="built_in">rite</span>(ite);</span><br><span class="line">cout &lt;&lt; *ite &lt;&lt; endl; <span class="comment">//99</span></span><br><span class="line">cout &lt;&lt; *rite &lt;&lt; endl;l <span class="comment">//26</span></span><br></pre></td></tr></table></figure><p>上例可以看出“正向迭代器”和“与其相应的逆向迭代器”取出了不同的元素&#x2F;这并不是一个错误，而是为了配合迭代器区间“前闭后开”的习惯。</p><p><img src="/../img/%E8%BF%AD%E4%BB%A3%E5%99%A8%E8%A2%AB%E9%80%86%E8%BD%AC.png" alt="迭代器被逆转"></p><p>唯有这样，当我们将一个正向迭代器区间转换为一个逆向迭代器区间后，不必再有任何额外处理，就可以让接受这个逆向迭代器区间的算法，以相反的元素次序来处理区间中的每一个元素。</p><p>带着这些认知，来看看reverse_iterator的源代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这是一个迭代器配接器(iterator adapter)，用来将某个迭代器逆反前进方向，</span></span><br><span class="line"><span class="comment">//使前进为后退，后退为前进</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Iterator</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">reverse_iterator</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">Iterator current;<span class="comment">//记录对应之正向迭代器</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//逆向迭代器的5种相应型别（associated types）都和其对应的正向迭代器相同</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">typename</span> iterator_traits&lt;Iterator&gt;::iterator_category</span><br><span class="line">iterator_category;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">typename</span> iterator_traits&lt;Iterator&gt;::value_type</span><br><span class="line">value_type;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">typename</span> iterator_traits&lt;Iterator&gt;::difference_type</span><br><span class="line">difference_type;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">typename</span> iterator_traits&lt;Iterator&gt;::pointer</span><br><span class="line">pointer;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">typename</span> iterator_traits&lt;Iterator&gt;::reference</span><br><span class="line">reference;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> Iterator iterator_type;<span class="comment">//代表正向迭代器</span></span><br><span class="line"><span class="keyword">typedef</span> reverse_iterator&lt;Iterator&gt; self; <span class="comment">//代表逆向迭代器</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">reverse_iterator</span>() &#123; &#125;</span><br><span class="line"><span class="comment">//下面这个ctor将reverse_iterator与某个迭代器×系结起来</span></span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">reverse_iterator</span><span class="params">(iterator_type x)</span> : current(x) &#123;</span>&#125;</span><br><span class="line"><span class="built_in">reverse_iterator</span>(<span class="type">const</span> self&amp; x) : <span class="built_in">current</span>(x.current) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">iterator_type <span class="title">base</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> current; &#125; <span class="comment">//取出对应的正向迭代器</span></span><br><span class="line">reference <span class="keyword">operator</span>*() <span class="type">const</span> &#123;</span><br><span class="line">Iterator tmp = current;</span><br><span class="line"><span class="keyword">return</span> *--tmp;</span><br><span class="line"><span class="comment">//以上为关键所在。对逆向迭代器取值，就是将“对应之正向迭代器”后退一格而后取值</span></span><br><span class="line">    &#125;</span><br><span class="line">pointer <span class="keyword">operator</span>-&gt;() <span class="type">const</span> &#123; <span class="keyword">return</span> &amp;(<span class="keyword">operator</span>*()); &#125;<span class="comment">//意义同上</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//前进（++）变成后退（--）</span></span><br><span class="line">self&amp; <span class="keyword">operator</span>++() &#123;</span><br><span class="line">--current;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">self <span class="keyword">operator</span>++(<span class="type">int</span>) &#123;</span><br><span class="line">self tmp = *<span class="keyword">this</span>;</span><br><span class="line">--current;</span><br><span class="line"><span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//后退（--）变成前进（++）</span></span><br><span class="line">self&amp; <span class="keyword">operator</span>--() &#123;</span><br><span class="line">++current;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">self <span class="keyword">operator</span>--(<span class="type">int</span>) &#123;</span><br><span class="line">self tmp =  *<span class="keyword">this</span>;</span><br><span class="line">++current;</span><br><span class="line"><span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//前进与后退方向完全逆转</span></span><br><span class="line">self <span class="keyword">operator</span>+(difference_type n) <span class="type">const</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">self</span>(current - n);</span><br><span class="line">    &#125;</span><br><span class="line">self&amp; <span class="keyword">operator</span>+=(difference_type n) &#123;</span><br><span class="line"> current -= n;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">self <span class="keyword">operator</span>-(difference_type n) <span class="type">const</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">self</span>(current + n);</span><br><span class="line">    &#125;</span><br><span class="line">self&amp; <span class="keyword">operator</span>-=(difference_type n) &#123;</span><br><span class="line"> current += n;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//注意，下面第一个*和唯一一个+都会调用本类的 opearator*和opreator+,</span></span><br><span class="line"><span class="comment">//第二个*则不会。（判断法则:完全看处理的型别是什么而定)</span></span><br><span class="line">reference <span class="keyword">operator</span>[](difference_type n) <span class="type">const</span> &#123; <span class="keyword">return</span>*(*<span class="keyword">this</span> + n); &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="IOStream-Iterators"><a href="#IOStream-Iterators" class="headerlink" title="IOStream Iterators"></a>IOStream Iterators</h4><p>所谓iostream iterators，可以将迭代器绑定到某个 iostream 对象身上。绑定到 istream 对象（例如 std::cin）身上的，称为istream_iterator，拥有输人功能；绑定到 ostream 对象（例如std::cout）身上的，称为ostream_iterator，拥有输出功能。</p><h5 id="istream-object"><a href="#istream-object" class="headerlink" title="istream object"></a>istream object</h5><p>istream iterator内部所做的事情，就是维护一个istream member，客户端对于这个迭代器所做的operator++操作，会被导引调用迭代器内部所含的那个istream member的输入操作（operator&gt;&gt;）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这是一个input iterator，能够为“来自某一basic_istream”的对象执行</span></span><br><span class="line"><span class="comment">//格式化输人操作。注意，此版本为旧有之HP规格，未符合标准接口:</span></span><br><span class="line"><span class="comment">//istream_iterator&lt;T, charT, traits, Distance&gt;</span></span><br><span class="line"><span class="comment">//然而一般使用input iterators时都只使用第一个template 参数，此时以下仍适用</span></span><br><span class="line"><span class="comment">//注: SGI STL 3.3已实现出符合标准接口的istream_iterator。做法与本版大同小异</span></span><br><span class="line"><span class="comment">//本版可读性较高</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Distance</span> = <span class="type">ptrdiff_t</span>&gt;</span><br><span class="line"><span class="keyword">class</span> istream_iterator &#123;</span><br><span class="line"><span class="keyword">friend</span> <span class="type">bool</span></span><br><span class="line"><span class="keyword">operator</span>== __STL_NULL_TMPL_ARGS (<span class="type">const</span> istream_iterator&lt;T, Distance&gt;&amp; x,</span><br><span class="line">   <span class="type">const</span> istream_iterator&lt;T, Distance&gt;&amp; y);</span><br><span class="line"><span class="comment">//在&lt;stl_config.h&gt;中，__STL_NULL_TMPL_ARGS被定义为&lt;&gt;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">istream* stream;</span><br><span class="line">T value;</span><br><span class="line"><span class="type">bool</span> end_marker;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">end_marker = (*stream) ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">if</span> (end_marker) *stream &gt;&gt; value;<span class="comment">//关键</span></span><br><span class="line"><span class="comment">//以上，输人之后，stream 的状态可能改变，所以下面再判断一次以决定end_marker</span></span><br><span class="line"><span class="comment">//当读到eof或读到型别不符的资料，stream即处于false状态</span></span><br><span class="line">end_marker = (*stream)? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">typedef</span> input_iterator_tagiterator_category;</span><br><span class="line"><span class="keyword">typedef</span> T   value_type;</span><br><span class="line"><span class="keyword">typedef</span> Distance    difference_type;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">const</span> T*pointer;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">const</span> T&amp;reference;</span><br><span class="line"><span class="comment">//以上，因身为input iterator，所以采用const比较保险</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">istream_iterator</span>() : <span class="built_in">stream</span>(&amp;cin), <span class="built_in">end_marker</span>(<span class="literal">false</span>) &#123;&#125;</span><br><span class="line"><span class="built_in">istream_iterator</span>(istream&amp; s) : <span class="built_in">stream</span>(&amp;s) &#123; <span class="built_in">read</span>(); &#125;</span><br><span class="line"><span class="comment">//以上两行的用法:</span></span><br><span class="line"><span class="comment">//istream_iterator&lt;int&gt; eos;造成end_marker为false。</span></span><br><span class="line"><span class="comment">//istream_iterator&lt;int&gt; initer(cin); 引发read()。程序至此会等待输入</span></span><br><span class="line"><span class="comment">//因此，下面这两行客户端程序:</span></span><br><span class="line"><span class="comment">//listream_iterator&lt;int&gt; initer(cin);(A)</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; &quot;please input...&quot; &lt;&lt;endl;(B)</span></span><br><span class="line"><span class="comment">//会停留在（A）等待一个输入，然后才执行（B〉出现提示信息。这是不合理的现象</span></span><br><span class="line"><span class="comment">//规避之道:永远在最必要的时候，才定义一个istream_iterator</span></span><br><span class="line"></span><br><span class="line">reference <span class="keyword">operator</span>*() <span class="type">const</span> &#123; <span class="keyword">return</span> value; &#125;</span><br><span class="line">pointer <span class="keyword">operator</span>-&gt;() <span class="type">const</span> &#123; <span class="keyword">return</span> &amp;(<span class="keyword">operator</span>*()); &#125;</span><br><span class="line"><span class="comment">//迭代器前进一个位置，就代表要读取一笔资料</span></span><br><span class="line">istream_iterator&lt;T, Distance&gt;&amp; <span class="keyword">operator</span>++() &#123;</span><br><span class="line"><span class="built_in">read</span>();</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line">istream_iterator&lt;T, Distance&gt; <span class="keyword">operator</span>++(<span class="type">int</span>) &#123;</span><br><span class="line">istream_iterator&lt;T, Distance&gt; tmp = *<span class="keyword">this</span>;</span><br><span class="line"><span class="built_in">read</span>();</span><br><span class="line"><span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h6 id="定义istream-iteretor的时机"><a href="#定义istream-iteretor的时机" class="headerlink" title="定义istream iteretor的时机"></a>定义istream iteretor的时机</h6><p>观察代码中的构造函数和read()函数可以发现，只要客户端定义一个istream iterator并绑定到某个istream object，程序便立刻停在istream_iterator&lt;T&gt;::read()函数，等待输入。因此，只有在绝对必要的时刻再去定义所需要的istream iteretor。</p><h5 id="ostream-iterator"><a href="#ostream-iterator" class="headerlink" title="ostream iterator"></a>ostream iterator</h5><p>ostream iterator内部所做的事情，就是维护一个ostream member，客户端对于这个迭代器所做的operator&#x3D;操作，会被导引调用迭代器内部所含的那个ostream member的输出操作（operator&lt;&lt;）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这是一个output iterator，能够将对象格式化输出到某个basic_ostream上</span></span><br><span class="line"><span class="comment">//注意，此版本为旧有之HP规格，未符合标准接口:</span></span><br><span class="line"><span class="comment">//ostream_iterator&lt;T, charT, traits&gt;</span></span><br><span class="line"><span class="comment">//然而一般使用onput iterators时都只使用第一个template 参数，此时以下仍适用</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ostream_iterator</span> &#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">ostream* stream;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* string;<span class="comment">//每次输出后的间隔符号</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">typedef</span> output_iterator_tag iterator_category;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">void</span>   value_type;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">void</span>   difference_type;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">void</span>   pointer;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">void</span>   reference;</span><br><span class="line"></span><br><span class="line"><span class="built_in">ostream_iterator</span>(ostream&amp; s) : <span class="built_in">stream</span>(&amp;s), <span class="built_in">string</span>(<span class="number">0</span>) &#123;&#125;</span><br><span class="line"><span class="built_in">ostream_iterator</span>(ostream&amp; s, <span class="type">const</span> <span class="type">char</span>* c) : <span class="built_in">stream</span>(&amp;s), <span class="built_in">string</span>(c) &#123;&#125;</span><br><span class="line"><span class="comment">//以上ctors的用法：</span></span><br><span class="line"><span class="comment">//ostream_iterator&lt;int&gt; outiter(cout, &#x27; &#x27;); 输出至cout，每次间隔一空格</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//对迭代器做赋值（assign）操作，就代表要输出一笔资料</span></span><br><span class="line">ostream_iterator&lt;T&gt;&amp; <span class="keyword">operator</span>=(<span class="type">const</span> T&amp; value) &#123;</span><br><span class="line">*stream &lt;&lt; value;<span class="comment">//关键：输出数值</span></span><br><span class="line"><span class="keyword">if</span> (string) *stream &lt;&lt; string; <span class="comment">//如果输出状态无误，输出间隔符号</span></span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//注意以下三个操作</span></span><br><span class="line">ostream_iterator&lt;T&gt;&amp; <span class="keyword">operator</span>*() &#123; <span class="keyword">return</span> *<span class="keyword">this</span>; &#125;</span><br><span class="line">ostream_iterator&lt;T&gt;&amp; <span class="keyword">operator</span>++() &#123; <span class="keyword">return</span> *<span class="keyword">this</span>; &#125;</span><br><span class="line">ostream_iterator&lt;T&gt;&amp; <span class="keyword">operator</span>++(<span class="type">int</span>) &#123; <span class="keyword">return</span> *<span class="keyword">this</span>; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="functor-adapters"><a href="#functor-adapters" class="headerlink" title="functor adapters"></a>functor adapters</h3><p>functor adapters（亦称为function adapters）是所有配接器中数量最庞大的一个族群，其配接灵活度也是前二者所不能及，可以配接、配接、再配接。这些配接操作包括系结（bind）、否定（negate）、组合（compose）、以及对一般函数或成员函数的修饰（使其成为一个仿函数)。C++ Standard 规定这些配接器的接口可由&lt;functional&gt; 获得，SGI STL 则将它们实际定义于&lt;stl_function.h&gt;。</p><p>请注意，所有期望获得配接能力的组件，本身都必须是可配接的（adaptable）。换句话说，一元仿函数必须继承自unary_function，二元仿函数必须继承自binary_function，成员函数必须以mem_fun处理过，一般函数必须以ptr_fun处理过。一个未经ptr_fun处理过的一般函数，虽然也可以函数指针（pointer to function）的形式传给STL算法使用，却无法拥有任何配接能力。</p><h4 id="对返回值进行逻辑否定：not1-not2"><a href="#对返回值进行逻辑否定：not1-not2" class="headerlink" title="对返回值进行逻辑否定：not1, not2"></a>对返回值进行逻辑否定：not1, not2</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//以下配接器用来表示某个Adaptable Predicate的逻辑负值（logical negation）</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Predicate</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">unary_negate</span></span><br><span class="line">: <span class="keyword">public</span> unary_function&lt;<span class="keyword">typename</span> Predicate::argument_type, <span class="type">bool</span>&gt; &#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">Predicate pred;<span class="comment">//内部成员</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">unary_negate</span><span class="params">(<span class="type">const</span> Predicate&amp; x)</span> : pred(x) &#123;</span>&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="type">const</span> <span class="keyword">typename</span> Predicate::argument_type&amp; x)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> !<span class="built_in">pred</span>(x);<span class="comment">//将pred的运算结果加上否定（negate）运算</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//辅助函数，使我们得以方便使用unary_negate&lt;Pred&gt;</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Predicate</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> unary_negate&lt;Predicate&gt; <span class="title">not1</span><span class="params">(<span class="type">const</span> Predicate&amp; pred)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">unary_negate</span>&lt;Predicate&gt;(pred);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//---------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">//以下配接器用来表示某个Adaptable Binary Predicate的逻辑负值</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Predicate</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">binary_negate</span></span><br><span class="line">: <span class="keyword">public</span> binary_function&lt;<span class="keyword">typename</span> Predicate::first_argument_type,</span><br><span class="line">   <span class="keyword">typename</span> Predicate::second_argument_type,</span><br><span class="line">   <span class="type">bool</span>&gt; &#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">Predicate pred;<span class="comment">//内部成员</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">binary_negate</span><span class="params">(<span class="type">const</span> Predicate&amp; x)</span> : pred(x) &#123;</span>&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="type">const</span> <span class="keyword">typename</span> Predicate::first_argument_type&amp; x,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> <span class="keyword">typename</span> Predicate::second_argument_type&amp; y)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> !<span class="built_in">pred</span>(x, y); <span class="comment">//将pred的运算结果加上否定（negate）运算</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//辅助函数，使我们得以方便使用bineary_negate&lt;Pred&gt;</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Predicate</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> binary_negate&lt;Predicate&gt; <span class="title">not2</span><span class="params">(<span class="type">const</span> Predicate&amp; pred)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">binary_negate</span>&lt;Predicate&gt;(pred);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="对参数进行绑定：bind1st-bind2nd"><a href="#对参数进行绑定：bind1st-bind2nd" class="headerlink" title="对参数进行绑定：bind1st, bind2nd"></a>对参数进行绑定：bind1st, bind2nd</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//以下配接器用来将某个Adaptable Binary function转换为Unary Function</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Operation</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">binder1st</span></span><br><span class="line">: <span class="keyword">public</span> unary_function&lt;<span class="keyword">typename</span> Operation::second_argument_type,</span><br><span class="line">  <span class="keyword">typename</span> Operation::result_type&gt; &#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">Operation op;<span class="comment">//内部成员</span></span><br><span class="line"><span class="keyword">typename</span> Operation::first_argument_type value; <span class="comment">//内部成员</span></span><br><span class="line">                              </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//constructor</span></span><br><span class="line"><span class="built_in">binder1st</span> (<span class="type">const</span> Operation&amp; x,</span><br><span class="line">       <span class="type">const</span> <span class="keyword">typename</span> Operation::first_argument_type&amp; y)</span><br><span class="line">: <span class="built_in">op</span>(x), <span class="built_in">value</span>(y) &#123;&#125;<span class="comment">//将表达式和第一参数记录于内部成员</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typename</span> Operation::result_type</span></span><br><span class="line"><span class="function"><span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> <span class="keyword">typename</span> Operation::second_argument_type&amp; x)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">op</span>(value, x);<span class="comment">//实际调用表达式，并将value 绑定为第一参数</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//辅助函数，让我们得以方便使用binder1st&lt;Op&gt;</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Operation</span>, <span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> binder1st&lt;Operation&gt; <span class="title">bind1st</span><span class="params">(<span class="type">const</span> Operation&amp; op, <span class="type">const</span> T&amp; x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> Operation::first_argument_type arg1_type;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">binder1st</span>&lt;Operation&gt;(op, <span class="built_in">arg1_type</span>(x));</span><br><span class="line"><span class="comment">//以上，注意，先把x转型为op的第一参数型别</span></span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//---------------------------------------------------------------------    </span></span><br><span class="line"><span class="comment">//以下配接器用来将某个Adaptable Binary function转换为Unary Function</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Operation</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">binder2nd</span></span><br><span class="line">: <span class="keyword">public</span> unary_function&lt;<span class="keyword">typename</span> Operation::first_argument_type,</span><br><span class="line">  <span class="keyword">typename</span> Operation:result_type&gt; &#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">Operation op;<span class="comment">//内部成员</span></span><br><span class="line"><span class="keyword">typename</span> Operation::second_argument_type value;<span class="comment">//内部成员</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">// constructor</span></span><br><span class="line"><span class="built_in">binder2nd</span>(<span class="type">const</span> Operation&amp; x,</span><br><span class="line">             <span class="type">const</span> <span class="keyword">typename</span> Operation::second_argument_type&amp; y)</span><br><span class="line">        : <span class="built_in">op</span>(x), <span class="built_in">value</span>(y) &#123;&#125;<span class="comment">//将表达式和第一参数记录于内部成员</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typename</span> Operation::result_type</span></span><br><span class="line"><span class="function"><span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> <span class="keyword">typename</span> Operation::first_argument_type&amp; x)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">op</span>(x, value);<span class="comment">//实际调用表达式，并将 value 绑定为第二参数</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//辅助函数，让我们得以方便使用binder2nd&lt;Op&gt;</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Operation</span>, <span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> binder2nd&lt;Operation&gt; <span class="title">bind2nd</span><span class="params">(<span class="type">const</span> Operation&amp; op, <span class="type">const</span> T&amp; x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">typename</span> Operation::second_argument_type arg2_type;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">binder2nd</span>&lt;Operation&gt;(op, <span class="built_in">arg2type</span>(x));</span><br><span class="line"><span class="comment">//以上，注意，先把x转型为op的第二参数型别</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="用于函数合成，compose1，compose2"><a href="#用于函数合成，compose1，compose2" class="headerlink" title="用于函数合成，compose1，compose2"></a>用于函数合成，compose1，compose2</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//已知两个Adaptable Unary Functions f(), g()，以下配接器用来产生一个h()，</span></span><br><span class="line"><span class="comment">//使h(x) = f(g(x))</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Operation1</span>, <span class="keyword">class</span> <span class="title class_">Operation2</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">unary_compose</span></span><br><span class="line">: <span class="keyword">public</span> unary_function&lt;<span class="keyword">typename</span> Operation2::argument_type,</span><br><span class="line">  <span class="keyword">typename</span> Operation1::result_type&gt; &#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">Operation1 op1;<span class="comment">//内部成员</span></span><br><span class="line">Operation2 op2;<span class="comment">//内部成员</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//constructor</span></span><br><span class="line"><span class="built_in">unary_compose</span>(<span class="type">const</span> Operation1&amp; x, <span class="type">const</span> Operation2&amp; y)</span><br><span class="line">: <span class="built_in">op1</span>(x), <span class="built_in">op2</span>(y) &#123;&#125;<span class="comment">//将两个表达式记录于内部成员</span></span><br><span class="line">                             </span><br><span class="line"><span class="function"><span class="keyword">typename</span> Operation1::result_type</span></span><br><span class="line"><span class="function"><span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="type">const</span> <span class="keyword">typename</span> Operation2::argument_type&amp; x)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">op1</span>(<span class="built_in">op2</span>(x));<span class="comment">//函数合成</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//辅助函数，让我们得以方便运用unary_compose&lt;Op1, Op2&gt;</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Operation1</span>, <span class="keyword">class</span> <span class="title class_">Operation2</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> unary_compose&lt;Operation1, Operation2&gt;</span></span><br><span class="line"><span class="function"><span class="title">compose1</span><span class="params">(<span class="type">const</span> Operation1&amp; op1, <span class="type">const</span> Operation2&amp; op2)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">unary_compose</span>&lt;Operation1, Operation2&gt;(op1, op2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//--------------------------------------------------------------------- </span></span><br><span class="line"><span class="comment">//已知一个Adaptable Binary Function f 和</span></span><br><span class="line"><span class="comment">//两个Adaptable Unary Functions g1(), g2()，</span></span><br><span class="line"><span class="comment">//以下配接器用来产生一个h()，使h(x) = f(g1(x), g2(x))</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Operation1</span>, <span class="keyword">class</span> <span class="title class_">Operation2</span>, <span class="keyword">class</span> <span class="title class_">Operation3</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">binary_compose</span></span><br><span class="line">: <span class="keyword">public</span> unary_function&lt;<span class="keyword">typename</span> Operation2::argument_type,</span><br><span class="line">  <span class="keyword">typename</span> Operation1::result_type&gt; &#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">Operation1 op1;<span class="comment">//内部成员</span></span><br><span class="line">Operation2 op2;<span class="comment">//内部成员</span></span><br><span class="line">Operation2 op3;<span class="comment">//内部成员</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//constructor</span></span><br><span class="line"><span class="built_in">binary_compose</span>(<span class="type">const</span> Operation1&amp; x, <span class="type">const</span> Operation2&amp; y</span><br><span class="line">                   <span class="type">const</span> Operation3&amp; z) : <span class="built_in">op1</span>(x), <span class="built_in">op2</span>(y), <span class="built_in">op3</span>(z) &#123; &#125;</span><br><span class="line">                             </span><br><span class="line"><span class="function"><span class="keyword">typename</span> Operation1::result_type</span></span><br><span class="line"><span class="function"><span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="type">const</span> <span class="keyword">typename</span> Operation2::argument_type&amp; x)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">op1</span>(<span class="built_in">op2</span>(x), <span class="built_in">op3</span>(x));<span class="comment">//函数合成</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//辅助函数，让我们得以方便运用unary_compose&lt;Op1, Op2&gt;</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Operation1</span>, <span class="keyword">class</span> <span class="title class_">Operation2</span>, <span class="keyword">class</span> <span class="title class_">Operation3</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> binary_compose&lt;Operation1, Operation2, Operation3&gt;</span></span><br><span class="line"><span class="function"><span class="title">compose2</span><span class="params">(<span class="type">const</span> Operation1&amp; op1, <span class="type">const</span> Operation2&amp; op2,</span></span></span><br><span class="line"><span class="params"><span class="function">          <span class="type">const</span> Operation3&amp; op3)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">binary_compose</span>&lt;Operation1, Operation2, Operation3&gt;</span><br><span class="line">        (op1, op2, op3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="用于函数指针：ptr-fun"><a href="#用于函数指针：ptr-fun" class="headerlink" title="用于函数指针：ptr_fun"></a>用于函数指针：ptr_fun</h4><p>这种配接器使我们能够将一般函数当做仿函数使用。一般函数当做仿函数传给STL算法，就语言层面本来就是可以的，就好像原生指针可被当做迭代器传给STL算法样。但如果你不使用这里所说的两个配接器先做一番包装，你所使用的那个一般函数将无配接能力，也就无法和前数小节介绍过的其它配接器接轨。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//以下配接器其实就是把一个一元函数指针包起来:</span></span><br><span class="line"><span class="comment">//当仿函数被使用时，就调用该函数指针</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Arg</span>, <span class="keyword">class</span> <span class="title class_">Result</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">pointer_to_unary_function</span> : <span class="keyword">public</span> unary_function&lt;Arg, Result&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="built_in">Result</span> (*ptr)(Arg); <span class="comment">//内部成员，一个函数指针</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">pointer_to_unary_function</span>() &#123;&#125;</span><br><span class="line"><span class="comment">//以下constructor将函数指针记录于内部成员之中</span></span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">pointer_to_unary_function</span><span class="params">(Result (*x)(Arg))</span> : ptr(x) &#123;</span>&#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//以下，通过函数指针执行函数</span></span><br><span class="line"><span class="function">Result <span class="title">operator</span><span class="params">()</span><span class="params">(Arg x)</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">ptr</span>(x); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//辅助函数，让我们得以方便运用pointer_to_unary_function</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Arg</span>, <span class="keyword">class</span> <span class="title class_">Result</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> pointer_to_unary_function&lt;Arg, Result&gt;</span></span><br><span class="line"><span class="function"><span class="title">ptr_fun</span><span class="params">(Result (*x)(Arg))</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">pointer_to_unary_function</span>&lt;Arg, Result&gt;(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//--------------------------------------------------------------------- </span></span><br><span class="line"><span class="comment">//以下配接器其实就是把一个二元函数指针包起来:</span></span><br><span class="line"><span class="comment">//当仿函数被使用时，就调用该函数指针</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Arg1</span>, <span class="keyword">class</span> <span class="title class_">Arg2</span>, <span class="keyword">class</span> <span class="title class_">Result</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">pointer_to_binary_function</span></span><br><span class="line">    : <span class="keyword">public</span> binary_function&lt;Arg1, Arg2, Result&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="built_in">Result</span> (*ptr)(Arg1, Arg2); <span class="comment">//内部成员，一个函数指针</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">pointer_to_binary_function</span>() &#123;&#125;</span><br><span class="line"><span class="comment">//以下constructor将函数指针记录于内部成员之中</span></span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">pointer_to_binary_function</span><span class="params">(Result (*x)(Arg1, Arg2))</span></span></span><br><span class="line"><span class="function">        : ptr(x) &#123;</span>&#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//以下，通过函数指针执行函数</span></span><br><span class="line"><span class="function">Result <span class="title">operator</span><span class="params">()</span><span class="params">(Arg1 x, Arg2 y)</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">ptr</span>(x, y); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//辅助函数，让我们得以方便运用pointer_to_binary_function</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Arg1</span>, <span class="keyword">class</span> <span class="title class_">Arg2</span>, <span class="keyword">class</span> <span class="title class_">Result</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> pointer_to_unary_function&lt;Arg, Result&gt;</span></span><br><span class="line"><span class="function"><span class="title">ptr_fun</span><span class="params">(Result (*x)(Arg))</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">pointer_to_unary_function</span>&lt;Arg, Result&gt;(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="用于成员函数指针：mem-fun-mem-fun-ref"><a href="#用于成员函数指针：mem-fun-mem-fun-ref" class="headerlink" title="用于成员函数指针：mem_fun, mem_fun_ref"></a>用于成员函数指针：mem_fun, mem_fun_ref</h4><p>这种配接器使我们能够将成员函数（ member functions ）当做仿函数来使用，于是成员函数可以搭配各种泛型算法。当容器的元素型式是 X&amp; 或 X*，而我们又以虚拟（ virtual ）成员函数作为仿函数，便可以藉由泛型算法完成所谓的多态调用（ polymorphic function call ）。这是泛型（ genericity ）与多态( polymorphism )之间的一个重要接轨。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Adapter function objects: pointers to member functions</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//这个族群一共有8 = 2^3 个function objects.</span></span><br><span class="line"><span class="comment">// (1)“无任何参数” vs “有一个参数”</span></span><br><span class="line"><span class="comment">// (2)“通过pointer调用” vs “通过reference调用”</span></span><br><span class="line"><span class="comment">// (3)“const成员函数” vs “non-const成员函数”</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//所有的复杂都只存在于function objects内部。你可以忽略它们，直接使用</span></span><br><span class="line"><span class="comment">//更上层的辅助函数mem_fun和 mem_fun_ref，它们会产生适当的配接器</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//“无任何参数”、“通过pointer调用”、“non-const成员函数”</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">S</span>, <span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">mem_fun_t</span> : <span class="keyword">public</span> unary_function&lt;T*, S&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">mem_fun_t</span><span class="params">(S (T::*pf)())</span> : f(pf) &#123;</span>&#125; <span class="comment">//记录下来</span></span><br><span class="line"><span class="function">S <span class="title">operator</span><span class="params">()</span><span class="params">(T* p)</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> (p-&gt;*f)(); &#125;<span class="comment">//转调用</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="built_in">S</span> (T::*f)();<span class="comment">//内部成员，pointer to member function</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//“无任何参数”、“通过pointer调用”、“const成员函数”</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">S</span>, <span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">const_mem_fun_t</span> : <span class="keyword">public</span> unary_function&lt;<span class="type">const</span> T*, S&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">const_men_fun_t</span><span class="params">(S (T::*pf)() <span class="type">const</span>)</span> : f(pf) &#123;</span>&#125;</span><br><span class="line"><span class="function">S <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> T* p)</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> (p-&gt;*f)(); &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="built_in">S</span> (T::*f)() <span class="type">const</span>;<span class="comment">//内部成员，pointer to const member function</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//“无任何参数”、“通过reference 调用”、“non-const成员函数”</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">S</span>, <span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">mem_fun_ref_t</span> : <span class="keyword">public</span> unary_function&lt;T, S&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">mem_fun_ref_t</span><span class="params">(S (T::pf)())</span> : f(pf) &#123;</span>&#125;<span class="comment">//记录下来</span></span><br><span class="line"><span class="function">S <span class="title">operator</span><span class="params">()</span><span class="params">(T&amp; r)</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> (r.*f)(); &#125;<span class="comment">//转调用</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="built_in">S</span> (T::*f)();<span class="comment">//内部成员，pointer to member function</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//“无任何参数”、“通过reference调用”、“const成员函数”</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">S</span>, <span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">const_mem_fun_ref_t</span> : <span class="keyword">public</span> unary_function&lt;T, S&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">const_mem_fun_ref_t</span><span class="params">(S (T::pf)() <span class="type">const</span>)</span> : f(pf) &#123;</span>&#125;<span class="comment">//记录下来</span></span><br><span class="line"><span class="function">S <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> T&amp; r)</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> (r.*f)(); &#125;<span class="comment">//转调用</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="built_in">S</span> (T::*f)() <span class="type">const</span>;<span class="comment">//内部成员，pointer to const member function</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//“有一个参数”、“通过pointer调用”、“non-const成员函数”</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">S</span>, <span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">A</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">mem_fun1_t</span> : <span class="keyword">public</span> binary_function&lt;T*, A, S&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">mem_fun1_t</span><span class="params">(S (T::*pf)(A))</span> : f(pf) &#123;</span>&#125;<span class="comment">//记录下来</span></span><br><span class="line"><span class="function">S <span class="title">operator</span><span class="params">()</span><span class="params">(T* p, A x)</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> (p-&gt;*f)(x); &#125; <span class="comment">//转调用</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="built_in">S</span> (T::*f)(A);<span class="comment">//内部成员，pointer to member function</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//“有一个参数”、“通过pointer调用”、“const成员函数”</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">S</span>, <span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">A</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">const_mem_fun1_t</span> : <span class="keyword">public</span> binary_function&lt;T*, A, S&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">const_mem_fun1_t</span><span class="params">(S (T::*pf)(A) <span class="type">const</span>)</span> : f(pf) &#123;</span>&#125;</span><br><span class="line"><span class="function">S <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> T* p, A x)</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> (p-&gt;*f)(x); &#125; <span class="comment">//转调用</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="built_in">S</span> (T::*f)(A) <span class="type">const</span>;<span class="comment">//内部成员，pointer to const member function</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//“有一个参数”、“通过reference 调用”、“non-const成员函数”</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">S</span>, <span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">A</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">mem_fun1_ref_t</span> : <span class="keyword">public</span> binary_function&lt;T, A, S&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">mem_fun1_ref_t</span><span class="params">(S (T::*pf)(A))</span> : f(pf) &#123;</span>&#125;<span class="comment">//记录下来</span></span><br><span class="line"><span class="function">S <span class="title">operator</span><span class="params">()</span><span class="params">(T&amp; r, A x)</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> (r.*f)(x); &#125; <span class="comment">//转调用</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="built_in">S</span> (T::*f)(A);<span class="comment">//内部成员，pointer to member function</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//“有一个参数”、﹒“通过reference 调用”、“const成员函数”</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">S</span>, <span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">A</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">const_mem_fun1_ref_t</span> : <span class="keyword">public</span> binary_function&lt;T, A, S&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">const_mem_fun1_ref_t</span><span class="params">(S (T::*pf)(A) <span class="type">const</span>)</span> : f(pf) &#123;</span>&#125;</span><br><span class="line"><span class="function">S <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> T&amp; r, A x)</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> (r.*f)(x); &#125; <span class="comment">//转调用</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="built_in">S</span> (T::*f)(A) <span class="type">const</span>;<span class="comment">//内部成员，pointer to const member function</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//--------------------------------------------------------------------- </span></span><br><span class="line"><span class="comment">//mem_fun adapter 的辅助函数: mem_fun, mem_fun_ref</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">S</span>, <span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">mem_fun_t</span>&lt;S, T&gt; <span class="title">mem_fun</span><span class="params">(S (T::*f)())</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">mem_fun_t</span>&lt;S, T&gt;(f);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">S</span>, <span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">const_mem_fun_t</span>&lt;S, T&gt; <span class="title">mem_fun</span><span class="params">(S (T::*f)() <span class="type">const</span>)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">const_mem_fun_t</span>&lt;S, T&gt;(f);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">S</span>, <span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">mem_fun_ref_t</span>&lt;S, T&gt; <span class="title">mem_fun_ref</span><span class="params">(S (T::*f)())</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">mem_fun_ref_t</span>&lt;S, T&gt;(f);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">S</span>, <span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">const_mem_fun_ref_t</span>&lt;S, T&gt; <span class="title">mem_fun_ref</span><span class="params">(S (T::*f)() <span class="type">const</span>)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">const_mem_fun_ref_t</span>&lt;S, T&gt;(f);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//注意:以下四个函数，其实可以采用和先前（以上）四个函数相同的名称（函数重载）。</span></span><br><span class="line"><span class="comment">//事实上C++ standard也的确这么做。</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">S</span>, <span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">A</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">mem_fun1_t</span>&lt;S, T, A&gt; <span class="title">mem_fun1</span><span class="params">(S (T::*f)(A))</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">mem_fun1_t</span>&lt;S, T, A&gt;(f);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">S</span>, <span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">A</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">const_mem_fun1_t</span>&lt;S, T, A&gt; <span class="title">mem_fun1</span><span class="params">(S (T::*f)(A) <span class="type">const</span>)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">const_mem_fun1_t</span>&lt;S, T, A&gt;(f);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">S</span>, <span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">A</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">mem_fun1_ref_t</span>&lt;S, T, A&gt; <span class="title">mem_fun1_ref</span><span class="params">(S (T::*f)(A) <span class="type">const</span>)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">mem_fun1_ref_t</span>&lt;S, T, A&gt;(f);</span><br><span class="line">&#125;</span><br><span class="line">                                              </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">S</span>, <span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">A</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">const_mem_fun1_ref_t</span>&lt;S, T, A&gt; <span class="title">mem_fun1_ref</span><span class="params">(S (T::*f)(A) <span class="type">const</span>)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">const_mem_fun1_ref_t</span>&lt;S, T, A&gt;(f);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;STL源码剖析&gt;第八章读书笔记，有关三种配接器（container adapters, iterator adapters, functor adapters）的相关知识。</summary>
    
    
    
    <category term="STL源码剖析读书笔记" scheme="http://example.com/categories/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="STL" scheme="http://example.com/tags/STL/"/>
    
    <category term="STL源码剖析" scheme="http://example.com/tags/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"/>
    
    <category term="配接器" scheme="http://example.com/tags/%E9%85%8D%E6%8E%A5%E5%99%A8/"/>
    
    <category term="adapter" scheme="http://example.com/tags/adapter/"/>
    
  </entry>
  
  <entry>
    <title>&lt;STL源码剖析&gt;第六章</title>
    <link href="http://example.com/2022/04/08/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E7%AC%AC%E5%85%AD%E7%AB%A0/"/>
    <id>http://example.com/2022/04/08/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E7%AC%AC%E5%85%AD%E7%AB%A0/</id>
    <published>2022-04-07T16:00:00.000Z</published>
    <updated>2022-05-08T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><h3 id="数值算法-lt-stl-numeric-h-gt"><a href="#数值算法-lt-stl-numeric-h-gt" class="headerlink" title="数值算法&lt;stl_numeric.h&gt;"></a>数值算法&lt;stl_numeric.h&gt;</h3><h4 id="accumulate"><a href="#accumulate" class="headerlink" title="accumulate"></a>accumulate</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//版本1</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>, <span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function">T <span class="title">accumulate</span><span class="params">(InputIterator first, InputIterator last, T init)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> ( ; first != last; ++first)</span><br><span class="line">init = init + *first; <span class="comment">//将每个元素值累加到初值init身上</span></span><br><span class="line"><span class="keyword">return</span> init;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//版本2</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>, <span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">BinaryOperation</span>&gt;</span><br><span class="line"><span class="function">T <span class="title">accumulate</span><span class="params">(InputIterator first, InputIterator last, T init,</span></span></span><br><span class="line"><span class="params"><span class="function">BinaryOperation binary_op)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span>( ; first != last; ++first)</span><br><span class="line">init = <span class="built_in">binary_op</span>(init, *first); <span class="comment">//对每一个元素执行二元操作</span></span><br><span class="line"><span class="keyword">return</span> init;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>式中的二元操作符不必满足交换律和结合律。</p><h4 id="adjacent-difference"><a href="#adjacent-difference" class="headerlink" title="adjacent_difference"></a>adjacent_difference</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//版本1</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>, <span class="keyword">class</span> <span class="title class_">OutputIterator</span>&gt;</span><br><span class="line"><span class="function">OutputIterator <span class="title">adjacent_difference</span><span class="params">(InputIterator first, InputIterator last,</span></span></span><br><span class="line"><span class="params"><span class="function">outputIterator result)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (first == last) <span class="keyword">return</span> result;</span><br><span class="line">*result = *first;<span class="comment">//首先记录第一个元素</span></span><br><span class="line"><span class="keyword">return</span> __adjacent_difference(first, last, result, <span class="built_in">value_type</span>(first));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>, <span class="keyword">class</span> <span class="title class_">OutputIterator</span>, <span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">OutputIterator __adjacent_difference(InputIterator first, InputIterator last, OutputIterator result, T*) &#123;</span><br><span class="line">T value = *first;</span><br><span class="line"><span class="keyword">while</span> (++first != last) &#123;   <span class="comment">//走过整个区间</span></span><br><span class="line">T tmp = *first;</span><br><span class="line">*++result = tmp - value;<span class="comment">//将相邻两元素的差额（后-前），赋值给目的端</span></span><br><span class="line">value = tmp;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">return</span> ++result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//版本2</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>, <span class="keyword">class</span> <span class="title class_">OutputIterator</span>, <span class="keyword">class</span> <span class="title class_">BinaryOperation</span>&gt;</span><br><span class="line"><span class="function">OutputIterator <span class="title">adjacent_difference</span><span class="params">(InputIterator first, InputIterator last,</span></span></span><br><span class="line"><span class="params"><span class="function">OutputIterator result, BinaryOperation binary_op)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (first == last) <span class="keyword">return</span> result;</span><br><span class="line">*result = *first;<span class="comment">//首先记录第一个元素</span></span><br><span class="line"><span class="keyword">return</span> __adjacent_difference(first, last, result, <span class="built_in">value_type</span>(first), binary_op);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>, <span class="keyword">class</span> <span class="title class_">OutputIterator</span>, <span class="keyword">class</span> <span class="title class_">T</span></span><br><span class="line"> <span class="keyword">class</span> <span class="title class_">BinaryOperation</span>&gt;</span><br><span class="line">OutputIterator __adjacent_difference(InputIterator first, InputIterator last, outputIterator result, T*, BinaryOperation binary_op) &#123;</span><br><span class="line">T value = *first;</span><br><span class="line"><span class="keyword">while</span> (++first != last) &#123;<span class="comment">//走过整个区间</span></span><br><span class="line">T tmp = *first;</span><br><span class="line">*++result = <span class="built_in">binary_op</span>(tmp, value); <span class="comment">//将相邻两元素的运算结果，赋值给目的端</span></span><br><span class="line">value = tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ++result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>算法adjacent_difference用来计算[first, last)中相邻元素的差额。</p><p>如果加法与减法的定义一如常规定义，那么adjacent_difference与partial_sum（稍后介绍）互为逆运算。这意思是，如果对区间值1,2,3,4,5执行adjacent_difference，获得结果为1,1,1,1,1，再对此结果执行partial_sum，便会获得原始区间值1,2,3,4,5。</p><h4 id="inner-producct"><a href="#inner-producct" class="headerlink" title="inner_producct"></a>inner_producct</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//版本1</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator1</span>, <span class="keyword">class</span> <span class="title class_">InputIterator2</span>, <span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function">T <span class="title">inner_product</span><span class="params">(InputIterator1 first1, InputIterator1 last1,</span></span></span><br><span class="line"><span class="params"><span class="function">   InputIterator2 first2, T init)</span> </span>&#123;</span><br><span class="line"><span class="comment">//以第一序列之元素个数为据，将两个序列都走一遍</span></span><br><span class="line"><span class="keyword">for</span> ( ; first1 != last1; ++first1, ++first2)</span><br><span class="line">init = init + (*first1 * *first2); <span class="comment">//执行两个序列的一般内积</span></span><br><span class="line"><span class="keyword">return</span> init;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//版本2</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator1</span>, <span class="keyword">class</span> <span class="title class_">InputIterator2</span>, <span class="keyword">class</span> <span class="title class_">T</span>,</span><br><span class="line"> <span class="keyword">class</span> <span class="title class_">BinaryOperation1</span>, <span class="keyword">class</span> <span class="title class_">BinaryOperation2</span>&gt;</span><br><span class="line"><span class="function">T <span class="title">inner_product</span><span class="params">(InputIterator1 first1, InputIterator1 last1,</span></span></span><br><span class="line"><span class="params"><span class="function">   InputIterator2 first2, T init, BinaryOperation1 binary_op1,   BinaryOperation2 binary_op2)</span> </span>&#123;</span><br><span class="line"><span class="comment">//以第一序列之元素个数为据，将两个序列都走一遍</span></span><br><span class="line"><span class="keyword">for</span> ( ; first1 != last1; ++first1, ++first2)</span><br><span class="line"><span class="comment">//以外界提供的仿函数来取代第一版本中的operator*和operator+</span></span><br><span class="line">init = <span class="built_in">binary_op1</span>(init, <span class="built_in">binary_op2</span>(*first1, *first2));</span><br><span class="line"><span class="keyword">return</span> init;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>算法inner_product能够计算[first1, last1)和[first2, first2 + (last1 - first1))的一般内积。</p><p>式中所用的二元仿函数不必满足交换律(commutative)和结合律(associative)。inner_product所有运算行为的顺序都有明确设定。</p><h4 id="partial-sum"><a href="#partial-sum" class="headerlink" title="partial_sum"></a>partial_sum</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//版本1</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>, <span class="keyword">class</span> <span class="title class_">OutputIterator</span>&gt;</span><br><span class="line"><span class="function">OutputIterator <span class="title">partial_sum</span><span class="params">(InputIterator first, InputIterator last,</span></span></span><br><span class="line"><span class="params"><span class="function"> Outputrterator result)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (first == last) <span class="keyword">return</span> result;</span><br><span class="line">*result = *first;</span><br><span class="line"><span class="keyword">return</span> __partial_sum(first, last, result, <span class="built_in">value_type</span>(first));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>, <span class="keyword">class</span> <span class="title class_">OutputIterator</span>, <span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function">OutputIterator <span class="title">partial_sum</span><span class="params">(InputIterator first, InputIterator last,</span></span></span><br><span class="line"><span class="params"><span class="function"> OutputIterator result, T*)</span> </span>&#123;</span><br><span class="line">T value = *first;</span><br><span class="line"><span class="keyword">while</span> (++first != last) &#123;</span><br><span class="line">value = value + *first;<span class="comment">//前n个元素的总和</span></span><br><span class="line">*++result = value;<span class="comment">//指定给目的端</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ++result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//版本2由binary_op取代operator+</span></span><br></pre></td></tr></table></figure><p>算法partial_sum用来计算局部总和。</p><p>此式所用之二元仿函数不必满足交换律(commutative)和结合律(associative)。所有运算行为的顺序都有明确设定。</p><p>本算法返回输出区间的最尾端位置: result + (last - first) 。</p><h4 id="power"><a href="#power" class="headerlink" title="power"></a>power</h4><p>这个算法由SGI专属，并不在STL标准之列。它用来计算某数的n幂次方。</p><p>这里所谓的n幂次是指自己对自己进行某种运算，达n次。运算类型可由外界指定。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//版本一，乘幂</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Integer</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> T <span class="title">power</span><span class="params">(T x, Integer n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">power</span>(x, n, <span class="built_in">multiplies</span>&lt;T&gt;());<span class="comment">//指定运算型式为乘法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//版本二，幂次方。如果指定为乘法运算，则当n &gt;= 0时返回x^n</span></span><br><span class="line"><span class="comment">//注意，&quot;Monoid0peration”必须满足结合律(associative),</span></span><br><span class="line"><span class="comment">//但不需满足交换律(commutative)</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Integer</span>, <span class="keyword">class</span> <span class="title class_">MonoidOperation</span>&gt;</span><br><span class="line"><span class="function">T <span class="title">power</span><span class="params">(T x, Integer n, MonoidOperation op)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">identity_element</span>(op);<span class="comment">//取出“证同元素”identity element</span></span><br><span class="line"><span class="keyword">else</span> &#123;  <span class="comment">//所谓“证同元素”，见7.3节</span></span><br><span class="line"><span class="keyword">while</span> ((n &amp; <span class="number">1</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">x = <span class="built_in">op</span>(x, x);</span><br><span class="line">&#125;</span><br><span class="line">        </span><br><span class="line">T result = x;</span><br><span class="line">n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (n != <span class="number">0</span>) &#123;</span><br><span class="line">x = <span class="built_in">op</span>(x, x);</span><br><span class="line"><span class="keyword">if</span> ((n &amp; <span class="number">1</span>) != <span class="number">0</span> )</span><br><span class="line">result = <span class="built_in">op</span>(result, x);</span><br><span class="line">n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="itoa"><a href="#itoa" class="headerlink" title="itoa"></a>itoa</h4><p>这个算法由SGI专属，并不在STL标准之列。它用来设定某个区间的内容，使其内的每一个元素从指定的value值开始，呈现递增状态。它改变了区间内容，所以是一种质变算法。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//函数意义:在[first, last)区间内填人value, value+1, value+2...</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">ForwardIterator</span>, <span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">iota</span> <span class="params">(ForwardIterator first, ForwardIterator last, T value)</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span> (first != last) *first++ = value++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="基本算法-lt-stl-algobase-h-gt"><a href="#基本算法-lt-stl-algobase-h-gt" class="headerlink" title="基本算法&lt;stl_algobase.h&gt;"></a>基本算法&lt;stl_algobase.h&gt;</h3><h4 id="equal"><a href="#equal" class="headerlink" title="equal"></a>equal</h4><p>如果两个序列在[first, last)区间内相等，equal()返回true。如果第二序列的元素比较多，多出来的元素不予考虑。因此，如果我们希望保证两个序列完全相等，必须先判断其元素个数是否相同：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( vec1.<span class="built_in">size</span>() == vec2.<span class="built_in">size</span>() &amp;&amp;</span><br><span class="line"> <span class="built_in">equal</span>( vec1.<span class="built_in">begin</span>(), vec1.<span class="built_in">end</span>(), vec2.<span class="built_in">begin</span>());</span><br></pre></td></tr></table></figure><p>如果第二序列的元素比第一序列少，这个算法内部进行迭代行为时，会超越序列的尾端，造成不可预测的结果。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator1</span>, <span class="keyword">class</span> <span class="title class_">InputIterator2</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">equa1</span><span class="params">(InputIterator1 first1, InputIterator1 last1,</span></span></span><br><span class="line"><span class="params"><span class="function"> InputIterator2 first2)</span> </span>&#123;</span><br><span class="line"><span class="comment">//以下，将序列一走过一遍。序列二亦步亦趋</span></span><br><span class="line"><span class="comment">//如果序列一的元素个数多过序列二的元素个数，就糟糕了</span></span><br><span class="line"><span class="keyword">for</span> ( ; first1 != last1; ++first1, ++first2) &#123;</span><br><span class="line"><span class="keyword">if</span> (*first1 != *first2)<span class="comment">//只要对应元素不相等</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;   <span class="comment">//就结束并返回false</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;   <span class="comment">//至此，全部相等，返回true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator1</span>, <span class="keyword">class</span> <span class="title class_">InputIterator2</span>,</span><br><span class="line"> <span class="keyword">class</span> <span class="title class_">BinaryPredicate</span>&gt;  </span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">equal</span> <span class="params">(Inputiterator1 first1, InputIterator1 last1,</span></span></span><br><span class="line"><span class="params"><span class="function">  InputIterator2 first2, BinaryPredicate binary_pred)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> ( ; first1 != last1; ++first1, ++first2)</span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">binary_pred</span>(*first1, *first2))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="fill"><a href="#fill" class="headerlink" title="fill"></a>fill</h4><p>将[first, last)内的所有元素改填新值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">ForwardIterator</span>, <span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fill</span><span class="params">(ForwardIterator first, Forwarditerator last, <span class="type">const</span> T&amp; value)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> ( ; first != last; ++first)<span class="comment">//迭代走过整个区间</span></span><br><span class="line">*first = value;   <span class="comment">//设定新值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="fill-n"><a href="#fill-n" class="headerlink" title="fill_n"></a>fill_n</h4><p>将[first, last)内的前n个元素改填新值，返回的迭代器指向被填人的最后一个元素的下一位置。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">OutputIterator</span>, <span class="keyword">class</span> <span class="title class_">Size</span>, <span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function">OutputIterator <span class="title">fill_n</span><span class="params">(OutputIterator first, Size n, <span class="type">const</span> T&amp; value)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> ( ; n &gt; <span class="number">0</span>; --n, ++first)<span class="comment">//经过n个元素</span></span><br><span class="line">*first = value;   <span class="comment">//设定新值</span></span><br><span class="line"><span class="keyword">return</span> first;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>利用inserter()产生一个具有插入(insert)而非覆写(overwrite)能力的迭代器，inserter()可产生一个用来修饰迭代器的配接器。具体用法如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> ia[<span class="number">3</span>]=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">iv</span><span class="params">(ia, ia+<span class="number">3</span>)</span></span>;<span class="comment">//0 1 2</span></span><br><span class="line"><span class="built_in">fi11_n</span>(<span class="built_in">inserter</span>(iv, iv.<span class="built_in">begin</span>()), <span class="number">5</span>, <span class="number">7</span>); <span class="comment">//7 7 7 7 7 0 1 2</span></span><br></pre></td></tr></table></figure><h4 id="iter-swap"><a href="#iter-swap" class="headerlink" title="iter_swap"></a>iter_swap</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">ForwardIterator1</span>, <span class="keyword">class</span> <span class="title class_">ForwardIterator2</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">iter_swap</span><span class="params">(ForwardIterator1 a, ForwardIterator2 b)</span> </span>&#123;</span><br><span class="line">__iter_swap(a, b, <span class="built_in">value_type</span>(a)); <span class="comment">//注意第三参数的型别!</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">ForwardIterator1</span>, <span class="keyword">class</span> <span class="title class_">ForwardIterator2</span>, <span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="type">void</span> __iter_swap(ForwardIterator1 a, ForwardIterator2 b, T*) &#123;</span><br><span class="line">T tmp = *a;</span><br><span class="line">*a = *b;</span><br><span class="line">*b = tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="lexicographical-compare"><a href="#lexicographical-compare" class="headerlink" title="lexicographical_compare"></a>lexicographical_compare</h4><p>以“字典排列方式”对两个序列[first1, last1)和[first2, last2)进行比较。比较操作针对两序列中的对应位置上的元素进行，并持续直到（1）某一组对应元素彼此不相等；（2）同时到达last1和last2（当两序列的大小相同）；（3）到达last1或last2（当两序列的大小不同）。</p><p>当这个函数在对应位置上发现第一组不相等的元素时，有下列几种可能：</p><ul><li>如果第一序列的元素较小，返回 true。否则返回false。</li><li>如果到达last1而尚未到达last2，返回true。</li><li>如果到达last2而尚未到达last1，返回false。</li><li>如果同时到达last1和last2（换句话说所有元素都匹配），返回false；</li></ul><p>第二版本允许你指定一个仿函数comp作为比较操作之用，取代元素类型所提供的less-than(小于)操作符。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator1</span>, <span class="keyword">class</span> <span class="title class_">InputIterator2</span>&gt;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">lexicographical_compare</span><span class="params">(InputIterator1 first1, InputIterator1 last1,</span></span></span><br><span class="line"><span class="params"><span class="function">   InputIterator2 first2, InputIterator2 last2)</span> </span>&#123;</span><br><span class="line"><span class="comment">//以下，任何一个序列到达尾端，就结束。否则两序列就相应元素一一进行比对</span></span><br><span class="line"><span class="keyword">for</span> ( ; first1 != last1 &amp;&amp; first2 != last2; ++first1, ++first2) &#123;</span><br><span class="line"><span class="keyword">if</span> (*first1 &lt; *first2) <span class="comment">//第一序列元素值小于第二序列的相应元素值</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span> (*first2 &lt; *first1) <span class="comment">//第二序列元素值小于第一序列的相应元素值</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="comment">//如果不符合以上两条件，表示两值相等，那就进行下一组相应元素值的比对</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//进行到这里，如果第一序列到达尾端而第二序列尚有余额，那么第一序列小于第二序列</span></span><br><span class="line">    <span class="keyword">return</span> first1 == last1 &amp;&amp; first2 != last2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator1</span>, <span class="keyword">class</span> <span class="title class_">InputIterator2</span>, <span class="keyword">class</span> <span class="title class_">Compare</span>&gt;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">lexicographical_compare</span><span class="params">(InputIterator1 first1, InputIterator1 last1,</span></span></span><br><span class="line"><span class="params"><span class="function">   InputIterator2 first2, InputIterator2 last2,</span></span></span><br><span class="line"><span class="params"><span class="function">                              Compare comp)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> ( ; first1 != last1 &amp;&amp; first2 != last2; ++first1, ++first2) &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">comp</span>(*first1, *first2))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">comp</span>(*first2, *first1))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">return</span> first1 == last1 &amp;&amp; first2 != last2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了增进效率，SGI还设计了一个特化版本，用于原生指针const unsignede char*:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span></span></span><br><span class="line"><span class="function"><span class="title">lexicographical_compare</span><span class="params">(<span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span>* first1,</span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span>* last1,</span></span></span><br><span class="line"><span class="params"><span class="function">                        <span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span>* first2,</span></span></span><br><span class="line"><span class="params"><span class="function">                        <span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span>* last2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">size_t</span> lenl = last1 - first1;<span class="comment">//第一序列长度</span></span><br><span class="line"><span class="type">const</span> <span class="type">size_t</span> len2 = last2 - first2;<span class="comment">//第二序列长度</span></span><br><span class="line"><span class="comment">//先比较相同长度的一段。memcmp()速度极快</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> result = <span class="built_in">memcmp</span>(first1, first2, <span class="built_in">min</span>(len1, len2));</span><br><span class="line"><span class="comment">//如果不相上下，则长度较长者被视为比较大</span></span><br><span class="line"><span class="keyword">return</span> result != <span class="number">0</span> ? result &lt; <span class="number">0</span> : lenl &lt; len2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="max"><a href="#max" class="headerlink" title="max"></a>max</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">const</span> T&amp; <span class="title">max</span><span class="params">(<span class="type">const</span> T&amp; a,<span class="type">const</span> T&amp; b)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> a &lt; b ? b : a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Compare</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">const</span> T&amp; <span class="title">max</span><span class="params">(<span class="type">const</span> T&amp; a, <span class="type">const</span> T&amp; b, Compare comp)</span></span></span><br><span class="line"><span class="function"><span class="keyword">return</span> <span class="title">comp</span><span class="params">(a, b)</span> ? b : a;</span><span class="comment">// 由comp决定“大小比较”标准</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="min"><a href="#min" class="headerlink" title="min"></a>min</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">const</span> T&amp; <span class="title">min</span><span class="params">(<span class="type">const</span> T&amp; a,<span class="type">const</span> T&amp; b)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> b &lt; a ? b : a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Compare</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">const</span> T&amp; <span class="title">min</span><span class="params">(<span class="type">const</span> T&amp; a, <span class="type">const</span> T&amp; b, Compare comp)</span></span></span><br><span class="line"><span class="function"><span class="keyword">return</span> <span class="title">comp</span><span class="params">(b, a)</span> ? b : a;</span><span class="comment">// 由comp决定“大小比较”标准</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="mismatch"><a href="#mismatch" class="headerlink" title="mismatch"></a>mismatch</h4><p>用来平行比较两个序列，指出两者之间的第一个不匹配点。返回一对迭代器，分别指向两序列中的不匹配点，如下图。如果两序列的所有对应元素都匹配，返回的便是两序列各自的last迭代器。缺省情况下是以equality操作符来比较元素；但第二版本允许用户指定比较操作。如果第二序列的元素个数比第一序列多，多出来的元素忽略不计。如果第二序列的元素个数比第一序列少，会发生未可预期的行为。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator1</span>, <span class="keyword">class</span> <span class="title class_">InputIterator2</span>&gt;</span><br><span class="line"><span class="function">pair&lt;InputIterator1, InputIterator2&gt; <span class="title">mismatch</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">InputIterator1 first1, </span></span></span><br><span class="line"><span class="params"><span class="function">     InputIterator1 last1, </span></span></span><br><span class="line"><span class="params"><span class="function">    InputIterator2 first2)</span> </span>&#123;</span><br><span class="line"><span class="comment">//以下，如果序列一走完，就结束</span></span><br><span class="line"><span class="comment">//以下，如果序列一和序列二的对应元素相等，就结束</span></span><br><span class="line"><span class="comment">//显然，序列一的元素个数必须多过序列二的元素个数，否则结果无可预期</span></span><br><span class="line"><span class="keyword">while</span> (first1 != last1 &amp;&amp; *first1 == *first2) &#123;</span><br><span class="line">++first1;</span><br><span class="line">++first2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">pair</span>&lt;InputIterator1, InputIterator2&gt;(first1, first2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator1</span>, <span class="keyword">class</span> <span class="title class_">InputIterator2</span>,</span><br><span class="line"> <span class="keyword">class</span> <span class="title class_">BinaryPredicate</span>&gt;</span><br><span class="line"><span class="function">pair&lt;InputIterator1, InputIterator2&gt; <span class="title">mismatch</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">InputIterator1 first1, </span></span></span><br><span class="line"><span class="params"><span class="function">     InputIterator1 last1, </span></span></span><br><span class="line"><span class="params"><span class="function">    InputIterator2 first2,</span></span></span><br><span class="line"><span class="params"><span class="function">           BinaryPredicate binary_pred)</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span> (first1 != last1 &amp;&amp; <span class="built_in">binary_pred</span>(*first1, *first2)) &#123;</span><br><span class="line">++first1;</span><br><span class="line">++first2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">pair</span>&lt;InputIterator1, InputIterator2&gt;(first1, first2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="swap"><a href="#swap" class="headerlink" title="swap"></a>swap</h4><p>该函数用来对调两个对象的内容。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">swap</span><span class="params">(T&amp; a, T&amp; b)</span> </span>&#123;</span><br><span class="line">T tmp = a;</span><br><span class="line">a = b;</span><br><span class="line">b = tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="copy"><a href="#copy" class="headerlink" title="copy"></a>copy</h4><p>SGI STL的copy算法使用assignment operator来进行复制操作，而在该过程由于某些元素类型拥有的是trivial assignment operator，因此，如果能够采用内存直接复制行为（例如memmove或者memcpy）将节省大量时间。</p><p>为此，SGI STL的copy算法用尽各种办法（包括函数重载、type traits、partial specailization）等编程技巧，极致地去加强效率。</p><p>整个copy()操作的脉络：</p><p><img src="/../img/copy%E5%AE%8C%E6%95%B4%E8%84%89%E7%BB%9C.png" alt="copy完整脉络"></p><p>copy对其template参数所要求的条件非常宽松。其输入区间只需由InputIterators构成即可，输出区间只需由OutputIterator构成即可。但是，copy算法需要特别注意区间重叠的问题：</p><p><img src="/../img/copy%E7%AE%97%E6%B3%95%E5%8C%BA%E9%97%B4%E9%87%8D%E5%8F%A0%E7%9A%84%E9%97%AE%E9%A2%98.png" alt="copy算法区间重叠的问题"></p><p>如果输入区间和输出区间完全没重叠，当然毫无问题。否则，当输出区间的起点位于输入区间以内的话，copy算法便可能会在输入区间的某些元素尚未被复制之前就覆盖其值，导致错误的结果。这里的“可能”是因为如果copy算法根据其所接收的迭代器特性决定调用memmove()来执行任务，就不会造成上述错误，因为memmove()会先将整个输入区间的内容复制下来，没有被覆盖的危险。</p><p>copy更改的是[result, result + (last - first))中的迭代器所指对象，而非更改迭代器本身。它会为输出区间内的元素赋予新值，而不是产生新的元素。它不能改变输出区间的迭代器个数。换句话说，copy不能直接用来将元素插人空容器中。</p><h5 id="copy算法的实现细节"><a href="#copy算法的实现细节" class="headerlink" title="copy算法的实现细节"></a>copy算法的实现细节</h5><p>对外接口：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//完全泛化版本</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>, <span class="keyword">class</span> <span class="title class_">OutputIterator</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> OutputIterator <span class="title">copy</span><span class="params">(InputIterator first, InputIterator last,</span></span></span><br><span class="line"><span class="params"><span class="function"> OutputIterator result)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> __copy_dispatch&lt;InputIterator, OutputIterator&gt;()</span><br><span class="line">(first, last, result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//特殊版本(1)。重载形式</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">char</span>* <span class="title">copy</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* first, <span class="type">const</span> <span class="type">char</span>* last, <span class="type">char</span>* result)</span> </span>&#123;</span><br><span class="line"><span class="built_in">memmove</span>(result, first, last - first);</span><br><span class="line"><span class="keyword">return</span> result + (last - first);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//特殊版本(2)。重载形式</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">wchar_t</span>* <span class="title">copy</span><span class="params">(<span class="type">const</span> <span class="type">wchar_t</span>* first, <span class="type">const</span> <span class="type">wchar_t</span>* last,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">wchar_t</span>* result)</span> </span>&#123;</span><br><span class="line"><span class="built_in">memmove</span>(result, first, <span class="built_in">sizeof</span>(<span class="type">wchar_t</span>) * (last - first));</span><br><span class="line"><span class="keyword">return</span> result + (last - first);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>copy()函数的泛化版本中调用了一个__copy_dispatch()函数，此函数有一个完全泛化版本和两个篇特化版本：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//完全泛化版本</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>, <span class="keyword">class</span> <span class="title class_">OutputIterator</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__copy_dispatch</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="function">OutputIterator <span class="title">operator</span><span class="params">()</span><span class="params">(InputIterator first, InputIterator last</span></span></span><br><span class="line"><span class="params"><span class="function">OutputIterator result)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> __copy(first, last, result, <span class="built_in">iterator_category</span>(first));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//偏特化版本(1)，两个参数都是T*指针形式</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__copy_dispatch</span>&lt;T*, T*&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="function">T* <span class="title">operator</span><span class="params">()</span><span class="params">(T* first, T* last, T* result)</span> </span>&#123;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">typename</span> __type_traits&lt;T&gt;::has_trivial_assignment_operator t;</span><br><span class="line"><span class="keyword">return</span> <span class="type">__copy_t</span>(first, last, result, <span class="built_in">t</span>());</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//偏特化版本(2)，第一个参数为const T*指针形式，第二参数为T*指针形式</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__copy_dispatch</span>&lt;<span class="type">const</span> T*, T*&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="function">T* <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> T* first, <span class="type">const</span> T* last,T* result)</span> </span>&#123;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">typename</span> __type_traits&lt;T&gt;::has_trivial_assignment_operator t;</span><br><span class="line"><span class="keyword">return</span> <span class="type">__copy_t</span>(first, last, result, <span class="built_in">t</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们先讨论__copy_dispatch()的完全泛化版本，该版本根据迭代器种类的不同，调用了不同的__copy()，原因是不同种类的迭代器所使用的循环条件不同，有快慢之分。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//InputIterator版本</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>, <span class="keyword">class</span> <span class="title class_">OutputIterator</span>&gt;</span><br><span class="line"><span class="keyword">inline</span> OutputIterator __copy(InputIterator first, InputIterator last,</span><br><span class="line">   OutputIterator result, input_iterator_tag)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//以迭代器等同与否，决定循环是否继续。速度慢</span></span><br><span class="line"><span class="keyword">for</span>( ; first != last; ++result, ++first)</span><br><span class="line">*result = *first;<span class="comment">//assignment operator</span></span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//RandomAccessIterator版本</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">RandomAccessIterator</span>, <span class="keyword">class</span> <span class="title class_">OutputIterator</span>&gt;</span><br><span class="line"><span class="keyword">inline</span> OutputIterator </span><br><span class="line">__copy(RandomAccessIterator first, RandomAccessIterator last,</span><br><span class="line">   OutputIterator result, random_access_iterator_tag)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//又划分出一个函数，为的是其它地方也可能用到</span></span><br><span class="line"><span class="keyword">return</span> __copy_d(first, last, result, <span class="built_in">distance_type</span>(first));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">RandomAccessIterato</span>, <span class="keyword">class</span> <span class="title class_">OutputIterator</span>, <span class="keyword">class</span> <span class="title class_">Distance</span>&gt;</span><br><span class="line"><span class="keyword">inline</span> OutputIterator __copy_d(RandomAccessIterator first, RandomAccessIterator last, OutputIterator result, Distance*)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//以n决定循环的执行次数。速度快</span></span><br><span class="line"><span class="keyword">for</span> (Distance n = last - first; n &gt; <span class="number">0</span>; --n, ++result, ++first)</span><br><span class="line">*result = *first;<span class="comment">//assignment operator</span></span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着是两个偏特化版本，通过采用__type_traits&lt;&gt;的技巧来判断对象类别是否具有trivial assignment operator，从而判断是否 可以采用快速的内存对拷方式（memmove()）来拷贝：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//以下版本适用于“指针所指之对象具备trivial assignment operator”</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">inline</span> T* <span class="type">__copy_t</span>(<span class="type">const</span> T* first, <span class="type">const</span> T* last, T* result,</span><br><span class="line">                   __true_type) &#123;</span><br><span class="line"><span class="built_in">memmove</span>(result, first, <span class="built_in">sizeof</span>(T) * (last - first));</span><br><span class="line"><span class="keyword">return</span> result + (last - first);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//以下版本适用于“指针所指之对象具备non-trivial assignment operator”</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">inline</span> T* <span class="type">__copy_t</span>(<span class="type">const</span> T* first, <span class="type">const</span> T* last, T* result,</span><br><span class="line">__false_type) &#123;</span><br><span class="line"><span class="comment">//原生指针毕竟是一种RandomAccessIterator，所以交给__copy_d()完成</span></span><br><span class="line"><span class="keyword">return</span> __copy_d(first, last, result, (<span class="type">ptrdiff_t</span>*)<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="copy-backward"><a href="#copy-backward" class="headerlink" title="copy_backward"></a>copy_backward</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">BidirectionalIterator1</span>, <span class="keyword">class</span> <span class="title class_">BidirectionalIterator2</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> BidirectionalIterator2 <span class="title">copy_backward</span> <span class="params">(Bidirectionallterator1 first,</span></span></span><br><span class="line"><span class="params"><span class="function"> BidirectionalIterator1 last,</span></span></span><br><span class="line"><span class="params"><span class="function">                                             BidirectionalTterator2 result)</span></span>;</span><br></pre></td></tr></table></figure><p>copy_backward()实现技巧与copy()类似。该算法将[first, last) 区间内的每一个元素，以逆行的方向复制到以result - 1为起点，方向亦为逆行的区间上。即，该算法会顺序执行赋值操作*(result - 1) &#x3D; *(last - 1), *(result - 2) &#x3D; *(last - 2),…以此类推。copy_backward()所接受的迭代器必须是BidirectionalIterators。</p><p>copy_backward()同样也需要注意输入空间和输出空间的问题：</p><p><img src="/../img/copy_backward%E5%8C%BA%E9%97%B4%E9%87%8D%E5%8F%A0.png" alt="copy_backward区间重叠"></p><h3 id="set相关算法"><a href="#set相关算法" class="headerlink" title="set相关算法"></a>set相关算法</h3><p>STL一共提供了四种与set相关的算法，分别是并集（union）、交集（intersection）、差集（difference）、对称差集（symmetric difference）。</p><p>这里的适用的的set需要有序，也就是说以hashtable为底层机制实现的set&#x2F;multiset不能应用于这四个算法。</p><h4 id="set-union"><a href="#set-union" class="headerlink" title="set_union"></a>set_union</h4><p>算法set_union可构造S1,S2的并集。S1，S2及其并集都是以排序区间表示。返回值为一个迭代器，指向输出空间的尾端。</p><p>由于S1和S2内的每个元素都不需唯一，因此，如果某个值在S1出现n次，在S2出现 m 次，那么该值在输出区间中会出现max(m,  n)次，其中n个来自S1，其余来自S2。在 STL set容器内，m ≤ 1且n ≤ 1。</p><p>set_union是一种稳定（stable）操作，意思是输人区间内的每个元素的相对顺序都不会改变。set_union有两个版本，差别在于如何定义某个元素小于另一个元素。第一版本使用operator&lt;进行比较，第二版本采用仿函数comp进行比较。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//并集，求存在于[first1, last1)或存在于[first2, last2)的所有元素</span></span><br><span class="line"><span class="comment">//注意，set是一种sorted range。这是以下算法的前提</span></span><br><span class="line"><span class="comment">//版本一</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator1</span>, <span class="keyword">class</span> <span class="title class_">InputIterator2</span>, <span class="keyword">class</span> <span class="title class_">OutputIterator</span>&gt;</span><br><span class="line"><span class="function">OutputIterator <span class="title">set_union</span><span class="params">(InputIterator1 first1, InputIterator1 last1,</span></span></span><br><span class="line"><span class="params"><span class="function">   InputIterator2 first2, InputIterator2 last2,</span></span></span><br><span class="line"><span class="params"><span class="function">                         OutputIterator result)</span> </span>&#123;</span><br><span class="line"><span class="comment">//当两个区间都尚未到达尾端时，执行以下操作...</span></span><br><span class="line"><span class="keyword">while</span> (first1 ! = last1 &amp;&amp; first2 != last2) &#123;</span><br><span class="line"><span class="comment">//在两区间内分别移动迭代器。首先将元素值较小者(假设为A区)记录于目标区,</span></span><br><span class="line"><span class="comment">//然后移动A区迭代器使之前进;同时间之另一个区迭代器不动。然后进行新一次</span></span><br><span class="line"><span class="comment">//的比大小、记录小值、迭代器移动…直到两区中有一区到达尾端。如果元素相等,</span></span><br><span class="line"> <span class="comment">//取S1者记录于目标区，并同时移动两个迭代器</span></span><br><span class="line"><span class="keyword">if</span> (*first1 &lt; *first2) &#123;</span><br><span class="line">*result = *first1;</span><br><span class="line">++first1;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (*first2 &lt; *first1) &#123;</span><br><span class="line">*result = *first2;</span><br><span class="line">++first2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;<span class="comment">// *first2 == *first1</span></span><br><span class="line">*result = *first1;</span><br><span class="line">++first1;</span><br><span class="line">++first2;</span><br><span class="line">&#125;</span><br><span class="line">++result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//只要两区之中有一区到达尾端，就结束上述的while循环</span></span><br><span class="line">    <span class="comment">//以下将尚未到达尾端的区间的所有剩余元素拷贝到目的端</span></span><br><span class="line"><span class="comment">//此刻的[first1, last1)和[first2, last2)之中有一个是空白区间</span></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">copy</span>(first2, last2, <span class="built_in">copy</span>(first1, last1, result));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="set-intersection"><a href="#set-intersection" class="headerlink" title="set_intersection"></a>set_intersection</h4><p>算法set_intersection可构造S1,S2之交集。S1，S2及其交集都是以排序区间表示。返回值为一个迭代器，指向输出空间的尾端。</p><p>由于S1和S2内的每个元素都不需唯一，因此，如果某个值在S1出现n次，在S2出现m次，那么该值在输出区间中会出现min(m, n)次，并且全部来自S1。在STL set容器内，m ≤ 1 且n ≤ 1。</p><p>set_intersection是一种稳定（stable）操作，意思是输出区间内的每个元素的相对顺序都和S1内的相对顺序相同。它有两个版本，差别在于如何定义某个元素小于另一个元素。第一版本使用operator&lt;进行比较，第二版本采用仿函数comp进行比较。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//交集，求存在于[first1, last1)且存在于[first2, last2)的所有元素</span></span><br><span class="line"><span class="comment">//注意，set是一种sorted range。这是以下算法的前提</span></span><br><span class="line"><span class="comment">//版本一</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator1</span>, <span class="keyword">class</span> <span class="title class_">InputIterator2</span>, <span class="keyword">class</span> <span class="title class_">OutputIterator</span>&gt;</span><br><span class="line"><span class="function">OutputIterator <span class="title">set_intersection</span><span class="params">(InputIterator1 first1, InputIterator1 last1,</span></span></span><br><span class="line"><span class="params"><span class="function"> InputIterator2 first2, InputIterator2 last2,</span></span></span><br><span class="line"><span class="params"><span class="function">                                OutputIterator result)</span> </span>&#123;</span><br><span class="line"><span class="comment">//当两个区间都尚未到达尾端时，执行以下操作...</span></span><br><span class="line"><span class="keyword">while</span> (first1 != last1 &amp;&amp; first2 != last2)</span><br><span class="line"><span class="comment">//在两区间内分别移动迭代器，直到遇有元素值相同，暂停，将该值记录于目标区，</span></span><br><span class="line"><span class="comment">//再继续移动迭代器...直到两区之中有一区到达尾端</span></span><br><span class="line"><span class="keyword">if</span> (*first1 &lt; *first2)</span><br><span class="line">++first1;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (*first2 &lt; *first1)</span><br><span class="line">++first2;</span><br><span class="line"><span class="keyword">else</span> &#123; <span class="comment">//*first2 == *first1</span></span><br><span class="line">*result = *first1;</span><br><span class="line">++first1;</span><br><span class="line">++first2;</span><br><span class="line">++result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="set-difference"><a href="#set-difference" class="headerlink" title="set_difference"></a>set_difference</h4><p>算法set_difference可构造S1、S2之差集。S1、S2及其差集都是以排序区间表示。返回值为一个迭代器，指向输出区间的尾端。</p><p>由于S1和S2内的每个元素都不需唯一，因此如果某个值在S1出现n次，在S2出现m次，那么该值在输出区间中会出现max(n-m, 0)次，并且全部来自s1。在STL set容器内，m ≤ 1 且n ≤ 1。</p><p>set_difference是一种稳定（stable）操作，意思是输出区间内的每个元素的相对顺序都和S1内的相对顺序相同。它有两个版本，差别在于如何定义某个元素小于另一个元素。第一版本使用operator&lt;进行比较，第二版本采用仿函数comp进行比较。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//差集，求存在于[first1, last1)且不存在于[first2, last2)的所有元素</span></span><br><span class="line"><span class="comment">//注意，set是一种sorted range。这是以下算法的前提</span></span><br><span class="line"><span class="comment">//版本一</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator1</span>, <span class="keyword">class</span> <span class="title class_">InputIterator2</span>, <span class="keyword">class</span> <span class="title class_">OutputIterator</span>&gt;</span><br><span class="line"><span class="function">OutputIterator <span class="title">set_difference</span><span class="params">(InputIterator1 first1, InputIterator1 last1,</span></span></span><br><span class="line"><span class="params"><span class="function">    InputIterator2 first2, InputIterator2 last2,</span></span></span><br><span class="line"><span class="params"><span class="function">    OutputIterator result)</span> </span>&#123;</span><br><span class="line"><span class="comment">//当两个区间都尚未到达尾端时，执行以下操作...</span></span><br><span class="line"><span class="keyword">while</span> (first1 != last1 &amp;&amp; first2 != last2)</span><br><span class="line"><span class="comment">//在两区间内分别移动迭代器。当第一区间的元素等于第二区间的元素(表示此值</span></span><br><span class="line"><span class="comment">//同时存在于两区间)，就让两区间同时前进;当第一区间的元素大于第二区间的元素，</span></span><br><span class="line"><span class="comment">//就让第二区间前进;有了这两种处理，就保证当第一区间的元素小于第二区间的</span></span><br><span class="line"><span class="comment">//元素时，第一区间的元素只存在于第一区间中，不存在于第二区间，于是将它</span></span><br><span class="line"><span class="comment">//记录于目标区</span></span><br><span class="line"><span class="keyword">if</span> (*first1 &lt; *first2) &#123;</span><br><span class="line">*result = *first1;</span><br><span class="line">++first1;</span><br><span class="line">++result;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (*first2 &lt; *first1) </span><br><span class="line">++first2;</span><br><span class="line"><span class="keyword">else</span> &#123; <span class="comment">// *first2 == *first1</span></span><br><span class="line">++first1;</span><br><span class="line">++first2;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">copy</span>(first1, last1, result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="set-symmetric-difference"><a href="#set-symmetric-difference" class="headerlink" title="set_symmetric_difference"></a>set_symmetric_difference</h4><p>算法set_symmetric_difference可构造S1、S2之对称差集。此集合内含“出现于S1但不出现于S2”以及“出现于S2但不出现于S1”的每一个元素。S1、S2及其交集都是以排序区间表示。返回值为一个迭代器，指向输出区间的尾端。</p><p>由于S1和S2内的每个元素都不需唯一，因此如果某个值在S1出现n次，在S2出现m次，那么该值在输出区间中会出现ln-ml次。如果n &gt; m，输出区间内的最后n-m个元素将由S1复制而来，如果n &lt; m则输出区间内的最后m-n个元素将由s2复制而来。在STL set容器内，m ≤ 1 且n ≤ 1。</p><p>set_symmetric_difference是一种稳定（stable）操作，意思是输入区间内的元素相对顺序不会被改变。它有两个版本，差别在于如何定义某个元素小于另一个元素。第一版本使用operator&lt;进行比较，第二版本采用仿函数comp。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对称差集，求存在于[first1, last1)且不存在于[first2, last2)的所有元素，</span></span><br><span class="line"><span class="comment">//以及存在于[first2, last2)且不存在于[first1, last1)的所有元素</span></span><br><span class="line"><span class="comment">//注意，上述定义只有在“元素值独一无二”的情况下才成立。如果将set一般化，</span></span><br><span class="line"><span class="comment">//允许出现重复元素，那么set-symmetric-difference的定义应该是:</span></span><br><span class="line"><span class="comment">//如果某值在[first1, last1)出现n次，在[first2, last2)出现m次，</span></span><br><span class="line"><span class="comment">//那么它在result range中应该出现abs(n-m)次</span></span><br><span class="line"><span class="comment">//注意，set是一种sorted range。这是以下算法的前提</span></span><br><span class="line"><span class="comment">//版本一</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator1</span>, <span class="keyword">class</span> <span class="title class_">InputIterator2</span>, <span class="keyword">class</span> <span class="title class_">OutputIterator</span>&gt;</span><br><span class="line"><span class="function">OutputIterator <span class="title">set_symmetric_difference</span><span class="params">(InputIterator1 first1,</span></span></span><br><span class="line"><span class="params"><span class="function"> InputIterator1 lastl,</span></span></span><br><span class="line"><span class="params"><span class="function"> InputIterator2 first2,</span></span></span><br><span class="line"><span class="params"><span class="function"> InputIterator2 last2,</span></span></span><br><span class="line"><span class="params"><span class="function"> OutputIterator result)</span> </span>&#123;</span><br><span class="line"><span class="comment">//当两个区间都尚未到达尾端时，执行以下操作...</span></span><br><span class="line"><span class="keyword">while</span> (first1 != last1 &amp;&amp; first2 != last2)</span><br><span class="line"><span class="comment">//在两区间内分别移动迭代器。当两区间内的元素相等，就让两区同时前进；</span></span><br><span class="line"><span class="comment">//当两区间内的元素不等，就记录较小值于目标区，并令较小值所在区间前进</span></span><br><span class="line"><span class="keyword">if</span> (*first1 &lt; *first2) &#123;</span><br><span class="line">*result = *first1;</span><br><span class="line">++first1;</span><br><span class="line">++result;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (*first2 &lt; *first1) &#123;</span><br><span class="line">*result = *first2;</span><br><span class="line">++first2;</span><br><span class="line">++result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;<span class="comment">// *first2 == *first1</span></span><br><span class="line">++first1;</span><br><span class="line">++first2;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">copy</span>(first2, last2, <span class="built_in">copy</span>(first1, last1, result));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="其它算法"><a href="#其它算法" class="headerlink" title="其它算法"></a>其它算法</h3><h4 id="单纯的数据处理"><a href="#单纯的数据处理" class="headerlink" title="单纯的数据处理"></a>单纯的数据处理</h4><h5 id="adjacent-find"><a href="#adjacent-find" class="headerlink" title="adjacent_find"></a>adjacent_find</h5><p>找出第一组满足条件的相邻元素。这里的条件，在版本一中是指“两元素相等”，在版本二中允许用户指定一个二元运算，两个操作数分别是相邻的第一元素和第二元素。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//查找相邻的重复元素。版本一</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">ForwardIterator</span>&gt;</span><br><span class="line"><span class="function">ForwardIterator <span class="title">adjacent_find</span><span class="params">(ForwardIterator first, ForwardIterator last)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (first == last) <span class="keyword">return</span> last;</span><br><span class="line">ForwardIterator next = first;</span><br><span class="line"><span class="keyword">while</span> (++next != last) &#123;</span><br><span class="line"><span class="keyword">if</span> (*first == *next) <span class="keyword">return</span> first; <span class="comment">//如果找到相邻的元素值相同，就结束</span></span><br><span class="line">first = next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> last;</span><br><span class="line">&#125;</span><br><span class="line">                              </span><br><span class="line"><span class="comment">//查找相邻的重复元素。版本二</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">ForwardIterator</span>, <span class="keyword">class</span> <span class="title class_">BinaryPredicate</span>&gt;</span><br><span class="line"><span class="function">ForwardIterator <span class="title">adjacent_find</span><span class="params">(ForwardIterator first, ForwardIterator last,</span></span></span><br><span class="line"><span class="params"><span class="function">                              BinaryPredicate binary_pred)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (first == last) <span class="keyword">return</span> last;</span><br><span class="line">ForwardIterator next = first;</span><br><span class="line"><span class="keyword">while</span> (++next != last) &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">binary_pred</span>(*first, *next)) <span class="keyword">return</span> first;</span><br><span class="line">first = next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> last;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="count"><a href="#count" class="headerlink" title="count"></a>count</h5><p>运用equality操作符，将[first, last)区间内的每一个元素拿来和指定值value比较，并返回与value相等的元素个数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>, <span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">typename</span> iterator_traits&lt;InputIterator&gt;::<span class="function">difference_type</span></span><br><span class="line"><span class="function"><span class="title">count</span><span class="params">(InputIterator first, InputIterator last, <span class="type">const</span> T&amp; value)</span> </span>&#123;</span><br><span class="line"><span class="comment">//以下声明一个计数器n</span></span><br><span class="line"><span class="keyword">typename</span> iterator_traits&lt;InputIterator&gt;::difference_type n = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> ( ; first != last; ++first)<span class="comment">//整个区间走一遍</span></span><br><span class="line"><span class="keyword">if</span> (*first == value)   <span class="comment">//如果元素值和value相等</span></span><br><span class="line">++n;  <span class="comment">//计数器累加1</span></span><br><span class="line"><span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="count-if"><a href="#count-if" class="headerlink" title="count_if"></a>count_if</h5><p>将指定操作（一个仿函数）pred实施于[first, last)区间内的每一个元素身上，并将“造成pred之计算结果为true”的所有元素的个数返回。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>, <span class="keyword">class</span> <span class="title class_">Predicates</span>&gt;</span><br><span class="line"><span class="keyword">typename</span> iterator_traits&lt;InputIterator&gt;::<span class="function">difference_type</span></span><br><span class="line"><span class="function"><span class="title">count_if</span><span class="params">(InputIterator first, InputIterator last, Predicate pred)</span> </span>&#123;</span><br><span class="line"><span class="comment">//以下声明一个计数器n</span></span><br><span class="line"><span class="keyword">typename</span> iterator_traits&lt;InputIterator&gt;::difference_type n = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> ( ; first != last; ++first)<span class="comment">//整个区间走一遍</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">pred</span>(*first))<span class="comment">//如果元素带入pred的运算结果为true</span></span><br><span class="line">++n;<span class="comment">//计数器累加1</span></span><br><span class="line"><span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="find"><a href="#find" class="headerlink" title="find"></a>find</h5><p>根据equality操作符，循序查找[first, last)内的所有元素，找出第一个匹配“等同(equality)条件”者。如果找到，就返回一个InputIterator指向该元素，否则返回迭代器last。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>, <span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function">InputIterator <span class="title">find</span><span class="params">(InputIterator first, InputIterator last,</span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="type">const</span> T&amp; value)</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span> (first != last &amp;&amp; *first != value) ++first;</span><br><span class="line"><span class="keyword">return</span> first;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="find-if"><a href="#find-if" class="headerlink" title="find_if"></a>find_if</h5><p>根据指定的pred运算条件（以仿函数表示），循序查找[first, last)内的所有元素，找出第一个令pred运算结果为true者。如果找到就返回InputIterator指向该元素，否则返回迭代器last。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>, <span class="keyword">class</span> <span class="title class_">Predicate</span>&gt;</span><br><span class="line"><span class="function">InputIterator <span class="title">find_if</span><span class="params">(InputIterator first, InputIterator last,</span></span></span><br><span class="line"><span class="params"><span class="function">     Predicate pred)</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span> (first != last &amp;&amp; !<span class="built_in">pred</span>(*first)) ++first;</span><br><span class="line"><span class="keyword">return</span> first;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="find-end"><a href="#find-end" class="headerlink" title="find_end"></a>find_end</h5><p>在序列一[first1, last1)所涵盖的区间中，查找序列二[first2, last2)的最后一次出现点。如果序列一之内不存在“完全匹配序列二”的子序列，便返回迭代器last1。此算法有两个版本，版本一使用元素型别所提供的equality操作符，版本二允许用户指定某个二元运算（以仿函数呈现），作为判断元素相等与否的依据。</p><p>由于这个算法查找的是“最后一次出现地点”，如果我们有能力逆向查找，题目就变成了“首次出现地点”，那对设计者而言当然比较省力。逆向查找的关键在于迭代器的双向移动能力，因此，SGI将算法设计为双层架构，一般称呼此种上层函数为dispatch function（分派函数、派送函数）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//版本一</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">ForwardIterator1</span>, <span class="keyword">class</span> <span class="title class_">ForwardIterator2</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ForwardIterator1</span></span><br><span class="line"><span class="function"><span class="title">find_end</span><span class="params">(ForwardIterator1 first1, ForwardIterator1 last1,</span></span></span><br><span class="line"><span class="params"><span class="function"> ForwardIterator2 first2, ForwardIterator2 last2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">typename</span> iterator_traits&lt;ForwardIterator1&gt;::iterator_category category1;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">typename</span> iterator_traits&lt;ForwardIterator2&gt;::iterator_category</span><br><span class="line">  category2;</span><br><span class="line"></span><br><span class="line"><span class="comment">//以下根据两个区间的类属，调用不同的下层函数</span></span><br><span class="line"><span class="keyword">return</span> __find_end(first1, last1, first2, last2, <span class="built_in">category1</span>(), <span class="built_in">category2</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是一种常见的技巧，令函数传递调用过程中产生迭代器类型（iterator category）的临时对象，再利用编译器的参数推导机制（argument deduction)，自动调用某个对应函数。此例之对应函数有两个候选者：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以下是forward iterators版</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">ForwardIterator1</span>, <span class="keyword">class</span> <span class="title class_">ForwardIterator2</span>&gt;</span><br><span class="line">ForwardIterator1 __find_end(ForwardIterator1 first1, ForwardIterator1 last1,</span><br><span class="line"> ForwardIterator2 first2, ForwardIterator2 last2,</span><br><span class="line"> forward_iterator_tag, forward_iterator_tag)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (first2 == last2)<span class="comment">//如果查找目标是空的，</span></span><br><span class="line"><span class="keyword">return</span> last1;<span class="comment">//返回last1，表示该“空子序列”的最后出现点</span></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">ForwardIterator1 result = last1;</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line"><span class="comment">//以下利用search()查找某个子序列的首次出现点。找不到的话返回last1</span></span><br><span class="line">Forwardlterator1 new_result = <span class="built_in">search</span>(first1, last1, first2, last2);</span><br><span class="line"><span class="keyword">if</span> (new_result == last1)<span class="comment">//没找到</span></span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">result = new_result;<span class="comment">//调动一下标兵，准备下一个查找行动</span></span><br><span class="line">first1 = new_result;</span><br><span class="line">++first1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下是bidirectional iterators版（可以逆向查找）</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">BidirectionalIterator1</span>, <span class="keyword">class</span> <span class="title class_">BidirectionalIterator2</span>&gt;</span><br><span class="line">BidirectionalIterator1</span><br><span class="line">__find_end(BidirectionalIterator1 first1, BidirectionalIterator1 last1,</span><br><span class="line">  BidirectionalIterator1 first2, BidirectionalIterator2 last2,</span><br><span class="line">  bidirectional_iterator_tag, bidirectional_iterator_tag)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//由于查找的是“最后出现地点”，因此反向查找比较快。利用reverse_iterator。</span></span><br><span class="line">    <span class="keyword">typedef</span> reverse_iterator&lt;BidirectionalIterator1&gt; reviter1;</span><br><span class="line">    <span class="keyword">typedef</span> reverse_iterator&lt;BidirectionalIterator2&gt; reviter2;</span><br><span class="line">    </span><br><span class="line">    <span class="function">reviter1 <span class="title">rlast1</span><span class="params">(first1)</span></span>;</span><br><span class="line">    <span class="function">reviter2 <span class="title">rlast2</span><span class="params">(first2)</span></span>;</span><br><span class="line">    <span class="comment">//查找时，将序列一和序列二统统逆转方向</span></span><br><span class="line">    reviter1 rresult = <span class="built_in">search</span>(<span class="built_in">reviter1</span>(last1), rlast1,</span><br><span class="line">                              <span class="built_in">reviter2</span>(last2), rlast2);</span><br><span class="line"><span class="keyword">if</span> (rresult == rlast1)<span class="comment">//没找到</span></span><br><span class="line"><span class="keyword">return</span> last1;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">BidirectionalIterator1 result = rresult.<span class="built_in">base</span>(); <span class="comment">//转回正常（非逆向）迭代器</span></span><br><span class="line"><span class="built_in">advance</span>(result, -<span class="built_in">distance</span>(first2, last2)); <span class="comment">//调整回到子序列的起点处</span></span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="find-first-of"><a href="#find-first-of" class="headerlink" title="find_first_of"></a>find_first_of</h5><p>本算法以[first2, last2)区间内的<strong>某些元素</strong>作为查找目标，寻找它们在[first1, last1)区间内的第一次出现地点。如果第一序列并未内含第二序列的任何元素，返回的将是last1。本算法第一个版本使用元素型别所提供的equality操作符，第二个版本允许用户指定一个二元运算pred。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//版本一</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>, <span class="keyword">class</span> <span class="title class_">ForwardIterator</span>&gt;</span><br><span class="line"><span class="function">InputIterator <span class="title">find_first_of</span> <span class="params">(InputIterator first1, InputIterator last1,</span></span></span><br><span class="line"><span class="params"><span class="function">   ForwardIterator first2, ForwardIterator last2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> ( ; first1 != last1; ++first1) <span class="comment">//遍访序列一</span></span><br><span class="line"><span class="comment">//以下，根据序列二的每个元素</span></span><br><span class="line"><span class="keyword">for</span> (ForwardIterator iter = first2; iter != last2; ++iter)</span><br><span class="line"><span class="keyword">if</span> (*first1 == *iter)<span class="comment">//如果序列一的元素等于序列二的元素</span></span><br><span class="line"><span class="keyword">return</span> first1;    <span class="comment">//找到了，结束</span></span><br><span class="line"><span class="keyword">return</span> last1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//版本二</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>, <span class="keyword">class</span> <span class="title class_">ForwardIterator</span>, <span class="keyword">class</span> <span class="title class_">BinaryPredicate</span>&gt;</span><br><span class="line"><span class="function">InputIterator <span class="title">find_first_of</span> <span class="params">(InputIterator first1, InputIterator last1,</span></span></span><br><span class="line"><span class="params"><span class="function">   ForwardIterator first2, ForwardIterator last2,</span></span></span><br><span class="line"><span class="params"><span class="function">                             BinaryPredicate comp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> ( ; first1 != last1; ++first1) <span class="comment">//遍访序列一</span></span><br><span class="line"><span class="comment">//以下，根据序列二的每个元素</span></span><br><span class="line"><span class="keyword">for</span> (ForwardIterator iter = first2; iter != last2; ++iter)</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">comp</span>(*first1, *iter)) <span class="comment">//如果序列一和序列二的元素满足comp条件</span></span><br><span class="line"><span class="keyword">return</span> first1; <span class="comment">//找到了，结束</span></span><br><span class="line"><span class="keyword">return</span> last1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="for-each"><a href="#for-each" class="headerlink" title="for_each"></a>for_each</h5><p>将仿函数f施行于[first, last)区间内的每一个元素身上。f不可以改变元素内容，因为first和last都是Inputlterators，不保证接受赋值行为(assignment)。如果想要一一修改元素内容，应该使用算法transform ( )。f可返回一个值，但该值会被忽略。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>, <span class="keyword">class</span> <span class="title class_">Function</span>&gt;</span><br><span class="line"><span class="function">Function <span class="title">for_each</span> <span class="params">(InputIterator first, InputIterator last, Function f)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> ( ; first != last; ++first)</span><br><span class="line"><span class="built_in">f</span>(*first);<span class="comment">//调用仿函数f的function call操作符。返回值被忽略</span></span><br><span class="line"><span class="keyword">return</span> f;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="generate"><a href="#generate" class="headerlink" title="generate"></a>generate</h5><p>将仿函数gen的运算结果填写在[first, last)区间内的所有元素身上。所谓填写，用的是迭代器所指元素之assignment操作符。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">ForwardIterator</span>, <span class="keyword">class</span> <span class="title class_">Generator</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">generate</span><span class="params">(ForwardIterator first, ForwardIterator last, Generator gen &#123;</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">for</span> ( ; first != last; ++first)<span class="comment">//整个序列区间</span></span></span></span><br><span class="line"><span class="params"><span class="function">*first = gen();</span></span></span><br><span class="line"><span class="params"><span class="function">&#125;</span></span></span><br></pre></td></tr></table></figure><h5 id="generate-n"><a href="#generate-n" class="headerlink" title="generate_n"></a>generate_n</h5><p>将仿函数gen的运算结果填写在从first开始的n个元素身上，所谓填写，用的是迭代器所指元素的assignment操作符。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">OutputIterator</span>, <span class="keyword">class</span> <span class="title class_">Size</span>, <span class="keyword">class</span> <span class="title class_">Generator</span>&gt;</span><br><span class="line"><span class="function">OutputIterator <span class="title">generate_n</span> <span class="params">(outputIterator first, Size n, Generator gen)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> ( ; n &gt; <span class="number">0</span>; --n, ++first)<span class="comment">//只限n个元素</span></span><br><span class="line">*first = <span class="built_in">gen</span>();</span><br><span class="line"><span class="keyword">return</span> first;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="includes（应用于有序区间）"><a href="#includes（应用于有序区间）" class="headerlink" title="includes（应用于有序区间）"></a>includes（应用于有序区间）</h5><p>该算法判断序列二S2是否“涵盖于”序列一S1。S1和S2都必须是有序集合，其中的元素可重复（假设某元素在S2出现n次，在S1出现m次，那么如果m &lt; n，此算法会返回false）。</p><p>由于判断两个元素是否相等，必须以less或greater运算为依据（当S1元素不小于S2元素且S2元素不小于S1元素，两者即相等；或说当S1元素不大于S2元素且S2元素不大于S1元素，两者即相等），因此配合着两个序列S1和S2的排序方式（递增或递减)，includes算法可供用户选择采用less或greater进行两元素的大小比较(comparison) 。</p><p>如果S1和S2是递增排序（以operator&lt;执行比较操作），includes算法应该这么使用：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">includes</span>(S1.<span class="built_in">begin</span>(), S1.<span class="built_in">end</span>(), S2.<span class="built_in">begin</span>(), S2.<span class="built_in">end</span>());</span><br></pre></td></tr></table></figure><p>这和下一行完全相同：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">includes</span>(S1.<span class="built_in">begin</span>(), S1.<span class="built_in">end</span>(), S2.<span class="built_in">begin</span>(), S2.<span class="built_in">end</span>(), <span class="built_in">less</span>&lt;<span class="type">int</span>&gt;();</span><br></pre></td></tr></table></figure><p>然而如果S1和S2是递减排序（以operator&gt;执行比较操作），includes算法应该这么使用:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">includes</span>(S1.<span class="built_in">begin</span>(), S1.<span class="built_in">end</span>(), S2.<span class="built_in">begin</span>(), S2.<span class="built_in">end</span>(), <span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;());</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//版本一。判断区间二的每个元素值是否都存在于区间一</span></span><br><span class="line"><span class="comment">//前提:区间一和区间二都是sorted ranges</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator1</span>, <span class="keyword">class</span> <span class="title class_">InputIterator2</span>&gt;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">includes</span> <span class="params">(InputIterator1 first1, InputIterator1 last1,</span></span></span><br><span class="line"><span class="params"><span class="function"> InputIterator2 first2, InputIterator2 last2)</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span> (first1 != last1 &amp;&amp; first2 != last2) <span class="comment">//两个区间都尚未走完</span></span><br><span class="line"><span class="keyword">if</span> (*first2 &lt; *first1)<span class="comment">//序列二的元素小于序列一的元素</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;   <span class="comment">//“涵盖”的情况必然不成立。结束执行</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (*first1 &lt; *first2)      <span class="comment">//序列二的元素大于序列一的元素</span></span><br><span class="line">++first1;   <span class="comment">//序列一前进1</span></span><br><span class="line"><span class="keyword">else</span>    <span class="comment">//* first1 == * first2</span></span><br><span class="line">++first1, ++first2;<span class="comment">//两序列各自前进1</span></span><br><span class="line"><span class="keyword">return</span> first2 == last2;<span class="comment">//有一个序列走完了，判断最后一关</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//版本二。判断序列一内是否有个子序列，其与序列二的每个对应元素都满足二元运算comp</span></span><br><span class="line"><span class="comment">//前提：序列一和序列二都是sorted ranges</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> InputIterator1, <span class="keyword">class</span> InputIterator2, <span class="keyword">class</span> Compare&gt;</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">includes</span> <span class="params">(InputIterator1 first1, InputIterator1 last1,</span></span></span><br><span class="line"><span class="params"><span class="function">    InputIterator2 first2, InputIterator2 last2, Compare comp)</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span> (first1 != last1 &amp;&amp; first2 != last2)<span class="comment">//两个区间都尚未走完</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">comp</span>(*first2, *first1))<span class="comment">//comp(s2元素,s1元素)为真</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;   <span class="comment">//“涵盖”的情况必然不成立。结束执行</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">comp</span>(*first1, *first2)) <span class="comment">//comp(s1元素,s2元素)为真</span></span><br><span class="line">++first1; <span class="comment">//S1前进1</span></span><br><span class="line"><span class="keyword">else</span>    <span class="comment">//*first1 == *first2</span></span><br><span class="line">++first1, ++first2; <span class="comment">//S1,S2各自前进1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> first2 == last2;<span class="comment">//有一个序列走完了，判断最后一关</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="max-element"><a href="#max-element" class="headerlink" title="max_element"></a>max_element</h5><p>该算法返回一个迭代器，指向序列之中数值最大的元素。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//版本一</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">ForwardIterator</span>&gt;</span><br><span class="line"><span class="function">ForwardIterator <span class="title">max_element</span><span class="params">(ForwardIterator first, ForwardIterator last)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (first == last) <span class="keyword">return</span> first;</span><br><span class="line">ForwardIterator result = first;</span><br><span class="line"><span class="keyword">while</span> (++first != last)</span><br><span class="line"><span class="keyword">if</span> (*result &lt; *first) result = first; <span class="comment">//如果目前元素比较大，就登记起来</span></span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//版本二</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">ForwardIterator</span>, <span class="keyword">class</span> <span class="title class_">Compare</span>&gt;</span><br><span class="line"><span class="function">ForwardIterator <span class="title">max_element</span><span class="params">(ForwardIterator first, ForwardIterator last,</span></span></span><br><span class="line"><span class="params"><span class="function">  Compare comp)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (first == last) <span class="keyword">return</span> first;</span><br><span class="line">ForwardIterator result = first;</span><br><span class="line"><span class="keyword">while</span> (++first != last)</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">comp</span>(*result, *first)) result = first;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="merge（应用于有序区间）"><a href="#merge（应用于有序区间）" class="headerlink" title="merge（应用于有序区间）"></a>merge（应用于有序区间）</h5><p>该算法将两个已经排序的集合S1和S2，合并起来置于另一段空间。所得结果也是一个有序（sorted）序列 。返回一个迭代器，指向最后结果序列的最后一个元素的下一位置。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//版本一</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator1</span>, <span class="keyword">class</span> <span class="title class_">InputIterator2</span>, <span class="keyword">class</span> <span class="title class_">OutputIterator</span>&gt;</span><br><span class="line"><span class="function">OutputIterator <span class="title">merge</span><span class="params">(InputIterator1 first1, InputIterator1 last1,</span></span></span><br><span class="line"><span class="params"><span class="function">   InputIterator2 first2, InputIterator2 last2,    OutputIterator result)</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span> (first1 != last1 &amp;&amp; first2 != last2) &#123;  <span class="comment">// 两个序列都尚未走完</span></span><br><span class="line"><span class="keyword">if</span> (*first2 &lt; *first1) &#123;<span class="comment">//序列二的元素比较小</span></span><br><span class="line">*result = *first2;    <span class="comment">//登记序列二的元素</span></span><br><span class="line">++first2;   <span class="comment">//序列二前进1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;   <span class="comment">//序列二的元索不比较小</span></span><br><span class="line">*result = *first1;    <span class="comment">//登记序列一的元素</span></span><br><span class="line">++first1;   <span class="comment">//序列一前进1</span></span><br><span class="line">&#125;</span><br><span class="line">++result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//最后剩余元素以copy复制到目的端。以下两个序列一定至少有一个为空</span></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">copy</span>(first2, last2, <span class="built_in">copy</span>(first1, last1, result));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//版本二</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator1</span>, <span class="keyword">class</span> <span class="title class_">InputIterator2</span>, <span class="keyword">class</span> <span class="title class_">OutputIterator</span>,</span><br><span class="line"> <span class="keyword">class</span> <span class="title class_">Compare</span>&gt;</span><br><span class="line"><span class="function">OutputIterator <span class="title">merge</span><span class="params">(InputIterator1 first1, InputIterator1 last1,</span></span></span><br><span class="line"><span class="params"><span class="function">        InputIterator2 first2, InputIterator2 last2,</span></span></span><br><span class="line"><span class="params"><span class="function">    OutputIterator result, Compare comp)</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span> (first1 != last1 &amp;&amp; first2 != last2) &#123; <span class="comment">//两个序列都尚未走完</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">comp</span>(*first2, *first1)) &#123;<span class="comment">//比较两序列的元素</span></span><br><span class="line">*result = *first2;   <span class="comment">//登记序列二的元素</span></span><br><span class="line">++first2;  <span class="comment">//序列二前进1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">*result = *first1;   <span class="comment">//登记序列一的元素</span></span><br><span class="line">++first1;  <span class="comment">//序列一前进1</span></span><br><span class="line">&#125;</span><br><span class="line">++result;</span><br><span class="line"><span class="comment">//最后剩余元素以copy复制到目的端。以下两个序列一定至少有一个为空</span></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">copy</span>(first2, last2, <span class="built_in">copy</span>(first1, last1, result));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="min-element"><a href="#min-element" class="headerlink" title="min_element"></a>min_element</h5><p>该算法返回一个迭代器，指向序列之中数值最小的元素。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//版本一</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">ForwardIterator</span>&gt;</span><br><span class="line"><span class="function">ForwardIterator <span class="title">min_element</span><span class="params">(ForwardIterator first, ForwardIterator last)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (first == last) <span class="keyword">return</span> first;</span><br><span class="line">ForwardIterator result = first;</span><br><span class="line"><span class="keyword">while</span> (++first != last)</span><br><span class="line"><span class="keyword">if</span> (*first &lt; *result) result = first; <span class="comment">//如果目前元素比较小，就登记起来</span></span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//版本一</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">ForwardIterator</span>, <span class="keyword">class</span> <span class="title class_">Compare</span>&gt;</span><br><span class="line"><span class="function">ForwardIterator <span class="title">min_element</span><span class="params">(ForwardIterator first, ForwardIterator last,</span></span></span><br><span class="line"><span class="params"><span class="function">                           Compare comp)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (first == last) <span class="keyword">return</span> first;</span><br><span class="line">ForwardIterator result = first;</span><br><span class="line"><span class="keyword">while</span> (++first != last)</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">comp</span>(*first, *result)) result = first; <span class="comment">//如果目前元素比较小，就登记起来</span></span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="partition"><a href="#partition" class="headerlink" title="partition"></a>partition</h5><p>该算法会将区间[first, last)中的元素重新排列。所有被一元条件运算符pred判定为true的元素，都会被放在区间的前端，被判定为false的元素，都会被放在区间的后端。这个算法并不保证保留元素的原始相对位置。如果需要保留原始相对位置，应使用stable_partition。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//所有被pred判定为true的元素，都被放到前段</span></span><br><span class="line"><span class="comment">//被pred判定为false的元素，都被放到后段</span></span><br><span class="line"><span class="comment">//不保证保留原相对位置。(not stable)</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">BidirectionalIterator</span>, <span class="keyword">class</span> <span class="title class_">Predicate</span>&gt;</span><br><span class="line"><span class="function">BidirectionalIterator <span class="title">partition</span> <span class="params">(BidirectionalIterator first,</span></span></span><br><span class="line"><span class="params"><span class="function">  BidirectionalIterator last,</span></span></span><br><span class="line"><span class="params"><span class="function">                                 Predicate pred)</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line"><span class="keyword">if</span> (first == last)<span class="comment">//头指针等于尾指针</span></span><br><span class="line"><span class="keyword">return</span> first;<span class="comment">//所有操作结束</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">pred</span>(*first)) <span class="comment">//头指针所指的元素符合不移动条件</span></span><br><span class="line">++first;    <span class="comment">//不移动：头指针前进1</span></span><br><span class="line"><span class="keyword">else</span>    <span class="comment">//头指针所指元素符合移动条件</span></span><br><span class="line"><span class="keyword">break</span>;<span class="comment">//跳出循环</span></span><br><span class="line">--last;        <span class="comment">//尾指针回溯1</span></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line"><span class="keyword">if</span> (first == last)<span class="comment">//头指针等于尾指针</span></span><br><span class="line"><span class="keyword">return</span> first;<span class="comment">//所有操作结束</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">pred</span>(*last)) <span class="comment">//尾指针所指的元素符合不移动条件</span></span><br><span class="line">--last;    <span class="comment">//不移动：尾指针回溯1</span></span><br><span class="line"><span class="keyword">else</span>    <span class="comment">//尾指针所指元素符合移动条件</span></span><br><span class="line"><span class="keyword">break</span>;<span class="comment">//跳出循环</span></span><br><span class="line"><span class="built_in">iter_swap</span>(first, last);  <span class="comment">//头尾指针所指元素彼此交换</span></span><br><span class="line">++first; <span class="comment">//头指针前进1，准备下一个外循环迭代</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="remove-移除（但不删除）"><a href="#remove-移除（但不删除）" class="headerlink" title="remove 移除（但不删除）"></a>remove 移除（但不删除）</h5><p>移除[first, last)之中所有与value相等的元素。这一算法并不真正从容器中删除那些元素（换句话说容器大小并未改变），而是将每一个不与value相等（也就是我们并不打算移除）的元素轮番赋值给first之后的空间。返回值ForwardIterator标示出重新整理后的最后元素的下一位置。</p><p><img src="/../img/remove%E7%A4%BA%E4%BE%8B.png" alt="remove示例"></p><p>如果想要删除那些残余数据，可将返回的迭代器交给区间所在之容器的erase() member function。</p><p>注意，array并不适合使用remove()和remove_if()，因为array无法缩小尺寸，导致残余数据永远存在。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> ForwardIterator, <span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function">ForwardIterator <span class="title">remove</span> <span class="params">(ForwardIterator first, ForwardIterator last,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">const</span> T&amp; value)</span>  </span>&#123;</span><br><span class="line">first = <span class="built_in">find</span>(first, last, value); <span class="comment">//利用循序查找法找出第一个相等元</span></span><br><span class="line">ForwardIterator next = first;  <span class="comment">//以next标示出来</span></span><br><span class="line"><span class="comment">//以下利用“remove_copy()允许新旧容器重叠”的性质，进行移除操作</span></span><br><span class="line"><span class="comment">//并将结果指定置于原容器中</span></span><br><span class="line"><span class="keyword">return</span> first == last ? first : <span class="built_in">remove_copy</span>(++next, last, first, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="remove-copy"><a href="#remove-copy" class="headerlink" title="remove_copy"></a>remove_copy</h5><p>移除[first, last)区间内所有与value相等的元素。它并不真正从容器中删除哪些元素（换句话说，原容器没有任何改变），而是将结果复制到一个以result标示起始位置的容器身上。新容器可以和原容器重叠，但如果对新容器实际给值时，超越了旧容器的大小，会产生无法预期的结果。返回值OutputIterator指出被复制的最后元素的下一位置。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>, <span class="keyword">class</span> <span class="title class_">OutputIterator</span>, <span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function">OutputIterator <span class="title">remove_copy</span> <span class="params">(InputIterator first, InputIterator last,</span></span></span><br><span class="line"><span class="params"><span class="function">  OutputIterator result, <span class="type">const</span> T&amp; value)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> ( ; first != last; ++first)</span><br><span class="line"><span class="keyword">if</span>(* first != value) &#123;<span class="comment">//如果不相等</span></span><br><span class="line">*result = *first;    <span class="comment">//就赋值给新容器</span></span><br><span class="line">++result;   <span class="comment">//新容器前进一个位置</span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="remove-if"><a href="#remove-if" class="headerlink" title="remove_if"></a>remove_if</h5><p>移除[first, last)区间内所有被仿函数pred核定为true的元素。它并不真正从容器中删除那些元素（换句话说，容器大小并未改变）。每一个不符合pred条件的元素都会被轮番赋值给first之后的空间。返回值Forwardlterator标示出重新整理后的最后元素的下一位置。此算法会留有一些残余数据，如果要删除那些残余数据，可将返回的迭代器交给区间所在之容器的erase() member function。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">ForwardIterator</span>, <span class="keyword">class</span> <span class="title class_">Predicate</span>&gt;</span><br><span class="line"><span class="function">ForwardIterator <span class="title">remove_if</span><span class="params">(ForwardIterator first, ForwardIterator last, </span></span></span><br><span class="line"><span class="params"><span class="function">Predicate pred)</span> </span>&#123;</span><br><span class="line">first = <span class="built_in">find_if</span>(first, last, pred); <span class="comment">//利用循序查找法找出第一个匹配者</span></span><br><span class="line">ForwardIterator next = first;    <span class="comment">//以next标记出来</span></span><br><span class="line"><span class="comment">//以下利用“remove_copy_if()允许新旧容器重叠”的性质，做删除操作</span></span><br><span class="line"><span class="comment">//并将结果放到原容器中</span></span><br><span class="line"><span class="keyword">return</span> first == last ? first : <span class="built_in">remove_copy_if</span>(++next, last, first, pred);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="remove-copy-if"><a href="#remove-copy-if" class="headerlink" title="remove_copy_if"></a>remove_copy_if</h5><p>移除[first, last)区间内所有被仿函数pred评估为true的元素。它并不真正从容器中删除那些元素（换句话说原容器没有任何改变），而是将结果复制到一个以result标示起始位置的容器身上。新容器可以和原容器重叠，但如果针对新容器实际给值时，超越了旧容器的大小，会产生无法预期的结果。返回值OutputIterator指出被复制的最后元素的下一位置。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>, <span class="keyword">class</span> <span class="title class_">OutputIterator</span>, <span class="keyword">class</span> <span class="title class_">Predicate</span>&gt;</span><br><span class="line"><span class="function">OutputIterator <span class="title">remove_copy_if</span> <span class="params">(InputIterator first, InputIterator last,</span></span></span><br><span class="line"><span class="params"><span class="function">     OutputIterator result, Predicate pred)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> ( ; first != last; ++first)</span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">pred</span>(*first)) &#123;<span class="comment">//如果pred核定为false,</span></span><br><span class="line">*result = *first;<span class="comment">//就赋值给新容器（保留，不删除)</span></span><br><span class="line">++result;   <span class="comment">//新容器前进一个位置</span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="replace"><a href="#replace" class="headerlink" title="replace"></a>replace</h5><p>将[first, last)区间内的所有old_value都以new_value取代。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">ForwardIterator</span>, <span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">replace</span><span class="params">(ForwardIterator first, ForwardIterator last,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">const</span> T&amp; old_value,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">const</span> T&amp; new_value)</span> </span>&#123;</span><br><span class="line"><span class="comment">//将区间内的所有old_value都以new_value取代</span></span><br><span class="line"><span class="keyword">for</span> ( ; first != last; ++first)</span><br><span class="line"><span class="keyword">if</span> (*first == old_value) *first = new_value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="replace-copy"><a href="#replace-copy" class="headerlink" title="replace_copy"></a>replace_copy</h5><p>行为与replace()类似，唯一不同的是新序列会被复制到result所指的容器中。返回值Outputlterator指向被复制的最后一个元素的下一位置。原序列没有任何改变。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>, <span class="keyword">class</span> <span class="title class_">OutputIterator</span>, <span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function">OutputIterator <span class="title">replace_copy</span><span class="params">(InputIterator first, InputIterator last,</span></span></span><br><span class="line"><span class="params"><span class="function">OutputIterator result, <span class="type">const</span> T&amp; old_value,</span></span></span><br><span class="line"><span class="params"><span class="function">                      <span class="type">const</span> T&amp; new_value)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> ( ; first != last; ++first, ++result)</span><br><span class="line"><span class="comment">//如果旧序列上的元素等于old_value，就放new_value到新序列中</span></span><br><span class="line"><span class="comment">//否则就将元素拷贝一份放进新序列中</span></span><br><span class="line">*result = *first == old_value ? new_value : *first;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="replace-if"><a href="#replace-if" class="headerlink" title="replace_if"></a>replace_if</h5><p>将[first, last)区间内所有“被pred评估为true”的元素，都以new value取而代之。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">ForwardIterator</span>, <span class="keyword">class</span> <span class="title class_">Predicate</span>, <span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">replace_if</span><span class="params">(ForwardIterator first, ForwardIterator last,</span></span></span><br><span class="line"><span class="params"><span class="function">   Predicate pred,</span></span></span><br><span class="line"><span class="params"><span class="function">   <span class="type">const</span> T&amp; new_value)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> ( ; first != last; ++first)</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">pred</span>(*first)) *first = new_value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="replace-copy-if"><a href="#replace-copy-if" class="headerlink" title="replace_copy_if"></a>replace_copy_if</h5><p>行为与replace_if()类似，但是新序列会被复制到result所指的区间内。返回值Outputlterator指向被复制的最后一个元素的下一位置。原序列无任何改变。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Iterator</span>, <span class="keyword">class</span> <span class="title class_">OutputIterator</span>, <span class="keyword">class</span> <span class="title class_">Predicate</span>, <span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function">OutputIterator <span class="title">replace_copy_if</span><span class="params">(Iterator first, Iterator last,</span></span></span><br><span class="line"><span class="params"><span class="function">     OutputIterator result, Predicate pred,</span></span></span><br><span class="line"><span class="params"><span class="function">     <span class="type">const</span> T&amp; new_value)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> ( ; first ! = last; ++first, ++result)</span><br><span class="line"><span class="comment">//如果旧序列上的元素被pred评估为true，就放new_value到新序列中，</span></span><br><span class="line"><span class="comment">//否则就将元素拷贝一份放进新序列中</span></span><br><span class="line">*result = <span class="built_in">pred</span>(*first) ? new_value : *first;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="reverse"><a href="#reverse" class="headerlink" title="reverse"></a>reverse</h5><p>将序列[first, last)的元素在原容器中颠倒重排。例如序列{0,1,1,3,5}颠倒重排后为{5,3,1,1,0}。迭代器的双向或随机定位能力，影响了这个算法的效率，所以设计为双层架构：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//分派函数(dispatch function)</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">BidirectionalIterator</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">reverse</span><span class="params">(BidirectionalIterator first, BidirectionalIterator last)</span> </span>&#123;</span><br><span class="line">    __reverse(first, last, <span class="built_in">iterator_category</span>(first));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//reverse的bidirectional iterator版</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">BidirectionalIterator</span>&gt;</span><br><span class="line"><span class="type">void</span> __reverse(BidirectionalIterator first, BidirectionalIterator last,</span><br><span class="line">  bidirectional_iterator_tag) &#123;</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line"><span class="keyword">if</span> (first == last || first == --last)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">iter_swap</span>(first++, last);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//reverse的random access iterator版</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">RandomAccessIterator</span>&gt;</span><br><span class="line"><span class="type">void</span> __reverse(RandomAccessIterator first, RandomAccessIterator last,</span><br><span class="line">   random_access_iterator_tag) &#123;</span><br><span class="line"><span class="comment">//以下，头尾两两互换，然后头部累进一个位置，尾部累退一个位置。两者交错时即停止</span></span><br><span class="line"><span class="comment">//注意，只有random iterators才能做以下的 first &lt; last 判断</span></span><br><span class="line"><span class="keyword">while</span> (first &lt; last) <span class="built_in">iter_swap</span> (first++, --last);</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h5 id="reverse-copy"><a href="#reverse-copy" class="headerlink" title="reverse_copy"></a>reverse_copy</h5><p>行为类似reverse()，但产生出来的新序列会被置于以result指出的容器中。返回值Outputlterator指向新产生的最后元素的下一位置。原序列没有任何改变。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">BidirectionalIterator</span>, <span class="keyword">class</span> <span class="title class_">OutputIterator</span>&gt;</span><br><span class="line"><span class="function">OutputIterator <span class="title">reverse_copy</span><span class="params">(BidirectionalIterator first,</span></span></span><br><span class="line"><span class="params"><span class="function">  BidirectionalIterator last,</span></span></span><br><span class="line"><span class="params"><span class="function">                          OutputIterator result)</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span> (first ! = last) &#123;<span class="comment">//整个序列走一遍</span></span><br><span class="line">--last;       <span class="comment">//尾端前移一个位置</span></span><br><span class="line">*result = *last;    <span class="comment">//将尾端所指元素复制到result所指位置</span></span><br><span class="line">++result;   <span class="comment">//result前进一个位置</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="rotate"><a href="#rotate" class="headerlink" title="rotate"></a>rotate</h5><p>将[first, middle)内的元素和[middle, last)内的元素互换。middle所指的元素会成为容器的第一个元素。</p><p>看起来这和swap_ranges()功能颇为近似，但swap_ranges()只能交换两个长度相同的区间，rotate()可以交换两个长度不同的区间。</p><p>迭代器的移动能力，影响了这个算法的效率，所以设计为双层架构：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//分派函数（dispatch function）</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">ForwardIterator</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">rotate</span><span class="params">(ForwardIterator first, ForwardIterator middle,</span></span></span><br><span class="line"><span class="params"><span class="function">      ForwardIterator last)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (first == middle || middle == last) <span class="keyword">return</span>;</span><br><span class="line">__rotate(first, middle, last, <span class="built_in">distance_type</span>(first),</span><br><span class="line"><span class="built_in">iterator_category</span>(first));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是根据不同的迭代器类型而完成的三个旋转操作：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// rotate 的 forward iterator 版</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">ForwardIterator</span>, <span class="keyword">class</span> <span class="title class_">Distance</span>&gt;</span><br><span class="line"><span class="type">void</span> __rotate(ForwardIterator first, ForwardIterator middle,</span><br><span class="line"> ForwardIterator last, Distance*, forward_iterator_tag) &#123;</span><br><span class="line"><span class="keyword">for</span> (ForwardIterator i = middle; ; ) &#123;</span><br><span class="line"><span class="built_in">iter_swap</span>(first, i);<span class="comment">//前段、后段的元素一一交换</span></span><br><span class="line">++first;   <span class="comment">//双双前进1</span></span><br><span class="line">++i;</span><br><span class="line"><span class="comment">//以下判断是前段[first, middle)先结束还是后段[middle, last)先结束</span></span><br><span class="line"><span class="keyword">if</span> (first == middle) &#123;<span class="comment">//前段结束了</span></span><br><span class="line"><span class="keyword">if</span> (i == last ) <span class="keyword">return</span>; <span class="comment">//如果后段同时也结束，整个就结束了</span></span><br><span class="line">middle = i;            <span class="comment">//否则调整，对新的前、后段再作交换</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (i == last)    <span class="comment">//后段先结束</span></span><br><span class="line">i = middle;    <span class="comment">//调整，准备对新的前、后段再作交换</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//rotate 的 bidirectiona1 iterator 版</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">BidirectionalIterator</span>, <span class="keyword">class</span> <span class="title class_">Distance</span>&gt;</span><br><span class="line"><span class="type">void</span> __rotate(BidirectionalIterator first, BidirectionalIterator middle,</span><br><span class="line"> BidirectionalIterator last, Distance*,</span><br><span class="line"> bidirectional_iterator_tag) &#123;</span><br><span class="line"><span class="built_in">reverse</span>(first, middle);</span><br><span class="line"><span class="built_in">reverse</span>(middle, last);</span><br><span class="line"><span class="built_in">reverse</span>(first, last);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// rotate 的 random access iterator 版</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">RandomAccessIterator</span>, <span class="keyword">class</span> <span class="title class_">Distance</span>&gt;</span><br><span class="line"><span class="type">void</span> __rotate(RandomaAccessIterator first, RandomAccessIterator middle</span><br><span class="line"> RandomAccessIterator last, Distance*,</span><br><span class="line"> random_access_iterator_tag) &#123;</span><br><span class="line"><span class="comment">//以下迭代器的相减操作，只适用于random access iterators</span></span><br><span class="line">    <span class="comment">//取全长和前段长度的最大公因子</span></span><br><span class="line">Distance n = __gcd(last - first, middle - first);</span><br><span class="line"><span class="keyword">while</span> (n--)</span><br><span class="line">__rotate_cycle(first, last, first + n, middle - first,</span><br><span class="line">  <span class="built_in">value_type</span>(first));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//最大公因子，利用辗转相除法</span></span><br><span class="line"><span class="comment">// __gcd()应用于__rotate()的random access iterator版</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">EuclideanRingElement</span>&gt;</span><br><span class="line">EuclideanRingE1ement __gcd(EuclideanRingElement m, EuclideanRingElement n)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span> (n != <span class="number">0</span>) &#123;</span><br><span class="line">EuclideanRingElement t = m % n;</span><br><span class="line">m = n;</span><br><span class="line">n = t;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">return</span> m;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">RandomAccessIterator</span>, <span class="keyword">class</span> <span class="title class_">Distance</span>, <span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> __rotate_cycle(RandomAccessIterator first, RandomAccessIterator last,</span><br><span class="line">   RandomAccessIterator initial, Distance shift, T*) &#123;</span><br><span class="line">T value = *initial;</span><br><span class="line">RandomAccessIterator ptr1 = initial;</span><br><span class="line">RandomAccessIterator ptr2 = ptr1 + shift;</span><br><span class="line"><span class="keyword">while</span> (ptr2 ! = initial) &#123;</span><br><span class="line">*ptr1 = *ptr2;</span><br><span class="line">ptr1 = ptr2;</span><br><span class="line"><span class="keyword">if</span> (last - ptr2 &gt; shift)</span><br><span class="line">ptr2 += shift;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">ptr2 = first + (shift - (last - ptr2));</span><br><span class="line">    &#125;</span><br><span class="line">*ptr1 = value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="rotate-copy"><a href="#rotate-copy" class="headerlink" title="rotate_copy"></a>rotate_copy</h5><p>行为类似rotate()，但产生出来的新序列会被置于result所指出的容器中。返回值OutputIterator指向新产生的最后元素的下一位置。原序列没有改变。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">ForwardIterator</span>, <span class="keyword">class</span> <span class="title class_">OutputIterator</span>&gt;</span><br><span class="line"><span class="function">OutputIterator <span class="title">rotate_copy</span><span class="params">(ForwardIterator first, ForwardIterator middle,</span></span></span><br><span class="line"><span class="params"><span class="function"> ForwardIterator last, OutputIterator result)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">copy</span>(first, middle, <span class="built_in">copy</span>(middle, last, result));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="search"><a href="#search" class="headerlink" title="search"></a>search</h5><p>在序列以[first1, last1)所涵盖的区间中，查找序列二[first2, last2)的首次出现点。如果序列一内不存在与序列二完全匹配的子序列，便返回迭代器last1.版本一使用元素型别所提供的equality操作符，版本二允许用户指定某个二元运算（以仿函数呈现），作为判断相等与否的 依据。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//查找子序列首次出现地点</span></span><br><span class="line"><span class="comment">//版本一</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">ForwardIterator1</span>, <span class="keyword">class</span> <span class="title class_">ForwardIterator2</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ForwardIterator1 <span class="title">search</span><span class="params">(Forwarditerator1 first1,</span></span></span><br><span class="line"><span class="params"><span class="function"> ForwardIterator1 last1, </span></span></span><br><span class="line"><span class="params"><span class="function">                               ForwardIterator2 first2,</span></span></span><br><span class="line"><span class="params"><span class="function">                               ForwardIterator2 last2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> __search(first1, last1, first2, last2, <span class="built_in">distance_type</span>(first1),</span><br><span class="line"><span class="built_in">distance_type</span>(first2));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">ForwardIterator1</span>, <span class="keyword">class</span> <span class="title class_">ForwardIterator2</span>, <span class="keyword">class</span> <span class="title class_">Distance1</span>,</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Distance2</span>&gt;</span><br><span class="line">ForwardIterator1 __search (ForwardIterator1 first1, ForwardIterator1 last1,</span><br><span class="line"> ForwardIterator2 first2, ForwardIterator2 last2,    Distance1*, Distance2*) &#123;</span><br><span class="line">Distance1 d1 = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">distance</span>(first1, last1, d1);</span><br><span class="line">Distance2 d2 = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">distance</span>(first2, last2, d2);</span><br><span class="line"><span class="keyword">if</span> (dl &lt; d2) <span class="keyword">return</span> last1; <span class="comment">// 如果第二序列大于第一序列，不可能成为其子序列</span></span><br><span class="line"></span><br><span class="line">ForwardIterator1 current1 = first1;</span><br><span class="line">ForwardIterator2 current2 = first2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (current2 != last2)<span class="comment">//遍历整个第二序列</span></span><br><span class="line"><span class="keyword">if</span> (*current1 == *current2) &#123;<span class="comment">//如果这个元素相同</span></span><br><span class="line">++current1;   <span class="comment">//调整，以便比对下一个元素</span></span><br><span class="line">++current2;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="keyword">else</span> &#123;<span class="comment">//如果这个元素不等</span></span><br><span class="line"><span class="keyword">if</span> (d1 == d2)<span class="comment">//如果两序列一样长</span></span><br><span class="line"><span class="keyword">return</span> last1;   <span class="comment">//表示不可能成功了</span></span><br><span class="line"><span class="keyword">else</span> &#123;   <span class="comment">//两序列不一样长（至此肯定是序列一大于序列二)</span></span><br><span class="line">current1 = ++first1;<span class="comment">//调整第一序列的标兵，</span></span><br><span class="line">current2 = first2;    <span class="comment">//准备在新起点上再找一次</span></span><br><span class="line">--d1; <span class="comment">//已经排除了序列的一个元素，所以序列一的长度要减1</span></span><br><span class="line">&#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="keyword">return</span> first1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="search-n"><a href="#search-n" class="headerlink" title="search_n"></a>search_n</h5><p>在序列[first, last)所涵盖的区间中，查找“连续count个符合条件之元素”所形成的子序列，并返回一个迭代器指向该子序列起始处。如果找不到这样的子序列，就返回迭代器last。上述所谓的“某条件”，在 search_n 版本一指的是相等条件“equality”，在search_n版本二指的是用户指定的某个二元运算（以仿函数呈现）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//版本一</span></span><br><span class="line"><span class="comment">//查找“元素value 连续出现 count次”所形成的那个子序列，返回其发生位置</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">ForwardIterator</span>, <span class="keyword">class</span> <span class="title class_">Integer</span>, <span class="keyword">class</span> <span class="title class_">T</span>&gt; </span><br><span class="line"><span class="function">ForwardIterator <span class="title">search_n</span><span class="params">(ForwardIterator first,</span></span></span><br><span class="line"><span class="params"><span class="function">        ForwardIterator last,</span></span></span><br><span class="line"><span class="params"><span class="function">   Integer count, <span class="type">const</span> T&amp; value)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (count &lt;= <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> first;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">first = <span class="built_in">find</span>(first, last, value); <span class="comment">//首先找出value第一次出现点</span></span><br><span class="line"><span class="keyword">while</span> (first != last) &#123;   <span class="comment">//继续查找余下元素</span></span><br><span class="line">Integer n = count - <span class="number">1</span>;   <span class="comment">//value还应出现n次</span></span><br><span class="line">ForwardIterator i = first; <span class="comment">//从上次出现点接下去查找</span></span><br><span class="line">++i;</span><br><span class="line"><span class="keyword">while</span> (i != last &amp;&amp; n != <span class="number">0</span> &amp;&amp; *i == value) &#123; <span class="comment">//下个元素是value</span></span><br><span class="line">++i;</span><br><span class="line">--n;<span class="comment">//既然找到了，“value应再出现次数”便可减1</span></span><br><span class="line">&#125;<span class="comment">//回到内循环内继续查找</span></span><br><span class="line"><span class="keyword">if</span> (n == <span class="number">0</span>)<span class="comment">//n==0表示确实找到了“元素值出现n次”的子序列。功德圆满</span></span><br><span class="line"><span class="keyword">return</span> first;</span><br><span class="line"><span class="keyword">else</span><span class="comment">//功德尚未圆满…</span></span><br><span class="line">first = <span class="built_in">find</span>(i, last, value); <span class="comment">//找value 的下一个出现点，并准备回到外循环</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> last;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//版本二</span></span><br><span class="line"><span class="comment">//查找“连续count个元素皆满足指定条件”所形成的那个子序列的起点，返回其发生位置</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">ForwardIterator</span>, <span class="keyword">class</span> <span class="title class_">Integer</span>, <span class="keyword">class</span> <span class="title class_">T</span>,</span><br><span class="line"> <span class="keyword">class</span> <span class="title class_">BinaryPredicate</span>&gt;</span><br><span class="line"><span class="function">ForwardIterator <span class="title">search_n</span><span class="params">(ForwardIterator first,</span></span></span><br><span class="line"><span class="params"><span class="function">        ForwardIterator last,</span></span></span><br><span class="line"><span class="params"><span class="function">   Integer count, <span class="type">const</span> T&amp; value,</span></span></span><br><span class="line"><span class="params"><span class="function"> BinaryPredicate binary_pred)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (count &lt;= <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> first;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(first != last) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">binary_pred</span>(*first, value)) <span class="keyword">break</span>;   <span class="comment">//首先找出第一个符合条件的元素</span></span><br><span class="line">            ++first;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="keyword">while</span> (first != last) &#123;   <span class="comment">//继续查找余下元素</span></span><br><span class="line">Integer n = count - <span class="number">1</span>;   <span class="comment">//value还应出现n次</span></span><br><span class="line">ForwardIterator i = first; <span class="comment">//从上次出现点接下去查找</span></span><br><span class="line">++i;</span><br><span class="line"><span class="keyword">while</span> (i != last &amp;&amp; n != <span class="number">0</span> &amp;&amp; <span class="built_in">binary_pred</span>(*i, value)) &#123; <span class="comment">//下个元素是value</span></span><br><span class="line">++i;</span><br><span class="line">--n;<span class="comment">//既然找到了，“value应再出现次数”便可减1</span></span><br><span class="line">&#125;<span class="comment">//回到内循环内继续查找</span></span><br><span class="line"><span class="keyword">if</span> (n == <span class="number">0</span>)<span class="comment">//n==0表示确实找到了“元素值出现n次”的子序列。功德圆满</span></span><br><span class="line"><span class="keyword">return</span> first;</span><br><span class="line"><span class="keyword">else</span> &#123;<span class="comment">//功德尚未圆满…</span></span><br><span class="line"><span class="keyword">while</span> (i != last) &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">binary_pred</span>(*i, value)) <span class="keyword">break</span>;                    </span><br><span class="line">++i;</span><br><span class="line">                &#125;</span><br><span class="line">                first = i;</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> last;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="swap-ranges"><a href="#swap-ranges" class="headerlink" title="swap_ranges"></a>swap_ranges</h5><p>将[first1, last1)区间内的元素与“从first2开始、个数相同”的元素互相交换。这两个序列可位于同一容器中，也可位于不同的容器中。如果第二序列的长度小于第一序列，或是两序列在同一容器中且彼此重叠，执行结果未可预期。此算法返回一个迭代器，指向第二序列中的最后一个被交换元素的下一位置。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将两段等长区间内的元素互换</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">ForwardIterator1</span>, <span class="keyword">class</span> <span class="title class_">ForwardIterator2</span>&gt;</span><br><span class="line"><span class="function">ForwardIterator2 <span class="title">swap_ranges</span><span class="params">(ForwardIterator1 first1,</span></span></span><br><span class="line"><span class="params"><span class="function">   ForwardIterator1 last1,</span></span></span><br><span class="line"><span class="params"><span class="function">   ForwardIterator2 first2)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> ( ; first1 != last1; ++first1, ++first2)</span><br><span class="line"><span class="built_in">iter_swap</span>(first1, first2);</span><br><span class="line"><span class="keyword">return</span> first2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="transform"><a href="#transform" class="headerlink" title="transform"></a>transform</h5><p>transform()的第一版本以仿函数op作用于[first, last)中的每一个元素身上，并以其结果产生出一个新序列。第二版本以仿函数binary_op作用于一双元素身上（其中一个元素来自 [first1, last)，另一个元素来自“从first2开始的序列”)，并以其结果产生出一个新序列。如果第二序列的元素少于第一序列，执行结果未可预期。</p><p>transform()的两个版本都把执行结果放进迭代器result所标示的容器中。result也可以指向源端容器，那么transform()的运算结果就会取代该容器内的元素。返回值OutputIterator将指向结果序列的最后元素的下一位置。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//版本一</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> InputIterator, <span class="keyword">class</span> OutputIterator, <span class="keyword">class</span> UnaryOperation&gt;</span></span><br><span class="line"><span class="function">OutputIterator <span class="title">transform</span><span class="params">(InputIterator first, InputIterator last,</span></span></span><br><span class="line"><span class="params"><span class="function">   OutputIterator result, UnaryOperation op)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> ( ; first != last; ++first, ++result)</span><br><span class="line">*result = <span class="built_in">op</span>(*first);</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//版本二</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator1</span>, <span class="keyword">class</span> <span class="title class_">InputIterator2</span>, <span class="keyword">class</span> <span class="title class_">OutputIterator</span>,</span><br><span class="line"> <span class="keyword">class</span> <span class="title class_">BinaryOperation</span>&gt;</span><br><span class="line"><span class="function">OutputIterator <span class="title">transform</span><span class="params">(InputIterator1 first1, InputIterator1 last1,</span></span></span><br><span class="line"><span class="params"><span class="function">                         InputIterator2 first2, OutputIterator result,</span></span></span><br><span class="line"><span class="params"><span class="function">                         BinaryOperation binary_op)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> ( ; first1 != last1; ++first1, ++first2, ++result)</span><br><span class="line">*result = <span class="built_in">binary_op</span>(*first1, *first2);</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="unique"><a href="#unique" class="headerlink" title="unique"></a>unique</h5><p>算法unique能够移除（remove）重复的元素。每当在[first, last)内遇有重复元素群，它便移除该元素群中第一个以后的所有元素。因此，unique想要移除包括不相邻的所有重复元素，必须先将序列排序，使所有重复元素都相邻。</p><p>unique会返回一个迭代器指向新区间的尾端，新区间之内不含相邻的陈聪父元素。</p><p>事实上unique并不会改变[first, last)的元素个数，有一些残余数据会留下，情况类似于remove算法。</p><p>unique有两个版本，因为所谓“相邻元素是否重复”可有不同的定义。第一版本使用简单的相等（equality）测试，第二版本使用一个 Binary Predicate binary_pred做为测试准则。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//版本一</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">ForwardIterator</span>&gt;</span><br><span class="line"><span class="function">ForwardIterator <span class="title">unique</span><span class="params">(ForwardIterator first, ForwardIterator last)</span> </span>&#123;</span><br><span class="line">first = <span class="built_in">adjacent_find</span>(first, last);<span class="comment">//首先找到相邻重复元素的起点</span></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">unique_copy</span>(first, last, first); <span class="comment">//利用unique_copy完成</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="unique-copy"><a href="#unique-copy" class="headerlink" title="unique_copy"></a>unique_copy</h5><p>算法unique_copy可从[first, last)中将元素复制到以result开头的区间上；如果面对相邻重复元素群，只会复制其中第一个元素。返回的迭代器指向以result开头的区间的尾端。</p><p>unique_copy有两个版本，因为所谓“相邻元素是否重复”可有不同的定义。第一版本使用简单的相等(equality)测试，第二版本使用一个Binary Predicate binary_pred作为测试准则。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//版本一</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>, <span class="keyword">class</span> <span class="title class_">OutputIterator</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> OutputIterator <span class="title">unique_copy</span><span class="params">(InputIterator first,</span></span></span><br><span class="line"><span class="params"><span class="function">   InputIterator last,</span></span></span><br><span class="line"><span class="params"><span class="function">   OutputIterator result)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (first == last) <span class="keyword">return</span> result;</span><br><span class="line"><span class="comment">//以下，根据result的iterator category，做不同的处理</span></span><br><span class="line"><span class="keyword">return</span> __unique_copy(first, last, result, <span class="built_in">iterator_category</span>(result));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//版本一辅助函数，forward_iterator_tag版</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>, <span class="keyword">class</span> <span class="title class_">ForwardIterator</span>&gt;</span><br><span class="line">Forwardrterator __unique_copy(InputIterator first,</span><br><span class="line">    InputIterator last,</span><br><span class="line">    ForwardIterator result,</span><br><span class="line">    forward_iterator_tag) &#123;</span><br><span class="line">*result = *first;<span class="comment">//记录第一个元素</span></span><br><span class="line"><span class="keyword">while</span> (++first != last) <span class="comment">//遍历整个区间</span></span><br><span class="line"><span class="comment">//以下，元素不同，就记录，否则（元素相同），就跳过</span></span><br><span class="line"><span class="keyword">if</span> (*result != *first) *++result = *first;</span><br><span class="line"><span class="keyword">return</span> ++result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//版本一辅助函数,output_iterator_tag版</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>, <span class="keyword">class</span> <span class="title class_">OutputIterator</span>&gt;</span><br><span class="line"><span class="keyword">inline</span> OutputIterator __unique_copy(InputIterator first,</span><br><span class="line"> InputIterator last,</span><br><span class="line"> OutputIterator result,</span><br><span class="line">                                    output_iterator_tag) &#123;</span><br><span class="line"><span class="comment">//以下,output iterator有一些功能限制，所以必须先知道其value type.</span></span><br><span class="line"><span class="keyword">return</span> __unique_copy(first, last, result, <span class="built_in">value_type</span>(first));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//由于output iterator为write only，无法像forward iterator那般可以读取</span></span><br><span class="line"><span class="comment">//所以不能有类似*result != *first这样的判断操作，所以才需要设计这一版本</span></span><br><span class="line"><span class="comment">//例如ostream_iterator就是一个output iterator.</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>, <span class="keyword">class</span> <span class="title class_">outputIterator</span>, <span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">OutputIterator __unique_copy(InputIterator first, InputIterator last,</span><br><span class="line">   OutputIterator result, T*) &#123;</span><br><span class="line"><span class="comment">// T 为input iterator 的value type</span></span><br><span class="line">T value = *first;</span><br><span class="line">*result = value;</span><br><span class="line"><span class="keyword">while</span> (++first != last)</span><br><span class="line"><span class="keyword">if</span> (value != *first) &#123;</span><br><span class="line"> value = *first;</span><br><span class="line">*++result = value;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="keyword">return</span> ++result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="lower-bound（应用于有序区间）"><a href="#lower-bound（应用于有序区间）" class="headerlink" title="lower_bound（应用于有序区间）"></a>lower_bound（应用于有序区间）</h4><p>算法利用二分查找（binary search），指出已排序的区间[first, last)中第一个“不小于value”的元素（不破坏排序状态下，可插入value的第一个位置）。如果value大于[first, last)内的任何一个元素，则返回last。</p><p>这个算法有两个版本，版本一采用operator&lt;进行比较，版本二采用仿函数comp。更正式地说，版本一返回[first, last)中最远的迭代器i，使得[first, i)中的每个迭代器j都满足*j &lt; value。版本二返回[first, last)中最远的迭代器i，使[first, i)中的每个迭代器j都满足“comp(*j, value)为真”。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//版本一</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">ForwardIterator</span>, <span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ForwardIterator <span class="title">lower_bound</span><span class="params">(ForwardIterator first,</span></span></span><br><span class="line"><span class="params"><span class="function">ForwardIterator last,</span></span></span><br><span class="line"><span class="params"><span class="function">     <span class="type">const</span> T&amp; value)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> __lower_bound(first, last, value, <span class="built_in">distance_type</span>(first),</span><br><span class="line"><span class="built_in">iterator_category</span>(first));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//版本二</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">ForwardIterator</span>, <span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Compare</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ForwardIterator <span class="title">lower_bound</span><span class="params">(ForwardIterator first,</span></span></span><br><span class="line"><span class="params"><span class="function">ForwardIterator last,</span></span></span><br><span class="line"><span class="params"><span class="function">     <span class="type">const</span> T&amp; value, Compare comp)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> __lower_bound(first, last, value, comp, <span class="built_in">distance_type</span>(first),</span><br><span class="line"><span class="built_in">iterator_category</span>(first));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//版本一的forward_iterator版本</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">ForwardIterator</span>, <span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Distance</span>&gt;</span><br><span class="line">ForwardIterator __lower_bound(ForwardIterator first,</span><br><span class="line">    ForwardIterator last,</span><br><span class="line"><span class="type">const</span> T&amp; value,</span><br><span class="line">Distance*,</span><br><span class="line">forward_iterator_tag) &#123;</span><br><span class="line">Distance len = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">distance</span>(first, last, len);<span class="comment">//求取整个区间的长度len</span></span><br><span class="line">Distance half;</span><br><span class="line">ForwardIterator middle;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">while</span> (len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">half = len &gt;&gt; <span class="number">1</span>;<span class="comment">//除以2</span></span><br><span class="line">middle = first;<span class="comment">//这两行令middle指向中间位置</span></span><br><span class="line"><span class="built_in">advance</span>(middle, half);</span><br><span class="line"><span class="keyword">if</span> (*middle &lt; value) &#123;   <span class="comment">//如果中间位置的元素值 &lt; 标的值</span></span><br><span class="line">first = middle;<span class="comment">//这两行令first指向middle的下一位置</span></span><br><span class="line">++first;</span><br><span class="line">len = len - half - <span class="number">1</span>;<span class="comment">//修正len，回头测试循环的结束条件</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">len = half;<span class="comment">//修正len，回头测试循环的结束条件</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> first;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//版本一的random_access_iterator版本</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">RandomAccessIterator</span>, <span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Distance</span>&gt;</span><br><span class="line">RandomAccessIterator __lower_bound(RandomAccessIterator first,</span><br><span class="line">RandomAccessiterator last,</span><br><span class="line"><span class="type">const</span> T&amp; value,</span><br><span class="line">Distance*,</span><br><span class="line">random_access_iterator_tag) &#123;</span><br><span class="line">Distance len = last - first;<span class="comment">//求取整个区间的长度len</span></span><br><span class="line">Distance half;</span><br><span class="line">RandomAccessIterator middle;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">half = len &gt;&gt; <span class="number">1</span>;<span class="comment">//除以2</span></span><br><span class="line">middle = first + half;<span class="comment">//令middle指向中间位置（r-a-i才能如此)</span></span><br><span class="line"><span class="keyword">if</span> (*middle &lt; value) &#123;<span class="comment">//如果中间位置的元素值&lt;目标值</span></span><br><span class="line">first = middle + <span class="number">1</span>;<span class="comment">//令first指向middle的下一位置</span></span><br><span class="line">len = len - half - <span class="number">1</span>;<span class="comment">//修正len，回头测试循环的结束条件</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">len = half;<span class="comment">//修正len，回头测试循环的结束条件</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> first;</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure><h4 id="upper-bound（应用于有序区间）"><a href="#upper-bound（应用于有序区间）" class="headerlink" title="upper_bound（应用于有序区间）"></a>upper_bound（应用于有序区间）</h4><p>算法利用二分查找（binary seaarch），它会返回“在不破坏顺序的情况下，可插入value的最后一个合适位置”。</p><p>upper_bound和lower_bound的区别：</p><p><img src="/../img/upper_bound%E5%92%8Clower_bound.png" alt="upper_bound和lower_bound"></p><p>upper_bound有两个版本，版本一采用operator&lt;进行比较，版本二采用仿函数comp。更正式地说，版本一返回[first, last)区间内最远的迭代器i，使[first, i)内的每个迭代器j都满足“value &lt; *j不为真”。版本二返回[first, last)区间内最远的迭代器i，使[first, i)中的每个迭代器j都满足“comp(value, *j)不为真”。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//版本一</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">ForwardIterator</span>, <span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ForwardIterator <span class="title">upper_bound</span><span class="params">(ForwardIterator first,</span></span></span><br><span class="line"><span class="params"><span class="function">ForwardIterator last,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">const</span> T&amp; value)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> __upper_bound(first, last, value, <span class="built_in">distance_type</span>(first),</span><br><span class="line"><span class="built_in">iterator_category</span>(first));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//版本二</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">ForwardIterator</span>, <span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Compare</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ForwardIterator <span class="title">upper_bound</span><span class="params">(ForwardIterator first,</span></span></span><br><span class="line"><span class="params"><span class="function">ForwardIterator last,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">const</span> T&amp; value,</span></span></span><br><span class="line"><span class="params"><span class="function">                                   Compare comp)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> __upper_bound(first, last, value, comp, <span class="built_in">distance_type</span>(first),</span><br><span class="line"><span class="built_in">iterator_category</span>(first));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//版本一的forward_iterator版本</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">ForwardIterator</span>, <span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Distance</span>&gt;</span><br><span class="line">ForwardIterator __upper_bound(ForwardIterator first,</span><br><span class="line">    ForwardIterator last,</span><br><span class="line">    <span class="type">const</span> T&amp; value,Distance*,     forward_iterator_tag) &#123;</span><br><span class="line">Distance len = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">distance</span>(first, last, len);<span class="comment">//求取整个区间的长度len</span></span><br><span class="line">Distance half;</span><br><span class="line">ForwardIterator middle;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">half = len &gt;&gt; <span class="number">1</span>;<span class="comment">//除以2</span></span><br><span class="line">middle = first;<span class="comment">//这两行令middle指向中间位置</span></span><br><span class="line"><span class="built_in">advance</span>(middle, half);</span><br><span class="line"><span class="keyword">if</span> (value &lt; *middle) <span class="comment">//如果中间位置的元素值&gt;标的值</span></span><br><span class="line">len = half;<span class="comment">//修正len，回头测试循环的结束条件</span></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">first = middle;<span class="comment">//这两行令first指向middle的下一位置</span></span><br><span class="line">++first;</span><br><span class="line">len = len - half - <span class="number">1</span>;<span class="comment">//修正 len，回头测试循环的结束条件</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> first;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//版本一的random_access_iterator版本</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">RandomAccessIterator</span>, <span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Distance</span>&gt;</span><br><span class="line">RandomAccessIterator __upper_bound(RandomAccessIterator first,</span><br><span class="line">RandomAccessIterator last,</span><br><span class="line"><span class="type">const</span> T&amp; value, Distance*,</span><br><span class="line">                                   random_access_iterator_tag) &#123;</span><br><span class="line">Distance len = last - first;<span class="comment">//求取整个区间的长度len</span></span><br><span class="line">Distance half;</span><br><span class="line">RandomAccessiterator = middle;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">half = len &gt;&gt; <span class="number">1</span>;<span class="comment">//除以2</span></span><br><span class="line">middle = first + half;<span class="comment">//令middle指向中间位置</span></span><br><span class="line"><span class="keyword">if</span> (value &lt; *middle)<span class="comment">//如果中间位置的元素值&gt;目标值</span></span><br><span class="line">len = half;    <span class="comment">//修正len，回头测试循环的结束条件</span></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">first = middle + <span class="number">1</span>;<span class="comment">//令first指向middle 的下一位置</span></span><br><span class="line">len = len - half - <span class="number">1</span>;<span class="comment">//修正len，回头测试循环的结束条件</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> first;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="binary-search（应用于有序区间）"><a href="#binary-search（应用于有序区间）" class="headerlink" title="binary_search（应用于有序区间）"></a>binary_search（应用于有序区间）</h4><p>算法binary_search是一种二分查找法，试图在已排序的[first, last)中寻找元素value。如果[first, last)内有等同于value的元素，便返回true，否则返回false。</p><p>事实上binary_search是利用lower_bound先找出“假设value存在的话，应该出现的位置”，然后再对比该位置上的值是否为我们所要查找的目标，并返回对比结果。</p><p>binary_search的第一版本采用operator&lt;进行比较，第二版本采用仿函数comp进行比较。</p><p>正式地说，当且仅当[first, last)中存在一个迭代器i使得“*i &lt; value和 value &lt; *i皆不为真”，则第一版本返回true。当且仅当[first, last)中存在一个迭代器i使得“comp(*i, value)和comp(value, *i)皆不为真”，则第二版本返回true。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//版本一</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">ForwardIterator</span>, <span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Binary_search</span><span class="params">(ForwardIterator first, ForwardIterator last,</span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="type">const</span> T&amp; value)</span> </span>&#123;</span><br><span class="line">ForwardIterator i = <span class="built_in">lower_bound</span>(first, last, value);</span><br><span class="line"><span class="keyword">return</span> i != last &amp;&amp; !(value &lt; *i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//版本二</span></span><br><span class="line">termplate &lt;<span class="keyword">class</span> <span class="title class_">ForwardIterator</span>, <span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Compare</span>&gt;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">binary_search</span><span class="params">(ForwardIterator first, ForwardIterator last,</span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="type">const</span> T&amp; value, Compare comp)</span> </span>&#123;</span><br><span class="line">ForwardIterator i = <span class="built_in">lower_bound</span>(first, last, value, comp);</span><br><span class="line"><span class="keyword">return</span> i ! = last &amp;&amp; !<span class="built_in">comp</span>(value, *i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="next-permutation"><a href="#next-permutation" class="headerlink" title="next_permutation"></a>next_permutation</h4><p>该算法会取得[first, last)所标识之序列的下一个排列组合。如果没有下一个排列组合，便返回false；否则返回true。</p><p>这个算法有两个版本。版本一使用元素型别所提供的less-than操作符来决定下一个排列组合，版本二则是以仿函数comp来决定。</p><h5 id="什么是排列组合？"><a href="#什么是排列组合？" class="headerlink" title="什么是排列组合？"></a>什么是排列组合？</h5><p>考虑三个字符所组成的序列{a,b,c}。这个序列有六个可能的排列组合: abc,acb,bac,bca， cab,cba。这些排列组合根据less-than操作符做字典顺序（lexicographical）的排序。也就是说，abc 名列第一，因为每一个元素都小于其后的元素。acb 是次一个排列组合，因为它是固定了a（序列内最小元素）之后所做的新组合。同样道理，那些固定b（序列内次小元素）而做的排列组合，在次序上将先于那些固定c而做的排列组合。以 bac 和 bca 为例，bac 在 bca 之前，因为序列 ac 小于序列 ca 。面对 bca ，我们可以说其前一个排列组合是 bac ，而其后一个排列组合是 cab 。序列 abc 没有“前一个”排列组合，cba 没有“后一个”排列组合。</p><h4 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h4><p>首先，从未断开始往前寻找两个相邻元素，令第一元素为*i，第二元素为*ii，且满足 *i &lt; *ii。找到这样一组相邻元素后，再从最尾端开始往前检验，找出第一个大于*i的元素，令其为*j，将i, j元素对调，再将 ii 之后的所有元素颠倒排列。此即所求之“下一个”排列组合。</p><p>算法应用于序列{0, 1, 2, 3, 4}上的示例：</p><p><img src="/../img/next_permutation%E7%A4%BA%E4%BE%8B.png" alt="next_permutation示例"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//版本一</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> BidirectionalIterators&gt;</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">next_permutation</span><span class="params">(BidirectionalIterator first,</span></span></span><br><span class="line"><span class="params"><span class="function">BidirectionalIterator last)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (first == last) <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//空区间</span></span><br><span class="line">BidirectionalIterator i = first;</span><br><span class="line">++i;</span><br><span class="line"><span class="keyword">if</span> (i == last) <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//只有一个元素</span></span><br><span class="line">i = last; <span class="comment">//i指向尾端</span></span><br><span class="line">--i;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line">BidirectionalIterator ii = i;</span><br><span class="line">--i;</span><br><span class="line"><span class="comment">//以上，锁定一组（两个）相邻元素</span></span><br><span class="line"><span class="keyword">if</span>(*i &lt; *ii) &#123;<span class="comment">//如果前一个元素小于后一个元素</span></span><br><span class="line">BidirectionalIterator j = last;<span class="comment">//令j指向尾端</span></span><br><span class="line"><span class="keyword">while</span> (!(*i &lt; *--j));<span class="comment">//由尾端往前找，直到遇上比*i大的元素</span></span><br><span class="line"><span class="built_in">iter_swap</span>(i, j);<span class="comment">//交换i，j</span></span><br><span class="line"><span class="built_in">reverse</span>(ii, last);<span class="comment">//将ii之后的元素全部逆向重排</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (i == first) &#123;<span class="comment">//进行至最前面了</span></span><br><span class="line"><span class="built_in">reverse</span> (first , last); <span class="comment">//全部逆向重排</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="prev-permutation"><a href="#prev-permutation" class="headerlink" title="prev_permutation"></a>prev_permutation</h4><p>该算法找出“前一个”排列组合，其意义已在上节阐述。</p><h4 id="算法实现-1"><a href="#算法实现-1" class="headerlink" title="算法实现"></a>算法实现</h4><p>首先，从最尾端开始往前寻找两个相邻元素，令第一元素为*i，第二元素为*ii，且满足 *i &gt; *ii。找到这样一组相邻元素后，再从最尾端开始往前检验，找出第一个小于*i 的元素，令为*j，将 i，j元素对调，再将ii 之后的所有元素颠倒排列。此即所求之“前一个”排列组合。</p><p>算法应用于序列{0, 1, 2, 3, 4}上的示例：</p><p><img src="/../img/prev_permutation%E7%A4%BA%E4%BE%8B.png" alt="prev_permutation示例"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//版本一</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> BidirectionalIterators&gt;</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">prev_permutation</span><span class="params">(BidirectionalIterator first,</span></span></span><br><span class="line"><span class="params"><span class="function">BidirectionalIterator last)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (first == last) <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//空区间</span></span><br><span class="line">BidirectionalIterator i = first;</span><br><span class="line">++i;</span><br><span class="line"><span class="keyword">if</span> (i == last) <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//只有一个元素</span></span><br><span class="line">i = last; <span class="comment">//i指向尾端</span></span><br><span class="line">--i;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line">BidirectionalIterator ii = i;</span><br><span class="line">--i;</span><br><span class="line"><span class="comment">//以上，锁定一组（两个）相邻元素</span></span><br><span class="line"><span class="keyword">if</span>(*ii &lt; *i) &#123;<span class="comment">//如果前一个元素大于后一个元素</span></span><br><span class="line">BidirectionalIterator j = last;<span class="comment">//令j指向尾端</span></span><br><span class="line"><span class="keyword">while</span> (!(*--j &lt; *i));<span class="comment">//由尾端往前找，直到遇上比*i小的元素</span></span><br><span class="line"><span class="built_in">iter_swap</span>(i, j);<span class="comment">//交换i，j</span></span><br><span class="line"><span class="built_in">reverse</span>(ii, last);<span class="comment">//将ii之后的元素全部逆向重排</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (i == first) &#123;<span class="comment">//进行至最前面了</span></span><br><span class="line"><span class="built_in">reverse</span> (first , last); <span class="comment">//全部逆向重排</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="random-shuffle"><a href="#random-shuffle" class="headerlink" title="random_shuffle"></a>random_shuffle</h4><p>概算法将[first，last)的元素次序随机重排。即，在N! 种可能的元素排列顺序中随机选出一种，此处N为last - first。</p><p>random_shuffle有两个版本，差别在于随机数的取得。版本一使用内部随机数产生器，版本二使用一个会产生随机随机数的仿函数。特别请你注意，该仿函数的传递方式是by reference 而非一般的by value，这是因为随机随机数产生器有一个重要特质：它拥有局部状态 ( local state)，每次被调用时都会有所改变，并因此保障产生出来的随机数能够随机。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//SGI版本一</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">RandomAccessIterator</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">random_shuffle</span><span class="params">(RandomAccessIterator first,</span></span></span><br><span class="line"><span class="params"><span class="function"> RandomAccessIterator last)</span> </span>&#123;</span><br><span class="line">__random_shuffle(first, last, <span class="built_in">distance_type</span>(first));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">RandomAccessIterator</span>, <span class="keyword">class</span> <span class="title class_">Distance</span>&gt;</span><br><span class="line"><span class="type">void</span> __random_shuffle(RandomAccessIterator first,</span><br><span class="line">RandomAccessIterator last,</span><br><span class="line">                      Distance*) &#123;</span><br><span class="line"><span class="keyword">if</span> (first == last) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">for</span> (RandomAccessIterator i = first + <span class="number">1</span>; i != last; ++i)</span><br><span class="line">        <span class="meta">#<span class="keyword">ifdef</span> __STL_NO_DRAND48</span></span><br><span class="line"><span class="built_in">iter_swap</span>(i, first + <span class="built_in">Distance</span>(<span class="built_in">rand</span>() % ((i - first) + <span class="number">1</span>)));</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="built_in">iter_swap</span>(i, first + <span class="built_in">Distance</span>(<span class="built_in">lrand48</span>() % ((i - first) + <span class="number">1</span>)));</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//SGI版本二</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">RandomAccessIterator</span>, <span class="keyword">class</span> <span class="title class_">RandomNumberGenerator</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">random_shuffle</span><span class="params">(RandomAccessIterator first, RandomAccessIterator last,</span></span></span><br><span class="line"><span class="params"><span class="function">RandomNumberGenerator&amp; rand)</span> </span>&#123;<span class="comment">//注意，by reference</span></span><br><span class="line"><span class="keyword">if</span> (first == last) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">for</span> (RandomAccessIterator i = first + <span class="number">1</span>; i != last; ++i)</span><br><span class="line"> <span class="built_in">iter_swap</span>(i, first + <span class="built_in">rand</span>((i - first) + <span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="partial-sort-x2F-partial-sort-copy"><a href="#partial-sort-x2F-partial-sort-copy" class="headerlink" title="partial_sort &#x2F; partial_sort_copy"></a>partial_sort &#x2F; partial_sort_copy</h4><p>该算法接受一个middle迭代器（位于序列[first, last)之内），然后重新安排[first, last)，是序列中的middle - first个最小元素以递增顺序排序，置于[first, middle)内。其余last - middle个元素安置于[middle, last)种，不保证有任何特定顺序。因此，只排序前N个元素时，partial_sort的效率要高于sort。</p><p>partial_sort有两个版本，其差别在于如何定义某个元素小于另一元素。第一版本使用less-than 操作符，第二版本使用仿函数comp。</p><h5 id="算法实现-2"><a href="#算法实现-2" class="headerlink" title="算法实现"></a>算法实现</h5><p>算法内部采用heap sort完成。partial_sort 的任务是找出 middle - first 个最小元素，因此，首先界定出区间[first, middle)，并利用 make_heap()将它组织成一个max-heap，然后就可以将[middle, last)中的每一个元素拿来与max-heap的最大值比较（max-heap的最大值就在第一个元素身上，轻松可以获得）：如果小于该最大值，就互换位置并重新保持max-heap的状态。如此一来，当我们走遍整个[middle, last)时，较大的元素都已经被抽离出[first, middle)，这时候再以sort_heap()将[first, middle)做一次排序，即功德圆满。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//版本一</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">RandomAccessIterator</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">partial_sort</span><span class="params">(RandomAccessIterator first,</span></span></span><br><span class="line"><span class="params"><span class="function">   RandomAccessIterator middle, </span></span></span><br><span class="line"><span class="params"><span class="function">                         RandomAccessIterator last)</span> </span>&#123;</span><br><span class="line">__partial_sort(first, middle, last, <span class="built_in">value_type</span>(first));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">RandomAccessIterator</span>, <span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> __partial_sort(RandomAccessIterator first,</span><br><span class="line">  RandomAccessIterator middle,</span><br><span class="line">  RandomAccessIterator last, T*) &#123;</span><br><span class="line"><span class="built_in">make_heap</span>(first, middle);</span><br><span class="line"><span class="comment">//注意，以下的i &lt; last判断操作，只适用于random iterator</span></span><br><span class="line"><span class="keyword">for</span> (RandomAccessIterator i = middle; i &lt; last; ++i)</span><br><span class="line"><span class="keyword">if</span> (*i &lt; *first)</span><br><span class="line">__pop_heap(first, middle, i, <span class="built_in">T</span>(*i), <span class="built_in">distance_type</span>(first));</span><br><span class="line"><span class="built_in">sort_heap</span>(first, middle);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>partial_sort有一个姊妹，就是partial_sort_copy。partial_sort 和 partial_sort_copy两者行为逻辑完全相同，只不过后者将(last - first)个最小元素（或最大元素，视 comp而定）排序后的所得结果置于[result_first, result_last )。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//版本一</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>, <span class="keyword">class</span> <span class="title class_">RandomAccessIterator</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> RandomAccessIterator</span></span><br><span class="line"><span class="function"><span class="title">partial_sort_copy</span><span class="params">(InputIterator first,</span></span></span><br><span class="line"><span class="params"><span class="function"> InputIterator last,</span></span></span><br><span class="line"><span class="params"><span class="function"> RandomAccessIterator result_first,</span></span></span><br><span class="line"><span class="params"><span class="function"> RandomAccessIterator result_last)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//版本二</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>, <span class="keyword">class</span> <span class="title class_">RandomAccessIterator</span></span><br><span class="line"> <span class="keyword">class</span> <span class="title class_">Compare</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> RandomAccessIterator</span></span><br><span class="line"><span class="function"><span class="title">partial_sort_copy</span><span class="params">(InputIterator first,</span></span></span><br><span class="line"><span class="params"><span class="function"> InputIterator last,</span></span></span><br><span class="line"><span class="params"><span class="function">     RandomAccessIterator result_first,</span></span></span><br><span class="line"><span class="params"><span class="function">                  RandomAccessIterator result_last,</span></span></span><br><span class="line"><span class="params"><span class="function">                  Compare comp)</span></span>;</span><br></pre></td></tr></table></figure><h4 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h4><p>STL所提供的各式各样算法中，sort()是最复杂最庞大的一个。该算法接受两个RandomAccesslterators（随机存取迭代器），然后将区间内的所有元素以渐增方式由小到大重新排列。第二个版本则允许用户指定一个仿函数（functor），作为排序标准。</p><p>STL的所有关系型容器( associative containers）都拥有自动排序功能（底层结构采用RB-tree），所以不需要用到这个sort 算法。至于顺序容器（ sequence containers）中的stack、queue和 priority-queue都有特别的出入口，不允许用户对元素排序。剩下vector、deque、 list和slist，前两者的迭代器属于RandomAccesslterators，适合使用sort算法，list的迭代器属于Bidirectioinalterators， slist的迭代器更属于Forwardlterators，都不适合使用sort 算法。如果要对 list或slist排序，应该使用它们自己提供的 member functions sort ( )。</p><p>STL的sort算法，数据量大时采用Quick Sort，分段递归排序。一旦分段后的数据量小于某个门槛，为避免Quick Sort的递归调用带来过大的额外负荷(overhead)，就改用Insertion Sort。如果递归层次过深，还会改用Heap sort。</p><h5 id="Insertion-Sort"><a href="#Insertion-Sort" class="headerlink" title="Insertion Sort"></a>Insertion Sort</h5><p>Insertion Sort以双层循环的形式进行。外循环遍历整个序列，每次迭代决定出一个子区间；内循环遍历子区间，将子区间内的每一个“逆转对(inversion)”倒转过来。所谓“逆转对”是指任何两个迭代器 i, j，其中i &lt; j 而*i &gt; *j。一旦不存在“逆转对”，序列即排序完毕。该算法的复杂度为O(N2)，说起来并不理想，但是当数据量很少时，却有不错的效果，原因是实现上有一些技巧（稍后源代码可见)，而且不像其它较为复杂的排序算法有着诸如递归调用等操作带来的额外负荷。</p><p>sGI STL的Insertion Sort有两个版本,版本一使以operator&lt;为两元素的比较函数（递增），版本二允许用户指定一个仿函数（functor)，作为两元素的比较函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//版本一</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">RandomAccessIterator</span>&gt;</span><br><span class="line"><span class="type">void</span> __insertion_sort(RandomAccessIterator first,</span><br><span class="line">RandomAccessIterator last) &#123;</span><br><span class="line"><span class="keyword">if</span> (first == last) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">for</span> (RandomAccessIterator i = first + <span class="number">1</span>; i != last; ++i)<span class="comment">//外循环</span></span><br><span class="line">__linear_insert(first, i, <span class="built_in">value_type</span>(first));</span><br><span class="line"><span class="comment">//以上，[first, i)形成一个子区间</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//版本一辅助函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">RandomAccessIterator</span>, <span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="type">void</span> __linear_insert(RandomAccessIterator first,</span><br><span class="line">  RandomAccessIterator last, T*) &#123;</span><br><span class="line">T value = *last;<span class="comment">//记录尾元素</span></span><br><span class="line"><span class="keyword">if</span> (value &lt; *first) &#123; <span class="comment">//尾比头还小（注意，头端必为最小元素)</span></span><br><span class="line">        <span class="comment">//那么就别一个个比较了，一次做完爽快些…</span></span><br><span class="line"><span class="built_in">copy_backward</span>(first, last, last + <span class="number">1</span>); <span class="comment">//将整个区间向右递移一个位置</span></span><br><span class="line">*first = value;<span class="comment">//令头元素等于原先的尾元素值</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="comment">//尾不小于头</span></span><br><span class="line">__unguarded_linear_insert(last, value);</span><br><span class="line">&#125;    </span><br><span class="line">    </span><br><span class="line"><span class="comment">//版本一辅助函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">RandomAccessIterator</span>, <span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> __unguarded_linear_insert(RandomAccessIterator last, T value) &#123;</span><br><span class="line">RandomAccessIterator next = last;</span><br><span class="line">--next;</span><br><span class="line"><span class="comment">//insertion sort 的内循环</span></span><br><span class="line"><span class="comment">//注意，一旦不再出现逆转对(inversion)，循环就可以结束了</span></span><br><span class="line"><span class="keyword">while</span> (value &lt; *next) &#123; <span class="comment">//逆转对（ inversion）存在</span></span><br><span class="line">*last = *next;<span class="comment">//调整</span></span><br><span class="line">last = next;<span class="comment">//调整迭代器</span></span><br><span class="line">--next;<span class="comment">//左移一个位置</span></span><br><span class="line">&#125;</span><br><span class="line">*last = value; <span class="comment">// value的正确落脚处</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="Quick-Sort"><a href="#Quick-Sort" class="headerlink" title="Quick Sort"></a>Quick Sort</h5><p>Quick Sort平均复杂度都为O(N log N)，最坏情况下将达O(N²)。</p><p>Quick Sort算法可以叙述如下。假设S代表将被处理的序列：</p><ol><li>如果S的元素个数为0或1，结束。</li><li>取S中的任何一个元素，当作枢轴(pivot) v。</li><li>将S分割为L，R两段，使L内的每一个元素都小于或等于v，R内的每一个<br>元素都大于或等于v。</li><li>对L,R递归执行Quick Sort。</li></ol><h6 id="Median-of-Three（三点中值）"><a href="#Median-of-Three（三点中值）" class="headerlink" title="Median-of-Three（三点中值）"></a>Median-of-Three（三点中值）</h6><p>虽然任何一个元素都可以被选来当作枢轴，但是其合适与否会影响Quick Sort的效率。为了避免“元素当初输入时不够随机”所带来的而化效应，最理想的方式就是取整个序列的头、尾、中央三个位置的元素，以其中值作为枢轴。为了能够快速取出中央位置的元素，显然迭代器必须能够随机定位，即必须是个RandomAccessIterators。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回a,b,c之居中者</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="type">const</span> T&amp; __median(<span class="type">const</span> T&amp; a, <span class="type">const</span> T&amp; b, <span class="type">const</span> T&amp; c) &#123;</span><br><span class="line"><span class="keyword">if</span> (a &lt; b)</span><br><span class="line"><span class="keyword">if</span> (b &lt; c)<span class="comment">// a &lt; b &lt; c</span></span><br><span class="line"><span class="keyword">return</span> b;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (a &lt; c)<span class="comment">// a &lt; b, b &gt;= c, a &lt; c</span></span><br><span class="line"><span class="keyword">return</span> c;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> a;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (a &lt; c)<span class="comment">// c &gt; a &gt;= b</span></span><br><span class="line"><span class="keyword">return</span> a;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (b &lt; c)<span class="comment">//a &gt;= b, a &gt;= c, b &lt; c</span></span><br><span class="line"><span class="keyword">return</span> c;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> b;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h6 id="Partitioning（分割）"><a href="#Partitioning（分割）" class="headerlink" title="Partitioning（分割）"></a>Partitioning（分割）</h6><p>分割方法不只一种，以下叙述既简单又有良好成效的做法。令头端迭代器first向尾部移动，尾端迭代器last向头部移动。当*first 大于或等于枢轴时就停下来，当*last 小于或等于枢轴时也停下来，然后检验两个迭代器是否交错。如果 first仍然在左而last 仍然在右，就将两者元素互换，然后各自调整一个位置（向中央逼近)，再继续进行相同的行为。如果发现两个迭代器交错了（亦即! (first &lt; last)) ，表示整个序列已经调整完毕，以此时的first 为轴，将序列分为左右两半，左半部所有元素值都小于或等于枢轴，右半部所有元素值都大于或等于枢轴。</p><p>下面是SGI STL提供的分割函数，其返回值是分割后的右端第一个位置：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//版本一</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">RandomAccessIterator</span>, <span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">RandomAccessIterator __unguarded_partition (</span><br><span class="line">RandomAccessIterator first,</span><br><span class="line">RandomAccessIterator last,</span><br><span class="line">T pivot) &#123;</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line"><span class="keyword">while</span> (*first &lt; pivot) ++first; <span class="comment">// first找到 &gt;= pivot的元素就停下来</span></span><br><span class="line">--last;  <span class="comment">//调整</span></span><br><span class="line"><span class="keyword">while</span> (pivot &lt; *last) --last;  <span class="comment">//last找到 &lt;= pivot 的元素就停下来</span></span><br><span class="line"><span class="comment">//注意，以下first &lt; last 判断操作，只适用于random iterator</span></span><br><span class="line"><span class="keyword">if</span> (!(first &lt; last)) <span class="keyword">return</span> first;<span class="comment">//交错，结束循环</span></span><br><span class="line"><span class="built_in">iter_swap</span>(first, last);<span class="comment">//大小值交换</span></span><br><span class="line">++first;<span class="comment">//调整</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure><h6 id="threshold（阈值）"><a href="#threshold（阈值）" class="headerlink" title="threshold（阈值）"></a>threshold（阈值）</h6><p>面对小型序列，Quick Sort可能并不比Insertion Sort划算，鉴于这种情况，需要适度评估序列的大小来决定采用Quick Sort或者Insertion Sort。该阈值并无定论，5-20都可能导致差不多的结果，实际的最佳值因设备而异。</p><h6 id="final-insertion-sort"><a href="#final-insertion-sort" class="headerlink" title="final insertion sort"></a>final insertion sort</h6><p>如果我们令某个大小以下的序列滞留在“几近排序但尚未完成”的状态，最后再以一次lnsertion Sort将所有这些“几近排序但尚未竟全功”的子序列做一次完整的排序，其效率一般认为会比“将所有子序列彻底排序”更好。这是因为Insertion Sort在面对“几近排序”的序列时，有很好的表现。</p><h6 id="introsort"><a href="#introsort" class="headerlink" title="introsort"></a>introsort</h6><p>Introspective Sorting（内省式排序），简称IntroSort，其行为在大部分情况下几乎与median-of-3 Quick Sort完全相同。但是当分割行为( partitioning）有恶化为二次行为的倾向时，能够自我侦测，转而改用Heap Sort，使效率维持在Heap Sort的O(N log N)，又比一开始就使用Heap Sort来得好。</p><h6 id="SGI-STL-sort"><a href="#SGI-STL-sort" class="headerlink" title="SGI STL sort"></a>SGI STL sort</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 版本一</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">RandomAccessIterator</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">sort</span><span class="params">(RandomAccessIterator first,</span></span></span><br><span class="line"><span class="params"><span class="function">RandomAccessIterator last)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (first != last) &#123;</span><br><span class="line">__introsort_loop(first, last, <span class="built_in">value_type</span>(first), __lg(last - first)  *<span class="number">2</span>);</span><br><span class="line">__final_insertion_sort(first, last);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;    </span><br><span class="line"></span><br><span class="line"><span class="comment">// __lg()用来控制分割恶化的情况；</span></span><br><span class="line"><span class="comment">//找出 2^k &lt;= n 的最大值k。例: n=7，得k=2，n=20，得k=4，n=8，得k=3</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Size</span>&gt;</span><br><span class="line"><span class="keyword">inline</span> Size __lg (Size n) &#123;</span><br><span class="line">Size k;</span><br><span class="line"><span class="keyword">for</span> (k = <span class="number">0</span>; n &gt; <span class="number">1</span>; n &gt;&gt;= <span class="number">1</span>) ++k;</span><br><span class="line"><span class="keyword">return</span> k;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当元素个数为40时，__introsort_loop()的最后一个参数将是5*2，意思是最多允许分割10层。IntroSort算法如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//版本一</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">RandomAccessIterator</span>, <span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Size</span>&gt;</span><br><span class="line"><span class="type">void</span> __introsort_loop(RandomAccessIterator first,</span><br><span class="line">RandomAccessIterator last, T*, </span><br><span class="line">Size depth_limit) &#123;</span><br><span class="line"><span class="comment">// 以下，__stl_threshold是个全局常数，稍早定义为const int 16</span></span><br><span class="line"><span class="keyword">while</span> (last - first &gt; __stl_threshold) &#123;<span class="comment">// &gt; 16</span></span><br><span class="line"><span class="keyword">if</span> (depth_limit == <span class="number">0</span> ) &#123; <span class="comment">//至此，分割恶化</span></span><br><span class="line"><span class="built_in">partial_sort</span>(first, last, last);  <span class="comment">//改用heapsort</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;            </span><br><span class="line">--depth_limit;</span><br><span class="line"><span class="comment">//以下是 median-of-3 partition，选择一个够好的枢轴并决定分割点</span></span><br><span class="line"><span class="comment">//分割点将落在迭代器cut身上</span></span><br><span class="line">RandomAccessIterator cut = __unguarded_partition</span><br><span class="line">(first, last, <span class="built_in">T</span>(__median(*first,</span><br><span class="line">    *(first + (last - first)/<span class="number">2</span>),</span><br><span class="line">   *(last - <span class="number">1</span>))));</span><br><span class="line"><span class="comment">//对右半段递归进行sort.</span></span><br><span class="line">__introsort_loop(cut，last, <span class="built_in">value_type</span>(first), depth_limit);</span><br><span class="line">last = cut;</span><br><span class="line"><span class="comment">//现在回到while循环，准备对左半段递归进行sort</span></span><br><span class="line"><span class="comment">//这种写法可读性较差，效率并没有比较好</span></span><br><span class="line"><span class="comment">// RW STL采用一般教科书写法（直观地对左半段和右半段递归），较易阅读</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当__introsort_loop()结束，[first, last)内有多个“元素个数小于16”的子序列，每个子序列都有相当程度的排序，但尚未完全排序（因为元素个数一旦小于__stl_threshold，就被中止进一步的排序操作了）。回到母函数sort()，再进入__final_insertion_sort()：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/版本一</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">RandomAccessIterator</span>&gt;</span><br><span class="line"><span class="type">void</span> __final_insertion_sort(RandomAccessIterator first,</span><br><span class="line">  RandomAccessIterator last) &#123;</span><br><span class="line"><span class="keyword">if</span> (last - first &gt; __stl_threshold) &#123;<span class="comment">// &gt; 16</span></span><br><span class="line">__insertion_sort(first, first + __stl_threshold);</span><br><span class="line">__unguarded_insertion_sort(first + __stl_threshold， last);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">__insertion_sort(first, last);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此函数首先判断元素个数是否大于16。如果答案为否，就调用__insertion_sort()加以处理。如果答案为是，就将[first, last)分割为长度16的一段子序列，和另一段剩余子序列，再针对两个子序列分别调用__insertion_sort()和__unguarded_insertion_sort()。前者源代码已前展示过，后者源代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//版本一</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">RandomAccessIterator</span>&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="type">void</span> __unguarded_insertion_sort(RandomAccessIterator first,</span><br><span class="line">    RandomAccessIterator last) &#123;</span><br><span class="line">__unguarded_insertion_sort_aux(first, last, <span class="built_in">value_type</span>(first));</span><br><span class="line">&#125;    </span><br><span class="line"></span><br><span class="line"><span class="comment">//版本一</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">RandomAccessIterator</span>, <span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> __unguarded_insertion_sort_aux(RandomAccessIterator first,</span><br><span class="line"> RandomAccessIterator last,</span><br><span class="line">                                    T*) &#123;</span><br><span class="line"><span class="keyword">for</span> (RandomAccessIterator i = first; i != last; ++i)</span><br><span class="line">__unguarded_linear_insert(i, <span class="built_in">T</span>(*i)); <span class="comment">//见先前展示</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>RW STL版本的sort()，纯粹的Quick Sort，不是IntroSort：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">RandomAccessIterator</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">sort</span><span class="params">(RandomAccessIterator first,</span></span></span><br><span class="line"><span class="params"><span class="function">    RandomAccessIterator last)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!(first == last)) &#123;</span><br><span class="line">__quick_sort_loop(first, last);</span><br><span class="line">__final_insertion_sort(first, last); <span class="comment">//其内操作与SGI STL完全相同</span></span><br><span class="line">&#125;        </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">RandomAccessIterator</span>&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="type">void</span> __quick_sort_loop(RandomAccessIterator first,</span><br><span class="line">    RandomAccessIterator last)</span><br><span class="line">&#123;</span><br><span class="line">__quick_sort_loop_aux(first, last, _RWSTD_VALUE_TYPE(first));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">RandomAccessIterator</span>, <span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> __quick_sort_loop_aux(RandomAccessIterator first,</span><br><span class="line"> RandomAccessIterator last, T*)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span> (last - first &gt; __stl_threshold)</span><br><span class="line">    &#123;</span><br><span class="line"><span class="comment">//median-of- 3 partitioning</span></span><br><span class="line">RandomAccessIterator cut = __unguarded_partition</span><br><span class="line">(first, last, <span class="built_in">T</span>(__median(*first, *(first + (last - first)/<span class="number">2</span>),</span><br><span class="line">*(last - <span class="number">1</span>))));</span><br><span class="line"><span class="keyword">if</span> (cut - first &gt;= last - cut)</span><br><span class="line">&#123;</span><br><span class="line">__quick_sort_loop(cut, last);<span class="comment">//对右段递归处理</span></span><br><span class="line">last = cut;</span><br><span class="line">&#125;            </span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">__quick_sort_loop(first, cut);<span class="comment">//对左段递归处理</span></span><br><span class="line">first = cut;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="equal-range（应用于有序区间）"><a href="#equal-range（应用于有序区间）" class="headerlink" title="equal_range（应用于有序区间）"></a>equal_range（应用于有序区间）</h4><p>该算法返回一对迭代器i和j，其中i是在不破坏次序的前提下，value可插入的第一个位置（亦即lower_bound），j则是在不破坏次序的前提下，value可插入的最后一个位置（亦即upper_bound）。因此，[i, j)内的每个元素都等同于value，而且[first, last)之中符合此一性质的最大子区间。</p><p>即使[first, last)并未含有“与value 等同”之任何元素，以上叙述仍然合理。这种情况下“与value 等同”之所有元素所形成的，其实是个空区间。在不破坏次序的前提下，只有一个位置可以插入value，而equal_range所返回的 pair，其第一和第二元素（都是迭代器）皆指向该位置。</p><p>本算法有两个版本，第一版本采用operator&lt;进行比较，第二版本采用仿函数comp进行比较。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//版本一</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">ForwardIterator</span>, <span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> pair&lt;ForwardIterator, ForwardIterator&gt;</span></span><br><span class="line"><span class="function"><span class="title">equal_range</span><span class="params">(ForwardIterator first, ForwardIterator last</span></span></span><br><span class="line"><span class="params"><span class="function">   <span class="type">const</span> T&amp; value)</span> </span>&#123;</span><br><span class="line"><span class="comment">//根据迭代器的种类型（category），采用不同的策略</span></span><br><span class="line"><span class="keyword">return</span> __equal_range(first, last, value, <span class="built_in">distance_type</span>(first),</span><br><span class="line">    <span class="built_in">iterator_category</span>(first));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//版本一的random_access_iterator版本</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">RandomAccessIterator</span>, <span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Distance</span>&gt;</span><br><span class="line">pair&lt;RandomAccessIterator, RandomAccessIterator&gt;</span><br><span class="line">__equal_range(RandomAccessIterator first, RandomAccessIterator last,</span><br><span class="line">  <span class="type">const</span> T&amp; value, Distance*, random_access_iterator_tag) &#123;</span><br><span class="line">Distance len = last - first;</span><br><span class="line">Distance half;</span><br><span class="line">RandomAccessIterator middle, left, right;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (len &gt; <span class="number">0</span> ) &#123;<span class="comment">//整个区间尚未遍历完毕</span></span><br><span class="line">half = len &gt;&gt; <span class="number">1</span>;<span class="comment">//找出中央位置</span></span><br><span class="line">middle = first + half;  <span class="comment">//设定中央迭代器</span></span><br><span class="line"><span class="keyword">if</span> (*middle &lt; value) &#123;  <span class="comment">//如果中央元素&lt;指定值</span></span><br><span class="line">first = middle + <span class="number">1</span>; <span class="comment">//将运作区间缩小（移至后半段），以提高效率</span></span><br><span class="line">len = len - half - <span class="number">1</span>;</span><br><span class="line">&#125;            </span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (value &lt; *middle)<span class="comment">//如果中央元素&gt;指定值</span></span><br><span class="line">len = half;   <span class="comment">//将运作区间缩小（移至前半段）以提高效率</span></span><br><span class="line"><span class="keyword">else</span> &#123;   <span class="comment">//如果中央元素==指定值</span></span><br><span class="line"><span class="comment">//在前半段找lower_bound</span></span><br><span class="line">left = <span class="built_in">lower_bound</span>(first, middle, value);</span><br><span class="line"><span class="comment">//在后半段找upper_bound</span></span><br><span class="line">right = <span class="built_in">upper_bound</span>(++middle, first + len, value);</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">pair</span>&lt;RandomAccessIterator, RandomAccesstterator&gt;(left, right);</span><br><span class="line">&#125;</span><br><span class="line">&#125;        </span><br><span class="line"><span class="comment">//整个区间内都没有匹配的值，那么应该返回一对迭代器，指向第一个大于value的元素</span></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">pair</span>&lt;RandomAccessIterator, RandomAccessIterator&gt;(first, first);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//版本一的forward_iterator版本</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">ForwardIterator</span>, <span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Distance</span>&gt;</span><br><span class="line">pair&lt;ForwardIterator, ForwardIterator&gt;</span><br><span class="line">__equal_range(ForwardIterator first, ForwardIterator last, <span class="type">const</span> T&amp; value,</span><br><span class="line">Distance*, forward_iterator_tag) &#123; </span><br><span class="line">Distance len = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">distance</span>(first, last, len);</span><br><span class="line">Distance half;</span><br><span class="line">ForwardIterator middle, left, right;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">half = len &gt;&gt; <span class="number">1</span>;</span><br><span class="line">middle = first;  <span class="comment">//此行及下一行，相当于RandomAccessiterator的</span></span><br><span class="line"><span class="built_in">advance</span>(middle, half); <span class="comment">//middle = first + half;</span></span><br><span class="line"><span class="keyword">if</span> (*middle &lt; value) &#123;</span><br><span class="line">first = middle;   <span class="comment">//此行及下一行，相当于RandomAccessiterator的</span></span><br><span class="line">++first;   <span class="comment">//first = middle + 1;</span></span><br><span class="line">len = len - half - <span class="number">1</span>;</span><br><span class="line">&#125;            </span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (value &lt; *middle)</span><br><span class="line">len = half;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">left = <span class="built_in">lower_bound</span>(first, middle, value);</span><br><span class="line"><span class="comment">//以下这行相当于RandomAccessIterator的first += len;</span></span><br><span class="line"><span class="built_in">advance</span>(first, len);</span><br><span class="line">right = <span class="built_in">upper_bound</span>(++middle, first, value);</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">pair</span>&lt;ForwardIterator, ForwardIterator&gt;(left, right);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;        </span><br><span class="line"><span class="keyword">return</span> <span class="built_in">pair</span>&lt;ForwardIterator, ForwardIterator&gt;(first, first);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="inplace-merge（应用于有序区间）"><a href="#inplace-merge（应用于有序区间）" class="headerlink" title="inplace_merge（应用于有序区间）"></a>inplace_merge（应用于有序区间）</h4><p>如果两个连接在一起的序列[first, middle)和[middle, last)都已排序，那么inplace_merge可将它们结合成单一一个序列，并仍保有序性(sorted)。如果原先两个序列是递增排序，执行结果也会是递增排序，如果原先两个序列是递减排序，执行结果也会是递减排序。</p><p>和merge一样， inplace_merge也是一种稳定（stable）操作。每个作为数据来源的子序列中的元素相对次序都不会变动；如果两个子序列有等同的元素，第一序列的元素会被排在第二序列元素之前。</p><p>inplace_merge 有两个版本，其差别在于如何定义某元素小于另一个元素。第一版本使用operator&lt;进行比较，第二版本使用仿函数（functor）comp进行比较。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">BidirectionalIterator</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">inplace_merge</span><span class="params">(BidirectionalIterator first,</span></span></span><br><span class="line"><span class="params"><span class="function">    BidirectionalIterator middle,</span></span></span><br><span class="line"><span class="params"><span class="function">    BidirectionalIterator last)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 只要有任何一个序列为空，就什么都不必做</span></span><br><span class="line"><span class="keyword">if</span> (first == middle || middle == last) <span class="keyword">return</span>;</span><br><span class="line">__inplace_merge_aux(first, middle, last, <span class="built_in">value_type</span>(first),</span><br><span class="line">   <span class="built_in">distance_type</span>(first));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//辅助函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">BidirectionalIterator</span>, <span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Distance</span>&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="type">void</span> __inplace_merge_aux(BidirectionalIterator first,</span><br><span class="line">  BidirectionalIterator middle,</span><br><span class="line">                                 BidirectionalIterator last, </span><br><span class="line">                                 T*, Distance*) &#123;</span><br><span class="line">Distance len1 = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">distance</span>(first, middle, len1);<span class="comment">// len1表示序列一的长度</span></span><br><span class="line">Distance len2 = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">distance</span>(middle, last, len2);<span class="comment">// len2表示序列二的长度</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//注意，本算法会使用额外的内存空间（暂时缓冲区）</span></span><br><span class="line"><span class="function">temporary_buffer&lt;BidirectionalIterator, T&gt; <span class="title">buf</span><span class="params">(first, last)</span></span>;</span><br><span class="line"><span class="keyword">if</span> (buf.<span class="built_in">begin</span>() == <span class="number">0</span>)<span class="comment">//内存配置失败</span></span><br><span class="line">__merge_without_buffer(first, middle, last, len1, len2);</span><br><span class="line"><span class="keyword">else</span><span class="comment">//在有暂时缓冲区的情况下进行</span></span><br><span class="line">__merge_adaptive(first, middle, last, len1, len2,</span><br><span class="line">buf.<span class="built_in">begin</span>(), <span class="built_in">Distance</span>(buf.<span class="built_in">size</span>()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个算法如果有额外的内存（缓冲区）辅助，效率会好很多。但是在没有缓冲区或缓冲区不足的情况下，也可以运作。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//辅助函数。有缓冲区的情况下</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">BidirectionalIterator</span>, <span class="keyword">class</span> <span class="title class_">Distance</span>, <span class="keyword">class</span> <span class="title class_">Pointer</span>&gt;</span><br><span class="line"><span class="type">void</span> __merge_adaptive(BidirectionalIterator first,</span><br><span class="line">BidirectionalIterator middle,</span><br><span class="line">                      BidirectionalIterator last,</span><br><span class="line">                      Distance len1, Distance len2,</span><br><span class="line">Pointer buffer, Distance buffer_size) &#123;</span><br><span class="line"><span class="keyword">if</span> (len1 &lt;= len2 &amp;&amp; len1 &lt;= buffer_size) &#123;</span><br><span class="line"><span class="comment">//case1．缓冲区足够安置序列一</span></span><br><span class="line">Pointer end_buffer = <span class="built_in">copy</span>(first, middle, buffer);</span><br><span class="line"><span class="built_in">merge</span>(buffer, end_buffer, middle, last, first);</span><br><span class="line">&#125;        </span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (len2 &lt;= buffer_size) &#123;</span><br><span class="line"><span class="comment">//case2．缓冲区足够安置序列二</span></span><br><span class="line">Pointer end_buffer = <span class="built_in">copy</span>(middle, last, buffer);</span><br><span class="line">__merge_backward(first, middle, buffer, end_buffer, last);</span><br><span class="line"><span class="keyword">else</span> &#123; <span class="comment">// case3. 缓冲区空间不足安置任何一个序列</span></span><br><span class="line">BidirectionalIterator first_cut = first;</span><br><span class="line">BidirectionalIterator second_cut = middle;</span><br><span class="line"> Distance len11 = <span class="number">0</span>;</span><br><span class="line">Distance len22 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (len1 &gt; len2) &#123;<span class="comment">//序列一比较长</span></span><br><span class="line">len11 = len1 / <span class="number">2</span>;</span><br><span class="line"><span class="built_in">advance</span>(first_cut, len11);</span><br><span class="line">second_cut = <span class="built_in">lower_bound</span>(middle, last, *first_cut);</span><br><span class="line"><span class="built_in">distance</span>(middle, second_cut, len22);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;<span class="comment">//序列二比较长</span></span><br><span class="line">len22 = len2 / <span class="number">2</span>;</span><br><span class="line"><span class="built_in">advance</span>(second_cut, len22);</span><br><span class="line">first_cut = <span class="built_in">lower_bound</span>(first, middle, *second_cut);</span><br><span class="line"><span class="built_in">distance</span>(first, first_cut, len11);</span><br><span class="line">&#125;</span><br><span class="line">BidirectionalIterator new_middle =</span><br><span class="line">__rotate_adaptive(first_cut, middle, second_cut, len1 - len11,</span><br><span class="line">len2 - len22, buffer, buffer_size);</span><br><span class="line"><span class="comment">//针对左段，递归调用</span></span><br><span class="line">__merge_adaptive(first, first_cut, new_middle, len11, len22, buffer,</span><br><span class="line">buffer_size);</span><br><span class="line"><span class="comment">//针对右段，递归调用</span></span><br><span class="line">__merge_adaptive(new_middle, second_cut, last, lenl - len11,</span><br><span class="line">len2 - len22, buffer, buffer_size);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述辅助函数首先判断缓冲区是否足以容纳 inplace_merge 所接受的两个序列中的任何一个。如果空间充裕（源代码中标示case1和 case2之处），工作逻辑很简单：把两个序列中的某一个 copy 到缓冲区中，再使用merge完成其余工作。是的，merge足堪胜任，它的功能就是将两个有序但分离（sorted and separated）的区间合并，形成一个有序区间，因此，我们只需将 merge 的结果置放处（迭代器result）指定为inplace_merge所接受之序列起始点（迭代器first）即可。</p><p>但是当缓冲区不足以容纳任何个序列时（源代码中标示 case3之处)，情况就棘手多了。面对这种情况，我们的处理原则是，以递归分割( recursive partitioning )的方式，让处理长度减半，看看能否容纳于缓冲区中。</p><p>举例来说，假设缓冲区大小为3，小于序列一的长度4和序列二的长度5，于是，拿较长的序列二开刀，计算出first_cut和 second_cut 如下：</p><p><img src="/../img/%E8%AE%A1%E7%AE%97first_cut%E5%92%8Csecond_cut.png" alt="计算first_cut和second_cut"></p><p>然后针对上图的淡蓝色阴影部分（{7, 2, 4}）执行旋转操作：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">BidirectionalIterator new_middle =</span><br><span class="line">__rotate_adaptive(first_cut, middle, second_cut, len1 - len11,</span><br><span class="line"> len22, buffer, buffer_size);</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">BidirectionalIterator1</span>, <span class="keyword">class</span> <span class="title class_">BidirectionalIterator2</span>,</span><br><span class="line"> <span class="keyword">class</span> <span class="title class_">Distance</span>&gt;</span><br><span class="line">Bidirectionallterator1 __rotate_adaptive(Bidirectionallterator1 first,</span><br><span class="line">  BidirectionalIterator1 middle,</span><br><span class="line">  BidirectionalIterator1 last,</span><br><span class="line">                                          Distance len1, Distance len2,   BidirectionalIterator2 buffer,   Distance buffer_size) &#123;</span><br><span class="line">BidirectionalIterator2 buffer_end;</span><br><span class="line"><span class="keyword">if</span> (lenl &gt; len2 &amp;&amp; len2 &lt;= buffer_size) &#123;<span class="comment">//缓冲区足够安置序列二（较短）</span></span><br><span class="line">buffer_end = <span class="built_in">copy</span>(middle, last, buffer);</span><br><span class="line"><span class="built_in">copy_backward</span>(first, middle, last);</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">copy</span>(buffer, buffer_end, first);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (len1 &lt;= buffer_size) &#123;<span class="comment">//缓冲区足够安置序列一</span></span><br><span class="line">buffer_end = <span class="built_in">copy</span>(first, middle, buffer);</span><br><span class="line"><span class="built_in">copy</span>(middle, last, first);</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">copy_backward</span>(buffer, buffer_end, last);</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//缓冲区仍然不足．改用rotate算法（不需缓冲区）</span></span><br><span class="line"><span class="built_in">rotate</span>(first, middle, last);</span><br><span class="line"><span class="built_in">advance</span>(first, len2);</span><br><span class="line"><span class="keyword">return</span> first;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经过这样的处理，原序列变成里：</p><p><img src="/../img/new_middle.png" alt="new_middle"></p><p>现在可以分段处理了。首先针对左段[first, first_cut, new_middle)，也就是上图的淡蓝色阴影部分{1, 3, 5, 2, 4}，做递归调用：</p><p><img src="/../img/%E5%B7%A6%E6%AE%B5%E9%80%92%E5%BD%92%E8%B0%83%E7%94%A8.png" alt="左段递归调用"></p><p>再针对右段[new_middle, second_cut, last)，也就是上图的淡蓝色阴影部分{7, 6, 8, 10}，做递归调用：</p><p><img src="/../img/%E5%8F%B3%E6%AE%B5%E9%80%92%E5%BD%92%E8%B0%83%E7%94%A8.png" alt="右段递归调用"></p><h4 id="nth-element"><a href="#nth-element" class="headerlink" title="nth_element"></a>nth_element</h4><p>该算法会重新排列[first, last)，使排序后第n个迭代器（nth）所指的元素，与“整个[first, last)序列完整排序后，第n个位置的元素”同值。此外，还保证排序前第n个元素可以在排序后分割整个序列（即左侧[first, nth)的元素全部不大于右侧[nth, last)的元素），但对于[first, nth)和[nth, last)两个子区间内的元素次序则无任何保证。</p><p>举例来说，假设有序列{22, 30, 30, 17, 33, 40, 17, 23, 22, 12, 20}，以下操作：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">nth_element</span>(iv.<span class="built_in">begin</span>(), iv.<span class="built_in">begin</span>() + <span class="number">5</span>, iv.<span class="built_in">end</span>());</span><br></pre></td></tr></table></figure><p>便是将小于*(iv.begin() + 5)（本例为40）的元素置于该元素之左，其余置于该元素之右，并且不保证维持原有的相对位置。获得的结果为{20, 12, 22, 17, 17, 22, 23, 30, 30, 33, 40}。执行完毕后的第5个位置上的元素值22，与整个序列完整排序后{12, 17, 17, 20, 22, 22, 23, 30, 30, 33, 40}的第5个位置上的元素值相同。</p><p>如果以上述结果{20, 12, 22,17,17, 22, 23, 30, 30, 33, 40}为根据，再执行以下操作：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">nth_element</span>(iv.<span class="built_in">begin</span>(), iv.<span class="built_in">begin</span>() + <span class="number">5</span>, iv.<span class="built_in">end</span>(), <span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;());</span><br></pre></td></tr></table></figure><p>那便是将大于*(iv.begin() + 5)（本例为22）的元素置于该元素之左，其余置于该元素之右，并且不保证维持原有的相对位置。获得的结果为{40, 33, 30, 30, 23, 22, 17, 17, 22, 12, 20}。</p><p>由于nth_element 比partial_sort的保证更少（是的，它不保证两个子序列内的任何次序），所以它当然应该比partial_sort较快。</p><p>nth_element有两个版本，其差异在于如何定义某个元素小于另一个元素。第一版本使用operator&lt;进行比较，第二个版本使用仿函数comp进行比较。注意，这个算法只接受RandomAccesslterator。</p><p>nth_element的做法是，不断地以median-of-3 partitioning（以首、尾、中央三点中值为枢轴之分割法）将整个序列分割为更小的左(L)、右(R)子序列。如果nth迭代器落于左子序列，就再对左子序列进行分割，否则就再对右子序列进行分割。依此类推，直到分割后的子序列长度不大于3（够小了），便对最后这个待分割的子序列做Insertion Sort，大功告成。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//版本一</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">RandomAccessIterator</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">nth_element</span><span class="params">(RandomAccessIterator first,</span></span></span><br><span class="line"><span class="params"><span class="function">  RandomAccessIterator nth,</span></span></span><br><span class="line"><span class="params"><span class="function">                        RandormAccessIterator last)</span> </span>&#123;</span><br><span class="line">__nth_element(first, nth, last, <span class="built_in">value_type</span>(first));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//版本一辅助函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">RandomAccessIterator</span>, <span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> __nth_element(RandomAccessIterator first,</span><br><span class="line">  RandomAccessIterator nth,</span><br><span class="line">  RandomAccessIterator last, T*) &#123;</span><br><span class="line"><span class="keyword">while</span> (last - first &gt; <span class="number">3</span>)&#123;<span class="comment">//长度超过3</span></span><br><span class="line"><span class="comment">//采用median-of-3 partitioning。参数:(first, last, pivot)</span></span><br><span class="line"><span class="comment">//返回一个迭代器，指向分割后的右段第一个元素</span></span><br><span class="line">RandomAccessIterator cut = __unguarded_partition</span><br><span class="line">            (first, last, <span class="built_in">T</span>(__median(*first,</span><br><span class="line">  *(first + (last - first)/<span class="number">2</span>),</span><br><span class="line">                                     *(last - <span class="number">1</span>))));</span><br><span class="line"><span class="keyword">if</span> (cut &lt;= nth)<span class="comment">//如果右段起点&lt;=指定位置(nth落于右段</span></span><br><span class="line">first = cut;<span class="comment">//再对右段实施分割(partitioning)</span></span><br><span class="line"><span class="keyword">else</span><span class="comment">//否则(nth落于左段)</span></span><br><span class="line">last = cut; <span class="comment">//对左段实施分割(partitioning)</span></span><br><span class="line">&#125;</span><br><span class="line">__insertion_sort(first, last);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="merge-sort"><a href="#merge-sort" class="headerlink" title="merge sort"></a>merge sort</h4><p>既然我们知道，将两个有序（sorted）区间归并成一个有序区间，效果不错，那么我们可以利用“分而治之”( devide and conquer )”的概念，以各个击破的方式来对一个区间进行排序。首先，将区间对半分割，左右两段各自排序，再利用inplace_merge重新组合为一个完整的有序序列。对半分割的操作可以递归进行，直到每一小段的长度为0或1（那么该小段也就自动完成了排序）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">BidirectionalIter</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mergesort</span><span class="params">(BidirectionalIter first, BidirectionalIter last)</span> </span>&#123;</span><br><span class="line"><span class="keyword">typename</span> iterator_traits&lt;BidirectionalIter&gt;::difference_type n</span><br><span class="line"> = <span class="built_in">distance</span>(first, last);</span><br><span class="line"><span class="keyword">if</span> (n == <span class="number">0</span> || n == <span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">BidirectionalIter mid = first + n / <span class="number">2</span>;</span><br><span class="line"><span class="built_in">mergesort</span>(first, mid);</span><br><span class="line"><span class="built_in">mergesort</span>(mid, last);</span><br><span class="line"><span class="built_in">inplace_merge</span>(first, mid, last);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Merge Sort的复杂度为O(N logN)。虽然这和Quick Sort是一样的，但因为Merge Sort需借用额外的内存，而且在内存之间移动（复制）数据也会耗费不少时间，所以Merge Sort的效率比不上 Quick Sort。实现简单、概念简单，是Merge Sort的两大优点。</p>]]></content>
    
    
    <summary type="html">&lt;STL源码剖析&gt;第六章读书笔记，各种算法实现</summary>
    
    
    
    <category term="STL源码剖析读书笔记" scheme="http://example.com/categories/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="STL" scheme="http://example.com/tags/STL/"/>
    
    <category term="STL源码剖析" scheme="http://example.com/tags/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"/>
    
    <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>&lt;STL源码剖析&gt;第五章</title>
    <link href="http://example.com/2022/04/02/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E7%AC%AC%E4%BA%94%E7%AB%A0/"/>
    <id>http://example.com/2022/04/02/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E7%AC%AC%E4%BA%94%E7%AB%A0/</id>
    <published>2022-04-01T16:00:00.000Z</published>
    <updated>2022-04-07T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h2><p><img src="/../img/%E5%AE%B9%E5%99%A8.png" alt="容器"></p><p>容器将运用最广的一些数据结构实现出来。这里的衍生不是inheritance关系，而是containment关系，例如：heap内含一个vector，priority-queue内含一个heap。</p><h2 id="关联式容器"><a href="#关联式容器" class="headerlink" title="关联式容器"></a>关联式容器</h2><p>所谓关联式容器，观念上类似关联式数据库（实际上则简单许多）：每笔数据（每个元素）都有一个键值（key）和一个实值（value）。当元素被插人到关联式容器中时，容器内部结构（可能是RB-tree，也可能是hash-table）便依照其键值大小，以某种特定规则将这个元素放置于适当位置。关联式容器没有所谓头尾（只有最大元素和最小元素），所以不会有所谓push_back()、push_front()、pop_back()、pop_front()、begin()、 end()这样的操作行为。</p><p>一般而言，关联式容器的内部结构是一个balanced binary tree(平衡二叉树)，以便获得良好的搜寻效率。balanced binary tree有许多种类型，包括AVL-tree、RB-tree、AA-tree，其中最广泛被运用于STL的是RB-tree。</p><h3 id="二叉搜索树（binary-search-tree）"><a href="#二叉搜索树（binary-search-tree）" class="headerlink" title="二叉搜索树（binary search tree）"></a>二叉搜索树（binary search tree）</h3><p>二叉搜索树可提供对数时间的元素插入和访问，二叉搜索树的节点放置规则是：任何节点的键值一定大于其左子树中的每一个节点的键值，并小于其右子树中的每一个节点的键值。因此，从根节点一直往左走，直至无左路可走，即得到最小元素；从根节点一直往右走，直至无右路可走，即得最大元素。</p><p><img src="/../img/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.png" alt="二叉搜索树"></p><h3 id="平衡二叉搜索树（balanced-binary-search-tree）"><a href="#平衡二叉搜索树（balanced-binary-search-tree）" class="headerlink" title="平衡二叉搜索树（balanced binary search tree）"></a>平衡二叉搜索树（balanced binary search tree）</h3><p>二叉搜索树可能会因为输入值不够随机或者一些插入删除操作的原因失去平衡，造成搜寻效率低的情况。</p><p><img src="/../img/%E4%B8%8D%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91.png" alt="不平衡二叉树"></p><p>“平衡”的大致意义是：没有任何一个节点过深，并没有一个绝对的衡量标准，因此，出现了不同的平衡条件造就的数种特殊结构如AVL-tree、RB-tree、AA-tree，他们都比一般的二叉搜索树复杂，因此，插入和删除节点的平均时间更长，但是可以避免不平衡的情况而实现更少的元素平均访问时间。</p><h3 id="AVL-tree"><a href="#AVL-tree" class="headerlink" title="AVL tree"></a>AVL tree</h3><p>AVL-tree要求任何节点的左右子树高度相差最多1，虽然要求每个节点的左右子树有着相同的高度是直观上的最佳平衡条件，但这样太过苛刻以至于难以在插入新元素时又保持着这种平衡状态。</p><p>AVL-tree的平衡策略是：调整“插入点至根节点”路径上，平衡状态被破坏之各节点中最深的那一个，使整棵树重新获得平衡。假设该最深节点为X，“平衡破坏”意味着X的左右两颗子树的高度相差2，可以将情况分为四种：</p><ol><li>插人点位于X的左子节点的左子树——左左。</li><li>插人点位于X的左子节点的右子树——左右。</li><li>插人点位于X的右子节点的左子树——右左。</li><li>插入点位于X的右子节点的右子树——右右。</li></ol><p>情况1，4称为外侧插入，可以用单旋操作调整；情况2，3称为内侧插入，可以采用双旋操作调整。</p><p><img src="/../img/AVL-tree%E7%A0%B4%E5%9D%8F%E5%B9%B3%E8%A1%A1.png" alt="AVL-tree破坏平衡"></p><h4 id="单旋转"><a href="#单旋转" class="headerlink" title="单旋转"></a>单旋转</h4><p><img src="/../img/%E5%8D%95%E6%97%8B%E8%BD%AC.png" alt="单旋转"></p><p>通过k1上提，k2下滑来获得平衡（以k1为新的根节点）。</p><h4 id="双旋转"><a href="#双旋转" class="headerlink" title="双旋转"></a>双旋转</h4><p><img src="/../img/%E5%8F%8C%E6%97%8B%E8%BD%AC.png" alt="双旋转"></p><p>以k2为新的根节点来获得平衡。</p><p>可拆解为两次单循环：</p><p><img src="/../img/%E5%8F%8C%E5%BE%AA%E7%8E%AF%E6%8B%86%E8%A7%A3.png" alt="双循环拆解"></p><h3 id="RB-tree（红黑树）"><a href="#RB-tree（红黑树）" class="headerlink" title="RB-tree（红黑树）"></a>RB-tree（红黑树）</h3><p>AVL-tree之外，另一个平衡二叉搜索树是RB-tree（红黑树），红黑树不仅是一个二叉搜索树，还必须满足以下规则：</p><ol><li>每个节点不是红色就是黑色（图中深色底纹代表黑色，浅色底纹代表红色，下同)。</li><li>根节点为黑色。</li><li>如果节点为红，其子节点必须为黑。</li><li>任一节点至 NULL（树尾端）的任何路径，所含之黑节点数必须相同。</li></ol><p>根据规则4，新增节点必须为红，根据规则3，新增节点之父节点必须为黑。</p><p><img src="/../img/%E7%BA%A2%E9%BB%91%E6%A0%91.png" alt="红黑树"></p><h4 id="插入节点"><a href="#插入节点" class="headerlink" title="插入节点"></a>插入节点</h4><p>假设新节点为X，其父节点为P，祖父节点为G，父节点的兄弟节点为S，曾祖父节点为GG。</p><p>首先，二叉搜索树的新增节点必为叶节点，因此，X节点必为叶节点即必是红色，如果此时P节点也为红色，就违反了规则，此时G必为黑，于是插入节点后需调整的情况可根据X插入位置以及S和GG的颜色分为四类：</p><ol><li>S为黑且X为外侧插入。此时，先对P，G做一次单旋转，再更改P,G颜色。</li></ol><p><img src="/../img/S%E9%BB%91%E5%A4%96%E6%8F%92.png" alt="S黑外插"></p><ol start="2"><li>S为黑且X为内侧插入。此时，做一次双旋转（先对P，X做一次单旋转且更改G，X颜色，再对G做一次单旋转）。</li></ol><p><img src="/../img/S%E9%BB%91%E5%86%85%E6%8F%92.png" alt="S黑内插"></p><ol start="3"><li>S为红且X为外侧插入。此时，先对P，G做一次单旋转，并改变X的颜色，此时如果GG为黑，则搞定。</li></ol><p><img src="/../img/S%E7%BA%A2%E5%A4%96%E6%8F%92GG%E9%BB%91.png" alt="S红外插GG黑"></p><ol start="4"><li>S为红且X为外侧插入，此时，先对P，G做一次单旋转，并改变X的颜色，此时如果GG为红，则不应该这样做，而是应该先实行一个由上而下的程序：假设新增节点为A，那么就沿着A的路径，只要看到有某节点X的两个子节点皆为红色，就把X改为红色，并把两个子节点改为黑色，如果X的父节点P以为红色，就得像状况1做一次单旋转并改变颜色或是像状况2做一次双旋转并改变颜色。程序结束后再插入就很简单了。</li></ol><h4 id="RB-tree节点设计"><a href="#RB-tree节点设计" class="headerlink" title="RB-tree节点设计"></a>RB-tree节点设计</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">bool</span> __rb_tree_color_type;</span><br><span class="line"><span class="type">const</span> __rb_tree_color_type __rb_tree_red = <span class="literal">false</span>; <span class="comment">//红色为0</span></span><br><span class="line"><span class="type">const</span> __rb_tree_color_type __rb_tree_black = <span class="literal">true</span>; <span class="comment">//黑色为1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__rb_tree_node_base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">typedef</span> __rb_tree_color_type color_type;</span><br><span class="line"><span class="keyword">typedef</span> __rb_tree_node_base* base_ptr;</span><br><span class="line"></span><br><span class="line">color_type color;  <span class="comment">//节点颜色，非红即黑</span></span><br><span class="line">base_ptr parent;   <span class="comment">//RB树的许多操作，必须知道父节点</span></span><br><span class="line">base_ptr left;     <span class="comment">//指向左节点</span></span><br><span class="line">base_ptr right;    <span class="comment">//指向右节点</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> base_ptr <span class="title">mininum</span><span class="params">(base_ptr x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"><span class="keyword">while</span> (x-&gt;left != <span class="number">0</span>) x = x-&gt;left;   <span class="comment">//一直向左走，就会找到最小值,</span></span><br><span class="line"><span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> base_ptr <span class="title">maximum</span><span class="params">(base_ptr x)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"><span class="keyword">while</span> (x-&gt;right != <span class="number">0</span>) x = x-&gt;right; <span class="comment">//一直向右走，就会找到最大,</span></span><br><span class="line"><span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Value</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__rb_tree_node</span> : <span class="keyword">public</span> __rb_tree_node_base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">typedef</span> __rb_tree_node&lt;Value&gt;* link_type;</span><br><span class="line">Value value_field;   <span class="comment">//节点值</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="RB-tree的迭代器"><a href="#RB-tree的迭代器" class="headerlink" title="RB-tree的迭代器"></a>RB-tree的迭代器</h4><p>RB-tree的节点和迭代器（Bidirectional Iterator）结构设计和slist类似，为两层结构：</p><p><img src="/../img/RB-tree%E8%8A%82%E7%82%B9%E5%92%8C%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%BB%93%E6%9E%84.png" alt="RB-tree节点和迭代器结构"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//基层迭代器</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__rb_tree_base_iterator</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">typedef</span> __rb_tree_node_base::base_ptr base_ptr;</span><br><span class="line"><span class="keyword">typedef</span> bidirectional_iterator_tag iterator_category;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">ptrdiff_t</span> difference_type;</span><br><span class="line"></span><br><span class="line">base_ptr node; <span class="comment">// 它用来与容器之间产生一个连结关系(make a reference)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//以下其实可实现于operator++内，因为再无他处会调用此函数了</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">increment</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (node-&gt;right != <span class="number">0</span>) &#123;<span class="comment">//如果有右子节点。状况(1)</span></span><br><span class="line">node = node-&gt;right;         <span class="comment">//就向右走</span></span><br><span class="line"><span class="keyword">while</span> (node-&gt;left != <span class="number">0</span>）    <span class="comment">//然后一直往左子树走到底</span></span><br><span class="line">node = node-&gt;left;      <span class="comment">//即是解答</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;                           <span class="comment">//没有右子节点。状况(2)</span></span><br><span class="line">base_ptr y = node-&gt;parent;   <span class="comment">//找出父节点</span></span><br><span class="line"><span class="keyword">while</span> (node == y-&gt;right) &#123;   <span class="comment">//如果现行节点本身是个右子节点，</span></span><br><span class="line">node = y;                <span class="comment">//就一直上溯，直到“不为右子节点”止</span></span><br><span class="line">y = y-&gt;parent;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="keyword">if</span> (node-&gt;right != y)        <span class="comment">//若此时的右子节点不等于此时的父节点</span></span><br><span class="line">node = y;                <span class="comment">//状况(3)此时的父节点即为解答</span></span><br><span class="line">               <span class="comment">//否则此时的node为解答。状况(4)</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//注意，以上判断“若此时的右子节点不等于此时的父节点”，是为了应付一种</span></span><br><span class="line"><span class="comment">//特殊情况:我们欲寻找根节点的下一节点，而恰巧根节点无右子节点</span></span><br><span class="line"><span class="comment">//当然，以上特殊做法必须配合RB-tree 根节点与特殊之header之间的</span></span><br><span class="line"><span class="comment">//特殊关系</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//以下其实可实现于operator--内，因为再无他处会调用此函数了</span></span><br><span class="line"><span class="type">void</span> <span class="built_in">decrement</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (node-&gt;color == __rb_tree_red &amp;&amp; <span class="comment">//如果是红节点，且</span></span><br><span class="line">node-&gt;parent-&gt;parent == node)   <span class="comment">//父节点的父节点等于自己，</span></span><br><span class="line">node = node-&gt;right;             <span class="comment">//状况(1)右子节点即为解答</span></span><br><span class="line"><span class="comment">//以上情况发生于node为header时(亦即node为end()时)</span></span><br><span class="line"><span class="comment">//注意，header之右子节点即mostright，指向整棵树的max节点</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (node-&gt;left != <span class="number">0</span>) &#123;         <span class="comment">//如果有左子节点。状况(2)</span></span><br><span class="line">base_ptr y = node-&gt;left;        <span class="comment">//令y指向左子节点</span></span><br><span class="line"><span class="keyword">while</span> (y-&gt;right ! = <span class="number">0</span>)          <span class="comment">//当y有右子节点时</span></span><br><span class="line">y = y-&gt;right;              <span class="comment">//一直往右子节点走到底</span></span><br><span class="line">node = y;                      <span class="comment">//最后即为答案</span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="keyword">else</span> &#123;                             <span class="comment">//既非根节点，亦无左子节点</span></span><br><span class="line">base_ptr y = node-&gt;parent;     <span class="comment">//状况(3）找出父节点</span></span><br><span class="line"><span class="keyword">while</span> (node == y-&gt;left) &#123;      <span class="comment">//当现行节点身为左子节点</span></span><br><span class="line">node = y;                  <span class="comment">//一直交替往上走，直到现行节点</span></span><br><span class="line">y = y-&gt;parent;             <span class="comment">//不为左子节点</span></span><br><span class="line">&#125;</span><br><span class="line">node = y;      <span class="comment">//此时之父节点即为答案</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;           </span><br><span class="line"></span><br><span class="line"><span class="comment">//RB-tree的正规迭代器</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> Value, <span class="keyword">class</span> Ref, <span class="keyword">class</span> Ptr&gt;</span><br><span class="line"><span class="keyword">struct</span> __rb_tree_iterator : <span class="keyword">public</span> __rb_tree_base_iterator</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">typedef</span> Value value_type;</span><br><span class="line"><span class="keyword">typedef</span> Ref reference;</span><br><span class="line"><span class="keyword">typedef</span> Ptr pointer;</span><br><span class="line"><span class="keyword">typedef</span> __rb_tree_iterator&lt;Value, Value&amp;, Value*&gt; iterator;</span><br><span class="line"><span class="keyword">typedef</span> __rb_tree_iterator&lt;Value, <span class="type">const</span> Value&amp;, <span class="type">const</span> value*&gt; const_iterator;</span><br><span class="line"><span class="keyword">typedef</span> __rb_tree_iterator&lt;Value, Ref, Ptr&gt; self;</span><br><span class="line"><span class="keyword">typedef</span> __rb_tree_node&lt;Value&gt;*    link_type;</span><br><span class="line"></span><br><span class="line">    __rb_tree_iterator() &#123; &#125;</span><br><span class="line">__rb_tree_iterator(link_type x) &#123; node = x; &#125;</span><br><span class="line">__rb_tree_iterator(<span class="type">const</span> iterator&amp; it) &#123; node = it.node; &#125;</span><br><span class="line"></span><br><span class="line">    reference <span class="keyword">operator</span>*() <span class="type">const</span> &#123; <span class="keyword">return</span> <span class="built_in">link_type</span>(node) -&gt; value_field; &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __SGI_STL_NO_ARROW_OPERATOR</span></span><br><span class="line">pointer <span class="keyword">operator</span>-&gt;() <span class="type">const</span> &#123; <span class="keyword">return</span> &amp;(<span class="keyword">operator</span>*()); &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/*__SGI_STL_NO_ARROW_OPERATOR */</span></span></span><br><span class="line"></span><br><span class="line">    self&amp; <span class="keyword">operator</span>++() &#123; <span class="built_in">increment</span>(); <span class="keyword">return</span> *<span class="keyword">this</span>; &#125;</span><br><span class="line">self <span class="keyword">operator</span>++(<span class="type">int</span>) &#123;</span><br><span class="line">self tmp = *<span class="keyword">this</span>;</span><br><span class="line"><span class="built_in">increment</span>();</span><br><span class="line"><span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">self&amp; <span class="keyword">operator</span>--() &#123; <span class="built_in">decrement</span>(); <span class="keyword">return</span> *<span class="keyword">this</span>; &#125;</span><br><span class="line">self <span class="keyword">operator</span>--(<span class="type">int</span>) &#123;</span><br><span class="line">self tmp = *<span class="keyword">this</span>;</span><br><span class="line"><span class="built_in">decrement</span>();</span><br><span class="line"><span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;              </span><br></pre></td></tr></table></figure><p><img src="/../img/inc%E5%92%8Cdec%E7%9A%84%E8%B4%B9%E8%A7%A3%E6%83%85%E5%86%B5.png" alt="inc和dec的费解情况"></p><h4 id="RB-tree的数据结构"><a href="#RB-tree的数据结构" class="headerlink" title="RB-tree的数据结构"></a>RB-tree的数据结构</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Key</span>, <span class="keyword">class</span> <span class="title class_">Value</span>, <span class="keyword">class</span> <span class="title class_">KeyOfValue</span>, <span class="keyword">class</span> <span class="title class_">Compare</span>,</span><br><span class="line"> <span class="keyword">class</span> <span class="title class_">Alloc</span> = alloc&gt;</span><br><span class="line"><span class="keyword">class</span> rb_tree &#123;</span><br><span class="line">    <span class="keyword">protected</span>:</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">void</span>* void_pointer;</span><br><span class="line"><span class="keyword">typedef</span> __rb_tree_node_base* base_ptr;</span><br><span class="line"><span class="keyword">typedef</span> __rb_tree_node&lt;Value&gt; rb_tree_node;</span><br><span class="line"><span class="keyword">typedef</span> simple_alloc&lt;rb_tree_node, Alloc&gt; rb_tree_node_allocator;</span><br><span class="line"><span class="keyword">typedef</span> __rb_tree_color_type color_type;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">protected</span>:</span><br><span class="line">    <span class="comment">//RB-tree只以三笔数据表现</span></span><br><span class="line">    size_type node_count; <span class="comment">//追踪记录树的大小</span></span><br><span class="line">    link_type header;     <span class="comment">//这是实现的一个技巧</span></span><br><span class="line">    Compare key_compare;  <span class="comment">//节点间的键值大小比较准则，function object</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//以下三个函数用来方便取得header的成员</span></span><br><span class="line"><span class="function">link_type&amp; <span class="title">root</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> (link_type&amp;) header-&gt;parent; &#125;</span><br><span class="line"><span class="function">link_type&amp; <span class="title">leftmost</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> (link_type&amp;) header-&gt;left; &#125;</span><br><span class="line"><span class="function">link_type&amp; <span class="title">rightmost</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> (link_type&amp;) header-&gt;right;&#125;</span><br><span class="line">...</span><br><span class="line">     <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> __rb_tree_iterator&lt;value_type, reference, pointer&gt; iterator;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">iterator __insert(base_ptr x, base_ptr y, <span class="type">const</span> value_type&amp; v);</span><br><span class="line">link_type __copy(link_type x, link_type p);</span><br><span class="line"><span class="type">void</span> __erase(link_type x);</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">header = <span class="built_in">get_node</span>();  <span class="comment">//产生一个节点空间，令header指向它</span></span><br><span class="line"><span class="built_in">color</span>(header) = __rb_tree_red; <span class="comment">//令header为红色，用来区分header</span></span><br><span class="line"><span class="comment">//和root，在iterator.operator++之中</span></span><br><span class="line"><span class="built_in">root</span>() = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">leftmost</span>() = header;<span class="comment">//令header的左子节点为自己</span></span><br><span class="line"><span class="built_in">rightmost</span>() = header;   <span class="comment">//令header 的右子节点为自己</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//allocation / deallocation</span></span><br><span class="line"><span class="built_in">rb_tree</span>(<span class="type">const</span> Compare&amp; comp = <span class="built_in">Compare</span>())</span><br><span class="line">: <span class="built_in">node_count</span>(<span class="number">0</span>), <span class="built_in">key_compare</span>(comp) &#123; <span class="built_in">init</span>(); &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">rb_tree</span>() &#123;</span><br><span class="line"><span class="built_in">clear</span>();</span><br><span class="line"><span class="built_in">put_node</span>(header);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    rb_tree&lt;Key, Value, KeyOfValue, Comapre, Alloc&gt;&amp;</span><br><span class="line">    <span class="keyword">operator</span>=(<span class="type">const</span> rb_tree&lt;Key, Value, KeyOfValue, Compare, Alloc&gt;&amp; x);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//accessors:</span></span><br><span class="line"><span class="function">Compare <span class="title">key_comp</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> key_compare; &#125;</span><br><span class="line"><span class="function">iterator <span class="title">begin</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">leftmost</span>(); &#125; <span class="comment">//RB树的起头为最左（最小）节点处</span></span><br><span class="line"><span class="function">iterator <span class="title">end</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> header; ) <span class="comment">//RB树的终点为header所指处</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> node_count == <span class="number">0</span>; &#125;</span><br><span class="line"><span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> node_count; &#125;</span><br><span class="line"><span class="function">size_type <span class="title">max_size</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">size_type</span> (<span class="number">-1</span>); &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">// insert / erase</span></span><br><span class="line"><span class="comment">//将x插入到RB-tree中(保持节点值独一无二)</span></span><br><span class="line"><span class="function">pair&lt;iterator, <span class="type">bool</span>&gt; <span class="title">insert_unique</span><span class="params">(<span class="type">const</span> value_type&amp; x)</span></span>;</span><br><span class="line"><span class="comment">//将x插入到RB-tree中(允许节点值重复)</span></span><br><span class="line"><span class="function">iterator <span class="title">insert_equal</span><span class="params">(<span class="type">const</span> value_type&amp; x)</span></span>;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>树状结构的各种操作，最需注意的就是边界情况的发生。为了简化处理，SGI STL特别为根节点再设计一个父节点，名为header。</p><p><img src="/../img/RB-treeheader.png" alt="RB-treeheader"></p><p>每当插入新节点使，不但要按照RB-tree的规则来调整，并且维护header的正确性，使其父节点指向根节点，左子节点指向最小节点，右子节点指向最大节点。</p><h4 id="RB-tree的元素操作"><a href="#RB-tree的元素操作" class="headerlink" title="RB-tree的元素操作"></a>RB-tree的元素操作</h4><p>RB-tree提供两种插入操作：insert_unique()和Insert_equal()，前者表示被插入节点的键值在整棵树中必须独一无二，后者表示被插入节点的键值在整棵树中可以重复。以下以最简单的版本作为说明对象：</p><h5 id="元素插入操作insert-equal"><a href="#元素插入操作insert-equal" class="headerlink" title="元素插入操作insert_equal()"></a>元素插入操作insert_equal()</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//插人新值:节点键值允许重复</span></span><br><span class="line"><span class="comment">//注意，返回值是一个RB-tree迭代器，指向新增节点</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">key</span>, <span class="keyword">class</span> <span class="title class_">Value</span>, <span class="keyword">class</span> <span class="title class_">Keyofvalue</span>, <span class="keyword">class</span> <span class="title class_">Compare</span>, <span class="keyword">class</span> <span class="title class_">Alloc</span>&gt;</span><br><span class="line"><span class="keyword">typename</span> rb_tree&lt;Key, Value, KeyOfvalue, Compare, Alloc&gt;::iterator</span><br><span class="line">rb_tree&lt;Key, value, KeyofValue, Compare, Alloc&gt;::<span class="built_in">insert_equal</span>(<span class="type">const</span> Value&amp; v)</span><br><span class="line">&#123;</span><br><span class="line">    link_type y = header;</span><br><span class="line">link_type x = <span class="built_in">root</span>();      <span class="comment">//从根节点开始</span></span><br><span class="line"><span class="keyword">while</span>(x != <span class="number">0</span>) &#123;            <span class="comment">//从根节点开始，往下寻找适当的插人点</span></span><br><span class="line">y = x;</span><br><span class="line">x = <span class="built_in">key_compare</span>(<span class="built_in">KeyOfvalue</span>()(v), <span class="built_in">key</span>(x)) ? <span class="built_in">left</span>(x) : <span class="built_in">right</span>(x);</span><br><span class="line"><span class="comment">//以上，遇“大”则往左，遇“小于或等于”则往右</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> __insert(x, y, v);</span><br><span class="line"><span class="comment">//以上，x为新值插人点，y为插人点之父节点，v为新值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="元素插入操作insert-unique"><a href="#元素插入操作insert-unique" class="headerlink" title="元素插入操作insert_unique()"></a>元素插入操作insert_unique()</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//插人新值：节点键值不允许重复，若重复则插人无效</span></span><br><span class="line"><span class="comment">//注意，返回值是个pair，第一元素是个RB-tree迭代器，指向新增节点，</span></span><br><span class="line"><span class="comment">//第二元素表示插入成功与否</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Key</span>, <span class="keyword">class</span> <span class="title class_">Value</span>, <span class="keyword">class</span> <span class="title class_">KeyOfValue</span>,</span><br><span class="line"> <span class="keyword">class</span> <span class="title class_">Compare</span>, <span class="keyword">class</span> <span class="title class_">Alloc</span>&gt;</span><br><span class="line">pair&lt;<span class="keyword">typename</span> rb_tree&lt;Key, Value, KeyOfValue, Compare, Alloc&gt;::iterator,</span><br><span class="line">     <span class="type">bool</span>&gt;</span><br><span class="line">rb_tree&lt;Key, Value, KeyOfValue, Compare, Alloc&gt;::</span><br><span class="line"><span class="built_in">insert_unique</span>(<span class="type">const</span> value&amp; v)</span><br><span class="line">&#123;</span><br><span class="line">link_type y = header;</span><br><span class="line">link_type x = <span class="built_in">root</span>();          <span class="comment">//从根节点开始</span></span><br><span class="line"><span class="type">bool</span> comp = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">while</span> (x != <span class="number">0</span>) &#123;               <span class="comment">//从根节点开始，往下寻找适当的插人点</span></span><br><span class="line">y = x;</span><br><span class="line">comp = <span class="built_in">key_compare</span>(<span class="built_in">KeyOfValue</span>()(v), <span class="built_in">key</span>(x));<span class="comment">//v键值小于目前节点之键值?</span></span><br><span class="line">x = comp ? <span class="built_in">left</span>(x) : <span class="built_in">right</span> (x);<span class="comment">//遇“大”则往左，遇“小于或等于”则往右</span></span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line"><span class="comment">//离开while循环之后，y所指即插入点之父节点（此时的它必为叶节点）</span></span><br><span class="line">iterator j = <span class="built_in">iterator</span>(y);   <span class="comment">//令迭代器j指向插入点之父节点y</span></span><br><span class="line"><span class="keyword">if</span> (comp)  <span class="comment">// 如果离开while循环时comp为真（表示遇“大”，将插入于左侧)</span></span><br><span class="line"><span class="keyword">if</span> (j == <span class="built_in">begin</span>())   <span class="comment">//如果插入点之父节点为最左节点</span></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">pair</span>&lt;iterator, <span class="type">bool</span>&gt;(__insert (x, y, v), <span class="literal">true</span>);</span><br><span class="line"><span class="comment">//以上，x为插入点，y为插入点之父节点，v为新值</span></span><br><span class="line"><span class="keyword">else</span> <span class="comment">//否则(插人点之父节点不为最左节点)</span></span><br><span class="line">--j;</span><br><span class="line"><span class="comment">//调整j，回头准备测试...</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">key_compare</span>(<span class="built_in">key</span>(j.node), <span class="built_in">KeyOfValue</span>()(v)))</span><br><span class="line"><span class="comment">//小于新值（表示遇“小”，将插入于右侧)</span></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">pair</span>&lt;iterator, <span class="type">bool</span>&gt;(__insert (x, y, v), <span class="literal">true</span>);</span><br><span class="line"><span class="comment">//以上，x为新值插人点，y 为插人点之父节点，v为新值</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//进行至此，表示新值一定与树中键值重复，那么就不该插入新值</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">pair</span>&lt;iterator, <span class="type">bool</span>&gt;(j, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>真正的插入执行程序__insert()</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Key</span>, <span class="keyword">class</span> <span class="title class_">Value</span>, <span class="keyword">class</span> <span class="title class_">KeyOfValue</span>,</span><br><span class="line"> <span class="keyword">class</span> <span class="title class_">Compare</span>, <span class="keyword">class</span> <span class="title class_">Alloc</span>&gt;</span><br><span class="line"><span class="keyword">typename</span> rb_tree&lt;Key, Value, KeyOfValue, Compare, Alloc&gt;::iterator</span><br><span class="line">rb_tree&lt;Key, Value, KeyOfValue, Compare, Alloc&gt;::</span><br><span class="line">__insert(base_ptr x_, base_ptr y_, <span class="type">const</span> Value&amp; v) &#123;</span><br><span class="line"><span class="comment">//参数x_为新值插人点，参数y_为插人点之父节点，参数v为新值</span></span><br><span class="line">link_type x = (link_type)x_;</span><br><span class="line">link_type y = (link_type)y_;</span><br><span class="line">link_type z;</span><br><span class="line"></span><br><span class="line"><span class="comment">//key_compare是键值大小比较准则。应该会是个function object</span></span><br><span class="line"><span class="keyword">if</span> (y == header || x != <span class="number">0</span> || <span class="built_in">key_compare</span>(<span class="built_in">KeyOfValue</span>()(v), <span class="built_in">key</span>(y))) &#123;</span><br><span class="line">z = <span class="built_in">create_node</span>(v); <span class="comment">//产生一个新节点</span></span><br><span class="line"><span class="built_in">left</span>(y) = z;        <span class="comment">//这使得当y即为header时，leftmost() = z</span></span><br><span class="line"><span class="keyword">if</span> (y == header) &#123;</span><br><span class="line"><span class="built_in">root</span>() = z;</span><br><span class="line"><span class="built_in">rightmost</span>() = z;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (y == <span class="built_in">leftmost</span>())             <span class="comment">//如果y为最左节点</span></span><br><span class="line"><span class="built_in">leftmost</span>() = z;        <span class="comment">//维护leftmost()，使它永远指向最左节点</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">z = <span class="built_in">create_node</span>(v);            <span class="comment">//产生一个新节点</span></span><br><span class="line"><span class="built_in">right</span>(y) = z;            <span class="comment">//令新节点成为插人点之父节点y的右子节点</span></span><br><span class="line"><span class="keyword">if</span> (y == <span class="built_in">rightmost</span>())</span><br><span class="line"><span class="built_in">rightmost</span>() = z;      <span class="comment">//维护rightmost()，使它永远指向最右节点</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">parent</span>(z) = y;                 <span class="comment">//设定新节点的父节点</span></span><br><span class="line"><span class="built_in">left</span>(z) = <span class="number">0</span>;                   <span class="comment">//设定新节点的左子节点</span></span><br><span class="line"><span class="built_in">right</span>(z) = <span class="number">0</span>;                  <span class="comment">//设定新节点的右子节点</span></span><br><span class="line"><span class="comment">//新节点的颜色将在__rb_tree_rebalance()设定（并调整）</span></span><br><span class="line">__rb_tree_rebalance(z, header-&gt;parent); <span class="comment">//参数一为新增节点，参数二为root</span></span><br><span class="line">++node_count;   <span class="comment">//节点数累加</span></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">iterator</span>(z);<span class="comment">//返回一个迭代器，指向新增节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="调整RB-tree（旋转及改变颜色）"><a href="#调整RB-tree（旋转及改变颜色）" class="headerlink" title="调整RB-tree（旋转及改变颜色）"></a>调整RB-tree（旋转及改变颜色）</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//全局函数</span></span><br><span class="line"><span class="comment">//重新令树形平衡（改变颜色及旋转树形）</span></span><br><span class="line"><span class="comment">//参数一为新增节点，参数二为root</span></span><br><span class="line"><span class="keyword">inline</span> <span class="type">void</span></span><br><span class="line">__rb_tree_rebalance(__rb_tree_node_base* x, __rb_tree_node_base*&amp; root) &#123;</span><br><span class="line">x-&gt;color = __rb_tree_red;<span class="comment">//新节点必为红</span></span><br><span class="line"><span class="keyword">while</span> (x != root &amp;&amp; x-&gt;parent-&gt;color == __rb_tree_red) &#123; <span class="comment">//父节点为红</span></span><br><span class="line"><span class="keyword">if</span> (x-&gt;parent == x-&gt;parent-&gt;parent-&gt;left) &#123; <span class="comment">//父节点为祖父节点之左子节点</span></span><br><span class="line">__rb_tree_node_base* y = x-&gt;parent-&gt;parent-&gt;right;<span class="comment">//令y为伯父节点</span></span><br><span class="line"><span class="keyword">if</span> (y &amp;&amp; y-&gt;color == __rb_tree_red) &#123;   <span class="comment">//伯父节点存在，且为红</span></span><br><span class="line">x-&gt;parent-&gt;color = __rb_tree_black; <span class="comment">//更改父节点为黑</span></span><br><span class="line">y-&gt;color = __rb_tree_black;         <span class="comment">//更改伯父节点为黑</span></span><br><span class="line">x-&gt;parent-&gt;parent-&gt;color = __rb_tree_red;<span class="comment">//更改祖父节点为红</span></span><br><span class="line">x = x-&gt;parent-&gt;parent;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123; <span class="comment">//无伯父节点，或伯父节点为黑</span></span><br><span class="line"><span class="keyword">if</span> (x = x-&gt;parent-&gt;right) &#123;<span class="comment">//如果新节点为父节点之右子节点</span></span><br><span class="line">x = x-&gt;parent;</span><br><span class="line">__rb_tree_rotate_left(x, root); <span class="comment">//第一参数为左旋点</span></span><br><span class="line">&#125;</span><br><span class="line">x-&gt;parent-&gt;color = __rb_tree_black;<span class="comment">//改变颜色</span></span><br><span class="line">x-&gt;parent-&gt;parent-&gt;color = __rb_tree_red;</span><br><span class="line">__rb_tree_rotate_right(x-&gt;parent-&gt;parent, root); <span class="comment">//第一参数为右旋点</span></span><br><span class="line">&#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="keyword">else</span> &#123;    <span class="comment">//父节点为祖父节点之右子节点</span></span><br><span class="line">__rb_tree_node_base* y = x-&gt;parent-&gt;parent-&gt;left; <span class="comment">//令y为伯父节点</span></span><br><span class="line">            <span class="keyword">if</span> (y &amp;&amp; y-&gt;color == __rb_tree_red) &#123;   <span class="comment">//有伯父节点，且为红</span></span><br><span class="line">x-&gt;parent-&gt;color = __rb_tree_black; <span class="comment">//更改父节点为黑</span></span><br><span class="line">y-&gt;color = __rb_tree_black;        <span class="comment">//更改伯父节点为黑</span></span><br><span class="line">x-&gt;parent-&gt;parent-&gt;color = __rb_tree_red;<span class="comment">//更改祖父节点为红</span></span><br><span class="line">x = x-&gt;parent-&gt;parent;<span class="comment">//准备继续往上层检查</span></span><br><span class="line">             &#125;</span><br><span class="line"><span class="keyword">else</span> &#123; <span class="comment">//无伯父节点，或伯父节点为黑</span></span><br><span class="line"><span class="keyword">if</span> (x == x-&gt;parent-&gt;left) &#123; <span class="comment">//如果新节点为父节点之左子节点</span></span><br><span class="line">x= x-&gt;parent;</span><br><span class="line">__rb_tree_rotate_right(x, root);<span class="comment">//第一参数为右旋点</span></span><br><span class="line">&#125;</span><br><span class="line">x-&gt;parent-&gt;color = __rb_tree_black;<span class="comment">//改变颜色</span></span><br><span class="line">x-&gt;parent -&gt;parent-&gt;color = __rb_tree_red;</span><br><span class="line">__rb_tree_rotate_left(x-&gt;parent-&gt;parent, root); <span class="comment">//第一参数为左旋点</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="comment">//while 结束</span></span><br><span class="line">root-&gt;color = __rb_tree_black;<span class="comment">//根节点永远为黑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是左旋函数和右旋函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//全局函数</span></span><br><span class="line"><span class="comment">//新节点必为红节点。如果插入处之父节点亦为红节点，就违反红黑树规则，此时必须</span></span><br><span class="line"><span class="comment">//做树形旋转（及颜色改变，在程序它处）</span></span><br><span class="line"><span class="keyword">inline</span> <span class="type">void</span></span><br><span class="line">__rb_tree_rotate_left (__rb_tree_node_base* x,</span><br><span class="line">      __rb_tree_node_base*&amp; root)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//x为旋转点</span></span><br><span class="line">__rb_tree_node__base* y = x-&gt;right; <span class="comment">//令y为旋转点的右子节点</span></span><br><span class="line">x-&gt;right = y-&gt;left;</span><br><span class="line"><span class="keyword">if</span> (y-&gt;left != <span class="number">0</span>)</span><br><span class="line">y-&gt;left-&gt;parent = x;   <span class="comment">//别忘了回马枪设定父节点</span></span><br><span class="line">y-&gt;parent = x-&gt;parent;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//令y完全顶替x的地位（必须将x对其父节点的关系完全接收过来)</span></span><br><span class="line"><span class="keyword">if</span> (x == root)       <span class="comment">//x为根节点</span></span><br><span class="line">root = y;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (x == x-&gt;parent-&gt;left)   <span class="comment">//x为其父节点的左子节点</span></span><br><span class="line">x-&gt;parent-&gt;left = y;</span><br><span class="line"><span class="keyword">else</span>                             <span class="comment">//x为其父节点的右子节点</span></span><br><span class="line">x-&gt;parent-&gt;right = y;</span><br><span class="line">y-&gt;left = x;</span><br><span class="line">x-&gt;parent = y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//全局函数</span></span><br><span class="line"><span class="comment">//新节点必为红节点。如果插入处之父节点亦为红节点，就违反红黑树规则，此时必须</span></span><br><span class="line"><span class="comment">//做树形旋转（及颜色改变，在程序它处）</span></span><br><span class="line"><span class="keyword">inline</span> <span class="type">void</span></span><br><span class="line">__rb_tree_rotate_right (__rb_tree_node_base* x,</span><br><span class="line">      __rb_tree_node_base*&amp; root)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//x为旋转点</span></span><br><span class="line">__rb_tree_node__base* y = x-&gt;left; <span class="comment">//令y为旋转点的左子节点</span></span><br><span class="line">x-&gt;left = y-&gt;right;</span><br><span class="line"><span class="keyword">if</span> (y-&gt;right != <span class="number">0</span>)</span><br><span class="line">y-&gt;right-&gt;parent = x;   <span class="comment">//别忘了回马枪设定父节点</span></span><br><span class="line">y-&gt;parent = x-&gt;parent;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//令y完全顶替x的地位（必须将x对其父节点的关系完全接收过来)</span></span><br><span class="line"><span class="keyword">if</span> (x == root)       <span class="comment">//x为根节点</span></span><br><span class="line">root = y;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (x == x-&gt;parent-&gt;right)   <span class="comment">//x为其父节点的右子节点</span></span><br><span class="line">x-&gt;parent-&gt;right = y;</span><br><span class="line"><span class="keyword">else</span>                             <span class="comment">//x为其父节点的左子节点</span></span><br><span class="line">x-&gt;parent-&gt;left = y;</span><br><span class="line">y-&gt;right = x;</span><br><span class="line">x-&gt;parent = y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="元素的搜寻"><a href="#元素的搜寻" class="headerlink" title="元素的搜寻"></a>元素的搜寻</h5><p>RB-tree提供的find函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//寻找RB树中是否有键值为k的节点</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Key</span>, <span class="keyword">class</span> <span class="title class_">Value</span>, <span class="keyword">class</span> <span class="title class_">KeyOfValue</span>, <span class="keyword">class</span> <span class="title class_">Compare</span>, <span class="keyword">class</span> <span class="title class_">Alloc</span>&gt;</span><br><span class="line"><span class="keyword">typename</span> rb_tree&lt;Key, Value, KeyOfValue, Compare, Alloc&gt;::iterator</span><br><span class="line">rb_tree&lt;Key, Value, KeyOfValue, Compare, Alloc&gt;::<span class="built_in">find</span> (<span class="type">const</span> Key&amp; k &#123;</span><br><span class="line">link_type y = header;     <span class="comment">//Last node which is not less than k.</span></span><br><span class="line">link_type x = <span class="built_in">root</span>();     <span class="comment">//current node.</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (x != <span class="number">0</span>)</span><br><span class="line"><span class="comment">//以下，key_compare是节点键值大小比较准则。应该会是个function object</span></span><br><span class="line"><span class="keyword">if</span>(!<span class="built_in">key_compare</span>(<span class="built_in">key</span>(x), k))</span><br><span class="line"><span class="comment">//进行到这里,表示x键值大于k。遇到大值就向左走</span></span><br><span class="line">y = x, x = <span class="built_in">left</span>(x);<span class="comment">//注意语法!</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="comment">//进行到这里，表示×键值小于k。遇到小值就向右走</span></span><br><span class="line">x = <span class="built_in">right</span>(x);</span><br><span class="line"></span><br><span class="line">    iterator j = <span class="built_in">iterator</span>(y);</span><br><span class="line"><span class="built_in">return</span> (j == <span class="built_in">end</span>() || <span class="built_in">key_compare</span>(k, <span class="built_in">key</span>(j.node))) ? <span class="built_in">end</span>() : j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="set"><a href="#set" class="headerlink" title="set"></a>set</h3><p>set的所有元素都会根据元素的键值自动被排序。</p><p>set元素的键值就是实值，实值就是键值。set不被允许两个元素有相同的键值。</p><p>set的迭代器是一种constant iterators，杜绝写入操作，不能改变set的元素值：因为set的元素值就是其键值，关系到set元素的排列规则。同时，set在进行元素新增操作或删除操作时，操作之前的所有迭代器（除了被删除的那个迭代器）在操作完成之后依然有效（类似于list）。</p><p>由于RB-tree是一种平衡二叉搜索树，自动排序的效果很不错，所以标准的STL set即以RB-tree为底层机制。又由于set所开放的各种操作接口，RB-tree也都提供了，所以几乎所有的set操作行为，都只是转调用RB-tree的操作行为而已。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Key</span>,</span><br><span class="line"> <span class="keyword">class</span> <span class="title class_">Compare</span> = less&lt;Key&gt;,        <span class="comment">//缺省情况下采用递增排序</span></span><br><span class="line"> <span class="keyword">class</span> Alloc = alloc&gt;</span><br><span class="line"><span class="keyword">class</span> set &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">// typedefs :</span></span><br><span class="line"><span class="keyword">typedef</span> Key key_type;</span><br><span class="line"><span class="keyword">typedef</span> Key value_type;</span><br><span class="line"><span class="comment">//注意，以下key_compare和value_compare使用同一个比较函数</span></span><br><span class="line"><span class="keyword">typedef</span> Compare ke _compare;</span><br><span class="line"><span class="keyword">typedef</span> Compare value_compare;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="comment">//注意，以下的identity定义于&lt;stl_function.h&gt;，参见第7章，其定义为:</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">template &lt;class T&gt;</span></span><br><span class="line"><span class="comment">struct identity : public unary_function&lt;T,T&gt; &#123;</span></span><br><span class="line"><span class="comment">const T&amp; operator() (const T&amp; x) const &#123; return x; &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">typedef</span> rb_tree&lt;key_type, value_type,</span><br><span class="line">identity&lt;value_type&gt;, key_compare, Alloc&gt; rep_type;</span><br><span class="line">rep_type t; <span class="comment">//采用红黑树(RB-tree)来表现set</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type::const_pointer pointer;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type::const_pointer const_pointer;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type::const_reference reference;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type::const_reference const_reference;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type::const_iterator iterator;</span><br><span class="line"><span class="comment">//注意上一行，iterator定义为RB-tree的const_iterator，这表示sets的</span></span><br><span class="line">    <span class="comment">//迭代器无法执行写入操作。这是因为set的元素有一定次序安排</span></span><br><span class="line"><span class="comment">//不允许用户在任意处进行写人操作</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type::const_iterator const_iterator;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type::const_reverse_iterator reverse_iterator;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type::const_reverse_iterator const_reverse_iterator;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type::size_type size_type;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type::difference_type difference_type;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// allocation / deallocation</span></span><br><span class="line"><span class="comment">//注意,set一定使用RB-tree的insert_unique()而非insert_equal()</span></span><br><span class="line"><span class="comment">//multiset才使用RB-tree的insert__equal()</span></span><br><span class="line"><span class="comment">//因为set不允许相同键值存在，multiset才允许相同键值存在</span></span><br><span class="line"><span class="built_in">set</span>() : <span class="built_in">t</span> (<span class="built_in">Compare</span>()) &#123; &#125;</span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">set</span><span class="params">(<span class="type">const</span> Compare&amp; comp)</span> : t(comp)&#123;</span> &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>&gt;</span><br><span class="line"><span class="built_in">set</span>(InputIterator first, InputIterator last)</span><br><span class="line">: <span class="built_in">t</span>(<span class="built_in">Compare</span>()) &#123; t.<span class="built_in">insert_unique</span>(first, last); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>&gt;</span><br><span class="line"><span class="built_in">set</span>(InputIterator first, InputIterator last, <span class="type">const</span> Compare&amp; comp)</span><br><span class="line">        : <span class="built_in">t</span>(comp) &#123; t.<span class="built_in">insert_unique</span>(first, last); &#125;</span><br><span class="line">    </span><br><span class="line"><span class="built_in">set</span>(<span class="type">const</span> set&lt;Key, Compare, Alloc&gt;&amp; x) : <span class="built_in">t</span>(x.t) &#123;&#125;</span><br><span class="line">set&lt;Key, Compare, Alloc&gt;&amp; <span class="keyword">operator</span>=(<span class="type">const</span> set&lt;Key, Compare, Alloc&gt;&amp; x) &#123; </span><br><span class="line">t = x.t;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">//以下所有的set操作行为，RB-tree都已提供，所以set只要传递调用即可</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//accessors:</span></span><br><span class="line"><span class="function">key_compare <span class="title">key_comp</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> t.<span class="built_in">key_comp</span>(); &#125;</span><br><span class="line">    <span class="comment">//以下注意,set的value_comp()事实上为RB-tree的key_comp()</span></span><br><span class="line"><span class="function">value_compare <span class="title">value_comp</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> t.<span class="built_in">key_comp</span>(); &#125;</span><br><span class="line"><span class="function">iterator <span class="title">begin</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> t.<span class="built_in">begin</span>(); &#125;</span><br><span class="line"><span class="function">iterator <span class="title">end</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> t.<span class="built_in">end</span>(); &#125;</span><br><span class="line"><span class="function">reverse_iterator <span class="title">rbegin</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> t.<span class="built_in">rbegin</span>(); &#125;</span><br><span class="line"><span class="function">reverse_iterator <span class="title">rend</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> t.<span class="built_in">rend</span>(); &#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> t.<span class="built_in">empty</span>(); &#125;</span><br><span class="line"><span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> t.<span class="built_in">size</span>(); &#125;</span><br><span class="line"><span class="function">size_type <span class="title">max_size</span><span class="params">( )</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> t.<span class="built_in">max_size</span>(); &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(set&lt;Key, Compare, Alloc&gt;&amp; x)</span> </span>&#123; t.<span class="built_in">swap</span>(x.t); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// insert/erase</span></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;iterator, <span class="type">bool</span>&gt; pair_iterator_bool;</span><br><span class="line"><span class="function">pair&lt;iterator, <span class="type">bool</span>&gt; <span class="title">insert</span><span class="params">(<span class="type">const</span> value_type&amp; x)</span> </span>&#123;</span><br><span class="line">pair&lt;<span class="keyword">typename</span> rep_type::iterator, <span class="type">bool</span>&gt; p = t.<span class="built_in">insert_unique</span>(x);</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">pair</span>&lt;iterator, <span class="type">bool</span>&gt;(p.first, p.second);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function">iterator <span class="title">insert</span><span class="params">(iterator position, <span class="type">const</span> value_type&amp; x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type::iterator rep_iterator;</span><br><span class="line"><span class="keyword">return</span> t.<span class="built_in">insert_unique</span>((rep_iterator&amp;)position, x);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(InputIterator first, InputIterator last)</span> </span>&#123;</span><br><span class="line">        t.<span class="built_in">insert__unique</span>(first, last);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">erase</span><span class="params">(iterator position)</span> </span>&#123;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type::iterator rep_iterator;</span><br><span class="line">t.<span class="built_in">erase</span>((rep_iterator&amp;)position);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function">size_type <span class="title">erase</span><span class="params">(<span class="type">const</span> key_type&amp; x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> t.<span class="built_in">erase</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">erase</span> <span class="params">(iterator first, iterator last)</span> </span>&#123;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type::iterator rep_iterator;</span><br><span class="line">         t.<span class="built_in">erase</span>((rep_iterator&amp;)first, (rep_iterator&amp;)Last);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123; t.<span class="built_in">clear</span>(); &#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// set operations:</span></span><br><span class="line"><span class="function">iterator <span class="title">find</span><span class="params">(<span class="type">const</span> key_type&amp; x)</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> t.<span class="built_in">find</span>(x); &#125;</span><br><span class="line"><span class="function">size_type <span class="title">count</span> <span class="params">(<span class="type">const</span> key_type&amp; x)</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> t.<span class="built_in">count</span>(x); &#125;</span><br><span class="line"><span class="function">iterator <span class="title">lower_bound</span> <span class="params">(<span class="type">const</span> key_type&amp; x)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> t.<span class="built_in">lower_bound</span>(x); </span><br><span class="line">    &#125;</span><br><span class="line"><span class="function">iterator <span class="title">upper_bound</span> <span class="params">(<span class="type">const</span> key_type&amp; x)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> t.<span class="built_in">upper_bound</span>(x);</span><br><span class="line">)</span><br><span class="line"><span class="function">pair&lt;iterator, iterator&gt; <span class="title">equal_range</span><span class="params">(<span class="type">const</span> key type&amp; x)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> t.<span class="built_in">equal_range</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><p>map与set类似，都以RB-tree为底层，不同的是map的所有元素都是pair，同时拥有实值（value）和键值（key）。pair的第一元素被视为键值，第二元素被视为实值。map不允许两个元素拥有相同的键值，因此，map的迭代器可以修改元素的实值但不可以修改元素的键值。map iterators既不是一种constant iterators，也不是一种mutable iterators。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注意，以下Key为键值(key)型别，T为实值(value)型别</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Key</span>, <span class="keyword">class</span> <span class="title class_">T</span>,</span><br><span class="line"> <span class="keyword">class</span> <span class="title class_">Compare</span> = less&lt;Key&gt;,       <span class="comment">//缺省采用递增排序</span></span><br><span class="line"> <span class="keyword">class</span> Alloc = alloc&gt;</span><br><span class="line"><span class="keyword">class</span> map &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment">//typedefs:</span></span><br><span class="line"><span class="keyword">typedef</span> Key key_type;   <span class="comment">//键值型别</span></span><br><span class="line"><span class="keyword">typedef</span> T data_type;    <span class="comment">//数据（实值）型别</span></span><br><span class="line"><span class="keyword">typedef</span> T mapped_type;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">const</span> Key, T&gt; value_type;<span class="comment">//元素型别（键值/实值)</span></span><br><span class="line"><span class="keyword">typedef</span> Compare key_compare; <span class="comment">//键值比较函数</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//以下定义一个functor，其作用就是调用“元素比较函数”</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">value_compare</span></span><br><span class="line">: <span class="keyword">public</span> binary_function&lt;value_type, value_type, <span class="type">bool</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">map</span>&lt;Key, T, Compare, Alloc&gt;;</span><br><span class="line"><span class="keyword">protected</span> :</span><br><span class="line">Compare comp;</span><br><span class="line"><span class="built_in">value_compare</span>(Compare c) : <span class="built_in">comp</span>(c) &#123;&#125;</span><br><span class="line"><span class="keyword">public</span> :</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="type">const</span> value_type&amp; x, <span class="type">const</span> value_type&amp; y)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">comp</span>(x.first, y.first);</span><br><span class="line">&#125;</span><br><span class="line">        </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">typedef</span> rb_tree&lt;key_type, value_type,</span><br><span class="line">        select1st&lt;value_type&gt;, key_compare, Alloc&gt; rep_type;</span><br><span class="line">        rep_type t;</span><br><span class="line">...</span><br><span class="line">     <span class="keyword">public</span>:</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">//注意下标操作符</span></span><br><span class="line">        T&amp; <span class="keyword">operator</span>[](<span class="type">const</span> key_type&amp; k) &#123;</span><br><span class="line">            <span class="keyword">return</span> (*((<span class="built_in">insert</span>(<span class="built_in">value_type</span>(k, <span class="built_in">T</span>()))).first)).second;</span><br><span class="line">        &#125;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="multiset"><a href="#multiset" class="headerlink" title="multiset"></a>multiset</h3><p>multiset和set的唯一差别在于它允许键值重复，因此它的插入操作采用的是底层机制RB-tree的insert_equal()而非insert_unique()。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Key</span>, <span class="keyword">class</span> <span class="title class_">Compare</span> = less&lt;Key&gt;, <span class="keyword">class</span> Alloc = alloc&gt;</span><br><span class="line"><span class="keyword">class</span> multiset &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//typedefs:</span></span><br><span class="line">    ...(与set相同)</span><br><span class="line"></span><br><span class="line"><span class="comment">// allocation/deallocation</span></span><br><span class="line"><span class="comment">//注意, multiset一定使用insert_equal()而不使用insert_unique()</span></span><br><span class="line"><span class="comment">//set才使用insert_unique()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> InputIterator&gt;</span><br><span class="line"><span class="built_in">multiset</span>(InputIterator first, InputIterator last)</span><br><span class="line">        : <span class="built_in">t</span>(<span class="built_in">Compare</span>()) &#123; t.<span class="built_in">insert_equal</span>(first, last); &#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>&gt;</span><br><span class="line"><span class="built_in">multiset</span>(InputIterator first, InputIterator last, <span class="type">const</span> Compare&amp; comp)</span><br><span class="line">        : <span class="built_in">t</span>(comp) &#123; t.<span class="built_in">insert_equal</span>(first, last); &#125;</span><br><span class="line">...(其它与set相同)</span><br><span class="line">        </span><br><span class="line"><span class="comment">// insert/erase</span></span><br><span class="line"><span class="function">iterator <span class="title">insert</span><span class="params">(<span class="type">const</span> value_type&amp; x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> t.<span class="built_in">insert_equal</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function">iterator <span class="title">insert</span><span class="params">(iterator position, <span class="type">const</span> value_type&amp; x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type::iterator rep_iterator;</span><br><span class="line"><span class="keyword">return</span> t.<span class="built_in">insert_equal</span>((rep_iterator&amp;)position,x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(InputIterator first, InputIterator last)</span> </span>&#123;</span><br><span class="line">        t.<span class="built_in">insert_equal</span>(first, last);</span><br><span class="line">    &#125;</span><br><span class="line">...(其它与set相同)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="multimap"><a href="#multimap" class="headerlink" title="multimap"></a>multimap</h3><p>multimap和map的唯一差别在于它允许键值重复，因此它的插入操作采用的是底层机制RB-tree的insert_equal()而非insert_unique()。</p><h3 id="hashtable"><a href="#hashtable" class="headerlink" title="hashtable"></a>hashtable</h3><p>SGI STL的hashtable采用的开链（separate chaining）法来处理冲突。因此，SGI命名称hash table表格内的元素为桶（bucket），此名称的意义是表格内的每个单元涵盖的不只是个节点（元素），甚至可能是一“桶”节点。</p><p>![bucket hashtable](..&#x2F;img&#x2F;bucket hashtable.png)</p><p>hash table的节点定义：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Value</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__hashtable_node</span></span><br><span class="line">&#123;</span><br><span class="line">    __hashtable_node* next;</span><br><span class="line">    Value val;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>bucket所维护的linked list，并不采用STL的list或slist，而是自行维护上述的hash table node。而buckets聚合体，则以vector完成以便有动态扩充能力。</p><h4 id="hashtable的迭代器"><a href="#hashtable的迭代器" class="headerlink" title="hashtable的迭代器"></a>hashtable的迭代器</h4><p>定义：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Value</span>, <span class="keyword">class</span> <span class="title class_">Key</span>, <span class="keyword">class</span> <span class="title class_">HashFcn</span>,</span><br><span class="line"> <span class="keyword">class</span> <span class="title class_">ExtractKey</span>, <span class="keyword">class</span> <span class="title class_">EqualKey</span>, <span class="keyword">class</span> <span class="title class_">Alloc</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__hashtable_iterator</span> &#123;</span><br><span class="line"><span class="keyword">typedef</span> hashtable&lt;Value, Key, HashFcn, ExtractKey, EqualKey, Alloc&gt;   hashtable;</span><br><span class="line"><span class="keyword">typedef</span> __hashtable_iterator&lt;value, Key, HashFcn,</span><br><span class="line">       ExtractKey, EqualKey,  Alloc&gt;</span><br><span class="line">           iterator;</span><br><span class="line"><span class="keyword">typedef</span> __hashtable_const_iterator&lt;Value, Key, HashFcn,</span><br><span class="line">ExtractKey, EqualKey, Alloc&gt;</span><br><span class="line">  const_iterator;</span><br><span class="line"><span class="keyword">typedef</span> __hashtable_node&lt;value&gt; node;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> forward_iterator_tag iterator_category;</span><br><span class="line"><span class="keyword">typedef</span> Value value_type;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">ptrdiff_t</span> difference_type;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">size_t</span> size_type;</span><br><span class="line"><span class="keyword">typedef</span> value&amp; reference;</span><br><span class="line"><span class="keyword">typedef</span> value* pointer;</span><br><span class="line"></span><br><span class="line">node* cur;<span class="comment">//迭代器目前所指之节点</span></span><br><span class="line">hashtable* ht;<span class="comment">//保持对容器的连结关系(因为可能需要从bucket跳到bucket)</span></span><br><span class="line"></span><br><span class="line">__hashtable_iterator(node* n, hashtable* tab) : <span class="built_in">cur</span>(n), <span class="built_in">ht</span>(tab) &#123; &#125;</span><br><span class="line">__hashtable_iterator() &#123; &#125;</span><br><span class="line">reference <span class="keyword">operator</span>*() <span class="type">const</span> &#123; <span class="keyword">return</span> cur-&gt;val; &#125;</span><br><span class="line">pointer <span class="keyword">operator</span>-&gt;() <span class="type">const</span> &#123; <span class="keyword">return</span> &amp;(<span class="keyword">operator</span>*()); &#125;</span><br><span class="line">iterator&amp; <span class="keyword">operator</span>++();</span><br><span class="line">iterator <span class="keyword">operator</span>++(<span class="type">int</span>);</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> iterator&amp; it) <span class="type">const</span> &#123; <span class="keyword">return</span> cur == it.cur; &#125;</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>!=(<span class="type">const</span> iterator&amp; it) <span class="type">const</span> &#123; <span class="keyword">return</span> cur != it.cur; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>hashtable迭代器需维系着与整个“buckets vecctor”的关系，并记录目前所指的节点。是因为其前进操作中，若下一步在同一bucket内，则利用节点的next指针完成操作（需要目前节点）；若目前节点正好是list的尾端，则跳至下一个bucket上（需要整个“bucket vector”）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">V</span>, <span class="keyword">class</span> <span class="title class_">K</span>, <span class="keyword">class</span> <span class="title class_">HF</span>, <span class="keyword">class</span> <span class="title class_">ExK</span>, <span class="keyword">class</span> <span class="title class_">EqK</span>, <span class="keyword">class</span> <span class="title class_">A</span>&gt;</span><br><span class="line">__hashtable_iterator&lt;V, K, HF, EXK, EqK, A&gt;&amp;</span><br><span class="line">__hashtable_iterator&lt;V, K, HF, ExK, EqK, A&gt;::<span class="keyword">operator</span>++()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> node* old = cur;</span><br><span class="line">cur = cur-&gt;next;      <span class="comment">//如果存在，就是它。否则进入以下if流程</span></span><br><span class="line"><span class="keyword">if</span> (!cur) &#123;</span><br><span class="line"><span class="comment">//根据元素值，定位出下一个bucket。其起头处就是我们的目的地</span></span><br><span class="line">size_type bucket = ht-&gt;<span class="built_in">bkt_num</span>(old-&gt;val);</span><br><span class="line"><span class="keyword">while</span> (!cur &amp;&amp; ++bucket &lt; ht-&gt;buckets.<span class="built_in">size</span>()) <span class="comment">//注意，operator++</span></span><br><span class="line">cur = ht-&gt;buckets[bucket];</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">V</span>, <span class="keyword">class</span> <span class="title class_">K</span>, <span class="keyword">class</span> <span class="title class_">HF</span>, <span class="keyword">class</span> <span class="title class_">ExK</span>, <span class="keyword">class</span> <span class="title class_">EqK</span>, <span class="keyword">class</span> <span class="title class_">A</span>&gt;</span><br><span class="line">__hashtable_iterator&lt;V, K, HF, EXK, EqK, A&gt;</span><br><span class="line">__hashtable_iterator&lt;V, K, HF, ExK, EqK, A&gt;::<span class="keyword">operator</span>++(<span class="type">int</span>)</span><br><span class="line">&#123;</span><br><span class="line">iterator tmp = *<span class="keyword">this</span>;</span><br><span class="line">++*<span class="keyword">this</span>;   <span class="comment">//调用operator++()</span></span><br><span class="line"><span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，hashtable的迭代器没有后退操作（operator–()），也没有定义所谓的逆向迭代器（reverse iterator）。</p><h4 id="hashtable的数据结构"><a href="#hashtable的数据结构" class="headerlink" title="hashtable的数据结构"></a>hashtable的数据结构</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Value</span>, <span class="keyword">class</span> <span class="title class_">Key</span>, <span class="keyword">class</span> <span class="title class_">HashFcn</span>,</span><br><span class="line"> <span class="keyword">class</span> <span class="title class_">ExtractKey</span>, <span class="keyword">class</span> <span class="title class_">EqualKey</span>, <span class="keyword">class</span> <span class="title class_">Allo</span> = alloc&gt;</span><br><span class="line"><span class="keyword">class</span> hashtable;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Value</span>, <span class="keyword">class</span> <span class="title class_">Key</span>, <span class="keyword">class</span> <span class="title class_">HashFcn</span>,</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ExtractKey</span>, <span class="keyword">class</span> <span class="title class_">EqualKey</span>,</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Alloc</span>&gt;    <span class="comment">//先前声明时，已给予Alloc默认值alloc</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">hashtable</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">typedef</span> HashFcn hasher;</span><br><span class="line"><span class="keyword">typedef</span> EqualKey key_equal;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">size_t</span> size_type;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="comment">//以下三者都是function objects.&lt;stl_hash_fun.h&gt;中定义有数个</span></span><br><span class="line"><span class="comment">//标准型别（如int, c-style string等）的hasher</span></span><br><span class="line">hasher hash;</span><br><span class="line">key_equal equals;</span><br><span class="line">ExtractKey get_key;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">typedef</span> __hashtable_node&lt;Value&gt; node;</span><br><span class="line"><span class="keyword">typedef</span> simple_alloc&lt;node, Alloc&gt; node_allocator;</span><br><span class="line">    </span><br><span class="line">vector&lt;node*, Alloc&gt; buckets; <span class="comment">//以vector完成</span></span><br><span class="line">size_type num_elements;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//bucket个数即buckets vector的大小</span></span><br><span class="line"><span class="function">size_type <span class="title">bucket_count</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> buckets.<span class="built_in">size</span>(); &#125;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>hashtable的模板参数的意义：</p><ul><li>Value: 节点的实值类型。</li><li>Key: 节点的键值类型。</li><li>HashFcn: hash function的函数类型。</li><li>ExtractKey: 从节点中去除键值的方法（函数或仿函数）。</li><li>EqualKey: 判断键值相同与否的方法（函数或仿函数）。</li><li>Alloc: 空间配置器，缺省使用std::alloc。</li></ul><p>虽然开链法并不要求表格大小必须为质数，但SGI STL仍然一直输来设计表格大小，并先将28个质数计算好，以备随时访问，同时提供一个函数，用来查询在这28个质数之中，“最接近某数并大于某数”的质数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注意:假设long至少有32bits</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">int</span> __stl_num_primes = <span class="number">28</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">unsigned</span> <span class="type">long</span> __stl_prime_list [__stl_num_primes] = </span><br><span class="line">&#123;</span><br><span class="line"><span class="number">53</span>,<span class="number">97</span>,<span class="number">193</span>,<span class="number">389</span>,<span class="number">769</span>,<span class="number">1543</span>,</span><br><span class="line">    <span class="number">3079</span>,<span class="number">6151</span>, <span class="number">12289</span>,  <span class="number">24593</span>,   <span class="number">49157</span>,   <span class="number">98317</span>,</span><br><span class="line"><span class="number">196613</span>,<span class="number">393241</span>,  <span class="number">786433</span>,   <span class="number">1572869</span>,   <span class="number">3145739</span>,   <span class="number">6291469</span>, <span class="number">12582917</span>,<span class="number">25165843</span>,<span class="number">50331653</span>, <span class="number">100663319</span>, <span class="number">201326611</span>, </span><br><span class="line">    <span class="number">402653189</span>,    <span class="number">805306457</span>,   <span class="number">1610612741</span>,   <span class="number">3221225473ul</span>, <span class="number">4294967291ul</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//以下找出上述28个质数之中，最接近并大于n的那个质数</span></span><br><span class="line"><span class="keyword">inline</span> <span class="type">unsigned</span> <span class="type">long</span> __stl_next_prime(<span class="type">unsigned</span> <span class="type">long</span> n)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">const</span> <span class="type">unsigned</span> <span class="type">long</span>* first = __stl_prime_list;</span><br><span class="line"><span class="type">const</span> <span class="type">unsigned</span> <span class="type">long</span>* last = __stl_prime_list + __stl_num_primes;</span><br><span class="line"><span class="type">const</span> <span class="type">unsigned</span> <span class="type">long</span>* pos = <span class="built_in">lower_bound</span>(first, last, n);</span><br><span class="line"><span class="comment">//以上，lower_bound()是泛型算法，见第6章</span></span><br><span class="line"><span class="comment">//使用lower_bound()，序列需先排序。没问题，上述数组已排序</span></span><br><span class="line">    <span class="keyword">return</span> pos == last ? *(last - <span class="number">1</span>) : *pos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//总共可以有多少buckets.以下是hast_table的一个member function</span></span><br><span class="line"><span class="function">size_type <span class="title">max_bucket_count</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="keyword">return</span> __stl_prime__list[__stl_num_primes - <span class="number">1</span>]; &#125;</span><br><span class="line"><span class="comment">//其值将为4294967291</span></span><br></pre></td></tr></table></figure><h4 id="hashtable的构造与内存管理"><a href="#hashtable的构造与内存管理" class="headerlink" title="hashtable的构造与内存管理"></a>hashtable的构造与内存管理</h4><p>构造函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">hashtable</span> (size_type n,</span><br><span class="line">  <span class="type">const</span> HashFcn&amp;hf,</span><br><span class="line">           <span class="type">const</span> EqualKey&amp; eql)</span><br><span class="line">: <span class="built_in">hash</span>(hf), <span class="built_in">equals</span>(eql), <span class="built_in">get_key</span>(<span class="built_in">ExtractKey</span>()), <span class="built_in">num_elements</span>(<span class="number">0</span>) </span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">initialize_buckets</span>(n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">initialize_buckets</span><span class="params">(size_type n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> size_type n_buckets = <span class="built_in">next_size</span>(n);</span><br><span class="line"><span class="comment">//举例:传人 50，返回53。以下首先保留53个元素空间，然后将其全部填0</span></span><br><span class="line">    buckets.<span class="built_in">reserve</span>(n_buckets);</span><br><span class="line">buckets.<span class="built_in">insert</span>(buckets.<span class="built_in">end</span>(), n_buckets, (node*)<span class="number">0</span>);</span><br><span class="line">num_elements = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中的next_size()返回最接近n并大于n的质数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">size_type <span class="title">next_size</span><span class="params">(size_type n)</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> __stl_next_prime(n); &#125;</span><br></pre></td></tr></table></figure><p>然后，为buckets vector保留空间，并将所有buckets初始化为null指针。</p><h5 id="insert操作与表格重整（resize）"><a href="#insert操作与表格重整（resize）" class="headerlink" title="insert操作与表格重整（resize）"></a>insert操作与表格重整（resize）</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//插人元素，不允许重复</span></span><br><span class="line"><span class="function">pair&lt;iterator, <span class="type">bool</span>&gt; <span class="title">insert_unique</span><span class="params">(<span class="type">const</span> value_type&amp; obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">resize</span>(num_elements + <span class="number">1</span>);<span class="comment">//判断是否需要重建表格，如需要就扩充</span></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">insert_unique_noresize</span>(obj);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//以下函数判断是否需要重建表格。如果不需要，立刻回返。如果需要，就动手…</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">V</span>, <span class="keyword">class</span> <span class="title class_">K</span>, <span class="keyword">class</span> <span class="title class_">HF</span>, <span class="keyword">class</span> <span class="title class_">Ex</span>, <span class="keyword">class</span> <span class="title class_">Eq</span>, <span class="keyword">class</span> <span class="title class_">A</span>&gt;</span><br><span class="line"><span class="type">void</span> hashtable&lt;V, K, HF, Ex, Eq, A&gt;::<span class="built_in">resize</span>(size_type num_elements_hint)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//以下，“表格重建与否”的判断原则颇为奇特，是拿元素个数（把新增元素计人后）和</span></span><br><span class="line">    <span class="comment">//bucket vector的大小来比。如果前者大于后者，就重建表格</span></span><br><span class="line"><span class="comment">//由此可判知，每个bucket(list)的最大容量和buckets vector的大小相同</span></span><br><span class="line"><span class="type">const</span> size_type old_n = buckets.<span class="built_in">size</span>();</span><br><span class="line"><span class="keyword">if</span> (num_elements_hint &gt; old_n) &#123; <span class="comment">//确定真的需要重新配置</span></span><br><span class="line"><span class="type">const</span> size_type n = <span class="built_in">next_size</span>(num_elements_hint);  <span class="comment">//找出下一个质数</span></span><br><span class="line"><span class="keyword">if</span> (n &gt; old_n) &#123;</span><br><span class="line"><span class="function">vector&lt;node*, A&gt; <span class="title">tmp</span><span class="params">(n, (node*)<span class="number">0</span>)</span></span>; <span class="comment">//设立新的buckets</span></span><br><span class="line">__STL_TRY &#123;</span><br><span class="line"><span class="comment">//以下处理每一个旧的bucket</span></span><br><span class="line"><span class="keyword">for</span> (size_type bucket = <span class="number">0</span>; bucket &lt; old_n; ++bucket) &#123;</span><br><span class="line">node* first = buckets[bucket]; <span class="comment">//指向节点所对应之串行的起始节点</span></span><br><span class="line"><span class="comment">//以下处理每一个旧bucket所含（串行）的每一个节点</span></span><br><span class="line"><span class="keyword">while</span>(first) &#123;<span class="comment">//串行还没结束时</span></span><br><span class="line"><span class="comment">//以下找出节点落在哪一个新bucket内</span></span><br><span class="line">size_type new_bucket = <span class="built_in">bkt_num</span>(first-&gt;val, n);</span><br><span class="line"><span class="comment">//以下四个操作颇为微妙</span></span><br><span class="line"><span class="comment">//(1)令旧bucket指向其所对应之串行的下一个节点(以便迭代处理)</span></span><br><span class="line">buckets[bucket] = first-&gt;next;</span><br><span class="line"><span class="comment">//(2)(3）将当前节点插人到新bucket内，成为其对应串行的第一个节点</span></span><br><span class="line">first-&gt;next = tmp[new_bucket];</span><br><span class="line">tmp[new_bucket] = first;</span><br><span class="line"><span class="comment">//(4)回到旧bucket所指的待处理串行，准备处理下一个节点</span></span><br><span class="line">first = buckets[bucket];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">buckets.<span class="built_in">swap</span>(tmp);<span class="comment">//vector::swap。新旧两个buckets对调</span></span><br><span class="line"><span class="comment">//注意，对调两方如果大小不同，大的会变小，小的会变大</span></span><br><span class="line"><span class="comment">//离开时释放local tmp的内存</span></span><br><span class="line">)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//在不需重建表格的情况下插人新节点。键值不允许重复</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">V</span>, <span class="keyword">class</span> <span class="title class_">K</span>, <span class="keyword">class</span> <span class="title class_">HF</span>, <span class="keyword">class</span> <span class="title class_">Ex</span>, <span class="keyword">class</span> <span class="title class_">Eq</span>, <span class="keyword">class</span> <span class="title class_">A</span>&gt;</span><br><span class="line">pair&lt;<span class="keyword">typename</span> hashtable&lt;V, K, HF, Ex, Eq, A&gt;::iterator, <span class="type">bool</span>&gt;</span><br><span class="line">hashtable&lt;V, K, HF, Ex, Eq, A&gt;::<span class="built_in">insert_unique_noresize</span>(<span class="type">const</span> value_type&amp; obj)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">const</span> size_type n = <span class="built_in">bkt_num</span>(obj); <span class="comment">//决定obj应位于#n bucket</span></span><br><span class="line">node* first = buckets[n]; <span class="comment">//令first指向bucket对应之串行头部</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果buckets[n]已被占用，此时first将不为0，于是进人以下循环，</span></span><br><span class="line">    <span class="comment">//走过bucket所对应的整个链表</span></span><br><span class="line"><span class="keyword">for</span> (node* cur = first; cur; cur = cur-&gt;next)</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">equals</span>(<span class="built_in">get_key</span>(cur-&gt;val), <span class="built_in">get_key</span>(obj)))</span><br><span class="line"><span class="comment">//如果发现与链表中的某键值相同，就不插人，立刻返回</span></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">pair</span>&lt;iterator, <span class="type">bool</span>&gt; (<span class="built_in">iterator</span>(cur, <span class="keyword">this</span>), <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//离开以上循环（或根本未进人循环）时， first 指向bucket所指链表的头部节点</span></span><br><span class="line">    node* tmp = <span class="built_in">new_node</span>(obj);<span class="comment">//产生新节点</span></span><br><span class="line">tmp-&gt;next = first;</span><br><span class="line">buckets[n] = tmp;   <span class="comment">//令新节点成为链表的第一个节点</span></span><br><span class="line">++num__elements;   <span class="comment">//节点个数累加1</span></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">pair</span>&lt;iterator, <span class="type">bool</span>&gt;(<span class="built_in">iterator</span>(tmp, <span class="keyword">this</span>), <span class="literal">true</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>insert_equal()与insert_unique的差别在于发现key值相同时立马插入：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">V</span>, <span class="keyword">class</span> <span class="title class_">K</span>, <span class="keyword">class</span> <span class="title class_">HF</span>, <span class="keyword">class</span> <span class="title class_">Ex</span>, <span class="keyword">class</span> <span class="title class_">Eq</span>, <span class="keyword">class</span> <span class="title class_">A</span>&gt;</span><br><span class="line"><span class="keyword">typename</span> hashtable&lt;V, K, HF, Ex, Eq, A&gt;::iterator, <span class="type">bool</span></span><br><span class="line">hashtable&lt;V, K, HF, Ex, Eq, A&gt;::<span class="built_in">insert_equal_noresize</span>(<span class="type">const</span> value_type&amp; obj)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//如果buckets[n]已被占用，此时first将不为0，于是进人以下循环，</span></span><br><span class="line">    <span class="comment">//走过bucket所对应的整个链表</span></span><br><span class="line"><span class="keyword">for</span> (node* cur = first; cur; cur = cur-&gt;next)</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">equals</span>(<span class="built_in">get_key</span>(cur-&gt;val), <span class="built_in">get_key</span>(obj))) &#123;</span><br><span class="line">             node* tmp = <span class="built_in">new_node</span>(obj);<span class="comment">//产生新节点</span></span><br><span class="line">tmp-&gt;next = cur-&gt;next;</span><br><span class="line">cur-&gt;next = tmp;   <span class="comment">//令将新节点插入于目前位置</span></span><br><span class="line">++num__elements;   <span class="comment">//节点个数累加1</span></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">iterator</span>(tmp, <span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="判断元素的落脚处（bkt-num）"><a href="#判断元素的落脚处（bkt-num）" class="headerlink" title="判断元素的落脚处（bkt_num）"></a>判断元素的落脚处（bkt_num）</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//版本1:接受实值(value)和buckets个数</span></span><br><span class="line"><span class="function">size_type <span class="title">bkt_num</span><span class="params">(<span class="type">const</span> value_type&amp; obj, <span class="type">size_t</span> n)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">bkt_num_key</span>(<span class="built_in">get_key</span>(obj), n); <span class="comment">//调用版本4</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//版本2:只接受实值(value)</span></span><br><span class="line"><span class="function">size_type <span class="title">bkt_num</span><span class="params">(<span class="type">const</span> value_type&amp; obj)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">bkt_num_key</span>(<span class="built_in">get_key</span>(obj));     <span class="comment">//调用版本3</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//版本3:只接受键值</span></span><br><span class="line"><span class="function">size_type <span class="title">bkt_num_key</span><span class="params">(<span class="type">const</span> key_type&amp; key)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">bkt_num_key</span>(key, buckets.<span class="built_in">size</span>());<span class="comment">//调用版本4</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//版本4:接受键值和buckets个数</span></span><br><span class="line"><span class="function">size_type <span class="title">bkt_num_key</span><span class="params">(<span class="type">const</span> key_type&amp; key, <span class="type">size_t</span> n)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">hash</span>(key) % n;  <span class="comment">// SGI 的所有内建的hash( )列于5.7.7节</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="复制（copy-from）和整体删除（clear）"><a href="#复制（copy-from）和整体删除（clear）" class="headerlink" title="复制（copy_from）和整体删除（clear）"></a>复制（copy_from）和整体删除（clear）</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">V</span>, <span class="keyword">class</span> <span class="title class_">K</span>, <span class="keyword">class</span> <span class="title class_">HF</span>, <span class="keyword">class</span> <span class="title class_">Ex</span>, <span class="keyword">class</span> <span class="title class_">Eq</span>, <span class="keyword">class</span> <span class="title class_">A</span>&gt;</span><br><span class="line"><span class="type">void</span> hashtable&lt;V, K, HF, Ex, Eq, A&gt;::<span class="built_in">clear</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//针对每一个bucket.</span></span><br><span class="line"><span class="keyword">for</span> (size_type i = <span class="number">0</span>; i &lt; buckets.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">node* cur = buckets[i];</span><br><span class="line"><span class="comment">//将bucket list中的每一个节点删除掉</span></span><br><span class="line"><span class="keyword">while</span> (cur != <span class="number">0</span> ) &#123;</span><br><span class="line">node* next = cur-&gt;next;</span><br><span class="line"><span class="built_in">delete_node</span>(cur);</span><br><span class="line">cur = next;</span><br><span class="line">&#125;</span><br><span class="line">buckets [i] = <span class="number">0</span>;<span class="comment">//令bucket内容为null指针</span></span><br><span class="line">&#125;</span><br><span class="line">num_elements = <span class="number">0</span> ;<span class="comment">//令总节点个数为0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//注意，buckets vector并未释放掉空间，仍保有原来大小</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">V</span>, <span class="keyword">class</span> <span class="title class_">K</span>, <span class="keyword">class</span> <span class="title class_">HF</span>, <span class="keyword">class</span> <span class="title class_">Ex</span>, <span class="keyword">class</span> <span class="title class_">Eq</span>, <span class="keyword">class</span> <span class="title class_">A</span>&gt;</span><br><span class="line"><span class="type">void</span> hashtable&lt;V, K, HF, Ex, Eq, A&gt;::<span class="built_in">copy_from</span>(<span class="type">const</span> hashtable&amp; ht)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//先清除己方的buckets vector.这操作是调用vector::clear.造成所有元素为0</span></span><br><span class="line">buckets.<span class="built_in">clear</span>();</span><br><span class="line"><span class="comment">//为己方的buckets vector保留空间，使与对方相同</span></span><br><span class="line"><span class="comment">//如果己方空间大于对方，就不动，如果己方空间小于对方，就会增大</span></span><br><span class="line">buckets.<span class="built_in">reserve</span>(ht.buckets.<span class="built_in">size</span>());</span><br><span class="line"><span class="comment">//从己方的buckets vector尾端开始，插人n个元素，其值为null指针</span></span><br><span class="line"><span class="comment">//注意，此时buckets vector为空，所以所谓尾端，就是起头处</span></span><br><span class="line">buckets.<span class="built_in">insert</span>(buckets.<span class="built_in">end</span>(), ht.buckets.<span class="built_in">size</span>(), (node*)<span class="number">0</span>);</span><br><span class="line">__STL_TRY &#123;</span><br><span class="line"><span class="comment">//针对buckets vector</span></span><br><span class="line"><span class="keyword">for</span> (size_type i = <span class="number">0</span>; i &lt; ht.buckets.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line"><span class="comment">//复制vector的每一个元素（是个指针，指向hashtable节点)</span></span><br><span class="line"><span class="keyword">if</span> (<span class="type">const</span> node* cur = ht.buckets[i]) &#123;</span><br><span class="line">node* copy = <span class="built_in">new_node</span>(cur-&gt;val);</span><br><span class="line">buckets [i] = copy;</span><br><span class="line"></span><br><span class="line">                 <span class="comment">//针对同一个bucket list，复制每一个节点</span></span><br><span class="line"><span class="keyword">for</span> (node* next = cur-&gt;next; next; cur = next, next = cur-&gt;next) &#123;</span><br><span class="line">copy-&gt;next = <span class="built_in">new_node</span>(next-&gt;val);</span><br><span class="line">copy = copy-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">        &#125;</span><br><span class="line">num_elements = ht.num_elements; <span class="comment">//重新登录节点个数(hashtable 的大小)</span></span><br><span class="line">    &#125;</span><br><span class="line">__STL_UNWIND(<span class="built_in">clear</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="hash-functions"><a href="#hash-functions" class="headerlink" title="hash functions"></a>hash functions</h4><p>&lt;stl_hash_fun.h&gt;定义有数个现成的hash functions，全都是仿函数，除了对于字符字符串（const char*）设计了一个转换函数外，其余char，short，int，long整型类型的hash functions几乎都什么都没做 ：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//以下定义于&lt;stl_hash_fun.h&gt;</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Key</span>&gt; <span class="keyword">struct</span> <span class="title class_">hash</span> &#123; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="type">size_t</span> __stl_hash_string (<span class="type">const</span> <span class="type">char</span>* s )</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> h = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> ( ; *s; ++s)</span><br><span class="line">h = <span class="number">5</span>*h + *s;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">size_t</span>(h);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//以下所有的__STL_TEMPLATE_NULL，在&lt;stl_config.h&gt;中皆被定义为template&lt;&gt;</span></span><br><span class="line">__STL_TEMPLATE_NULL <span class="keyword">struct</span> <span class="title class_">hash</span>&lt;<span class="type">char</span>*&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="type">const</span> <span class="type">char</span>* s)</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> __stl_hash_string(s);&#125; &#125;;</span><br><span class="line">__STL_TEMPLATE_NULL <span class="keyword">struct</span> <span class="title class_">hash</span>&lt;<span class="type">const</span> <span class="type">char</span>*&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="type">const</span> <span class="type">char</span>* s)</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> __stl_hash_string(s);&#125; &#125;;</span><br><span class="line">__STL_TEMPLATE_NULL <span class="keyword">struct</span> <span class="title class_">hash</span>&lt;<span class="type">char</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="type">char</span> x)</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> x;&#125; </span><br><span class="line">&#125;;</span><br><span class="line">__STL_TEMPLATE_NULL <span class="keyword">struct</span> <span class="title class_">hash</span>&lt;<span class="type">unsigned</span> <span class="type">char</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="type">unsigned</span> <span class="type">char</span> x)</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> x;&#125; </span><br><span class="line">&#125;;</span><br><span class="line">__STL_TEMPLATE_NULL <span class="keyword">struct</span> <span class="title class_">hash</span>&lt;<span class="type">signed</span> <span class="type">char</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="type">unsigned</span> <span class="type">char</span> x)</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> x;&#125; </span><br><span class="line">&#125;;</span><br><span class="line">__STL_TEMPLATE_NULL <span class="keyword">struct</span> <span class="title class_">hash</span>&lt;<span class="type">short</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="type">short</span> x)</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> x;&#125; </span><br><span class="line">&#125;;</span><br><span class="line">__STL_TEMPLATE_NULL <span class="keyword">struct</span> <span class="title class_">hash</span>&lt;<span class="type">unsigned</span> <span class="type">short</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="type">unsigned</span> <span class="type">short</span> x)</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> x;&#125; </span><br><span class="line">&#125;;</span><br><span class="line">__STL_TEMPLATE_NULL <span class="keyword">struct</span> <span class="title class_">hash</span>&lt;<span class="type">int</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="type">int</span> x)</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> x;&#125; </span><br><span class="line">&#125;;</span><br><span class="line">__STL_TEMPLATE_NULL <span class="keyword">struct</span> <span class="title class_">hash</span>&lt;<span class="type">unsigned</span> <span class="type">int</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="type">unsigned</span> <span class="type">int</span> x)</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> x;&#125; </span><br><span class="line">&#125;;</span><br><span class="line">__STL_TEMPLATE_NULL <span class="keyword">struct</span> <span class="title class_">hash</span>&lt;<span class="type">long</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="type">long</span> x)</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> x;&#125; </span><br><span class="line">&#125;;</span><br><span class="line">__STL_TEMPLATE_NULL <span class="keyword">struct</span> <span class="title class_">hash</span>&lt;<span class="type">unsigned</span> <span class="type">long</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="type">unsigned</span> <span class="type">long</span> x)</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> x;&#125; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>除了上述定义过hash function的类型之外的类型，例如string，double，float。欲处理这些类型，用户必须自行为它们定义hash function。</p><h3 id="hash-set和hash-multiset"><a href="#hash-set和hash-multiset" class="headerlink" title="hash_set和hash_multiset"></a>hash_set和hash_multiset</h3><p>hash_set不同于set的地方是hash_set的底层机制时hashtable而set的底层机制是RB-tree。因此，set的元素具有自动排序功能而hash_set没有，除此之外，使用方式完全相同。</p><p>而hash_multiset与hash_set的区别仅在于对不同插入函数的调用（insert_equal()和insert_unique()）。</p><h3 id="hash-map和hash-multimap"><a href="#hash-map和hash-multimap" class="headerlink" title="hash_map和hash_multimap"></a>hash_map和hash_multimap</h3><p>hash_map不同于map的地方是hash_map的底层机制时hashtable而map的底层机制是RB-tree。因此，map的元素具有自动排序功能而hash_map没有，除此之外，使用方式完全相同。</p><p>而hash_multimap与hash_map的区别仅在于对不同插入函数的调用（insert_equal()和insert_unique()）。</p>]]></content>
    
    
    <summary type="html">&lt;STL源码剖析&gt;第五章读书笔记，关于关联式容器的源码剖析</summary>
    
    
    
    <category term="STL源码剖析读书笔记" scheme="http://example.com/categories/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="STL" scheme="http://example.com/tags/STL/"/>
    
    <category term="STL源码剖析" scheme="http://example.com/tags/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"/>
    
    <category term="容器" scheme="http://example.com/tags/%E5%AE%B9%E5%99%A8/"/>
    
    <category term="关联式容器" scheme="http://example.com/tags/%E5%85%B3%E8%81%94%E5%BC%8F%E5%AE%B9%E5%99%A8/"/>
    
    <category term="二叉搜索树" scheme="http://example.com/tags/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
    
    <category term="RB-tree" scheme="http://example.com/tags/RB-tree/"/>
    
    <category term="set" scheme="http://example.com/tags/set/"/>
    
    <category term="map" scheme="http://example.com/tags/map/"/>
    
    <category term="multiset" scheme="http://example.com/tags/multiset/"/>
    
    <category term="multimap" scheme="http://example.com/tags/multimap/"/>
    
    <category term="hashtable" scheme="http://example.com/tags/hashtable/"/>
    
  </entry>
  
  <entry>
    <title>&lt;STL源码剖析&gt;第四章</title>
    <link href="http://example.com/2022/03/26/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E7%AC%AC%E5%9B%9B%E7%AB%A0/"/>
    <id>http://example.com/2022/03/26/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E7%AC%AC%E5%9B%9B%E7%AB%A0/</id>
    <published>2022-03-25T16:00:00.000Z</published>
    <updated>2022-03-30T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h2><p><img src="/../img/%E5%AE%B9%E5%99%A8.png" alt="容器"></p><p>容器将运用最广的一些数据结构实现出来。这里的衍生不是inheritance关系，而是containment关系，例如：heap内含一个vector，priority-queue内含一个heap。</p><h2 id="序列式容器"><a href="#序列式容器" class="headerlink" title="序列式容器"></a>序列式容器</h2><h3 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h3><p>vector与内置的array相似，唯一差别在于array是静态空间，配置了大小就无法改变，而vector是动态空间，内部机制会在空间不足时自行扩充空间。</p><p>vector的实现技术关键在于其对空间大小的控制以及重新配置空间时的数据移动效率。</p><h4 id="vector的迭代器"><a href="#vector的迭代器" class="headerlink" title="vector的迭代器"></a>vector的迭代器</h4><p>vector维护一个连续线性空间且支持随机读取，普通指针即可满足要求，所以，vector提供的是Random Access Iterators。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>,<span class="keyword">class</span> <span class="title class_">Alloc</span> = alloc&gt;</span><br><span class="line"><span class="keyword">class</span> vector &#123;</span><br><span class="line"><span class="keyword">public</span> :</span><br><span class="line"><span class="keyword">typedef</span> T value_type;</span><br><span class="line"><span class="keyword">typedef</span> value_type*  iterator;    <span class="comment">//vector 的迭代器是普通指针</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="vector的数据结构"><a href="#vector的数据结构" class="headerlink" title="vector的数据结构"></a>vector的数据结构</h4><p>vector的数据结构采取先行连续空间，空间范围由三个迭代器表示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Alloc</span> = alloc&gt;</span><br><span class="line"><span class="keyword">class</span> vector &#123;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">protected</span> :</span><br><span class="line">iterator start ;  <span class="comment">//表示目前使用空间的头</span></span><br><span class="line">iterator finish;  <span class="comment">//表示目前使用空间的尾</span></span><br><span class="line">iterator end_of_storage; <span class="comment">//表示目前可用空间的尾</span></span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>end_of_storage的意义：一旦vector的容量等于使用空间大小时，再有新增元素，整个vector就得一起“搬家”，因此vector实际配置的大小可能比需求量更大一些来降低空间配置的速度成本。</p><p>运用这三个迭代器，可以轻松地提供首尾标示、大小、容量、空容器判断、[]运算符、取首尾元素等操作。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Alloc</span> = alloc&gt;</span><br><span class="line"><span class="keyword">class</span> vector &#123;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">iterator <span class="built_in">begin</span>() &#123; <span class="keyword">return</span> start; &#125;</span><br><span class="line"><span class="function">iterator <span class="title">end</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> finish; &#125;</span><br><span class="line"><span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">size_type</span> (<span class="built_in">end</span>() - <span class="built_in">begin</span>()); &#125;</span><br><span class="line"><span class="function">size_type <span class="title">capacity</span> <span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">size_type</span>(end_of_storage - <span class="built_in">begin</span> ()); &#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">begin</span>() == <span class="built_in">end</span>(); &#125;</span><br><span class="line">reference <span class="keyword">operator</span>[](size_type n) &#123; <span class="keyword">return</span> *(<span class="built_in">begin</span>() + n); &#125;</span><br><span class="line"><span class="function">reference <span class="title">front</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> *<span class="built_in">begin</span>(); &#125;</span><br><span class="line"><span class="function">reference <span class="title">back</span> <span class="params">()</span> </span>&#123; <span class="keyword">return</span> *(<span class="built_in">end</span>() - <span class="number">1</span>); &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p><img src="/../img/vector%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="vector示意图"></p><h3 id="list"><a href="#list" class="headerlink" title="list"></a>list</h3><p>list相比vector对空间的应用有着绝对的精准，每次插入或删除一个元素，只涉及到一个元素空间的配置获释放。</p><h4 id="list的节点"><a href="#list的节点" class="headerlink" title="list的节点"></a>list的节点</h4><p>list本身和list的节点是不同的结构，以下是STL list的节点结构：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__list_node</span> &#123;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">void</span>* void_pointer;</span><br><span class="line">void_pointer prev;     <span class="comment">//型别为 void*。其实可设为__list_node&lt;T&gt;*</span></span><br><span class="line">void_pointer next;</span><br><span class="line">T data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="list的迭代器"><a href="#list的迭代器" class="headerlink" title="list的迭代器"></a>list的迭代器</h4><p>由于list节点不保证在存储空间中连续存在，所以不能像vector一样以普通指针作为迭代器。需要单独实现以有能力指向list节点并能正确的递增、递减、取值、成员存取等操作。</p><p>由于STL list是一个双向链表，迭代器必须具备前移、后移的能力，所以list提供的是Bidirectional Iterators。</p><p>以下是list迭代器的设计：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Ref</span> , <span class="keyword">class</span> <span class="title class_">Ptr</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__list_iterator</span> &#123;</span><br><span class="line"><span class="keyword">typedef</span> __list_iterator&lt;T, T&amp;, T*&gt;    iterator;</span><br><span class="line"><span class="keyword">typedef</span> __list_iterator&lt;T, Ref, Ptr&gt;      self;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">typedef</span> bidirectional_iterator_tag iterator_category;</span><br><span class="line"><span class="keyword">typedef</span> T value_type;</span><br><span class="line"><span class="keyword">typedef</span> Ptr pointer;</span><br><span class="line"><span class="keyword">typedef</span> Ref reference;</span><br><span class="line"><span class="keyword">typedef</span> __list_node&lt;T&gt;* link_type;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">size_t</span> size_type;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">ptrdiff_t</span> difference_type;</span><br><span class="line"></span><br><span class="line">link_type node; <span class="comment">// 迭代器内部当然要有一个普通指针，指向list 的节点</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// constructor</span></span><br><span class="line">__list_iterator(link_type x) : <span class="built_in">node</span>(x) &#123; &#125;</span><br><span class="line">__list_iterator() &#123; &#125;</span><br><span class="line">__list_iterator(<span class="type">const</span> iterator&amp; x) : <span class="built_in">node</span>(x.node) &#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> self&amp; x) <span class="type">const</span> &#123; <span class="keyword">return</span> node == x.node; &#125;</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>!=(<span class="type">const</span> self&amp; x) <span class="type">const</span> &#123; <span class="keyword">return</span> node != x.node; &#125;</span><br><span class="line"><span class="comment">//以下对迭代器取值（dereference)，取的是节点的数据值</span></span><br><span class="line">reference <span class="keyword">operator</span>*() <span class="type">const</span> &#123; <span class="keyword">return</span> (*node).data; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//以下是迭代器的成员存取（member access）运算子的标准做法</span></span><br><span class="line">pointer <span class="keyword">operator</span>-&gt;() <span class="type">const</span> &#123; <span class="keyword">return</span> &amp;(<span class="keyword">operator</span>*()); &#125;</span><br><span class="line"><span class="comment">//对迭代器累加1，就是前进一个节点</span></span><br><span class="line">self&amp; <span class="keyword">operator</span>++() &#123;</span><br><span class="line">node = (link_type)((*node).next);</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">self <span class="keyword">operator</span>++(<span class="type">int</span>) &#123;</span><br><span class="line">self tmp = *<span class="keyword">this</span>;</span><br><span class="line">++*<span class="keyword">this</span>;</span><br><span class="line"><span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对迭代器递减1，就是后退一个节点</span></span><br><span class="line">    self&amp; <span class="keyword">operator</span>--() &#123;</span><br><span class="line">node = (link_type)((*node).prev);</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line">self <span class="keyword">operator</span>--(<span class="type">int</span>) &#123;</span><br><span class="line">        self tmp = *<span class="keyword">this</span>;</span><br><span class="line">        --*<span class="keyword">this</span>;</span><br><span class="line"><span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="list的数据结构"><a href="#list的数据结构" class="headerlink" title="list的数据结构"></a>list的数据结构</h4><p>STL list是一个循环双向列表，得到一个指针便可以完整的遍历整个链表：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Alloc</span> = alloc&gt; <span class="comment">//缺省使用alloc为配置器</span></span><br><span class="line"><span class="keyword">class</span> list &#123;</span><br><span class="line"><span class="keyword">protected</span> :</span><br><span class="line"><span class="keyword">typedef</span> __list_node&lt;T&gt; list_node;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">typedef</span> list_node* link_type;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> :</span><br><span class="line">link_type node;    <span class="comment">//只要一个指针，便可表示整个环状双向链表</span></span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>node节点的值：通过让node节点置于刻意在尾端加入的一个空白节点，可以满足“前闭后开”的区间要求并作为end迭代器使用。</p><h4 id="list的sort"><a href="#list的sort" class="headerlink" title="list的sort()"></a>list的sort()</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//list 不能使用sTL算法sort()，必须使用自己的sort()member function,</span></span><br><span class="line"><span class="comment">//因为STL算法sort()只接受RandomAccessIterator</span></span><br><span class="line"><span class="comment">//本函数采用quick sort</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Alloc</span>&gt;</span><br><span class="line"><span class="type">void</span> list&lt;T, Alloc&gt;::<span class="built_in">sort</span>() &#123;</span><br><span class="line"><span class="comment">//以下判断，如果是空链表，或仅有一个元素，就不进行任何操作</span></span><br><span class="line"><span class="comment">//使用size() == 0 || size() == 1来判断，虽然也可以，但是比较慢</span></span><br><span class="line">    <span class="keyword">if</span>(node-&gt;next == node || <span class="built_in">link_type</span>(node-&gt;next)-&gt;next == node)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="comment">//一些新的lists，作为中介数据存放区</span></span><br><span class="line">list&lt;T,Alloc&gt; carry;</span><br><span class="line">list&lt;T,Alloc&gt; counter[<span class="number">64</span>];</span><br><span class="line"><span class="type">int</span> fill = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(!<span class="built_in">empty</span>()) &#123;</span><br><span class="line">carry.<span class="built_in">splice</span>(carry.<span class="built_in">begin</span>(), *<span class="keyword">this</span>, <span class="built_in">begin</span>());</span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(i &lt; fill &amp;&amp; !counter[i].<span class="built_in">empty</span>()) &#123;</span><br><span class="line">counter[i].<span class="built_in">merge</span>(carry);</span><br><span class="line">carry.<span class="built_in">swap</span>(counter[i++]);</span><br><span class="line">&#125;</span><br><span class="line">carry.<span class="built_in">swap</span>(counter[i]);</span><br><span class="line"><span class="keyword">if</span>(i == fill) ++fill;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; fill; ++i)</span><br><span class="line">counter[i].<span class="built_in">merge</span>(counter[i<span class="number">-1</span>]);</span><br><span class="line"><span class="built_in">swap</span>(counter[fi11<span class="number">-1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="deque"><a href="#deque" class="headerlink" title="deque"></a>deque</h3><p>deque是一种双向开口的连续线性空间，即可以在deque头尾两端分别做元素的插入和删除操作。</p><p>deque和vector的最大差异：</p><ul><li>deque允许在常数时间内对头端进行元素的插入或移除操作。</li><li>deque没有所谓的容量（capacity）观念，因为它是动态地以分段连续空间组合而成，随时可以增加一段新的空间并链接起来。</li></ul><h4 id="deque的中控器"><a href="#deque的中控器" class="headerlink" title="deque的中控器"></a>deque的中控器</h4><p>关于三种连续空间，array无法成长，vector可以成长，但vector的成长只是个假象（实际上是通过1、找到更大的连续空间。2、将原数据复制过去。2、释放原空间。完成的）。可见完成这种“假象”的背后需要高昂的代价。所以可想而知，deque将分段的连续空间动态拼接起来也需要一些代价来完成。</p><p>deque 采用一块所谓的map（不是STL的 map容器）作为主控。这里所谓map是一小块连续空间，其中每个元素（此处称为一个节点，node）都是指针，指向另一段（较大的）连续线性空间，称为缓冲区。缓冲区才是 deque 的储存空间主体。SGI STL允许我们指定缓冲区大小，默认值0表示将使用512bytes缓冲区。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Alloc</span> = alloc, <span class="type">size_t</span> Bufsize = <span class="number">0</span>&gt;</span><br><span class="line"><span class="keyword">class</span> deque &#123;</span><br><span class="line"><span class="keyword">public</span>:                  <span class="comment">//Basic types</span></span><br><span class="line"><span class="keyword">typedef</span> T value_type;</span><br><span class="line"><span class="keyword">typedef</span> value_type* pointer;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">protected</span>:               <span class="comment">//Internal typedefs</span></span><br><span class="line"><span class="comment">//元素的指针的指针(pointer of pointer of T)</span></span><br><span class="line"><span class="keyword">typedef</span> pointer* map_pointer;</span><br><span class="line"><span class="keyword">protected</span>:               <span class="comment">//Data members</span></span><br><span class="line">map_pointer map;     <span class="comment">//指向map，map是块连续空间，其内的每个元素</span></span><br><span class="line">                         <span class="comment">//都是一个指针（称为节点），指向一块缓冲区</span></span><br><span class="line">    size_type map_size;  <span class="comment">//map内可容纳多少指针</span></span><br></pre></td></tr></table></figure><p>![deque map](..&#x2F;img&#x2F;deque map.png) </p><h4 id="deque的迭代器"><a href="#deque的迭代器" class="headerlink" title="deque的迭代器"></a>deque的迭代器</h4><p>deque提供Random Access Iterator，但它的迭代器不是普通指针，复杂度和vector相比大幅增加。</p><p>deque是分段连续空间，要想维持其表面上的“整体连续”的假象，deque的迭代器需要能够指出分段连续空间的位置以及判断前进或者后退时是否需要跳跃到别的缓冲区上。因此，deque必须随时掌握中控器map：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Ref</span>, <span class="keyword">class</span> <span class="title class_">ptr</span>, <span class="type">size_t</span> Bufsiz&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__deque_iterator</span> &#123;  <span class="comment">//未继承std::iterator</span></span><br><span class="line"><span class="keyword">typedef</span> __deque_iterator&lt;T, T&amp;, T*, BufSiz&gt;    iterator;</span><br><span class="line"><span class="keyword">typedef</span> __deque_iterator&lt;T, <span class="type">const</span> T&amp;, <span class="type">const</span> T*, BufSiz&gt; const_iterator;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">size_t</span> <span class="title">buffer_size</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> __deque_buf_size(BufSiz, <span class="built_in">sizeof</span>(T)); &#125;</span><br><span class="line"><span class="comment">//未继承std::iterator，所以必须自行撰写五个必要的迭代器相应型别（第3章)</span></span><br><span class="line"><span class="keyword">typedef</span> random_access_iterator_tag iterator_category; <span class="comment">// (1)</span></span><br><span class="line"><span class="keyword">typedef</span> T value_type;   <span class="comment">// (2)</span></span><br><span class="line"><span class="keyword">typedef</span> Ptr pointer;    <span class="comment">// (3)</span></span><br><span class="line"><span class="keyword">typedef</span> Ref reference;   <span class="comment">// (4)</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">size_t</span> size_type;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">ptrdiff_t</span> difference_type;  <span class="comment">// (5)</span></span><br><span class="line"><span class="keyword">typedef</span> T** map_pointer;</span><br><span class="line"><span class="keyword">typedef</span> __deque_iterator self;</span><br><span class="line"><span class="comment">//保持与容器的联结</span></span><br><span class="line">T* cur;   <span class="comment">//此迭代器所指之缓冲区中的现行（current）元素</span></span><br><span class="line">T* first; <span class="comment">//此迭代器所指之缓冲区的头</span></span><br><span class="line">T* last; <span class="comment">//此迭代器所指之缓冲区的尾（含备用空间)</span></span><br><span class="line">map_pointer node; <span class="comment">//指向管控中心</span></span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用来决定缓冲区大小的函数buffer_size(),调用全局函数__deque_buf_size()。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="type">size_t</span> __deque_buf_size(<span class="type">size_t</span> n, <span class="type">size_t</span> sz)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> n != <span class="number">0</span> ? n : (sz &lt; <span class="number">512</span> ? <span class="built_in">size_t</span>(<span class="number">512</span> / sz) : <span class="built_in">size_t</span>(<span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/../img/deque%E8%BF%AD%E4%BB%A3%E5%99%A8.png" alt="deque迭代器"></p><p>deque的迭代器操作最关键的点在于行进到缓冲区边缘时，需要注意是否切换缓冲区：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">set_node</span> <span class="params">(map_pointer new_node)</span> </span>&#123;</span><br><span class="line">node = new_node;</span><br><span class="line">first = *new_node;</span><br><span class="line">last = first + <span class="built_in">difference_type</span>(<span class="built_in">buffer_size</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//以opretor++和operator+=为例</span></span><br><span class="line">self&amp; <span class="keyword">operator</span>++ () &#123;</span><br><span class="line">++cur;     <span class="comment">//切换至下一个元素</span></span><br><span class="line"><span class="keyword">if</span>(cur == last) &#123;        <span class="comment">//如果已达所在缓冲区的尾端</span></span><br><span class="line"><span class="built_in">set_node</span>(node + <span class="number">1</span>); <span class="comment">//就切换至下一节点（亦即缓冲区)</span></span><br><span class="line">cur = first;        <span class="comment">//的第一个元素</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">self&amp; <span class="keyword">operator</span>+= (difference_type n) &#123;</span><br><span class="line">difference_type offset = n + (cur - first);</span><br><span class="line"><span class="keyword">if</span> (offset &gt;= <span class="number">0</span> &amp;&amp; offset &lt; <span class="built_in">difference_type</span>(<span class="built_in">buffer_size</span>())) &#123;</span><br><span class="line">        <span class="comment">//目标位置在同一缓冲区内</span></span><br><span class="line">cur +=n;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//标的位置不在同一缓冲区内</span></span><br><span class="line">difference_type node_offset = offset &gt; <span class="number">0</span> ? offset / <span class="built_in">difference_type</span>(<span class="built_in">buffer_size</span>())</span><br><span class="line">: -<span class="built_in">difference_type</span>((-offset - <span class="number">1</span>) / <span class="built_in">buffer_size</span>()) - <span class="number">1</span>;</span><br><span class="line"><span class="comment">//切换至正确的节点（亦即缓冲区)</span></span><br><span class="line"><span class="built_in">set_node</span>(node + node_offset);</span><br><span class="line"><span class="comment">//切换至正确的元素</span></span><br><span class="line">cur = first + (offset - node_offset * <span class="built_in">difference_type</span>(buffer_size));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>deque除了维护一个先前说过的指向map的指针外，也需要维护start,finish两个迭代器分别指向第一缓冲区的第一个元素和最后缓冲区的最后一个元素的下一个位置以及map的大小以在节点不足时配置更大的map：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Alloc</span> = alloc, <span class="type">size_t</span> BufSiz = <span class="number">0</span>&gt;</span><br><span class="line"><span class="keyword">class</span> deque &#123;</span><br><span class="line">...</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> __deque_iterator&lt;T, T&amp;, T* BufSiz&gt; iterator;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">protected</span>:</span><br><span class="line">    iterator start;    <span class="comment">//第一个节点</span></span><br><span class="line">    iterator finish;   <span class="comment">//最后一个节点的后一个位置</span></span><br><span class="line">    </span><br><span class="line">    map_pointer map;</span><br><span class="line">    size_type map_size;   <span class="comment">//map内有多少指针</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有了这个结构，便可完成一下几种机制：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function">iterator <span class="title">begin</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> start; &#125;</span><br><span class="line"><span class="function">iterator <span class="title">end</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> finish; &#125;</span><br><span class="line"></span><br><span class="line">reference <span class="keyword">operator</span>[](size_type n) &#123;</span><br><span class="line"><span class="keyword">return</span> start[<span class="built_in">difference_type</span>(n)]; <span class="comment">//调用__deque_iterator&lt;&gt;: :operator[]</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="function">reference <span class="title">front</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> *start; &#125; <span class="comment">// 调用__deque_iterator&lt;&gt;::operator*</span></span><br><span class="line"><span class="function">reference <span class="title">back</span><span class="params">()</span> </span>&#123;</span><br><span class="line">iterator tmp = finish;</span><br><span class="line">--tmp;</span><br><span class="line"><span class="keyword">return</span> *tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> finish - start; &#125;<span class="comment">//以上调用iterator:: operator-</span></span><br><span class="line"><span class="function">size_type <span class="title">max_size</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">size_type</span>(<span class="number">-1</span>); &#125;;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> finish == start; &#125;</span><br></pre></td></tr></table></figure><h4 id="deque的构造与内存管理"><a href="#deque的构造与内存管理" class="headerlink" title="deque的构造与内存管理"></a>deque的构造与内存管理</h4><p>deque构造的内存管理的重点在以下三点：</p><ul><li>deque的初始化ctor</li><li>普通的构造对象push_back,push_front（备用内存够用）</li><li>map的头或尾空间不够用需重新分配map（配置更大的，拷贝原来的，释放原来的）</li></ul><p>deuqe自行定义了两个专属的空间配置器：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span>:        <span class="comment">//Internal typedefs</span></span><br><span class="line"><span class="comment">//专属之空间配置器，每次配置一个元素大小</span></span><br><span class="line"><span class="keyword">typedef</span> simple_alloc&lt;value_type, Alloc&gt; data_allocator;</span><br><span class="line"><span class="comment">//专属之空间配置器，每次配置一个指针大小</span></span><br><span class="line"><span class="keyword">typedef</span> simple_alloc&lt;pointer, Alloc&gt; map_allocator;</span><br></pre></td></tr></table></figure><h5 id="deque的初始化ctor"><a href="#deque的初始化ctor" class="headerlink" title="deque的初始化ctor"></a>deque的初始化ctor</h5><p>以deque的其中一个constructor为例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">deque</span>(<span class="type">int</span> n, <span class="type">const</span> value_type&amp; value)</span><br><span class="line">: <span class="built_in">start</span>(), <span class="built_in">finish</span>(), <span class="built_in">map</span>(<span class="number">0</span>), <span class="built_in">map_size</span>(<span class="number">0</span>) </span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">fill_initialize</span>(n, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Alloc</span>, <span class="type">size_t</span> Bufsize&gt;</span><br><span class="line"><span class="type">void</span> deque&lt;T, Alloc, BufSize&gt;::<span class="built_in">fi11_initialize</span>(size_type n, </span><br><span class="line"><span class="type">const</span> value_type&amp; value) &#123;</span><br><span class="line"><span class="built_in">create_map_and_nodes</span>(n);  <span class="comment">//把deque的结构都产生并安排好</span></span><br><span class="line">map_pointer cur;</span><br><span class="line">__STL_TRY &#123;</span><br><span class="line"><span class="comment">//为每个节点的缓冲区设定初值</span></span><br><span class="line"><span class="keyword">for</span>(cur = start.node; cur &lt; finish.node; ++cur)</span><br><span class="line"><span class="built_in">uninitialized_fill</span>(*cur, *cur + <span class="built_in">buffer_size</span>(), value);</span><br><span class="line"><span class="comment">//最后一个节点的设定稍有不同（因为尾端可能有备用空间，不必设初值)</span></span><br><span class="line"><span class="built_in">uninitialized_fill</span>(finish.first, finish.cur, value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">catch</span>(...) &#123;</span><br><span class="line">...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//产生并安排deque的结构的函数create_map_and_nodes</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Alloc</span>, <span class="type">size_t</span> Bufsize&gt;</span><br><span class="line"><span class="type">void</span> deque&lt;T, Alloc, BufSize&gt;::<span class="built_in">create_map_and_nodes</span>(size_type num_elements)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//需要节点数=(元素个数/每个缓冲区可容纳的元素个数)+1</span></span><br><span class="line"><span class="comment">//如果刚好整除，会多配一个节点</span></span><br><span class="line">size_type num_nodes = num_elements / <span class="built_in">buffer_size</span>() + <span class="number">1</span>;</span><br><span class="line"><span class="comment">//一个map要管理几个节点。最少8个，最多是“所需节点数加2&quot;</span></span><br><span class="line"><span class="comment">//（前后各预留一个，扩充时可用)</span></span><br><span class="line">map_size = <span class="built_in">max</span>(<span class="built_in">initial_map_size</span>(), num_nodes + <span class="number">2</span>);</span><br><span class="line">map = map_allocator::<span class="built_in">allocate</span>(map_size);</span><br><span class="line"><span class="comment">//以上配置出一个“具有map_size个节点”的map</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//以下令nstart和nfinish指向map所拥有之全部节点的最中央区段</span></span><br><span class="line"><span class="comment">//保持在最中央，可使头尾两端的扩充能量一样大。每个节点可对应一个缓冲区</span></span><br><span class="line">map_pointer nstart = map + (map_size - num_nodes) / <span class="number">2</span>;</span><br><span class="line">map_pointer nfinish = nstart + num_nodes - <span class="number">1</span>;</span><br><span class="line">map_pointer cur;</span><br><span class="line">__STL_TRY &#123;</span><br><span class="line"><span class="comment">//为map内的每个现用节点配置缓冲区。所有缓冲区加起来就是deque的</span></span><br><span class="line"><span class="comment">//可用空间（最后一个缓冲区可能留有一些余裕)</span></span><br><span class="line"><span class="keyword">for</span>(cur = nstart; cur &lt;= nfinish; ++cur)</span><br><span class="line">            *cur = <span class="built_in">allocate_node</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">catch</span>(...) &#123;</span><br><span class="line"><span class="comment">//&quot;commit or rollback”语意:若非全部成功，就一个都不留</span></span><br><span class="line">...</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//为deque内的两个迭代器start和end设定正确内容</span></span><br><span class="line">start.<span class="built_in">set_node</span>(nstart);</span><br><span class="line">finish.<span class="built_in">set_node</span>(nfinish);</span><br><span class="line">start.cur = start.first;<span class="comment">// first,cur都是public</span></span><br><span class="line">finish.cur = finish.first + num_elements % <span class="built_in">buffer_size</span>();</span><br><span class="line">    <span class="comment">//前面说过，如果刚好整除,会多配一个节点</span></span><br><span class="line"><span class="comment">//此时即令cur指向这多配的一个节点（所对映之缓冲区）的起始处</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="普通的构造对象push-back-push-front（备用内存够用）"><a href="#普通的构造对象push-back-push-front（备用内存够用）" class="headerlink" title="普通的构造对象push_back,push_front（备用内存够用）"></a>普通的构造对象push_back,push_front（备用内存够用）</h5><p>以push_back为例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>:               <span class="comment">//push_* and pop_*</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push_back</span><span class="params">(<span class="type">const</span> value_type&amp; t)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(finish.cur != finish.last - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">//最后缓冲区尚有一个以上的备用空间</span></span><br><span class="line"><span class="built_in">construct</span>(finish.cur, t); <span class="comment">//直接在备用空间上构造元素</span></span><br><span class="line">++finish.cur;         <span class="comment">//调整最后缓冲区的使用状态</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="comment">//最后缓冲区已无（或只剩一个）元素备用空间</span></span><br><span class="line"><span class="built_in">push_back_aux</span>(t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当尾部（头部）缓冲区的备用空间只剩一个的时候，此时需要先配置一整块再去设置新元素内容：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//只有当finish.cur == finish.last - 1时才会被调用</span></span><br><span class="line"><span class="comment">//也就是说，只有当最后一个缓冲区只剩一个备用元素空间时才会被调用</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Alloc</span>, <span class="type">size_t</span> Bufsize&gt;</span><br><span class="line"><span class="type">void</span> deque&lt;T,Alloc，BufSize&gt;::<span class="built_in">push_back_aux</span>(<span class="type">const</span> value_type&amp; t) &#123;</span><br><span class="line">value_type t_copy = t;</span><br><span class="line"><span class="built_in">reserve_map_at_back</span>();            <span class="comment">//若符合某种条件则必须重换一个map</span></span><br><span class="line">*(finish.node + <span class="number">1</span>) = <span class="built_in">allocate_node</span>(); <span class="comment">//配置一个新节点（缓冲区）</span></span><br><span class="line">__STL_TRY &#123;</span><br><span class="line"><span class="built_in">construct</span>(finish.cur, t_copy);    <span class="comment">//针对标的元素设值</span></span><br><span class="line">finish.<span class="built_in">set_node</span>(finish.node + <span class="number">1</span>); <span class="comment">//改变finish，令其指向新节点</span></span><br><span class="line">finish.cur = finish.first;        <span class="comment">//设定finish的状态</span></span><br><span class="line">&#125;</span><br><span class="line">_STL_UNWIND(<span class="built_in">deallocate_node</span>(*(finish.node + <span class="number">1</span>)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="map的头或尾空间不够用需重新分配map（配置更大的，拷贝原来的，释放原来的）"><a href="#map的头或尾空间不够用需重新分配map（配置更大的，拷贝原来的，释放原来的）" class="headerlink" title="map的头或尾空间不够用需重新分配map（配置更大的，拷贝原来的，释放原来的）"></a>map的头或尾空间不够用需重新分配map（配置更大的，拷贝原来的，释放原来的）</h5><p>函数会在函数开始调用reserve_map_at_back()来判断是否需要扩充map，如有需要就付诸行动：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">reserve_map_at_back</span><span class="params">(size_type nodes_to_add = <span class="number">1</span>)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(nodes_to_add + <span class="number">1</span> &gt; map_size - (finish.node - map))</span><br><span class="line"><span class="comment">//如果map尾端的节点备用空间不足</span></span><br><span class="line"><span class="comment">//符合以上条件则必须重换一个map(配置更大的，拷贝原来的，释放原来的)</span></span><br><span class="line"><span class="built_in">reallocate_map</span>(nodes_to_add, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Alloc</span>, <span class="type">size_t</span> Bufsize&gt;</span><br><span class="line"><span class="type">void</span> deque&lt;T, Alloc, BufSize&gt;::<span class="built_in">reallocate_map</span>(size_type nodes_to_add,</span><br><span class="line"><span class="type">bool</span> add_at_front)  &#123;</span><br><span class="line">size_type old_num_nodes = finish.node - start.node + <span class="number">1</span>;</span><br><span class="line">size_type new_num_nodes = old_num_nodes + nodes_to_add;</span><br><span class="line">    </span><br><span class="line">map_pointer new_nstart;</span><br><span class="line"><span class="keyword">if</span>(map_size &gt; <span class="number">2</span> * new_num_nodes) &#123;</span><br><span class="line">        <span class="comment">//如果map_size足够大，只需要move原有元素</span></span><br><span class="line">new_nstart = map + (map_size - new_num__nodes) / <span class="number">2</span></span><br><span class="line">+ (add_at_front ? nodes_to_add : <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span>(new_nstart &lt; start.node)</span><br><span class="line"><span class="built_in">copy</span>(start.node, finish.node + <span class="number">1</span>, new_nstart);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">copy_backward</span>(start.node, finish.node + <span class="number">1</span>, new_nstart + old_num_nodes);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">size_type new_map_size = map_size + <span class="built_in">max</span>(map_size, nodes_to_add) + <span class="number">2</span>;</span><br><span class="line"><span class="comment">//配置一块空间，准备给新map使用</span></span><br><span class="line">map_pointer new_map = map_allocator::<span class="built_in">allocate</span>(new_map_size); new_nstart = new_map + (new_map_size - new_num_nodes) / <span class="number">2</span></span><br><span class="line">+ (add_at_front ? nodes_to_add : <span class="number">0</span>);</span><br><span class="line"><span class="comment">//把原map内容拷贝过来</span></span><br><span class="line"><span class="built_in">copy</span>(start.node,finish.node + <span class="number">1</span>,new_nstart) ;</span><br><span class="line"><span class="comment">//释放原map</span></span><br><span class="line">map_allocator::<span class="built_in">deallocate</span>(map, map_size);</span><br><span class="line"><span class="comment">//设定新map的起始地址与大小</span></span><br><span class="line">map = new_map;</span><br><span class="line">map_size = new_map_size;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//重新设定迭代器start和finish</span></span><br><span class="line">start.<span class="built_in">set_node</span>(new_nstart);</span><br><span class="line">finish.<span class="built_in">set_node</span>(new_nstart + old_num_nodes - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="deque的其它元素操作"><a href="#deque的其它元素操作" class="headerlink" title="deque的其它元素操作"></a>deque的其它元素操作</h4><p>pop_back()：重点在于关注是否需要切换缓冲区</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">pop_back</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(finish.cur != finish.first) &#123;<span class="comment">//最后缓冲区有一个（或更多）元素</span></span><br><span class="line">--finish.cur;</span><br><span class="line"><span class="comment">//调整指针，相当于排除了最后元素</span></span><br><span class="line"><span class="built_in">destroy</span>(finish.cur); <span class="comment">//将最后元素析构</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="comment">//最后缓冲区没有任何元素</span></span><br><span class="line"><span class="built_in">pop_back_aux</span>();             <span class="comment">//这里将进行缓冲区的释放工作</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//只有当finish.cur == finish.first时才会被调用</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Alloc</span>, <span class="type">size_t</span> Bufsize&gt;</span><br><span class="line"><span class="type">void</span> deque&lt;T, Alloc, Bufsize&gt;::<span class="built_in">pop_back_aux</span>() &#123;</span><br><span class="line"><span class="built_in">deallocate_node</span>(finish.first);<span class="comment">//释放最后一个缓冲区</span></span><br><span class="line">finish.<span class="built_in">set_node</span>(finish.node - <span class="number">1</span>); <span class="comment">//调整finish的状态，使指向</span></span><br><span class="line">finish.cur = finish.last - <span class="number">1</span>;  <span class="comment">//上一个缓冲区的最后一个元素</span></span><br><span class="line"><span class="built_in">destroy</span>(finish.cur); <span class="comment">//将该元素析构</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>clear():clear()完成之后需要恢复初始状态，而deque的初始状态（无任何元素时）保有一个缓冲区，因此，clear()之后也要保留一个缓冲区</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注意，最终需要保留一个缓冲区。这是deque的策略，也是deque的初始状态</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Alloc</span>, <span class="type">size_t</span> Bufsize&gt;</span><br><span class="line"><span class="type">void</span> deque&lt;T，Alloc, BufSize&gt;::<span class="built_in">clear</span>() &#123;</span><br><span class="line"><span class="comment">//以下针对头尾以外的每一个缓冲区（它们一定都是饱满的）</span></span><br><span class="line"><span class="keyword">for</span>(map_pointer node = start.node + <span class="number">1</span>; node &lt; finish.node; ++node) &#123;</span><br><span class="line">        <span class="comment">//将缓冲区内的所有元素析构。</span></span><br><span class="line"><span class="built_in">destroy</span>(*node, *node + <span class="built_in">buffer_size</span>());</span><br><span class="line"><span class="comment">//释放缓冲区内存</span></span><br><span class="line">data_allocator::<span class="built_in">deallocate</span>(*node, <span class="built_in">buffer_size</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span>(start.node != finish.node)&#123;<span class="comment">//至少有头尾两个缓冲区</span></span><br><span class="line"><span class="built_in">destroy</span>(start.cur, start.last); <span class="comment">//将头缓冲区的目前所有元素析构</span></span><br><span class="line"><span class="built_in">destroy</span>(finish.first, finish.cur); <span class="comment">//将尾缓冲区的目前所有元素析构</span></span><br><span class="line"><span class="comment">//以下释放尾缓冲区。注意，头缓冲区保留</span></span><br><span class="line">data_allocator::<span class="built_in">deallocate</span>(finish.first, <span class="built_in">buffer_size</span>());</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">else</span> <span class="comment">//只有一个缓冲区</span></span><br><span class="line"><span class="built_in">destroy</span>(start.cur, finish.cur); <span class="comment">//将此唯一缓冲区内的所有元素析构</span></span><br><span class="line"><span class="comment">//注意，并不释放缓冲区空间。这唯一的缓冲区将保留</span></span><br><span class="line">finish = start; <span class="comment">//调整状态</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>erase()和insert()：重点在于移动元素时根据前侧元素少还是后侧元素少来决定移动哪一段（移动更少元素的一端来获取最佳效率）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Alloc</span>, <span class="type">size_t</span> Bufsize&gt;</span><br><span class="line">deque&lt;T, Alloc, Bufsize&gt;::iterator</span><br><span class="line">deque&lt;T, Alloc, BufSize&gt;::<span class="built_in">erase</span>(iterator first, iterator last) &#123;</span><br><span class="line"><span class="keyword">if</span>(first == start &amp;&amp; last == finish)&#123; <span class="comment">//如果清除区间就是整个deque</span></span><br><span class="line"><span class="built_in">clear</span>();</span><br><span class="line"><span class="comment">//直接调用clear()即可</span></span><br><span class="line"><span class="keyword">return</span> finish;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">difference_type n = last - first;   <span class="comment">//清除区间的长度</span></span><br><span class="line">difference_type elems_before = first - start;<span class="comment">//清除区间前方的元素个数</span></span><br><span class="line"><span class="keyword">if</span>(elems_before &lt; (<span class="built_in">size</span>() - n) / <span class="number">2</span>) &#123; <span class="comment">//如果前方的元素比较少，</span></span><br><span class="line"><span class="built_in">copy_backward</span>(start, first, last);<span class="comment">//向后移动前方元素（覆盖清除区间)</span></span><br><span class="line">iterator new_start = start + n;   <span class="comment">//标记deque 的新起点</span></span><br><span class="line"><span class="built_in">destroy</span>(start, new_start);        <span class="comment">//移动完毕，将冗余的元素析构</span></span><br><span class="line"><span class="comment">//以下将冗余的缓冲区释放</span></span><br><span class="line"><span class="keyword">for</span>(map_pointer cur = start.node; cur &lt; new_start.node; ++cur)</span><br><span class="line">                data_allocator::<span class="built_in">deallocate</span>(*cur, <span class="built_in">buffer_size</span>());</span><br><span class="line">start = new_start;    <span class="comment">//设定deque 的新起点</span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="keyword">else</span> &#123;<span class="comment">//如果清除区间后方的元素比较少</span></span><br><span class="line"><span class="built_in">copy</span>(last, finish, first);   <span class="comment">//向前移动后方元素（覆盖清除区间)</span></span><br><span class="line">iterator new_finish = finish - n; <span class="comment">//标记deque的新尾点</span></span><br><span class="line"><span class="built_in">destroy</span>(new_finish, finish);     <span class="comment">//移动完毕，将冗余的元素析构</span></span><br><span class="line"><span class="comment">//以下将冗余的缓冲区释放</span></span><br><span class="line"><span class="keyword">for</span>(map_pointer cur = new_finish.node + <span class="number">1</span>; cur &lt;= finish.node; ++cur)</span><br><span class="line">data_allocator::<span class="built_in">deallocate</span>(*cur, <span class="built_in">buffer_size</span>());</span><br><span class="line">finish = new_finish; <span class="comment">//设定deque的新尾点</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> start + elems_before;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在position处插入一个元素，其值为x</span></span><br><span class="line"><span class="function">iterator <span class="title">insert</span><span class="params">(iterator position, <span class="type">const</span> value_type&amp; x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(position.cur == start.cur) &#123; <span class="comment">//如果插人点是deque最前端</span></span><br><span class="line"><span class="built_in">push_front</span>(x);              <span class="comment">//交给push_front去做</span></span><br><span class="line"><span class="keyword">return</span> start;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (position.cur == finish.cur) &#123; <span class="comment">//如果插人点是deque最尾端</span></span><br><span class="line"><span class="built_in">push_back</span>(x); <span class="comment">//交给push_back去做</span></span><br><span class="line">iterator tmp = finish;</span><br><span class="line">--tmp;</span><br><span class="line"><span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">insert_aux</span>(position, x);<span class="comment">//交给 insert_aux去做</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Alloc</span>, <span class="type">size_t</span> Bufsize&gt;</span><br><span class="line"><span class="keyword">typename</span> deque&lt;T, Alloc, Bufsize&gt;::iterator</span><br><span class="line">deque&lt;T, Alloc, BufSize&gt;::<span class="built_in">insert_aux</span>(iterator pos,<span class="type">const</span> value_type&amp; x) &#123;</span><br><span class="line">difference_type index = pos - start;   <span class="comment">//插人点之前的元素个数</span></span><br><span class="line">value_type x_copy = x;</span><br><span class="line"><span class="keyword">if</span> (index &lt; <span class="built_in">size</span>() / <span class="number">2</span>) &#123;    <span class="comment">//如果插人点之前的元素个数比较少</span></span><br><span class="line"><span class="built_in">push_front</span>(<span class="built_in">front</span>());     <span class="comment">//在最前端加人与第一元素同值的元素</span></span><br><span class="line">iterator front1 = start; <span class="comment">//以下标示记号，然后进行元素移动</span></span><br><span class="line">++front1;</span><br><span class="line">iterator front2 = front1;</span><br><span class="line">++front2;</span><br><span class="line">pos = start + index;</span><br><span class="line">iterator pos1 = pos;</span><br><span class="line">++pos1;</span><br><span class="line"><span class="built_in">copy</span>(front2, pos1, front1);   <span class="comment">//元素移动</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;                       <span class="comment">//插入点之后的元素个数比较少</span></span><br><span class="line"><span class="built_in">push_back</span>(/<span class="built_in">back</span>());     <span class="comment">//在最尾端加人与最后元素同值的元素</span></span><br><span class="line">iterator back1 = finish;     <span class="comment">//以下标示记号，然后进行元素移动</span></span><br><span class="line">--back1;</span><br><span class="line">iterator back2 = back1;</span><br><span class="line">--back2;</span><br><span class="line">pos = start + index;</span><br><span class="line"><span class="built_in">copy_backward</span>(pos, back2, back1);<span class="comment">//元素移动</span></span><br><span class="line">    &#125;</span><br><span class="line">*pos = x_copy; <span class="comment">//在插入点上设定新值</span></span><br><span class="line"><span class="keyword">return</span> pos;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="stack"><a href="#stack" class="headerlink" title="stack"></a>stack</h3><p>stack以既有容器deque为底部结构，在其封装上定义接口（封闭其前端的出入口），使之符合“先进后出”的特性即可。因此STL stack不是container，而是归类为container adapter。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">temp1ate &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Sequence</span> = deque&lt;T&gt; &gt;</span><br><span class="line"><span class="keyword">class</span> stack &#123;</span><br><span class="line"><span class="comment">//以下的__STL_NULL_TMPL_ARGS会开展为&lt;&gt;</span></span><br><span class="line"><span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span>== __STL_NULL_TMPL_ARGS(<span class="type">const</span> stack&amp;, <span class="type">const</span> stack&amp;);</span><br><span class="line"><span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span>&lt; __STL_NULL_TMPL_ARGS(<span class="type">const</span> stack&amp;, <span class="type">const</span> stack&amp;);</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">typename</span> Sequence::value_type value_type;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">typename</span> Sequence::size_type size_type;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">typename</span> Sequence::reference reference;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">typename</span> Sequence::const_reference const_reference;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">sequence c;         <span class="comment">//底层容器</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//以下完全利用Sequence c的操作，完成stack的操作</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> c.<span class="built_in">empty</span>(); &#125;</span><br><span class="line"><span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> c.<span class="built_in">size</span>(); &#125;</span><br><span class="line"><span class="function">reference <span class="title">top</span> <span class="params">()</span> </span>&#123; <span class="keyword">return</span> c.<span class="built_in">back</span>(); &#125;</span><br><span class="line"><span class="function">const_reference <span class="title">top</span> <span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> c.<span class="built_in">back</span>(); &#125;</span><br><span class="line"><span class="comment">//deque是两头可进出，stack 是末端进，末端出（所以后进者先出）。</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">const</span> value_type&amp; x)</span> </span>&#123; c.<span class="built_in">push_back</span>(x); &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123; c.<span class="built_in">pop_back</span>(); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">sequence</span>&gt;</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> stack&lt;T, Sequence&gt;&amp; x, <span class="type">const</span> stack&lt;T, Sequence&gt;&amp; y)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> x.c == y.c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">sequence</span>&gt;</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> stack&lt;T, Sequence&gt;&amp; x, <span class="type">const</span> stack&lt;T，Sequence&gt;&amp; y)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> x.c &lt; y.c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为stack必须符合“先进后出”的条件，只有顶端的元素才有机会被外界取用，因此不提供遍历功能，<strong>即不提供迭代器。</strong></p><p>同deque一样，list也是双向开口的数据结构，list也具备empty(),size(),push_back(),pop_back()等操作，因此list也可作为stack的底部结构。</p><h3 id="queue"><a href="#queue" class="headerlink" title="queue"></a>queue</h3><p>queue以既有容器deque为底部结构，在其封装上定义接口（封闭其底端的出口和前端的入口），使之符合“先进先出”的特性即可。因此STL queue不是container，而是归类为container adapter。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Sequence</span> = deque&lt;T&gt; &gt;</span><br><span class="line"><span class="keyword">class</span> queue &#123;</span><br><span class="line"><span class="comment">//以下的__STL_NULL_TMPL_ARGS会开展为&lt;&gt;</span></span><br><span class="line"><span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span>== __STL_NULL_TMPL_ARGS (<span class="type">const</span> queue&amp; x, <span class="type">const</span> queue&amp; y);</span><br><span class="line"><span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span>&lt; __STL_NULL_TMPL_ARGS (<span class="type">const</span> queue&amp; x, <span class="type">const</span> queue&amp; y);</span><br><span class="line"><span class="keyword">public</span> :</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">typename</span> sequence::value_type value_type;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">typename</span> sequence::size_type size_type;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">typename</span> Sequence::reference reference;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">typename</span> Sequence::const_reference const_reference;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">sequence c;<span class="comment">//底层容器</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//以下完全利用Sequence c的操作，完成queue的操作</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> c.<span class="built_in">empty</span>(); &#125;</span><br><span class="line"><span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> c.<span class="built_in">size</span>(); &#125;</span><br><span class="line"><span class="function">reference <span class="title">front</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> c.<span class="built_in">front</span>(); &#125;</span><br><span class="line"><span class="function">const_reference <span class="title">front</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> c.<span class="built_in">front</span>(); &#125;</span><br><span class="line"><span class="function">reference <span class="title">back</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> c.<span class="built_in">back</span>(); &#125;</span><br><span class="line"><span class="function">const_reference <span class="title">back</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> c.<span class="built_in">back</span>(); &#125;</span><br><span class="line"><span class="comment">//deque是两头可进出，queue 是末端进,前端出（所以先进者先出）</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">const</span> value_type&amp; x)</span> </span>&#123; c.<span class="built_in">push_back</span>(x); &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123; c.<span class="built_in">pop_front</span>(); &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>因为queue必须符合“先进先出”的条件，只有顶端的元素才有机会被外界取用，因此不提供遍历功能，<strong>即不提供迭代器。</strong></p><p>同deque一样，list也是双向开口的数据结构，list也具备empty(),size(),push_back(),pop_back()等操作，因此list也可作为queue的底部结构。</p><h3 id="heap"><a href="#heap" class="headerlink" title="heap"></a>heap</h3><p>heap并不属于STL容器组件，它是为了实现优先队列（priority queue）所需要的。优先队列允许用户以任何次序将任何元素推入容器内，但取出时一定是从优先权最高的元素开始取，而binary max heap具有这样的特性。</p><h4 id="使用binary-max-heap的原因"><a href="#使用binary-max-heap的原因" class="headerlink" title="使用binary max heap的原因"></a>使用binary max heap的原因</h4><p>list不适合做优先队列的底层：元素插入快，但找到极值需要线性扫描。</p><p>binary search tree不适合做优先队列的底层：插入和取极值都只需要O(logN)的表现，但是输入需要足够的随机性，而且实现复杂度较高。</p><p>而binary heap的复杂度介于queue和binary search tree之间，所以适合做优先队列的底层。binary heap是一种complete binary tree（完全二叉树），完全二叉树的优点在于可以利用array来储存所有节点。因此，我们只需要一个vector（一起动态性来取代array）和一组heap算法即可实现优先队列。</p><h4 id="max-heap和min-heap"><a href="#max-heap和min-heap" class="headerlink" title="max-heap和min-heap"></a>max-heap和min-heap</h4><p>根据元素排列方式，heap可分为max-heap和min-heap两种，前者每个节点的键值（key）都大于或等于其子节点键值，后者的每个节点键值（key）都小于或等于其子节点键值。因此， max-heap的最大值在根节点，并总是位于底层array或vector的起头处； min-heap的最小值在根节点，亦总是位于底层array或vector的起头处。STL供应的是max-heap，因此，以下说起heap时，指的是max-heap。</p><h4 id="heap算法"><a href="#heap算法" class="headerlink" title="heap算法"></a>heap算法</h4><h5 id="push-heap算法"><a href="#push-heap算法" class="headerlink" title="push_heap算法"></a>push_heap算法</h5><p><img src="/../img/push_heap%E7%AE%97%E6%B3%95.png" alt="push_heap"></p><p>为满足max-heap的条件，我们执行一个percolate up（上溯）程序：将新节点拿来与其父节点比较，如果其键值（key）比父节点大，就父子对换位置。如果一直上溯，直到不需对换或直到根节点为止。</p><p>算法细节：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">RandomAccessIterator</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">push_heap</span><span class="params">(RandomAccessIterator first,</span></span></span><br><span class="line"><span class="params"><span class="function">RandomAccessIterator last)</span> </span>&#123;</span><br><span class="line"><span class="comment">//注意，此函数被调用时，新元素应已置于底部容器的最尾端</span></span><br><span class="line">__push_heap_aux(first, last, <span class="built_in">distance_type</span>(first),</span><br><span class="line"><span class="built_in">value_type</span>(first));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">RandomAccessIterator</span>, <span class="keyword">class</span> <span class="title class_">Distance</span>, <span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="type">void</span> __push_heap_aux(RandomAccessIterator first,</span><br><span class="line">RandomAccessIterator last, Distance*, T*) &#123;</span><br><span class="line">__push_heap(first, <span class="built_in">Distance</span>((last - first) - <span class="number">1</span>), <span class="built_in">Distance</span>(<span class="number">0</span>),</span><br><span class="line"><span class="built_in">T</span>(*(last - <span class="number">1</span>)));</span><br><span class="line"><span class="comment">//以上系根据implicit representation heap 的结构特性:新值必置于底部</span></span><br><span class="line"><span class="comment">//容器的最尾端，此即第一个洞号:(last-first)-1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//以下这组push_back()不允许指定“大小比较标准”</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">RandomAccessIterator</span>, <span class="keyword">class</span> <span class="title class_">Distance</span>, <span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> __push_heap(RandomAccessIterator first, Distance holeIndex,</span><br><span class="line">Distance topIndex, T value) &#123;</span><br><span class="line">Distance parent = (holeIndex - <span class="number">1</span>) / <span class="number">2</span>; <span class="comment">//找出父节点</span></span><br><span class="line"><span class="keyword">while</span> (holeIndex &gt; topIndex &amp;&amp; *(first + parent) &lt; value) &#123;</span><br><span class="line"><span class="comment">//当尚未到达顶端，且父节点小于新值（于是不符合heap 的次序特性)</span></span><br><span class="line"><span class="comment">//由于以上使用operator&lt;，可知STL heap是一种max-heap(大者为父）。</span></span><br><span class="line">*(first + holeindex) = *(first + parent); <span class="comment">//令洞值为父值</span></span><br><span class="line">holeIndex = parent; <span class="comment">//percolate up:调整洞号，向上提升至父节点</span></span><br><span class="line">parent = (holeIndex - <span class="number">1</span>) / <span class="number">2</span>;    <span class="comment">//新洞的父节点</span></span><br><span class="line">&#125;<span class="comment">//持续至顶端，或满足heap的次序特性为止</span></span><br><span class="line">*(first + holeIndex) = value; <span class="comment">//令洞值为新值，完成插人操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="pop-heap算法"><a href="#pop-heap算法" class="headerlink" title="pop_heap算法"></a>pop_heap算法</h5><p><img src="/../img/pop_heap%E7%AE%97%E6%B3%95.png" alt="pop_heap"></p><p>pop操作取走根节点（最大值）后，为了满足完全二叉树的条件，必须将最下一层最右边的叶节点拿掉，并执行percolate down（下溯）程序来为这个节点找一个适当的位置：将根节点（最大值被取走后，形成一个“洞”）填人上述那个失去生存空间的叶节点值，再将它拿来和其两个子节点比较键值（key)，并与较大子节点对调位置。如此一直下放，直到这个“洞”的键值大于左右两个子节点，或直到下放至叶节点为止。</p><p>算法细节：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">RandomAccessIterator</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">pop_heap</span><span class="params">(RandomAccessIterator first,</span></span></span><br><span class="line"><span class="params"><span class="function">RandomAccessIterator last)</span> </span>&#123;</span><br><span class="line">__pop_heap_aux(first, last, <span class="built_in">value_type</span>(first)); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">RandomAccessIterator</span>, <span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="type">void</span> __pop_heap_aux(RandomAccessIterator first,</span><br><span class="line">RandomAccessIterator last, T*) &#123;</span><br><span class="line">__pop_heap(first, last<span class="number">-1</span>, last<span class="number">-1</span>, <span class="built_in">T</span>(*(last<span class="number">-1</span>))，</span><br><span class="line"><span class="built_in">distance_type</span>(first));</span><br><span class="line"><span class="comment">//以上，根据implicit representation heap的次序特性，pop操作的结果</span></span><br><span class="line"><span class="comment">//应为底部容器的第一个元素。因此，首先设定欲调整值为尾值，然后将首值调至</span></span><br><span class="line"><span class="comment">//尾节点（所以以上将迭代器result设为last-1)。然后重整[first, last-1) ,</span></span><br><span class="line"><span class="comment">//使之重新成一个合格的heap</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//以下这组__pop_heap ()不允许指定“大小比较标准”</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">RandomAccessIterator</span>, <span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Distance</span>&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="type">void</span> __pop_heap(RandomAccessIterator first,</span><br><span class="line"> RandomAccessIterator last,</span><br><span class="line">                       RandomAccessIterator result,</span><br><span class="line">                       T value, Distance*) &#123;</span><br><span class="line">*result = *first; <span class="comment">//设定尾值为首值，于是尾值即为欲求结果，</span></span><br><span class="line">     <span class="comment">//可由客户端稍后再以底层容器之pop_back()取出尾值</span></span><br><span class="line">__adjust_heap(first, <span class="built_in">Distance</span>(<span class="number">0</span>), <span class="built_in">Distance</span>(last - first), value);</span><br><span class="line">    <span class="comment">//以上欲重新调整 heap，洞号为0（亦即树根处），欲调整值为 value（原尾值)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//以下这个__adjust_heap()不允许指定“大小比较标准”</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">RandomAccessIterator</span>, <span class="keyword">class</span> <span class="title class_">Distance</span>, <span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> __adjust_heap(RandomAccessIterator first, Distance holeIndex, </span><br><span class="line">Distance len, T value) &#123;</span><br><span class="line">Distance topIndex = holeIndex;</span><br><span class="line">Distance secondchild = <span class="number">2</span> * holeIndex + <span class="number">2</span>;  <span class="comment">//洞节点之右子节点</span></span><br><span class="line"><span class="keyword">while</span> (secondChild &lt; len) &#123;</span><br><span class="line"><span class="comment">//比较洞节点之左右两个子值，然后以secondChild代表较大子节点</span></span><br><span class="line"><span class="keyword">if</span> (*(first + secondchild) &lt; *(first + (secondChild - <span class="number">1</span>)))</span><br><span class="line">secondChild--;</span><br><span class="line"><span class="comment">//Percolate down:令较大子值为洞值，再令洞号下移至较大子节点处</span></span><br><span class="line">*(first + holeIndex) = *(first + secondChild);</span><br><span class="line">holeindex = secondchild;</span><br><span class="line"><span class="comment">//找出新洞节点的右子节点</span></span><br><span class="line">secondChild = <span class="number">2</span> * ( secondChild + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">if</span>(secondchild == len) &#123; <span class="comment">//没有右子节点，只有左子节点</span></span><br><span class="line"><span class="comment">//Percolate down:令左子值为洞值，再令洞号下移至左子节点处。</span></span><br><span class="line">*(first + holeIndex) = *(first + (secondChild - <span class="number">1</span>));</span><br><span class="line">holeIndex = secondChild - l;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//将欲调整值填入目前的洞号内。注意，此时肯定满足次序特性</span></span><br><span class="line">__push_heap(first, holeIndex, topIndex, value) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>pop_heap之后，最大元素只是被置放于底部容器的最尾端，尚未被取走。</p><h5 id="sort-heap算法"><a href="#sort-heap算法" class="headerlink" title="sort_heap算法"></a>sort_heap算法</h5><p>既然每次pop_heap操作都可以把heap中键值最大的元素调整到尾部，那么如果持续pop_heap，并在每次pop_heap之后将操作范围从后向前缩减一个元素，这样整个程序结束之后就可以得到一个递增序列。</p><p>算法实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//以下这个sort_heap()不允许指定“大小比较标准”</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">RandomAccessIterator</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sort_heap</span><span class="params">(RandomAccessIterator first,</span></span></span><br><span class="line"><span class="params"><span class="function">  RandomAccessIterator last)</span> </span>&#123;</span><br><span class="line"><span class="comment">//以下，每执行一次pop_heap()，极值（在STL heap中为极大值）即被放在尾端。</span></span><br><span class="line"><span class="comment">//扣除尾端再执行一次pop_heap()，次极值又被放在新尾端。一直下去，最后即得</span></span><br><span class="line"><span class="comment">//排序结果</span></span><br><span class="line"><span class="keyword">while</span>(last - first &gt; <span class="number">1</span>)</span><br><span class="line"><span class="built_in">pop_heap</span>(first, last--); <span class="comment">//每执行pop_heap()一次，操作范围即退缩一格</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="make-heap算法"><a href="#make-heap算法" class="headerlink" title="make_heap算法"></a>make_heap算法</h5><p>这个算法讲一段现有的数据转化为一个heap</p><p>算法实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将[first, last)排列为一个heap</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">RandomAccessIterator</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">make_heap</span><span class="params">(RandomAccessIterator first,</span></span></span><br><span class="line"><span class="params"><span class="function">RandomAccessIterator last)</span> </span>&#123;</span><br><span class="line">__make_heap(first, last, <span class="built_in">value_type</span>(first), <span class="built_in">distance_type</span>(first));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//以下这组make_heap()不允许指定“大小比较标准”</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">RandomAccessIterator</span>,<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Distance</span>&gt;</span><br><span class="line"><span class="type">void</span> __make_heap(RandomAccessIterator first,</span><br><span class="line">    RandomAccessIterator last, T*, Distance*) &#123;</span><br><span class="line"><span class="keyword">if</span>(last - first &lt; <span class="number">2</span>) <span class="keyword">return</span>; <span class="comment">//如果长度为0或1，不必重新排列</span></span><br><span class="line">Distance len = last - first;</span><br><span class="line"><span class="comment">//找出第一个需要重排的子树头部，以parent标示出。由于任何叶节点都不需执行</span></span><br><span class="line"><span class="comment">//perlocate down，所以有以下计算。parent命名不佳，名为holeIndex更好</span></span><br><span class="line">Distance parent = (len - <span class="number">2</span>) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line"><span class="comment">//重排以parent为首的子树。len是为了让_adjust_heap()判断操作范</span></span><br><span class="line">__adjust_heap(first, parent, len, <span class="built_in">T</span>(*(first + parent)));</span><br><span class="line"><span class="keyword">if</span> (parent == <span class="number">0</span>) <span class="keyword">return</span>;       <span class="comment">//走完根节点，就结束</span></span><br><span class="line">parent--;     <span class="comment">//（即将重排之子树的）头部向前一个节点</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="heap的迭代器"><a href="#heap的迭代器" class="headerlink" title="heap的迭代器"></a>heap的迭代器</h4><p>heap不提供遍历功能，不提供迭代器。</p><h3 id="priority-queue"><a href="#priority-queue" class="headerlink" title="priority queue"></a>priority queue</h3><p>priority可以看作一个拥有权值观念的queue，同样是只允许在底端加入元素，并从顶端取出元素，但元素并非依照被推入的次序排列，而是自动依照元素的权值排列。因此缺省情况下priority queue利用一个max heap完成。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Sequence</span> = vector&lt;T&gt;,</span><br><span class="line"><span class="keyword">class</span> Compare = less&lt;<span class="keyword">typename</span> Sequence::value_type&gt; &gt;</span><br><span class="line"><span class="keyword">class</span> priority_queue &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">typename</span> Sequence::value_type value_type;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">typename</span> Sequence::size_type size_type;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">typename</span> Sequence::reference reference;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">typename</span> Sequence::const_reference const_reterence;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">Sequence c;     <span class="comment">//底层容器</span></span><br><span class="line">Compare comp;   <span class="comment">//元素大小比较标准</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">priority_queue</span>() : <span class="built_in">c</span>() &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">priority_queue</span><span class="params">(<span class="type">const</span> Compare&amp; x)</span> : c(), comp(x) &#123;</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//以下用到的make_heap(), push_heap(), pop_heap()都是泛型算法</span></span><br><span class="line"><span class="comment">//注意，任一个构造函数都立刻于底层容器内产生一个implicit representation heap</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>&gt;</span><br><span class="line"><span class="built_in">priority_queue</span>(InputIterator first, InputIterator last, <span class="type">const</span> Compare&amp; x) : <span class="built_in">c</span>(first,last), <span class="built_in">comp</span>(x) &#123; <span class="built_in">make_heap</span>(c.<span class="built_in">begin</span>(), c.<span class="built_in">end</span>(), comp); &#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>&gt;</span><br><span class="line"><span class="built_in">priority_queue</span>(InputIterator first, InputIterator last) : <span class="built_in">c</span> (first, last) &#123; <span class="built_in">make_heap</span>(c.<span class="built_in">begin</span>(), c.<span class="built_in">end</span>(), comp); &#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> c.<span class="built_in">empty</span>(); &#125;</span><br><span class="line"><span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> c.<span class="built_in">size</span>(); &#125;</span><br><span class="line"><span class="function">const_reference <span class="title">top</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> c.<span class="built_in">front</span>(); &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push</span> <span class="params">(<span class="type">const</span> value_type&amp; x)</span> </span>&#123;</span><br><span class="line">__STL_TRY &#123;</span><br><span class="line"><span class="comment">//push_heap是泛型算法，先利用底层容器的push_back()将新元素</span></span><br><span class="line"><span class="comment">//推人末端，再重排heap。</span></span><br><span class="line">c.<span class="built_in">push_back</span>(x);</span><br><span class="line"><span class="built_in">push_heap</span>(c.<span class="built_in">begin</span>(), c.<span class="built_in">end</span>(), comp); <span class="comment">//push_heap是泛型算法</span></span><br><span class="line">        &#125;</span><br><span class="line">__STL_UNWIND(c.<span class="built_in">clear</span>());</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">__STL_TRY &#123;</span><br><span class="line"><span class="comment">//pop_heap 是泛型算法，从heap内取出一个元素。它并不是真正将元素</span></span><br><span class="line"><span class="comment">//弹出，而是重排heap，然后再以底层容器的pop_back()取得被弹出</span></span><br><span class="line"><span class="comment">//的元素。</span></span><br><span class="line"><span class="built_in">pop_heap</span>(c.<span class="built_in">begin</span>(), c.<span class="built_in">end</span>(), comp);</span><br><span class="line">c.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">__STL_UNWTND(c.<span class="built_in">clear</span>()); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="priority的迭代器"><a href="#priority的迭代器" class="headerlink" title="priority的迭代器"></a>priority的迭代器</h4><p>priority不提供遍历功能，没有迭代器。</p><h3 id="slist"><a href="#slist" class="headerlink" title="slist"></a>slist</h3><p>slist是一个单项列表，不同于list的是，list的迭代器属于双向的Bidirectional Iterator，而slist的迭代器属于单向的Forward Iterator。因此，slist显然功能有更多限制但同时耗用的空间更小。</p><p><strong>注意</strong>，根据STL的习惯，插人操作会将新元素插入于指定位置之前，而非之后。然而作为一个单向链表, slist没有任何方便的办法可以回头定出前一个位置，因此它必须从头找起。换句话说，除了slist起点处附近的区域之外，在其它位置上采用insert或erase操作函数，都属不智之举。这便是slist相较于list之下的大缺点。为此，slist特别提供了insert_after()和 erase_after ()供灵活运用。基于同样的(效率)考虑，slist不提供push_back()，只提供push_front()。因此slist的元素次序会和元素插人进来的次序相反。</p><h4 id="slist的节点"><a href="#slist的节点" class="headerlink" title="slist的节点"></a>slist的节点</h4><p><img src="/../img/slist%E8%8A%82%E7%82%B9%E8%AE%BE%E8%AE%A1%E6%9E%B6%E6%9E%84.png" alt="slist节点设计架构"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//单向链表的节点基本结构</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__slist_node_base</span></span><br><span class="line">&#123;</span><br><span class="line">__slist_node_base* next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//单向链表的节点结构</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__slist_node</span> : <span class="keyword">public</span> __slist_node_base</span><br><span class="line">&#123;</span><br><span class="line">    T data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//全局函数:已知某一节点，插入新节点于其后</span></span><br><span class="line"><span class="keyword">inline</span> __slist_node_base* __slist_make_link (</span><br><span class="line">__slist_node_base* prev_node,</span><br><span class="line">__slist_node_base* new_node)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//令new节点的下一节点为prev节点的下一节点</span></span><br><span class="line">new_node-&gt;next = prev_node-&gt;next;</span><br><span class="line">prev_node-&gt;next = new_node;<span class="comment">//令prev节点的下一节点指向new节点</span></span><br><span class="line"><span class="keyword">return</span> new_node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//全局函数:单向链表的大小（元素个数）</span></span><br><span class="line"><span class="keyword">inline</span> <span class="type">size_t</span> __slist_size(__slist_node_base* node)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">size_t</span> result = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> ( ; node != <span class="number">0</span>; node = node-&gt;next)</span><br><span class="line">        ++result;    <span class="comment">//一个一个累计</span></span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="slist的数据结构"><a href="#slist的数据结构" class="headerlink" title="slist的数据结构"></a>slist的数据结构</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Alloc</span> = alloc&gt;</span><br><span class="line"><span class="keyword">class</span> slist</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    list_node_base head; <span class="comment">//虚拟头部</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">slist</span>() &#123; head.next = <span class="number">0</span>; &#125;</span><br><span class="line">    ~<span class="built_in">slist</span>() &#123; <span class="built_in">clear</span>(); &#125;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Iterator <span class="title">begin</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">iterator</span>((list_node*)head.next); &#125;</span><br><span class="line">    <span class="function">Iterator <span class="title">end</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">iterator</span>(<span class="number">0</span>); &#125;  <span class="comment">//构造一个指向空节点的</span></span><br><span class="line">    <span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> __slist_size(head.next); &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> head.next == <span class="number">0</span>; &#125;</span><br><span class="line">    <span class="comment">//两个slist互换：只要将head交换互指即可</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">swap</span> <span class="params">(slist&amp; L)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            list_node_base* tmp = head.next;</span><br><span class="line">            head.next = L.head.next;</span><br><span class="line">            L.head.next = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;STL源码剖析&gt;第四章读书笔记，关于顺序容器的源码剖析</summary>
    
    
    
    <category term="STL源码剖析读书笔记" scheme="http://example.com/categories/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="STL" scheme="http://example.com/tags/STL/"/>
    
    <category term="STL源码剖析" scheme="http://example.com/tags/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"/>
    
    <category term="容器" scheme="http://example.com/tags/%E5%AE%B9%E5%99%A8/"/>
    
    <category term="序列式容器" scheme="http://example.com/tags/%E5%BA%8F%E5%88%97%E5%BC%8F%E5%AE%B9%E5%99%A8/"/>
    
    <category term="vector" scheme="http://example.com/tags/vector/"/>
    
    <category term="list" scheme="http://example.com/tags/list/"/>
    
    <category term="deque" scheme="http://example.com/tags/deque/"/>
    
    <category term="stack" scheme="http://example.com/tags/stack/"/>
    
    <category term="queue" scheme="http://example.com/tags/queue/"/>
    
    <category term="heap" scheme="http://example.com/tags/heap/"/>
    
    <category term="priority queue" scheme="http://example.com/tags/priority-queue/"/>
    
    <category term="slist" scheme="http://example.com/tags/slist/"/>
    
  </entry>
  
  <entry>
    <title>&lt;STL源码剖析&gt;第三章</title>
    <link href="http://example.com/2022/03/23/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E7%AC%AC%E4%B8%89%E7%AB%A0/"/>
    <id>http://example.com/2022/03/23/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E7%AC%AC%E4%B8%89%E7%AB%A0/</id>
    <published>2022-03-22T16:00:00.000Z</published>
    <updated>2022-03-23T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="迭代器（iterator）"><a href="#迭代器（iterator）" class="headerlink" title="迭代器（iterator）"></a>迭代器（iterator）</h2><p>《Design Patterns》中的iterator模式定义：提供一种方法，使之能够依序巡防某个聚合物（容器）所含的各个元素，而又无需暴露该聚合物的内部表述方式。</p><h3 id="迭代器——STL关键所在"><a href="#迭代器——STL关键所在" class="headerlink" title="迭代器——STL关键所在"></a>迭代器——STL关键所在</h3><p>​STL的中心思想在于：将数据容器（containers）和算法（algorithms）分开，彼此独立设计，最后再以一种胶着剂将两者撮合在一起，而迭代器（iterator）就扮演者这个胶着剂的角色。</p><h3 id="迭代器是一种smart-pointer"><a href="#迭代器是一种smart-pointer" class="headerlink" title="迭代器是一种smart pointer"></a>迭代器是一种smart pointer</h3><p>迭代器是一种行为类似指针的对象，而指针最重要的行为便是dereference和member access，因此迭代器最重要的编程工作就是对operator*和operator-&gt;进行重载工作。</p><p><strong>为什么每一种STL容器都提供有专属迭代器?</strong></p><p>要设计容器的迭代器，首先必须对容器的实现细节有非常丰富的了解，比如：重载operator++时需要了解容器的next()指向哪里。那么干脆就把迭代器的开放工作交给容器的设计者从而封装容器的实现细节。</p><h3 id="迭代器相应类型（associated-types）和Traits编程技法"><a href="#迭代器相应类型（associated-types）和Traits编程技法" class="headerlink" title="迭代器相应类型（associated types）和Traits编程技法"></a>迭代器相应类型（associated types）和Traits编程技法</h3><p>在算法中使用迭代器时，会用到其相应类型，比如其中之一的“迭代器所指对象的类型”（value type），那么如何获取这个类型呢？由于C++不支持typeof()，我们需要一些技巧来获取这些相应类型用来声明变量。</p><h4 id="技巧一：利用function-template的参数推导（argument-deducation）机制获得value-type"><a href="#技巧一：利用function-template的参数推导（argument-deducation）机制获得value-type" class="headerlink" title="技巧一：利用function template的参数推导（argument deducation）机制获得value type"></a>技巧一：利用function template的参数推导（argument deducation）机制获得value type</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">I</span>, <span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func_impl</span><span class="params">(I iter, T t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">T tmp; <span class="comment">//这里解决了问题。T就是迭代器所指之物的型别，本例为int</span></span><br><span class="line"><span class="comment">// ...这里做原本func()应该做的全部工作</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">I</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">func</span><span class="params">(I iter)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">func_impl</span>(iter,*iter);    <span class="comment">//func的工作全部移往func_impl()</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="built_in">func</span>(&amp;i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里以func()为对外接口，却把实际操作放在func_impl中，通过调用func_impl()让编译器自动进行template参数推导来获得value type。</p><p>然而，并非所有相应类型都可以用template参数推导机制来获得，这时候就需要更全面的解法。</p><h4 id="技巧二：在迭代器内声明内嵌类型"><a href="#技巧二：在迭代器内声明内嵌类型" class="headerlink" title="技巧二：在迭代器内声明内嵌类型"></a>技巧二：在迭代器内声明内嵌类型</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MyIter</span> &#123;</span><br><span class="line"><span class="keyword">typedef</span> T value_type;    <span class="comment">//内嵌型别声明(nested type)</span></span><br><span class="line">T* ptr;</span><br><span class="line"><span class="built_in">MyIter</span>(T* p=<span class="number">0</span>) : <span class="built_in">ptr</span>(p) &#123; &#125;</span><br><span class="line">T&amp; <span class="keyword">operator</span>*() <span class="type">const</span> &#123; <span class="keyword">return</span> *ptr; &#125;  </span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">I</span>&gt;</span><br><span class="line"><span class="keyword">typename</span> I::value-type <span class="comment">//这一整行是func的回返值型别</span></span><br><span class="line"><span class="built_in">func</span>(I ite)</span><br><span class="line">&#123; <span class="keyword">return</span> *ite; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="function">MyIter&lt;<span class="type">int</span>&gt; <span class="title">ite</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">8</span>))</span></span>;</span><br><span class="line">cout &lt;&lt; <span class="built_in">func</span>(ite);       <span class="comment">//输出:8</span></span><br></pre></td></tr></table></figure><p>template参数推到机制只能用在方法模板的参数上，但对于方法的返回值就无可奈何，此时用在迭代器内声明内嵌类型的方法即可在需要的位置使用相应类型。</p><p>然而，并非所有原生迭代器都是class type，例如原生指针。此时便无法为其声明内嵌类型，但是原生指针作为一种迭代器是STL以及整个泛性思维所要求的，此时需要一种可以应用于原生指针同时适用于原来迭代器的机制。</p><h4 id="偏特化（partial-Specialization）"><a href="#偏特化（partial-Specialization）" class="headerlink" title="偏特化（partial Specialization）"></a>偏特化（partial Specialization）</h4><p>偏特化指针对（任何）template参数更进一步限制所设计出来的一个特化版本。</p><p>之前由于原生指针并非class type而无法为他们定义内嵌类型，而有了偏特化，我们就可以为原生指针设计特化版的迭代器：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">I</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">iterator_traits</span> &#123;  <span class="comment">//traits意为“特性”</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> I::value_type value_type;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">iterator_traits</span>&lt;T*&gt; &#123;  <span class="comment">//偏特化版——迭代器是个原生指针</span></span><br><span class="line">    <span class="keyword">typedef</span> T value_type;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">iterator_traits</span>&lt;<span class="type">const</span> T*&gt; &#123;<span class="comment">//偏特化版——当迭代器是个pointer-to-const时，</span></span><br><span class="line"><span class="keyword">typedef</span> T value_type;         <span class="comment">//萃取出来的型别应该是T而非const T</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>注意，以上代码用到了<strong>traits</strong>，通过配合偏特化机制（for 原生指针）可以萃取到各种迭代器的相应类型，同时，为了配合这个traits，应用于STL的迭代器必须自行定义内嵌类型来表示自己的相应类型。</p><p><img src="/../img/traits%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%89%B9%E6%80%A7.png"></p><h4 id="迭代器的五个相应类型"><a href="#迭代器的五个相应类型" class="headerlink" title="迭代器的五个相应类型"></a>迭代器的五个相应类型</h4><table><thead><tr><th align="left">迭代器相应类型</th><th align="center">说明（以类型T为例）</th></tr></thead><tbody><tr><td align="left">value type</td><td align="center">指迭代器所指对象类型（T）</td></tr><tr><td align="left">difference type</td><td align="center">指两个迭代器之间的距离，因此也可以表示容器的最大容量，原生指针使用内置的ptrdiff_t作为difference type</td></tr><tr><td align="left">reference type</td><td align="center">对于mutable iterators，operator*获取的应该是一个左值（可赋值），因此，对于mutable iter，*iter应返回T&amp;，对于constant iter，*iter应返回const T&amp;。（T&amp;,const T&amp;）</td></tr><tr><td align="left">pointer type</td><td align="center">类似于reference type(T*,const T* )</td></tr><tr><td align="left">iterator_category</td><td align="center">迭代器类型，原生指针的迭代器类型为random access iterator</td></tr></tbody></table><h3 id="五类迭代器"><a href="#五类迭代器" class="headerlink" title="五类迭代器"></a>五类迭代器</h3><p>根据移动特性与施行操作，迭代器被分为五类：</p><table><thead><tr><th>迭代器类型</th><th align="center">说明</th></tr></thead><tbody><tr><td>Input Iterator</td><td align="center">这种迭代器所指的对象，不允许外界改变，只读(read only)</td></tr><tr><td>Output Iterator</td><td align="center">只写(write only)</td></tr><tr><td>Forward Iterator</td><td align="center">允许“写入型”算法（例如replace()）在此种迭代器所形成的区间上进行读写操作</td></tr><tr><td>Bidirectional Iterator</td><td align="center">可双向移动，某些算法需要逆向走访某个迭代器区间（例如逆向拷贝某范围内的元素），可以使用Bidirectional Iterators</td></tr><tr><td>Random Access Iterator</td><td align="center">前四种迭代器都只供应一部分指针算术能力（前三种支持operator++，第四种再加上 operator–)，第五种则涵盖所有指针算术能力，包括 p+n, p-n，p[n]， p1 - p2， p1 &lt; p2</td></tr></tbody></table><p>迭代器间的关系体现在代码继承上：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//节录自SGr STL &lt;stl_iterator.h&gt;//五种迭代器类型</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">input_iterator_tag</span> &#123; &#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">output_iterator_tag</span> &#123; &#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">forward_iterator_tag</span> : <span class="keyword">public</span> input_iterator_tag &#123; &#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">bidirectional_iterator_tag</span> : <span class="keyword">public</span> forward_iterator_tag &#123; &#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">random_access_iterator_tag</span> : <span class="keyword">public</span> bidirectional_iterator_tag &#123; &#125;;</span><br></pre></td></tr></table></figure><p><img src="/../img/%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%88%86%E7%B1%BB.png" alt="迭代器分类"></p><p>设计算法时，需要为各个类型的迭代器各自设计一个函数来获得最佳效率，此时迭代器的相应类型iterator_category即可帮助编译器做函数的重载决定（以distance(为例)）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>&gt;  <span class="comment">//以算法能接受最初级类型作为template参数</span></span><br><span class="line"><span class="keyword">inline</span> iterator traits&lt;InputIterator&gt;::difference_type    <span class="comment">//迭代器类型之间存在继承关系</span></span><br><span class="line">__distance(InputIterator first, InputIterator last,</span><br><span class="line">input_iterator_tag) &#123;</span><br><span class="line">iterator_traits&lt;InputIterator&gt;::difference_type n = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//逐一累计距离</span></span><br><span class="line"><span class="keyword">while</span> (first != last) &#123;</span><br><span class="line">++first; ++n;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">RandomAccessIterator</span>&gt;</span><br><span class="line"><span class="keyword">inline</span> iterator traits&lt;RandomAccessIterator&gt;::difference_type</span><br><span class="line">__distance (RandomAccessIterator first,RandomAccessIterator last,</span><br><span class="line">random_access_iterator_tag)&#123;</span><br><span class="line"><span class="comment">//直接计算差距</span></span><br><span class="line"><span class="keyword">return</span> last - first;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>&gt;</span><br><span class="line"><span class="keyword">inline</span> iterator_traits&lt;InputIterator&gt;::<span class="function">difference_type</span></span><br><span class="line"><span class="function"><span class="title">distance</span><span class="params">(InputIterator first,InputTterator last)</span> </span>&#123;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">typename</span> iterator_traits&lt;InputIterator::iterator_category category;</span><br><span class="line"><span class="keyword">return</span> _distance(first, last, <span class="built_in">category</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="std-iterator"><a href="#std-iterator" class="headerlink" title="std::iterator"></a>std::iterator</h4><p>STL提供了一个iterator class，如果每个新设计的迭代器都继承自他，就可以保证符合STL所需之规范：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">category</span>,</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">T</span>,</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Distance</span> = <span class="type">ptrdiff_t</span>,</span><br><span class="line"><span class="keyword">class</span> Pointer = T*,</span><br><span class="line"><span class="keyword">class</span> Reference = T&amp;&gt;</span><br><span class="line"><span class="keyword">struct</span> iterator &#123;</span><br><span class="line"><span class="keyword">typedef</span> Category iterator_category;</span><br><span class="line"><span class="keyword">typedef</span> T value_type;</span><br><span class="line"><span class="keyword">typedef</span> Distance difference_type;</span><br><span class="line"><span class="keyword">typedef</span> Pointer pointer;</span><br><span class="line"><span class="keyword">typedef</span> Reference reference;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>​设计适当的相应类型(associated types），是迭代器的责任。设计适当的迭代器，则是容器的责任。唯容器本身，才知道该设计出怎样的迭代器来遍历自己，并执行迭代器该有的各种行为（前进、后退、取值、取用成员…)。至于算法，完全可以独立于容器和迭代器之外自行发展，只要设计时以迭代器为对外接口就行。<br>​traits 编程技法大量运用于STL实现品中。它利用“内嵌类型”的编程技巧与编译器的template参数推导功能，增强C++未能提供的关于类型认证方面的能力，弥补C++不为强类型（strong typed）语言的遗憾。了解traits编程技法，就像获得“芝麻开门”的口诀一样，从此得以一窥STL源代码堂奥。</p><h2 id="type-traits"><a href="#type-traits" class="headerlink" title="__type_traits"></a>__type_traits</h2><p>iterator_traits负责萃取迭代器的特性，__type_traits则负责萃取类型（type）的特性。类型的特性具体是指:</p><ol><li>type是否具备non-trivial default ctor</li><li>type是否具备non-trivial copy ctor</li><li>type是否具备non-trivial assignment operator</li><li>type是否具备non-trivial dtor</li><li>type是否是POD（Plain Old Data）</li></ol><h4 id="为什么要关注这些特性？"><a href="#为什么要关注这些特性？" class="headerlink" title="为什么要关注这些特性？"></a>为什么要关注这些特性？</h4><p>当type不具备这些特性时，我们就可以在对这些类型进行构造、析构、拷贝、赋值等操作时，采取最有效率的措施——根本不调用无意义的constructor或者destructor，而是采用直接处理内存的操作如malloc()、memcpy()等等。这对于大规模而操作频繁的容器，有着显著的效率提升。</p><h4 id="type-traits的响应值"><a href="#type-traits的响应值" class="headerlink" title="__type_traits的响应值"></a>__type_traits的响应值</h4><p>假设程序想要知道某个类型T是否具备trivial default cotr时，通过调用__type_triats<T>::has_trivial_default_constructor即可获得结果，而该结果的响应值不应该只是个bool值（true or false），他应该是个类型，这样我们才可以使用该响应值来进行参数推导。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">__true_type</span> &#123; &#125;;       </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__false_type</span> &#123; &#125;;</span><br></pre></td></tr></table></figure><h4 id="SGI内的-type-traits"><a href="#SGI内的-type-traits" class="headerlink" title="SGI内的__type_traits"></a>SGI内的__type_traits</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">type</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__type_traits</span> &#123;</span><br><span class="line"><span class="keyword">typedef</span> __true_type this_dummy_member_must_be_first;</span><br><span class="line"><span class="comment">/*不要移除这个成员。它通知“有能力自动将__type_traits特化”的编译器说，我们现在所看到的这个__type_traits template是特殊的。这是为了确保万一编译器也使用一 个名为__type_traits而其实与此处定义并无任何关联的template时，所有事情都仍将  顺利运作*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*以下条件应被遵守，因为编译器有可能自动为各型别产生专属的__type_traits特化版本:</span></span><br><span class="line"><span class="comment">-你可以重新排列以下的成员次序</span></span><br><span class="line"><span class="comment">-你可以移除以下任何成员</span></span><br><span class="line"><span class="comment">-绝对不可以将以下成员重新命名而却没有改变编译器中的对应名称</span></span><br><span class="line"><span class="comment">-新加入的成员会被视为一般成员，除非你在编译器中加上适当支持*/</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">typedef</span> __false_type has_trivial_default_constructor;</span><br><span class="line"><span class="keyword">typedef</span> __false_type has_trivial_copy_constructor;</span><br><span class="line"><span class="keyword">typedef</span> __false_type has_trivial_assignment_operator;</span><br><span class="line"><span class="keyword">typedef</span> __false_type has_trivial_destructor;</span><br><span class="line"><span class="keyword">typedef</span> __false_type is_POD_type;</span><br><span class="line">&#125; ;</span><br></pre></td></tr></table></figure><p>此处将所有参数的默认值设置为__false_type是因为SGI定义了最保守的值，然后再针对每个标量类型（scalar types）设计特化的版本。</p>]]></content>
    
    
    <summary type="html">&lt;STL源码剖析&gt;第三章读书笔记，迭代器以及萃取器技巧(__type_traits)</summary>
    
    
    
    <category term="STL源码剖析读书笔记" scheme="http://example.com/categories/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="STL" scheme="http://example.com/tags/STL/"/>
    
    <category term="STL源码剖析" scheme="http://example.com/tags/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"/>
    
    <category term="迭代器" scheme="http://example.com/tags/%E8%BF%AD%E4%BB%A3%E5%99%A8/"/>
    
    <category term="traits" scheme="http://example.com/tags/traits/"/>
    
  </entry>
  
  <entry>
    <title>&lt;STL源码剖析&gt;第一二章</title>
    <link href="http://example.com/2022/03/21/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E7%AC%AC%E4%B8%80%E4%BA%8C%E7%AB%A0/"/>
    <id>http://example.com/2022/03/21/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E7%AC%AC%E4%B8%80%E4%BA%8C%E7%AB%A0/</id>
    <published>2022-03-20T16:00:00.000Z</published>
    <updated>2022-03-22T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="STL六大组件"><a href="#STL六大组件" class="headerlink" title="STL六大组件"></a>STL六大组件</h2><ul><li>class template<ul><li>容器（containers）</li></ul></li><li>function template<ul><li>算法（algorithms）</li><li>迭代器（iterators）</li><li>仿函数（functors）</li><li>配置器（allocators）</li></ul></li><li>修饰容器、迭代器、仿函数以获得新的功能<ul><li><p>适配器（adaptors）<br>###六大组件的相互关系</p><p>Container通过Allocator获得数据存储空间，Algorithm通过Iterator存取Container内容，Functor可以协助Algorithm来改变内部策略，而Adapter可以修饰Container、Functor以及Iterator。</p></li></ul></li></ul><hr><h2 id="空间配置器"><a href="#空间配置器" class="headerlink" title="空间配置器"></a>空间配置器</h2><h3 id="STL规范下的空间配置器接口"><a href="#STL规范下的空间配置器接口" class="headerlink" title="STL规范下的空间配置器接口"></a>STL规范下的空间配置器接口</h3><p>  根据STL的规范，allocator的必要接口：</p><table><thead><tr><th align="center">接口</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">allocator::value_type<br>allocator::pointer<br>allocator::const_pointer<br>allocator::reference<br>allocator::const_reference<br>allocator::size_type<br>allocator::difference_type</td><td align="center">T<br>T*<br>const T*<br>T&amp;<br>const T&amp;<br>size_t<br>ptrdiff_t</td></tr><tr><td align="center">allocator::rebind</td><td align="center">一个嵌套的(nested)class template，class rebind<U>拥有唯一成员other，那是一个typedef，代表allocator<U></td></tr><tr><td align="center">allocator::allocator()</td><td align="center">default constructor</td></tr><tr><td align="center">allocator::allocator(const allocator&amp;)</td><td align="center">copy constructor</td></tr><tr><td align="center">typename<class U> allocator::allocator(const allocator<U>&amp;)</td><td align="center">泛化的copy constructor</td></tr><tr><td align="center">allocator::~allocator()</td><td align="center">default destructor</td></tr><tr><td align="center">pointer allocator::address(reference x) const</td><td align="center">返回某个对象的地址，算式a.address(x)等同于&amp;x</td></tr><tr><td align="center">const_pointer allocator::address(const_reference x) const</td><td align="center">返回某个const对象的地址，算式a.address(x)等同于&amp;x</td></tr><tr><td align="center">pointer allocator::allocate(size_type n, const void* &#x3D; 0)</td><td align="center">配置空间，足以存储n个T对象，第二个参数是个提示，实际上可能会利用它来增进区域性(locality)，或完全忽略之</td></tr><tr><td align="center">void allocator::deallocate(pointer p, size_type n)</td><td align="center">归还先前配置的空间</td></tr><tr><td align="center">size_type allocator::max_size() const</td><td align="center">返回可成功配置的最大量</td></tr><tr><td align="center">void allocator::construct(pointer p, const T&amp; x)</td><td align="center">等同于new((const void*)p) T(x)</td></tr><tr><td align="center">void allocator::destroy(pointer p)</td><td align="center">等同于 p-&gt;~T()</td></tr></tbody></table><p>  而SGI STL在配置器上逃脱了STL标准规格，转而使用一个专属的、拥有次层配置（sub-allocation）能力的配置器alloc，<strong>该alloc不接受任何参数。</strong>虽然SGI也定义有一个符合标准、名为allcoator的配置器，但SGI不使用他（效率不佳，只是对 new 和 delete 的一层薄薄包装）。</p><h3 id="具有次配置力的SGI配置器alloc"><a href="#具有次配置力的SGI配置器alloc" class="headerlink" title="具有次配置力的SGI配置器alloc"></a>具有次配置力的SGI配置器alloc</h3><h4 id="配置器alloc所处的文件"><a href="#配置器alloc所处的文件" class="headerlink" title="配置器alloc所处的文件"></a>配置器alloc所处的文件</h4><p>配置器定义于<memory>中，SGI<memory>内含以下两个文件：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stl_alloc.h&gt;</span> <span class="comment">//负责内存空间的配置与释放</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stl_construct.h&gt;</span>  <span class="comment">//负责对象内容的构造与析构</span></span></span><br></pre></td></tr></table></figure><h4 id="构造和析构的基本工具：construct-和destroy"><a href="#构造和析构的基本工具：construct-和destroy" class="headerlink" title="构造和析构的基本工具：construct()和destroy()"></a>构造和析构的基本工具：construct()和destroy()</h4><p><img src="/../img/constructor_des.png" alt="png"></p><p>需要注意的是，destroy()有两个版本，第一个版本接受一个指针并调用析构函数直接析构掉，而第二个版本接受范围迭代器，使用value_type()获取迭代器所指对象类型，再根据_type_traits<T>判断该类型的析构函数是否无关痛痒来决定是否可以直接忽视析构函数的调用以获得更佳效率。</p><h4 id="空间的配置与释放，std-alloc"><a href="#空间的配置与释放，std-alloc" class="headerlink" title="空间的配置与释放，std::alloc"></a>空间的配置与释放，std::alloc</h4><p>SGI对对象空间的配置和释放的设计哲学如下：</p><ul><li>向system heap要求空间</li><li>考虑多线程状态</li><li>考虑内存不足时的应变措施</li><li>考虑过多“小型区块”可能造成的内存碎片问题。</li></ul><p>考虑到内存碎片问题，SGI设计了双层级配置器，第一级配置器直接使用malloc()和free()，第二级配置器则视情况采用不同的策略，当配置区块足够大（超过128bytes）时，直接调用第一级配置器，而区块过小时，则采用复杂的memory pool整理方式来降低负担。使用第一级还是第二级取决于_USE_MALLOC是否定义。</p><p><img src="/../img/%E4%B8%80%E4%BA%8C%E7%BA%A7%E9%85%8D%E7%BD%AE%E5%99%A8%E5%85%B3%E7%B3%BB.png" alt="png"></p><p>无论alloc被定义为第一级或是第二级配置器，SGI会再在alloc之上包装一个符合STL规格的接口simple_alloc，SGI STL容器全部使用这个simple_alloc接口:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Alloc</span>&gt; <span class="comment">//Alloc参数可以是第一级配置器，也可以是第二级配置器，SGI默认设置为第二级配置器</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">simple_alloc</span> &#123;</span><br><span class="line"><span class="keyword">public</span> :</span><br><span class="line"><span class="function"><span class="type">static</span> T *<span class="title">allocate</span> <span class="params">(<span class="type">size_t</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="keyword">return</span> <span class="number">0</span> == n?<span class="number">0</span> :(T*)Alloc::<span class="built_in">allocate</span>(n * <span class="built_in">sizeof</span> (T)); &#125;</span><br><span class="line"><span class="function"><span class="type">static</span> T *<span class="title">allocate</span> <span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123; <span class="keyword">return</span> (T*) Alloc::<span class="built_in">allocate</span>(<span class="built_in">sizeof</span>(T));&#125;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">deallocate</span> <span class="params">(T *p,<span class="type">size_t</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="keyword">if</span> (<span class="number">0</span> ! = n) Alloc::<span class="built_in">deallocate</span>(p,n * <span class="built_in">sizeof</span>(T));&#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">deallocate</span> <span class="params">(T *p)</span></span></span><br><span class="line"><span class="function">    </span>&#123; Alloc::<span class="built_in">deallocate</span>(p, <span class="built_in">sizeof</span>(T)); &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="第一级配置器-malloc-alloc-template"><a href="#第一级配置器-malloc-alloc-template" class="headerlink" title="第一级配置器__malloc_alloc_template"></a>第一级配置器__malloc_alloc_template</h4><p>第一级配置器以malloc(),free(),realloc()等函数执行实际的内存配置、释放、重配置操作，并实现出类似C++ new-handler的机制来在内存配置无法被满足时调用一个用户指定的函数即“内存不足处理例程”。</p><p>第一级配置器处理内存不足的方式很简单，就是在内存不足时不断地调用“内存不足处理例程”，以期待在其中一次调用后分配到足够的内存，而如果该“内存不足处理例程”违背用户指定时，则会直接抛出bad_alloc异常信息。</p><p>以alloc为例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> * <span class="title">allocate</span> <span class="params">( <span class="type">size_t</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">void</span> *result = <span class="built_in">malloc</span>(n) ;  <span class="comment">//第一级配置器直接使用malloc()</span></span><br><span class="line">    <span class="comment">//以下无法满足需求时，改用oom_mnalloc()</span></span><br><span class="line"><span class="keyword">if</span> ( <span class="number">0</span> == result ) result = <span class="built_in">oom_malloc</span>(n);</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">void</span> (*__malloc_alloc_template&lt;inst&gt;::_malloc_alloc_oom_handler)() = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="type">int</span> inst&gt;</span><br><span class="line"><span class="type">void</span> * ___malloc_alloc_template&lt;inst&gt;::<span class="built_in">oom_malloc</span>(<span class="type">size_t</span> n)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">void</span> (*my_malloc_handler)();</span><br><span class="line"><span class="type">void</span> *result ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(; ;) &#123;            <span class="comment">//不断尝试释放、配置、再释放、再配置…</span></span><br><span class="line">my_malloc_handler = __malloc_alloc_oom_handler;</span><br><span class="line">         <span class="keyword">if</span>(<span class="number">0</span> == my_malloc_handler) &#123; __THROW_BAD_ALLOC; &#125;</span><br><span class="line">         (*my_malloc_handler)();   <span class="comment">//调用处理例程，企图释放内存</span></span><br><span class="line">         result = <span class="built_in">malloc</span>(n) ;     <span class="comment">//再次尝试配置内存</span></span><br><span class="line"><span class="keyword">if</span> (result) <span class="keyword">return</span>(result) ;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="第二级配置器-default-alloc-template"><a href="#第二级配置器-default-alloc-template" class="headerlink" title="第二级配置器__default_alloc_template"></a>第二级配置器__default_alloc_template</h4><p>小额区块带来的不仅是内存碎片，还有配置时的额外负担。额外负担是必要的，系统需要靠这块多出来的空间来管理内存，但是区块越小，额外负担所占比例就越大，越浪费。</p><p><img src="/../img/%E5%B0%8F%E5%86%85%E5%AD%98%E9%A2%9D%E5%A4%96%E8%B4%9F%E6%8B%85.png" alt="额外负担"></p><p>SGI第二级配置器的做法：</p><ul><li>&gt;128bytes，交由第一配置器处理。</li><li>&lt;128bytes，以内存池（memory pool）管理，又称为次层配置（sub-allocation）：每次配置一大块内存，并维护对应的自由链表（free-list）。下次若再有相同大小的内存需求，就直接从free-lists中拨出。相对应的，如果客端释还小额区块，就由配置器回收到free-lists中——是的，<strong>配置器除了负责配置，也负责回收</strong>。为了方便管理，SGI第二级配置器会主动将任何小额区块的内存需求量上调至8的倍数（例如客端要求30 bytes，就自动调整为32 bytes) ，并维护16个free-lists，各自管理大小分别为8,16,24,32,40,48,56,64,72,80,88,96,104,112,120,128 bytes的小额区块。</li></ul><p>free-list的节点结构：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> <span class="title class_">obj</span> &#123;</span><br><span class="line"><span class="keyword">union</span> <span class="title class_">obj</span> * free_list_link ;</span><br><span class="line"><span class="type">char</span> client __data[<span class="number">1</span>];<span class="comment">/*The client sees this. */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>该节点结构使用union来避免维护链表必须的指针而造成的内存浪费。（这种技巧在非强类型语言中十分普遍）</p><p><img src="/../img/freelist.png" alt="freelist"></p><h4 id="第二级配置器的空间配置函数allocate"><a href="#第二级配置器的空间配置函数allocate" class="headerlink" title="第二级配置器的空间配置函数allocate()"></a>第二级配置器的空间配置函数allocate()</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//n must be &gt; 0</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> * <span class="title">al1ocate</span><span class="params">(<span class="type">size_t</span> n)</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">obj * <span class="keyword">volatile</span> * my_free_list;</span></span></span><br><span class="line"><span class="params"><span class="function">obj * result;</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="comment">//大于128就调用第一级配置器</span></span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">if</span> (n &gt; (<span class="type">size_t</span>) _MAX_BYTES)&#123;</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">return</span> (malloc_alloc::allocate(n));</span></span></span><br><span class="line"><span class="params"><span class="function">    &#125;</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="comment">//寻找16个free lists中适当的一个</span></span></span></span><br><span class="line"><span class="params"><span class="function">my_free_list = free_list + FREELIST_INDEX(n);</span></span></span><br><span class="line"><span class="params"><span class="function">    result = *my_free_list ;</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">if</span> (result == <span class="number">0</span> )&#123;</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="comment">//没找到可用的free list，准备重新填充free list</span></span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">void</span> *r = refill(ROUND_UP(n)); <span class="comment">//下节详述</span></span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">return</span> r;</span></span></span><br><span class="line"><span class="params"><span class="function">&#125;</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="comment">//调整free list</span></span></span></span><br><span class="line"><span class="params"><span class="function">*my_free_list = result -&gt; free_list_link;</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">return</span> (result);</span></span></span><br><span class="line"><span class="params"><span class="function">&#125;;</span></span></span><br></pre></td></tr></table></figure><p><img src="/../img/%E6%8B%94%E5%87%BAfreelist%E4%B8%AD%E5%8C%BA%E5%9D%97.png" alt="allocate()示意"></p><h5 id="重新填充free-lists的refill-函数"><a href="#重新填充free-lists的refill-函数" class="headerlink" title="重新填充free lists的refill()函数"></a>重新填充free lists的refill()函数</h5><p>refill()函数为不够用的free list重新填充空间，新的空间取自内存池（由chunk_alloc()完成），新区块数量默认缺省为20个，但内存池不足够时，获得的区块数可能小于20个。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回一个大小为n的对象，并且有时候会为适当的free list增加节点</span></span><br><span class="line"><span class="comment">//假设n已经适当上调至8的倍数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">bool</span> threads, <span class="type">int</span> inst&gt;</span><br><span class="line"><span class="type">void</span>* _default_alloc_template&lt;threads, inst&gt;::<span class="built_in">refill</span>(<span class="type">size_t</span> n)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> nobjs = <span class="number">20</span>;</span><br><span class="line"><span class="comment">//调用chunk_alloc( )，尝试取得nobjs个区块作为free list的新节点</span></span><br><span class="line"><span class="comment">//注意参数nobjs是pass by reference</span></span><br><span class="line"><span class="type">char</span> * chunk = <span class="built_in">chunk_alloc</span>(n, nobjs);<span class="comment">//下节详述</span></span><br><span class="line">obj * <span class="keyword">volatile</span> *my__free_list;</span><br><span class="line">obj * result;</span><br><span class="line">obj * current_obj, * next__obj;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果只获得一个区块，这个区块就分配给调用者用，free list无新节点</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">1</span> == nobjs) <span class="keyword">return</span> (chunk);</span><br><span class="line"><span class="comment">//否则准备调整free list，纳人新节点</span></span><br><span class="line"></span><br><span class="line">    my_free_list = free_list + <span class="built_in">FREELIST_INDEX</span>(n);</span><br><span class="line"><span class="comment">//以下在chunk空间内建立free list</span></span><br><span class="line">result = (obj *)chunk;    <span class="comment">//这一块准备返回给客端</span></span><br><span class="line">    <span class="comment">//以下导引free list指向新配置的空间（取自内存池)</span></span><br><span class="line">*my_free_list = next_obj = (obj *)(chunk + n);</span><br><span class="line">    <span class="comment">//以下将free list的各节点串接起来</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; ; i++) &#123;  <span class="comment">//从1开始，因为第О个将返回给客端</span></span><br><span class="line">current_obj = next__obj;</span><br><span class="line">next_obj = (obj *)((<span class="type">char</span> *)next__obj + n);</span><br><span class="line"><span class="keyword">if</span> (nobjs - <span class="number">1</span> == i) &#123;</span><br><span class="line">current__obj -&gt; free_list_link = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">current__obj -&gt; free_list_link = next__obj;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ( result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="从内存池取空间给free-lists的chunk-alloc-函数"><a href="#从内存池取空间给free-lists的chunk-alloc-函数" class="headerlink" title="从内存池取空间给free lists的chunk_alloc()函数"></a>从内存池取空间给free lists的chunk_alloc()函数</h5><p>该函数以end_free - start_free来判断内存池余量来决定内存分配方式：</p><ul><li>充足，直接调出20个区块返回给free_list。</li><li>不充足但是还有余力供应一个以上的区块，就拨出这不足20个的区块出去。（区块数参数引用传递因此可以不断修正为实际能够供应的区块数）。</li><li>如果一个区块的空间都不供不起了，需利用malloc()从heap中配置内存，新配置内存大小为需求量的两倍再加上一个随配置次数增加而越来越大的附加量。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//假设size已经适当上调至8的倍数</span></span><br><span class="line"><span class="comment">//注意参数nobjs是pass by reference</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">bool</span> threads, <span class="type">int</span> inst&gt;</span><br><span class="line"><span class="type">char</span>*</span><br><span class="line">__default_alloc_template&lt;threads, inst&gt;::</span><br><span class="line"><span class="built_in">chunk_alloc</span>(<span class="type">size_t</span> size, <span class="type">int</span>&amp; nobjs)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> * result;</span><br><span class="line"><span class="type">size_t</span> total bytes = size * nobjs;</span><br><span class="line"><span class="type">size_t</span> bytes_left = end_free - start free; <span class="comment">//内存池剩余空间</span></span><br><span class="line"><span class="keyword">if</span> (bytes_left &gt;= total_bytes)&#123;</span><br><span class="line"><span class="comment">//内存池剩余空间完全满足需求量</span></span><br><span class="line">result = start_free;</span><br><span class="line">start_free += total_bytes;</span><br><span class="line"><span class="keyword">return</span> (result);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (bytes_left &gt;= size) &#123;</span><br><span class="line"><span class="comment">//内存池剩余空间不能完全满足需求量，但足够供应一个（含）以上的区块</span></span><br><span class="line">nobjs = bytes_left / size;</span><br><span class="line">total_bytes = size * nobjs;</span><br><span class="line">result = start_free;</span><br><span class="line">start_free += total_bytes;</span><br><span class="line"><span class="keyword">return</span> (result);</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//内存池剩余空间连一个区块的大小都无法提供</span></span><br><span class="line"><span class="type">size_t</span> bytes_to_get = <span class="number">2</span> * total_bytes + <span class="built_in">ROUND_UP</span>(heap_size &gt;&gt; <span class="number">4</span>);</span><br><span class="line"><span class="comment">//以下试着让内存池中的残余零头还有利用价值</span></span><br><span class="line"><span class="keyword">if</span> (bytes_left &gt; <span class="number">0</span>)&#123;</span><br><span class="line"><span class="comment">//内存池内还有一些零头，先配给适当的free list</span></span><br><span class="line"><span class="comment">//首先寻找适当的free list</span></span><br><span class="line">obj * <span class="keyword">volatile</span> * my_free_list = </span><br><span class="line">                free_list + <span class="built_in">FREELIST_INDEX</span>(bytes_left);</span><br><span class="line"><span class="comment">//调整free list，将内存池中的残余空间编入</span></span><br><span class="line">((obj *)start_free) -&gt; free_list_1ink = *my_free_list;</span><br><span class="line">*my_free_list = (obj *)start_free;</span><br><span class="line">&#125;</span><br><span class="line">        </span><br><span class="line"><span class="comment">//配置heap空间，用来补充内存池</span></span><br><span class="line">start_free = (<span class="type">char</span> *)<span class="built_in">malloc</span>(bytes_to_get);</span><br><span class="line"><span class="keyword">if</span>(<span class="number">0</span> == start_free) &#123;</span><br><span class="line"><span class="comment">//heap空间不足，malloc()失败</span></span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line">obj * <span class="keyword">volatile</span> * my _free_list, *p;</span><br><span class="line"><span class="comment">//试着检视我们手上拥有的东西。这不会造成伤害。我们不打算尝试配置</span></span><br><span class="line"><span class="comment">//较小的区块，因为那在多进程(multi-process）机器上容易导致灾难</span></span><br><span class="line"><span class="comment">//以下搜寻适当的free list</span></span><br><span class="line"><span class="comment">//所谓适当是指“尚有未用区块，且区块够大”之free list</span></span><br><span class="line"><span class="keyword">for</span> (i = size; i &lt;= __MAX_BYTES; i += __ALIGN) &#123;</span><br><span class="line">my_free_list = free_list + <span class="built_in">FREELIST__INDEX</span> (i);</span><br><span class="line">p= *my_free_list;</span><br><span class="line"><span class="keyword">if</span> (<span class="number">0</span> != p) &#123;   <span class="comment">// free list内尚有未用区块</span></span><br><span class="line"><span class="comment">//调整free list以释出未用区块</span></span><br><span class="line">*my_free_list = p -&gt;free_list_link;</span><br><span class="line">start_free = (<span class="type">char</span> *)p;</span><br><span class="line">end_free = start_free + i;</span><br><span class="line"><span class="comment">//递归调用自己，为了修正nobjs</span></span><br><span class="line"><span class="keyword">return</span> (chunk.<span class="built_in">alloc</span>(size, nobjs));</span><br><span class="line"><span class="comment">//注意，任何残余零头终将被编人适当的free-list中备用</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">end_free = <span class="number">0</span>; <span class="comment">//如果出现意外（山穷水尽，到处都没内存可用了)</span></span><br><span class="line"><span class="comment">//调用第一级配置器，看看out-of-memory机制能否尽点力</span></span><br><span class="line">start_free = (<span class="type">char</span> *)malloc_alloc::<span class="built_in">allocate</span>(bytes_to_get);</span><br><span class="line"><span class="comment">//这会导致抛出异常(exception)，或内存不足的情况获得改善</span></span><br><span class="line">&#125;</span><br><span class="line">heap_size += bytes_to_get;</span><br><span class="line">end_free = start_free + bytes_to_get;</span><br><span class="line"><span class="comment">//递归调用自己、为了修正nobjs,nodejs个返回给free_list，其余的留给线程池。</span></span><br><span class="line"><span class="keyword">return</span>(<span class="built_in">chunk_alloc</span>(size, nobjs));</span><br><span class="line">)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="第二级配置器的空间释放函数deallocate"><a href="#第二级配置器的空间释放函数deallocate" class="headerlink" title="第二级配置器的空间释放函数deallocate()"></a>第二级配置器的空间释放函数deallocate()</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//p不可以是0</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">deallocate</span> <span class="params">(<span class="type">void</span> *p, <span class="type">size_t</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">obj *q = (obj *)p;</span><br><span class="line">obj * <span class="keyword">volatile</span> *my_free_list;</span><br><span class="line">    <span class="comment">//大于128就调用第一级配置器</span></span><br><span class="line"><span class="keyword">if</span> (n &gt; (<span class="type">size_t</span>)__MAX__BYTES)&#123;</span><br><span class="line">malloc_alloc::<span class="built_in">deallocate</span>(p, n);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">)</span><br><span class="line"><span class="comment">//寻找对应的free list</span></span><br><span class="line">my_free_list = free_list + <span class="built_in">FREELIST_INDEX</span>(n);</span><br><span class="line"><span class="comment">//调整free list，回收区块</span></span><br><span class="line">q -&gt; free_list_link = *my_free_list;</span><br><span class="line">*my_free_list = q;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><img src="/../img/freelist%E5%9B%9E%E6%94%B6%E5%8C%BA%E5%9D%97.png" alt="区块回收"></p><h3 id="内存基本处理工具"><a href="#内存基本处理工具" class="headerlink" title="内存基本处理工具"></a>内存基本处理工具</h3><p>STL有五个作用于未初始化空间上的全局函数，除了之前的construct()、destroy()，还有uninitialized_copy()、 uninitialized_fill()、uninitialized_fill_n()。这些函数可以使我们能够将内存的配置与对象的构造行为分离开来。</p><table><thead><tr><th align="center">函数</th><th align="center">参数说明</th></tr></thead><tbody><tr><td align="center">uninitialized_copy(InputIterator first,<br>InputIterator last,<br>ForwardIterator result)</td><td align="center">迭代器first指向输人端的起始位置。<br>迭代器last指向输人端的结束位置（前闭后开区间）。<br>迭代器result指向输出端（欲初始化空间）的起始处。</td></tr><tr><td align="center">uninitialized_fill(ForwardIterator first,<br>ForwardIterator last,<br>const T&amp; x)</td><td align="center">迭代器first指向输出端（欲初始化空间）的起始处。<br>迭代器last指向输出端（欲初始化空间）的结束处（前闭后开区间）。<br>x表示初值。</td></tr><tr><td align="center">uninitialized_fill_n(ForwardIterator first,<br>Size n,<br>const T&amp; x)</td><td align="center">迭代器first指向与初始化空间的起始处。<br>n表示与初始化空间的大小。<br>x表示初值。</td></tr></tbody></table><h4 id="commit-or-rollback"><a href="#commit-or-rollback" class="headerlink" title="commit or rollback"></a>commit or rollback</h4><p>三个函数都具有<strong>“commit or rollback”</strong>语意，即要么产生所有必要的元素，否则就不产生任何元素。如果构造过程中任何一个copy constructor丢出异常，函数必须负责析构已产生的所有元素。</p><h4 id="POD"><a href="#POD" class="headerlink" title="POD"></a>POD</h4><p>POD指Plain Old Data，也就是标量类型(scalar types)或传统的C struct类型，POD类型必然拥有trivial ctor&#x2F;dtor&#x2F;copyassignment函数。因此，在这三个函数的对象构造过程中，可以对POD类型采用最有效率的初值填写手法，而对non-POD类型采取最安全保险的做法。以uninitialized_fill为例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果copy construction等同于assignment,而且</span></span><br><span class="line"><span class="comment">//destructor是trivial，以下就有效</span></span><br><span class="line"><span class="comment">//如果是POD型别，执行流程就会转进到以下函数。这是藉由function template</span></span><br><span class="line"><span class="comment">//的参数推导机制而得</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">ForwardIterator</span>, <span class="keyword">class</span> <span class="title class_">Size</span>, <span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">inline</span> ForwardIterator</span><br><span class="line">__uninitialized_fill_n_aux(ForwardIterator first, Size n,</span><br><span class="line"><span class="type">const</span> T&amp; x, __true_type) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">fill_n</span>(first,n,x);<span class="comment">//交由高阶函数执行</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果不是POD型别，执行流程就会转进到以下函数。这是藉由function template</span></span><br><span class="line"><span class="comment">//的参数推导机制而得</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">ForwardIterator</span>, <span class="keyword">class</span> <span class="title class_">size</span>, <span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">ForwardIterator</span><br><span class="line">__uninitialized_fill_n_aux(ForwardIterator first,Size n,</span><br><span class="line"><span class="type">const</span> T&amp; x,_false_type) &#123;</span><br><span class="line">ForwardIterator cur = first;</span><br><span class="line"><span class="comment">//为求阅读顺畅，以下将原本该有的异常处理(exception handling)省略</span></span><br><span class="line">    <span class="keyword">for</span>( ; n &gt; <span class="number">0</span> ;--n,++cur) </span><br><span class="line"><span class="built_in">construct</span>(&amp;*cur, x);</span><br><span class="line"><span class="keyword">return</span> cur;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于uninitialized_copy()函数，有两种类型：char*和wchar_t*可以采用最具效率的做法memmove（直接移动内存内容）来执行复制行为。因此SGI为这两种类型设计了一份特化的版本：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//以下是针对const char*的特化版本</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">char</span>* <span class="title">uninitialized_copy</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* first,<span class="type">const</span> <span class="type">char</span>* last,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">char</span>* result)</span></span>&#123;</span><br><span class="line"><span class="built_in">memmove</span>(result, first, last - first);</span><br><span class="line"><span class="keyword">return</span> result + (last - first);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//以下是针对const wchar_t*的特化版本</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">wchar_t</span>* <span class="title">uninitialized_copy</span><span class="params">(<span class="type">const</span> <span class="type">wchar_t</span>* first, <span class="type">const</span> <span class="type">wchar_t</span>* last,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">wchar_t</span>* result)</span> </span>&#123;</span><br><span class="line"><span class="built_in">memmove</span>(result, first, <span class="built_in">sizeof</span>(<span class="type">wchar_t</span>) * (last - first));</span><br><span class="line"><span class="keyword">return</span> result + (last - first);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/../img/%E4%B8%89%E4%B8%AA%E5%86%85%E5%AD%98%E5%9F%BA%E6%9C%AC%E5%87%BD%E6%95%B0.png" alt="内存基本函数"></p>]]></content>
    
    
    <summary type="html">&lt;STL源码剖析&gt;第一二章读书笔记，STL初识以及allocator的知识</summary>
    
    
    
    <category term="STL源码剖析读书笔记" scheme="http://example.com/categories/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="STL" scheme="http://example.com/tags/STL/"/>
    
    <category term="STL源码剖析" scheme="http://example.com/tags/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"/>
    
    <category term="allocator" scheme="http://example.com/tags/allocator/"/>
    
    <category term="空间配置器" scheme="http://example.com/tags/%E7%A9%BA%E9%97%B4%E9%85%8D%E7%BD%AE%E5%99%A8/"/>
    
  </entry>
  
</feed>

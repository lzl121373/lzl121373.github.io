<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>&lt;STL源码剖析&gt;第六章——算法 | 😊</title><meta name="keywords" content="STL,STL源码剖析,算法"><meta name="author" content="lzl121373"><meta name="copyright" content="lzl121373"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="第六章读书笔记，各种算法实现">
<meta property="og:type" content="article">
<meta property="og:title" content="&lt;STL源码剖析&gt;第六章——算法">
<meta property="og:url" content="http://example.com/2022/04/08/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E7%AC%AC%E5%85%AD%E7%AB%A0/index.html">
<meta property="og:site_name" content="😊">
<meta property="og:description" content="第六章读书笔记，各种算法实现">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E5%B0%81%E9%9D%A2.jpg">
<meta property="article:published_time" content="2022-04-07T16:00:00.000Z">
<meta property="article:modified_time" content="2022-05-08T16:00:00.000Z">
<meta property="article:author" content="lzl121373">
<meta property="article:tag" content="STL">
<meta property="article:tag" content="STL源码剖析">
<meta property="article:tag" content="算法">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E5%B0%81%E9%9D%A2.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2022/04/08/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E7%AC%AC%E5%85%AD%E7%AB%A0/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '<STL源码剖析>第六章——算法',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-05-09 00:00:00'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="😊" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">11</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">51</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">2</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-images"></i><span> Photo</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/../img/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E5%B0%81%E9%9D%A2.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">😊</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-images"></i><span> Photo</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">&lt;STL源码剖析&gt;第六章——算法</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-04-07T16:00:00.000Z" title="发表于 2022-04-08 00:00:00">2022-04-08</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-05-08T16:00:00.000Z" title="更新于 2022-05-09 00:00:00">2022-05-09</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">STL源码剖析读书笔记</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">21.8k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>87分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="&lt;STL源码剖析&gt;第六章——算法"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><h3 id="数值算法-lt-stl-numeric-h-gt"><a href="#数值算法-lt-stl-numeric-h-gt" class="headerlink" title="数值算法&lt;stl_numeric.h&gt;"></a>数值算法&lt;stl_numeric.h&gt;</h3><h4 id="accumulate"><a href="#accumulate" class="headerlink" title="accumulate"></a>accumulate</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//版本1</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>, <span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function">T <span class="title">accumulate</span><span class="params">(InputIterator first, InputIterator last, T init)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> ( ; first != last; ++first)</span><br><span class="line">		init = init + *first; <span class="comment">//将每个元素值累加到初值init身上</span></span><br><span class="line">		<span class="keyword">return</span> init;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//版本2</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>, <span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">BinaryOperation</span>&gt;</span><br><span class="line"><span class="function">T <span class="title">accumulate</span><span class="params">(InputIterator first, InputIterator last, T init, BinaryOperation binary_op)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span>( ; first != last; ++first)</span><br><span class="line">		init = <span class="built_in">binary_op</span>(init, *first); <span class="comment">//对每一个元素执行二元操作</span></span><br><span class="line">	<span class="keyword">return</span> init;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>式中的二元操作符不必满足交换律和结合律。</p>
<h4 id="adjacent-difference"><a href="#adjacent-difference" class="headerlink" title="adjacent_difference"></a>adjacent_difference</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//版本1</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>, <span class="keyword">class</span> <span class="title class_">OutputIterator</span>&gt;</span><br><span class="line"><span class="function">OutputIterator <span class="title">adjacent_difference</span><span class="params">(InputIterator first, InputIterator last, OutputIterator result)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (first == last) <span class="keyword">return</span> result;</span><br><span class="line">	*result = *first;	<span class="comment">//首先记录第一个元素</span></span><br><span class="line">	<span class="keyword">return</span> __adjacent_difference(first, last, result, <span class="built_in">value_type</span>(first));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>, <span class="keyword">class</span> <span class="title class_">OutputIterator</span>, <span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">OutputIterator __adjacent_difference(InputIterator first, InputIterator last, OutputIterator result, T*) &#123;</span><br><span class="line">	T value = *first;</span><br><span class="line">	<span class="keyword">while</span> (++first != last) &#123;   <span class="comment">//走过整个区间</span></span><br><span class="line">		T tmp = *first;</span><br><span class="line">		*++result = tmp - value;	<span class="comment">//将相邻两元素的差额（后-前），赋值给目的端</span></span><br><span class="line">		value = tmp;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ++result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//版本2</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>, <span class="keyword">class</span> <span class="title class_">OutputIterator</span>, <span class="keyword">class</span> <span class="title class_">BinaryOperation</span>&gt;</span><br><span class="line"><span class="function">OutputIterator <span class="title">adjacent_difference</span><span class="params">(InputIterator first, InputIterator last, OutputIterator result, BinaryOperation binary_op)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (first == last) <span class="keyword">return</span> result;</span><br><span class="line">	*result = *first;	<span class="comment">//首先记录第一个元素</span></span><br><span class="line">	<span class="keyword">return</span> __adjacent_difference(first, last, result, <span class="built_in">value_type</span>(first), 								binary_op);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>, <span class="keyword">class</span> <span class="title class_">OutputIterator</span>, <span class="keyword">class</span> <span class="title class_">T</span>， <span class="keyword">class</span> <span class="title class_">BinaryOperation</span>&gt;</span><br><span class="line">OutputIterator __adjacent_difference(InputIterator first, InputIterator last, OutputIterator result, T*, BinaryOperation binary_op) &#123;</span><br><span class="line">	T value = *first;	</span><br><span class="line">	<span class="keyword">while</span> (++first != last) &#123;	<span class="comment">//走过整个区间</span></span><br><span class="line">		T tmp = *first;</span><br><span class="line">		*++result = <span class="built_in">binary_op</span>(tmp, value); <span class="comment">//将相邻两元素的运算结果，赋值给目的端</span></span><br><span class="line">		value = tmp;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ++result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>算法adjacent_difference用来计算[first, last)中相邻元素的差额。</p>
<p>如果加法与减法的定义一如常规定义，那么adjacent_difference与partial_sum（稍后介绍）互为逆运算。这意思是，如果对区间值1,2,3,4,5执行adjacent_difference，获得结果为1,1,1,1,1，再对此结果执行partial_sum，便会获得原始区间值1,2,3,4,5。</p>
<h4 id="inner-producct"><a href="#inner-producct" class="headerlink" title="inner_producct"></a>inner_producct</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//版本1</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator1</span>, <span class="keyword">class</span> <span class="title class_">InputIterator2</span>, <span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function">T <span class="title">inner_product</span><span class="params">(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, T init)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//以第一序列之元素个数为据，将两个序列都走一遍</span></span><br><span class="line">	<span class="keyword">for</span> ( ; first1 != last1; ++first1, ++first2)</span><br><span class="line">		init = init + (*first1 * *first2); <span class="comment">//执行两个序列的一般内积</span></span><br><span class="line">	<span class="keyword">return</span> init;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//版本2</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator1</span>, <span class="keyword">class</span> <span class="title class_">InputIterator2</span>, <span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">BinaryOperation1</span>, <span class="keyword">class</span> <span class="title class_">BinaryOperation2</span>&gt;</span><br><span class="line"><span class="function">T <span class="title">inner_product</span><span class="params">(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, T init, BinaryOperation1 binary_op1, BinaryOperation2 binary_op2)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//以第一序列之元素个数为据，将两个序列都走一遍</span></span><br><span class="line">	<span class="keyword">for</span> ( ; first1 != last1; ++first1, ++first2)</span><br><span class="line">		<span class="comment">//以外界提供的仿函数来取代第一版本中的operator*和operator+</span></span><br><span class="line">		init = <span class="built_in">binary_op1</span>(init, <span class="built_in">binary_op2</span>(*first1, *first2));</span><br><span class="line">	<span class="keyword">return</span> init;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>算法inner_product能够计算[first1, last1)和[first2, first2 + (last1 - first1))的一般内积。</p>
<p>式中所用的二元仿函数不必满足交换律(commutative)和结合律(associative)。inner_product所有运算行为的顺序都有明确设定。</p>
<h4 id="partial-sum"><a href="#partial-sum" class="headerlink" title="partial_sum"></a>partial_sum</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//版本1</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>, <span class="keyword">class</span> <span class="title class_">OutputIterator</span>&gt;</span><br><span class="line"><span class="function">OutputIterator <span class="title">partial_sum</span><span class="params">(InputIterator first, InputIterator last, Outputrterator result)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (first == last) <span class="keyword">return</span> result;</span><br><span class="line">	*result = *first;</span><br><span class="line">	<span class="keyword">return</span> __partial_sum(first, last, result, <span class="built_in">value_type</span>(first));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>, <span class="keyword">class</span> <span class="title class_">OutputIterator</span>, <span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function">OutputIterator <span class="title">partial_sum</span><span class="params">(InputIterator first, InputIterator last, OutputIterator result, T*)</span> </span>&#123;</span><br><span class="line">	T value = *first;</span><br><span class="line">	<span class="keyword">while</span> (++first != last) &#123;</span><br><span class="line">		value = value + *first;		<span class="comment">//前n个元素的总和</span></span><br><span class="line">		*++result = value;			<span class="comment">//指定给目的端</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ++result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//版本2由binary_op取代operator+</span></span><br></pre></td></tr></table></figure>

<p>算法partial_sum用来计算局部总和。</p>
<p>此式所用之二元仿函数不必满足交换律(commutative)和结合律(associative)。所有运算行为的顺序都有明确设定。</p>
<p>本算法返回输出区间的最尾端位置: result + (last - first) 。</p>
<h4 id="power"><a href="#power" class="headerlink" title="power"></a>power</h4><p>这个算法由SGI专属，并不在STL标准之列。它用来计算某数的n幂次方。</p>
<p>这里所谓的n幂次是指自己对自己进行某种运算，达n次。运算类型可由外界指定。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//版本一，乘幂</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Integer</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> T <span class="title">power</span><span class="params">(T x, Integer n)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">power</span>(x, n, <span class="built_in">multiplies</span>&lt;T&gt;());	<span class="comment">//指定运算型式为乘法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//版本二，幂次方。如果指定为乘法运算，则当n &gt;= 0时返回x^n</span></span><br><span class="line"><span class="comment">//注意，&quot;Monoid0peration”必须满足结合律(associative),</span></span><br><span class="line"><span class="comment">//但不需满足交换律(commutative)</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Integer</span>, <span class="keyword">class</span> <span class="title class_">MonoidOperation</span>&gt;</span><br><span class="line"><span class="function">T <span class="title">power</span><span class="params">(T x, Integer n, MonoidOperation op)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">identity_element</span>(op);	<span class="comment">//取出“证同元素”identity element</span></span><br><span class="line">	<span class="keyword">else</span> &#123;							  <span class="comment">//所谓“证同元素”，见7.3节</span></span><br><span class="line">		<span class="keyword">while</span> ((n &amp; <span class="number">1</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">			n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">			x = <span class="built_in">op</span>(x, x);</span><br><span class="line">		&#125;</span><br><span class="line">        </span><br><span class="line">		T result = x;</span><br><span class="line">		n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">while</span> (n != <span class="number">0</span>) &#123;</span><br><span class="line">			x = <span class="built_in">op</span>(x, x);</span><br><span class="line">			<span class="keyword">if</span> ((n &amp; <span class="number">1</span>) != <span class="number">0</span> )</span><br><span class="line">				result = <span class="built_in">op</span>(result, x);</span><br><span class="line">			n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="itoa"><a href="#itoa" class="headerlink" title="itoa"></a>itoa</h4><p>这个算法由SGI专属，并不在STL标准之列。它用来设定某个区间的内容，使其内的每一个元素从指定的value值开始，呈现递增状态。它改变了区间内容，所以是一种质变算法。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//函数意义:在[first, last)区间内填人value, value+1, value+2...</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">ForwardIterator</span>, <span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">iota</span> <span class="params">(ForwardIterator first, ForwardIterator last, T value)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (first != last) *first++ = value++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="基本算法-lt-stl-algobase-h-gt"><a href="#基本算法-lt-stl-algobase-h-gt" class="headerlink" title="基本算法&lt;stl_algobase.h&gt;"></a>基本算法&lt;stl_algobase.h&gt;</h3><h4 id="equal"><a href="#equal" class="headerlink" title="equal"></a>equal</h4><p>如果两个序列在[first, last)区间内相等，equal()返回true。如果第二序列的元素比较多，多出来的元素不予考虑。因此，如果我们希望保证两个序列完全相等，必须先判断其元素个数是否相同：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( vec1.<span class="built_in">size</span>() == vec2.<span class="built_in">size</span>() &amp;&amp;</span><br><span class="line">	 <span class="built_in">equal</span>( vec1.<span class="built_in">begin</span>(), vec1.<span class="built_in">end</span>(), vec2.<span class="built_in">begin</span>());</span><br></pre></td></tr></table></figure>

<p>如果第二序列的元素比第一序列少，这个算法内部进行迭代行为时，会超越序列的尾端，造成不可预测的结果。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator1</span>, <span class="keyword">class</span> <span class="title class_">InputIterator2</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">equa1</span><span class="params">(InputIterator1 first1, InputIterator1 last1,</span></span></span><br><span class="line"><span class="params"><span class="function">				 InputIterator2 first2)</span> </span>&#123;</span><br><span class="line"><span class="comment">//以下，将序列一走过一遍。序列二亦步亦趋</span></span><br><span class="line"><span class="comment">//如果序列一的元素个数多过序列二的元素个数，就糟糕了</span></span><br><span class="line">	<span class="keyword">for</span> ( ; first1 != last1; ++first1, ++first2) &#123;</span><br><span class="line">		<span class="keyword">if</span> (*first1 != *first2)			<span class="comment">//只要对应元素不相等</span></span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;			   <span class="comment">//就结束并返回false</span></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;				   <span class="comment">//至此，全部相等，返回true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator1</span>, <span class="keyword">class</span> <span class="title class_">InputIterator2</span>,</span><br><span class="line">		 <span class="keyword">class</span> <span class="title class_">BinaryPredicate</span>&gt;  </span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">equal</span> <span class="params">(Inputiterator1 first1, InputIterator1 last1,</span></span></span><br><span class="line"><span class="params"><span class="function">				  InputIterator2 first2, BinaryPredicate binary_pred)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> ( ; first1 != last1; ++first1, ++first2)</span><br><span class="line">		<span class="keyword">if</span> (!<span class="built_in">binary_pred</span>(*first1, *first2))</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="fill"><a href="#fill" class="headerlink" title="fill"></a>fill</h4><p>将[first, last)内的所有元素改填新值。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">ForwardIterator</span>, <span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fill</span><span class="params">(ForwardIterator first, Forwarditerator last, <span class="type">const</span> T&amp; value)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> ( ; first != last; ++first)		<span class="comment">//迭代走过整个区间</span></span><br><span class="line">		*first = value;				   <span class="comment">//设定新值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="fill-n"><a href="#fill-n" class="headerlink" title="fill_n"></a>fill_n</h4><p>将[first, last)内的前n个元素改填新值，返回的迭代器指向被填人的最后一个元素的下一位置。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">OutputIterator</span>, <span class="keyword">class</span> <span class="title class_">Size</span>, <span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function">OutputIterator <span class="title">fill_n</span><span class="params">(OutputIterator first, Size n, <span class="type">const</span> T&amp; value)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> ( ; n &gt; <span class="number">0</span>; --n, ++first)	<span class="comment">//经过n个元素</span></span><br><span class="line">		*first = value;			   <span class="comment">//设定新值</span></span><br><span class="line">	<span class="keyword">return</span> first;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>利用inserter()产生一个具有插入(insert)而非覆写(overwrite)能力的迭代器，inserter()可产生一个用来修饰迭代器的配接器。具体用法如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> ia[<span class="number">3</span>]=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>&#125;;									</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">iv</span><span class="params">(ia, ia+<span class="number">3</span>)</span></span>;						<span class="comment">//0 1 2</span></span><br><span class="line"><span class="built_in">fill_n</span>(<span class="built_in">inserter</span>(iv, iv.<span class="built_in">begin</span>()), <span class="number">5</span>, <span class="number">7</span>);			 <span class="comment">//7 7 7 7 7 0 1 2</span></span><br></pre></td></tr></table></figure>

<h4 id="iter-swap"><a href="#iter-swap" class="headerlink" title="iter_swap"></a>iter_swap</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">ForwardIterator1</span>, <span class="keyword">class</span> <span class="title class_">ForwardIterator2</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">iter_swap</span><span class="params">(ForwardIterator1 a, ForwardIterator2 b)</span> </span>&#123;</span><br><span class="line">	__iter_swap(a, b, <span class="built_in">value_type</span>(a)); <span class="comment">//注意第三参数的型别!</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">ForwardIterator1</span>, <span class="keyword">class</span> <span class="title class_">ForwardIterator2</span>, <span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="type">void</span> __iter_swap(ForwardIterator1 a, ForwardIterator2 b, T*) &#123;</span><br><span class="line">	T tmp = *a;</span><br><span class="line">	*a = *b;</span><br><span class="line">	*b = tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="lexicographical-compare"><a href="#lexicographical-compare" class="headerlink" title="lexicographical_compare"></a>lexicographical_compare</h4><p>以“字典排列方式”对两个序列[first1, last1)和[first2, last2)进行比较。比较操作针对两序列中的对应位置上的元素进行，并持续直到（1）某一组对应元素彼此不相等；（2）同时到达last1和last2（当两序列的大小相同）；（3）到达last1或last2（当两序列的大小不同）。</p>
<p>当这个函数在对应位置上发现第一组不相等的元素时，有下列几种可能：</p>
<ul>
<li>如果第一序列的元素较小，返回 true。否则返回false。</li>
<li>如果到达last1而尚未到达last2，返回true。</li>
<li>如果到达last2而尚未到达last1，返回false。</li>
<li>如果同时到达last1和last2（换句话说所有元素都匹配），返回false；</li>
</ul>
<p>第二版本允许你指定一个仿函数comp作为比较操作之用，取代元素类型所提供的less-than(小于)操作符。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator1</span>, <span class="keyword">class</span> <span class="title class_">InputIterator2</span>&gt;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">lexicographical_compare</span><span class="params">(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//以下，任何一个序列到达尾端，就结束。否则两序列就相应元素一一进行比对</span></span><br><span class="line">	<span class="keyword">for</span> ( ; first1 != last1 &amp;&amp; first2 != last2; ++first1, ++first2) &#123;</span><br><span class="line">		<span class="keyword">if</span> (*first1 &lt; *first2) <span class="comment">//第一序列元素值小于第二序列的相应元素值</span></span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">if</span> (*first2 &lt; *first1) <span class="comment">//第二序列元素值小于第一序列的相应元素值</span></span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		<span class="comment">//如果不符合以上两条件，表示两值相等，那就进行下一组相应元素值的比对</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//进行到这里，如果第一序列到达尾端而第二序列尚有余额，那么第一序列小于第二序列</span></span><br><span class="line">	<span class="keyword">return</span> first1 == last1 &amp;&amp; first2 != last2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator1</span>, <span class="keyword">class</span> <span class="title class_">InputIterator2</span>, <span class="keyword">class</span> <span class="title class_">Compare</span>&gt;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">lexicographical_compare</span><span class="params">(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2, Compare comp)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> ( ; first1 != last1 &amp;&amp; first2 != last2; ++first1, ++first2) &#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">comp</span>(*first1, *first2))</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">comp</span>(*first2, *first1))</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> first1 == last1 &amp;&amp; first2 != last2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了增进效率，SGI还设计了一个特化版本，用于原生指针const unsignede char*:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span></span></span><br><span class="line"><span class="function"><span class="title">lexicographical_compare</span><span class="params">(<span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span>* first1, <span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span>* last1, <span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span>* first2, <span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span>* last2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">const</span> <span class="type">size_t</span> lenl = last1 - first1;		<span class="comment">//第一序列长度</span></span><br><span class="line">	<span class="type">const</span> <span class="type">size_t</span> len2 = last2 - first2;		<span class="comment">//第二序列长度</span></span><br><span class="line">	<span class="comment">//先比较相同长度的一段。memcmp()速度极快</span></span><br><span class="line">	<span class="type">const</span> <span class="type">int</span> result = <span class="built_in">memcmp</span>(first1, first2, <span class="built_in">min</span>(len1, len2));</span><br><span class="line">	<span class="comment">//如果不相上下，则长度较长者被视为比较大</span></span><br><span class="line">	<span class="keyword">return</span> result != <span class="number">0</span> ? result &lt; <span class="number">0</span> : lenl &lt; len2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="max"><a href="#max" class="headerlink" title="max"></a>max</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">const</span> T&amp; <span class="title">max</span><span class="params">(<span class="type">const</span> T&amp; a,	<span class="type">const</span> T&amp; b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a &lt; b ? b : a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Compare</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">const</span> T&amp; <span class="title">max</span><span class="params">(<span class="type">const</span> T&amp; a, <span class="type">const</span> T&amp; b, Compare comp)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">comp</span>(a, b) ? b : a;	<span class="comment">// 由comp决定“大小比较”标准</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="min"><a href="#min" class="headerlink" title="min"></a>min</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">const</span> T&amp; <span class="title">min</span><span class="params">(<span class="type">const</span> T&amp; a,	<span class="type">const</span> T&amp; b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> b &lt; a ? b : a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Compare</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">const</span> T&amp; <span class="title">min</span><span class="params">(<span class="type">const</span> T&amp; a, <span class="type">const</span> T&amp; b, Compare comp)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">comp</span>(b, a) ? b : a;	<span class="comment">// 由comp决定“大小比较”标准</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="mismatch"><a href="#mismatch" class="headerlink" title="mismatch"></a>mismatch</h4><p>用来平行比较两个序列，指出两者之间的第一个不匹配点。返回一对迭代器，分别指向两序列中的不匹配点，如下图。如果两序列的所有对应元素都匹配，返回的便是两序列各自的last迭代器。缺省情况下是以equality操作符来比较元素；但第二版本允许用户指定比较操作。如果第二序列的元素个数比第一序列多，多出来的元素忽略不计。如果第二序列的元素个数比第一序列少，会发生未可预期的行为。	</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator1</span>, <span class="keyword">class</span> <span class="title class_">InputIterator2</span>&gt;</span><br><span class="line"><span class="function">pair&lt;InputIterator1, InputIterator2&gt; <span class="title">mismatch</span><span class="params">(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//以下，如果序列一走完，就结束</span></span><br><span class="line">	<span class="comment">//以下，如果序列一和序列二的对应元素相等，就结束</span></span><br><span class="line">	<span class="comment">//显然，序列一的元素个数必须多过序列二的元素个数，否则结果无可预期</span></span><br><span class="line">	<span class="keyword">while</span> (first1 != last1 &amp;&amp; *first1 == *first2) &#123;</span><br><span class="line">		++first1;</span><br><span class="line">		++first2;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">pair</span>&lt;InputIterator1, InputIterator2&gt;(first1, first2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator1</span>, <span class="keyword">class</span> <span class="title class_">InputIterator2</span>, <span class="keyword">class</span> <span class="title class_">BinaryPredicate</span>&gt;</span><br><span class="line"><span class="function">pair&lt;InputIterator1, InputIterator2&gt; <span class="title">mismatch</span><span class="params">(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, BinaryPredicate binary_pred)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (first1 != last1 &amp;&amp; <span class="built_in">binary_pred</span>(*first1, *first2)) &#123;</span><br><span class="line">		++first1;</span><br><span class="line">		++first2;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">pair</span>&lt;InputIterator1, InputIterator2&gt;(first1, first2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="swap"><a href="#swap" class="headerlink" title="swap"></a>swap</h4><p>该函数用来对调两个对象的内容。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">swap</span><span class="params">(T&amp; a, T&amp; b)</span> </span>&#123;</span><br><span class="line">	T tmp = a;</span><br><span class="line">	a = b;</span><br><span class="line">	b = tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="copy"><a href="#copy" class="headerlink" title="copy"></a>copy</h4><p>SGI STL的copy算法使用assignment operator来进行复制操作，而在该过程由于某些元素类型拥有的是trivial assignment operator，因此，如果能够采用内存直接复制行为（例如memmove或者memcpy）将节省大量时间。</p>
<p>为此，SGI STL的copy算法用尽各种办法（包括函数重载、type traits、partial specailization）等编程技巧，极致地去加强效率。</p>
<p>整个copy()操作的脉络：</p>
<p><img src="/../img/copy%E5%AE%8C%E6%95%B4%E8%84%89%E7%BB%9C.png" alt="copy完整脉络"></p>
<p>copy对其template参数所要求的条件非常宽松。其输入区间只需由InputIterators构成即可，输出区间只需由OutputIterator构成即可。但是，copy算法需要特别注意区间重叠的问题：</p>
<p><img src="/../img/copy%E7%AE%97%E6%B3%95%E5%8C%BA%E9%97%B4%E9%87%8D%E5%8F%A0%E7%9A%84%E9%97%AE%E9%A2%98.png" alt="copy算法区间重叠的问题"></p>
<p>如果输入区间和输出区间完全没重叠，当然毫无问题。否则，当输出区间的起点位于输入区间以内的话，copy算法便可能会在输入区间的某些元素尚未被复制之前就覆盖其值，导致错误的结果。这里的“可能”是因为如果copy算法根据其所接收的迭代器特性决定调用memmove()来执行任务，就不会造成上述错误，因为memmove()会先将整个输入区间的内容复制下来，没有被覆盖的危险。</p>
<p>copy更改的是[result, result + (last - first))中的迭代器所指对象，而非更改迭代器本身。它会为输出区间内的元素赋予新值，而不是产生新的元素。它不能改变输出区间的迭代器个数。换句话说，copy不能直接用来将元素插人空容器中。</p>
<h5 id="copy算法的实现细节"><a href="#copy算法的实现细节" class="headerlink" title="copy算法的实现细节"></a>copy算法的实现细节</h5><p>对外接口：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//完全泛化版本</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>, <span class="keyword">class</span> <span class="title class_">OutputIterator</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> OutputIterator <span class="title">copy</span><span class="params">(InputIterator first, InputIterator last, OutputIterator result)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> __copy_dispatch&lt;InputIterator, OutputIterator&gt;() (first, last, result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//特殊版本(1)。重载形式</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">char</span>* <span class="title">copy</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* first, <span class="type">const</span> <span class="type">char</span>* last, <span class="type">char</span>* result)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">memmove</span>(result, first, last - first);</span><br><span class="line">	<span class="keyword">return</span> result + (last - first);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//特殊版本(2)。重载形式</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">wchar_t</span>* <span class="title">copy</span><span class="params">(<span class="type">const</span> <span class="type">wchar_t</span>* first, <span class="type">const</span> <span class="type">wchar_t</span>* last, <span class="type">wchar_t</span>* result)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">memmove</span>(result, first, <span class="built_in">sizeof</span>(<span class="type">wchar_t</span>) * (last - first));</span><br><span class="line">	<span class="keyword">return</span> result + (last - first);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>copy()函数的泛化版本中调用了一个__copy_dispatch()函数，此函数有一个完全泛化版本和两个篇特化版本：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//完全泛化版本</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>, <span class="keyword">class</span> <span class="title class_">OutputIterator</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__copy_dispatch</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="function">OutputIterator <span class="title">operator</span><span class="params">()</span><span class="params">(InputIterator first, InputIterator last, OutputIterator result)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> __copy(first, last, result, <span class="built_in">iterator_category</span>(first));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//偏特化版本(1)，两个参数都是T*指针形式</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__copy_dispatch</span>&lt;T*, T*&gt;</span><br><span class="line">&#123;</span><br><span class="line">	<span class="function">T* <span class="title">operator</span><span class="params">()</span><span class="params">(T* first, T* last, T* result)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">typedef</span> <span class="keyword">typename</span> __type_traits&lt;T&gt;::has_trivial_assignment_operator t;</span><br><span class="line">		<span class="keyword">return</span> <span class="type">__copy_t</span>(first, last, result, <span class="built_in">t</span>());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//偏特化版本(2)，第一个参数为const T*指针形式，第二参数为T*指针形式</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__copy_dispatch</span>&lt;<span class="type">const</span> T*, T*&gt;</span><br><span class="line">&#123;</span><br><span class="line">	<span class="function">T* <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> T* first, <span class="type">const</span> T* last,T* result)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">typedef</span> <span class="keyword">typename</span> __type_traits&lt;T&gt;::has_trivial_assignment_operator t;</span><br><span class="line">		<span class="keyword">return</span> <span class="type">__copy_t</span>(first, last, result, <span class="built_in">t</span>());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>我们先讨论__copy_dispatch()的完全泛化版本，该版本根据迭代器种类的不同，调用了不同的__copy()，原因是不同种类的迭代器所使用的循环条件不同，有快慢之分。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//InputIterator版本</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>, <span class="keyword">class</span> <span class="title class_">OutputIterator</span>&gt;</span><br><span class="line"><span class="keyword">inline</span> OutputIterator __copy(InputIterator first, InputIterator last, OutputIterator result, input_iterator_tag)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//以迭代器等同与否，决定循环是否继续。速度慢</span></span><br><span class="line">	<span class="keyword">for</span>( ; first != last; ++result, ++first)</span><br><span class="line">		*result = *first;	<span class="comment">//assignment operator</span></span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//RandomAccessIterator版本</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">RandomAccessIterator</span>, <span class="keyword">class</span> <span class="title class_">OutputIterator</span>&gt;</span><br><span class="line"><span class="keyword">inline</span> OutputIterator </span><br><span class="line">__copy(RandomAccessIterator first, RandomAccessIterator last, OutputIterator result, random_access_iterator_tag)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//又划分出一个函数，为的是其它地方也可能用到</span></span><br><span class="line">	<span class="keyword">return</span> __copy_d(first, last, result, <span class="built_in">distance_type</span>(first));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">RandomAccessIterato</span>, <span class="keyword">class</span> <span class="title class_">OutputIterator</span>, <span class="keyword">class</span> <span class="title class_">Distance</span>&gt;</span><br><span class="line"><span class="keyword">inline</span> OutputIterator __copy_d(RandomAccessIterator first, RandomAccessIterator last, OutputIterator result, Distance*)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//以n决定循环的执行次数。速度快</span></span><br><span class="line">	<span class="keyword">for</span> (Distance n = last - first; n &gt; <span class="number">0</span>; --n, ++result, ++first)</span><br><span class="line">		*result = *first;	<span class="comment">//assignment operator</span></span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着是两个偏特化版本，通过采用__type_traits&lt;&gt;的技巧来判断对象类别是否具有trivial assignment operator，从而判断是否 可以采用快速的内存对拷方式（memmove()）来拷贝：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//以下版本适用于“指针所指之对象具备trivial assignment operator”</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">inline</span> T* <span class="type">__copy_t</span>(<span class="type">const</span> T* first, <span class="type">const</span> T* last, T* result, __true_type) &#123;</span><br><span class="line">	<span class="built_in">memmove</span>(result, first, <span class="built_in">sizeof</span>(T) * (last - first));</span><br><span class="line">	<span class="keyword">return</span> result + (last - first);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//以下版本适用于“指针所指之对象具备non-trivial assignment operator”</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">inline</span> T* <span class="type">__copy_t</span>(<span class="type">const</span> T* first, <span class="type">const</span> T* last, T* result, __false_type) &#123;</span><br><span class="line">	<span class="comment">//原生指针毕竟是一种RandomAccessIterator，所以交给__copy_d()完成</span></span><br><span class="line">	<span class="keyword">return</span> __copy_d(first, last, result, (<span class="type">ptrdiff_t</span>*)<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="copy-backward"><a href="#copy-backward" class="headerlink" title="copy_backward"></a>copy_backward</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">BidirectionalIterator1</span>, <span class="keyword">class</span> <span class="title class_">BidirectionalIterator2</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> BidirectionalIterator2 <span class="title">copy_backward</span> <span class="params">(Bidirectionallterator1 first, BidirectionalIterator1 last, BidirectionalTterator2 result)</span></span>;</span><br></pre></td></tr></table></figure>

<p>copy_backward()实现技巧与copy()类似。该算法将[first, last) 区间内的每一个元素，以逆行的方向复制到以result - 1为起点，方向亦为逆行的区间上。即，该算法会顺序执行赋值操作*(result - 1) &#x3D; *(last - 1), *(result - 2) &#x3D; *(last - 2),…以此类推。copy_backward()所接受的迭代器必须是BidirectionalIterators。</p>
<p>copy_backward()同样也需要注意输入空间和输出空间的问题：</p>
<p><img src="/../img/copy_backward%E5%8C%BA%E9%97%B4%E9%87%8D%E5%8F%A0.png" alt="copy_backward区间重叠"></p>
<h3 id="set相关算法"><a href="#set相关算法" class="headerlink" title="set相关算法"></a>set相关算法</h3><p>STL一共提供了四种与set相关的算法，分别是并集（union）、交集（intersection）、差集（difference）、对称差集（symmetric difference）。</p>
<p>这里的适用的的set需要有序，也就是说以hashtable为底层机制实现的set&#x2F;multiset不能应用于这四个算法。</p>
<h4 id="set-union"><a href="#set-union" class="headerlink" title="set_union"></a>set_union</h4><p>算法set_union可构造S1,S2的并集。S1，S2及其并集都是以排序区间表示。返回值为一个迭代器，指向输出空间的尾端。</p>
<p>由于S1和S2内的每个元素都不需唯一，因此，如果某个值在S1出现n次，在S2出现 m 次，那么该值在输出区间中会出现max(m,  n)次，其中n个来自S1，其余来自S2。在 STL set容器内，m ≤ 1且n ≤ 1。</p>
<p>set_union是一种稳定（stable）操作，意思是输人区间内的每个元素的相对顺序都不会改变。set_union有两个版本，差别在于如何定义某个元素小于另一个元素。第一版本使用operator&lt;进行比较，第二版本采用仿函数comp进行比较。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//并集，求存在于[first1, last1)或存在于[first2, last2)的所有元素</span></span><br><span class="line"><span class="comment">//注意，set是一种sorted range。这是以下算法的前提</span></span><br><span class="line"><span class="comment">//版本一</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator1</span>, <span class="keyword">class</span> <span class="title class_">InputIterator2</span>, <span class="keyword">class</span> <span class="title class_">OutputIterator</span>&gt;</span><br><span class="line"><span class="function">OutputIterator <span class="title">set_union</span><span class="params">(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2, OutputIterator result)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//当两个区间都尚未到达尾端时，执行以下操作...</span></span><br><span class="line">	<span class="keyword">while</span> (first1 ! = last1 &amp;&amp; first2 != last2) &#123;</span><br><span class="line">		<span class="comment">//在两区间内分别移动迭代器。首先将元素值较小者(假设为A区)记录于目标区,</span></span><br><span class="line">		<span class="comment">//然后移动A区迭代器使之前进;同时间之另一个区迭代器不动。然后进行新一次</span></span><br><span class="line">		<span class="comment">//的比大小、记录小值、迭代器移动…直到两区中有一区到达尾端。如果元素相等,</span></span><br><span class="line"> 		<span class="comment">//取S1者记录于目标区，并同时移动两个迭代器</span></span><br><span class="line">		<span class="keyword">if</span> (*first1 &lt; *first2) &#123;</span><br><span class="line">			*result = *first1;</span><br><span class="line">			++first1;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (*first2 &lt; *first1) &#123;</span><br><span class="line">			*result = *first2;</span><br><span class="line">			++first2;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;	<span class="comment">// *first2 == *first1</span></span><br><span class="line">			*result = *first1;</span><br><span class="line">			++first1;</span><br><span class="line">			++first2;</span><br><span class="line">		&#125;</span><br><span class="line">		++result;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">//只要两区之中有一区到达尾端，就结束上述的while循环</span></span><br><span class="line">	<span class="comment">//以下将尚未到达尾端的区间的所有剩余元素拷贝到目的端</span></span><br><span class="line">	<span class="comment">//此刻的[first1, last1)和[first2, last2)之中有一个是空白区间</span></span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">copy</span>(first2, last2, <span class="built_in">copy</span>(first1, last1, result));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="set-intersection"><a href="#set-intersection" class="headerlink" title="set_intersection"></a>set_intersection</h4><p>算法set_intersection可构造S1,S2之交集。S1，S2及其交集都是以排序区间表示。返回值为一个迭代器，指向输出空间的尾端。</p>
<p>由于S1和S2内的每个元素都不需唯一，因此，如果某个值在S1出现n次，在S2出现m次，那么该值在输出区间中会出现min(m, n)次，并且全部来自S1。在STL set容器内，m ≤ 1 且n ≤ 1。</p>
<p>set_intersection是一种稳定（stable）操作，意思是输出区间内的每个元素的相对顺序都和S1内的相对顺序相同。它有两个版本，差别在于如何定义某个元素小于另一个元素。第一版本使用operator&lt;进行比较，第二版本采用仿函数comp进行比较。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//交集，求存在于[first1, last1)且存在于[first2, last2)的所有元素</span></span><br><span class="line"><span class="comment">//注意，set是一种sorted range。这是以下算法的前提</span></span><br><span class="line"><span class="comment">//版本一</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator1</span>, <span class="keyword">class</span> <span class="title class_">InputIterator2</span>, <span class="keyword">class</span> <span class="title class_">OutputIterator</span>&gt;</span><br><span class="line"><span class="function">OutputIterator <span class="title">set_intersection</span><span class="params">(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2, OutputIterator result)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//当两个区间都尚未到达尾端时，执行以下操作...</span></span><br><span class="line">	<span class="keyword">while</span> (first1 != last1 &amp;&amp; first2 != last2)</span><br><span class="line">		<span class="comment">//在两区间内分别移动迭代器，直到遇有元素值相同，暂停，将该值记录于目标区，</span></span><br><span class="line">		<span class="comment">//再继续移动迭代器...直到两区之中有一区到达尾端</span></span><br><span class="line">		<span class="keyword">if</span> (*first1 &lt; *first2)</span><br><span class="line">			++first1;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (*first2 &lt; *first1)</span><br><span class="line">			++first2;</span><br><span class="line">		<span class="keyword">else</span> &#123; <span class="comment">//*first2 == *first1</span></span><br><span class="line">			*result = *first1;</span><br><span class="line">			++first1;</span><br><span class="line">			++first2;</span><br><span class="line">			++result;</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="set-difference"><a href="#set-difference" class="headerlink" title="set_difference"></a>set_difference</h4><p>算法set_difference可构造S1、S2之差集。S1、S2及其差集都是以排序区间表示。返回值为一个迭代器，指向输出区间的尾端。</p>
<p>由于S1和S2内的每个元素都不需唯一，因此如果某个值在S1出现n次，在S2出现m次，那么该值在输出区间中会出现max(n-m, 0)次，并且全部来自s1。在STL set容器内，m ≤ 1 且n ≤ 1。</p>
<p>set_difference是一种稳定（stable）操作，意思是输出区间内的每个元素的相对顺序都和S1内的相对顺序相同。它有两个版本，差别在于如何定义某个元素小于另一个元素。第一版本使用operator&lt;进行比较，第二版本采用仿函数comp进行比较。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//差集，求存在于[first1, last1)且不存在于[first2, last2)的所有元素</span></span><br><span class="line"><span class="comment">//注意，set是一种sorted range。这是以下算法的前提</span></span><br><span class="line"><span class="comment">//版本一</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator1</span>, <span class="keyword">class</span> <span class="title class_">InputIterator2</span>, <span class="keyword">class</span> <span class="title class_">OutputIterator</span>&gt;</span><br><span class="line"><span class="function">OutputIterator <span class="title">set_difference</span><span class="params">(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2, OutputIterator result)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//当两个区间都尚未到达尾端时，执行以下操作...</span></span><br><span class="line">	<span class="keyword">while</span> (first1 != last1 &amp;&amp; first2 != last2)</span><br><span class="line">	<span class="comment">//在两区间内分别移动迭代器。当第一区间的元素等于第二区间的元素(表示此值</span></span><br><span class="line">	<span class="comment">//同时存在于两区间)，就让两区间同时前进;当第一区间的元素大于第二区间的元素，</span></span><br><span class="line">	<span class="comment">//就让第二区间前进;有了这两种处理，就保证当第一区间的元素小于第二区间的</span></span><br><span class="line">	<span class="comment">//元素时，第一区间的元素只存在于第一区间中，不存在于第二区间，于是将它</span></span><br><span class="line">	<span class="comment">//记录于目标区</span></span><br><span class="line">	<span class="keyword">if</span> (*first1 &lt; *first2) &#123;</span><br><span class="line">		*result = *first1;</span><br><span class="line">		++first1;</span><br><span class="line">		++result;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (*first2 &lt; *first1) </span><br><span class="line">		++first2;</span><br><span class="line">	<span class="keyword">else</span> &#123;	 <span class="comment">// *first2 == *first1</span></span><br><span class="line">		++first1;</span><br><span class="line">		++first2;</span><br><span class="line"> &#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">copy</span>(first1, last1, result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="set-symmetric-difference"><a href="#set-symmetric-difference" class="headerlink" title="set_symmetric_difference"></a>set_symmetric_difference</h4><p>算法set_symmetric_difference可构造S1、S2之对称差集。此集合内含“出现于S1但不出现于S2”以及“出现于S2但不出现于S1”的每一个元素。S1、S2及其交集都是以排序区间表示。返回值为一个迭代器，指向输出区间的尾端。</p>
<p>由于S1和S2内的每个元素都不需唯一，因此如果某个值在S1出现n次，在S2出现m次，那么该值在输出区间中会出现ln-ml次。如果n &gt; m，输出区间内的最后n-m个元素将由S1复制而来，如果n &lt; m则输出区间内的最后m-n个元素将由s2复制而来。在STL set容器内，m ≤ 1 且n ≤ 1。</p>
<p>set_symmetric_difference是一种稳定（stable）操作，意思是输入区间内的元素相对顺序不会被改变。它有两个版本，差别在于如何定义某个元素小于另一个元素。第一版本使用operator&lt;进行比较，第二版本采用仿函数comp。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对称差集，求存在于[first1, last1)且不存在于[first2, last2)的所有元素，</span></span><br><span class="line"><span class="comment">//以及存在于[first2, last2)且不存在于[first1, last1)的所有元素</span></span><br><span class="line"><span class="comment">//注意，上述定义只有在“元素值独一无二”的情况下才成立。如果将set一般化，</span></span><br><span class="line"><span class="comment">//允许出现重复元素，那么set-symmetric-difference的定义应该是:</span></span><br><span class="line"><span class="comment">//如果某值在[first1, last1)出现n次，在[first2, last2)出现m次，</span></span><br><span class="line"><span class="comment">//那么它在result range中应该出现abs(n-m)次</span></span><br><span class="line"><span class="comment">//注意，set是一种sorted range。这是以下算法的前提</span></span><br><span class="line"><span class="comment">//版本一</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator1</span>, <span class="keyword">class</span> <span class="title class_">InputIterator2</span>, <span class="keyword">class</span> <span class="title class_">OutputIterator</span>&gt;</span><br><span class="line"><span class="function">OutputIterator <span class="title">set_symmetric_difference</span><span class="params">(InputIterator1 first1, InputIterator1 lastl, InputIterator2 first2, InputIterator2 last2, OutputIterator result)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//当两个区间都尚未到达尾端时，执行以下操作...</span></span><br><span class="line">	<span class="keyword">while</span> (first1 != last1 &amp;&amp; first2 != last2)</span><br><span class="line">		<span class="comment">//在两区间内分别移动迭代器。当两区间内的元素相等，就让两区同时前进；</span></span><br><span class="line">		<span class="comment">//当两区间内的元素不等，就记录较小值于目标区，并令较小值所在区间前进</span></span><br><span class="line">		<span class="keyword">if</span> (*first1 &lt; *first2) &#123;</span><br><span class="line">			*result = *first1;</span><br><span class="line">			++first1;</span><br><span class="line">			++result;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (*first2 &lt; *first1) &#123;</span><br><span class="line">			*result = *first2;</span><br><span class="line">			++first2;</span><br><span class="line">			++result;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;		<span class="comment">// *first2 == *first1</span></span><br><span class="line">			++first1;</span><br><span class="line">			++first2;</span><br><span class="line">        &#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">copy</span>(first2, last2, <span class="built_in">copy</span>(first1, last1, result));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="其它算法"><a href="#其它算法" class="headerlink" title="其它算法"></a>其它算法</h3><h4 id="单纯的数据处理"><a href="#单纯的数据处理" class="headerlink" title="单纯的数据处理"></a>单纯的数据处理</h4><h5 id="adjacent-find"><a href="#adjacent-find" class="headerlink" title="adjacent_find"></a>adjacent_find</h5><p>找出第一组满足条件的相邻元素。这里的条件，在版本一中是指“两元素相等”，在版本二中允许用户指定一个二元运算，两个操作数分别是相邻的第一元素和第二元素。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//查找相邻的重复元素。版本一</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">ForwardIterator</span>&gt;</span><br><span class="line"><span class="function">ForwardIterator <span class="title">adjacent_find</span><span class="params">(ForwardIterator first, ForwardIterator last)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (first == last) <span class="keyword">return</span> last;</span><br><span class="line">	ForwardIterator next = first;</span><br><span class="line">	<span class="keyword">while</span> (++next != last) &#123;</span><br><span class="line">		<span class="keyword">if</span> (*first == *next) <span class="keyword">return</span> first; <span class="comment">//如果找到相邻的元素值相同，就结束</span></span><br><span class="line">		first = next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> last;</span><br><span class="line">&#125;</span><br><span class="line">                              </span><br><span class="line"><span class="comment">//查找相邻的重复元素。版本二</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">ForwardIterator</span>, <span class="keyword">class</span> <span class="title class_">BinaryPredicate</span>&gt;</span><br><span class="line"><span class="function">ForwardIterator <span class="title">adjacent_find</span><span class="params">(ForwardIterator first, ForwardIterator last, BinaryPredicate binary_pred)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (first == last) <span class="keyword">return</span> last;</span><br><span class="line">	ForwardIterator next = first;</span><br><span class="line">	<span class="keyword">while</span> (++next != last) &#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">binary_pred</span>(*first, *next)) <span class="keyword">return</span> first;</span><br><span class="line">		first = next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> last;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="count"><a href="#count" class="headerlink" title="count"></a>count</h5><p>运用equality操作符，将[first, last)区间内的每一个元素拿来和指定值value比较，并返回与value相等的元素个数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>, <span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">typename</span> iterator_traits&lt;InputIterator&gt;::<span class="function">difference_type</span></span><br><span class="line"><span class="function"><span class="title">count</span><span class="params">(InputIterator first, InputIterator last, <span class="type">const</span> T&amp; value)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//以下声明一个计数器n</span></span><br><span class="line">	<span class="keyword">typename</span> iterator_traits&lt;InputIterator&gt;::difference_type n = <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> ( ; first != last; ++first)		<span class="comment">//整个区间走一遍</span></span><br><span class="line">		<span class="keyword">if</span> (*first == value)		   <span class="comment">//如果元素值和value相等</span></span><br><span class="line">			++n;					  <span class="comment">//计数器累加1</span></span><br><span class="line">	<span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="count-if"><a href="#count-if" class="headerlink" title="count_if"></a>count_if</h5><p>将指定操作（一个仿函数）pred实施于[first, last)区间内的每一个元素身上，并将“造成pred之计算结果为true”的所有元素的个数返回。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>, <span class="keyword">class</span> <span class="title class_">Predicates</span>&gt;</span><br><span class="line"><span class="keyword">typename</span> iterator_traits&lt;InputIterator&gt;::<span class="function">difference_type</span></span><br><span class="line"><span class="function"><span class="title">count_if</span><span class="params">(InputIterator first, InputIterator last, Predicate pred)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//以下声明一个计数器n</span></span><br><span class="line">	<span class="keyword">typename</span> iterator_traits&lt;InputIterator&gt;::difference_type n = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> ( ; first != last; ++first)		<span class="comment">//整个区间走一遍</span></span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">pred</span>(*first))			<span class="comment">//如果元素带入pred的运算结果为true</span></span><br><span class="line">			++n;					<span class="comment">//计数器累加1</span></span><br><span class="line">	<span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="find"><a href="#find" class="headerlink" title="find"></a>find</h5><p>根据equality操作符，循序查找[first, last)内的所有元素，找出第一个匹配“等同(equality)条件”者。如果找到，就返回一个InputIterator指向该元素，否则返回迭代器last。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>, <span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function">InputIterator <span class="title">find</span><span class="params">(InputIterator first, InputIterator last, <span class="type">const</span> T&amp; value)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (first != last &amp;&amp; *first != value) ++first;</span><br><span class="line">	<span class="keyword">return</span> first;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="find-if"><a href="#find-if" class="headerlink" title="find_if"></a>find_if</h5><p>根据指定的pred运算条件（以仿函数表示），循序查找[first, last)内的所有元素，找出第一个令pred运算结果为true者。如果找到就返回InputIterator指向该元素，否则返回迭代器last。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>, <span class="keyword">class</span> <span class="title class_">Predicate</span>&gt;</span><br><span class="line"><span class="function">InputIterator <span class="title">find_if</span><span class="params">(InputIterator first, InputIterator last, Predicate pred)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (first != last &amp;&amp; !<span class="built_in">pred</span>(*first)) ++first;</span><br><span class="line">	<span class="keyword">return</span> first;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="find-end"><a href="#find-end" class="headerlink" title="find_end"></a>find_end</h5><p>在序列一[first1, last1)所涵盖的区间中，查找序列二[first2, last2)的最后一次出现点。如果序列一之内不存在“完全匹配序列二”的子序列，便返回迭代器last1。此算法有两个版本，版本一使用元素型别所提供的equality操作符，版本二允许用户指定某个二元运算（以仿函数呈现），作为判断元素相等与否的依据。</p>
<p>由于这个算法查找的是“最后一次出现地点”，如果我们有能力逆向查找，题目就变成了“首次出现地点”，那对设计者而言当然比较省力。逆向查找的关键在于迭代器的双向移动能力，因此，SGI将算法设计为双层架构，一般称呼此种上层函数为dispatch function（分派函数、派送函数）：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//版本一</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">ForwardIterator1</span>, <span class="keyword">class</span> <span class="title class_">ForwardIterator2</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ForwardIterator1</span></span><br><span class="line"><span class="function"><span class="title">find_end</span><span class="params">(ForwardIterator1 first1, ForwardIterator1 last1, ForwardIterator2 first2, ForwardIterator2 last2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">typename</span> iterator_traits&lt;ForwardIterator1&gt;::iterator_category  category1;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">typename</span> iterator_traits&lt;ForwardIterator2&gt;::iterator_category category2;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//以下根据两个区间的类属，调用不同的下层函数</span></span><br><span class="line">	<span class="keyword">return</span> __find_end(first1, last1, first2, last2, <span class="built_in">category1</span>(), <span class="built_in">category2</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是一种常见的技巧，令函数传递调用过程中产生迭代器类型（iterator category）的临时对象，再利用编译器的参数推导机制（argument deduction)，自动调用某个对应函数。此例之对应函数有两个候选者：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以下是forward iterators版</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">ForwardIterator1</span>, <span class="keyword">class</span> <span class="title class_">ForwardIterator2</span>&gt;</span><br><span class="line">ForwardIterator1 __find_end(ForwardIterator1 first1, ForwardIterator1 last1, ForwardIterator2 first2, ForwardIterator2 last2, forward_iterator_tag, forward_iterator_tag)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (first2 == last2)	<span class="comment">//如果查找目标是空的，</span></span><br><span class="line">		<span class="keyword">return</span> last1;		<span class="comment">//返回last1，表示该“空子序列”的最后出现点</span></span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		ForwardIterator1 result = last1;</span><br><span class="line">		<span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">			<span class="comment">//以下利用search()查找某个子序列的首次出现点。找不到的话返回last1</span></span><br><span class="line">			Forwardlterator1 new_result = <span class="built_in">search</span>(first1, last1, first2, last2);</span><br><span class="line">			<span class="keyword">if</span> (new_result == last1)	<span class="comment">//没找到</span></span><br><span class="line">				<span class="keyword">return</span> result;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				result = new_result;	<span class="comment">//调动一下标兵，准备下一个查找行动</span></span><br><span class="line">				first1 = new_result;</span><br><span class="line">				++first1;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下是bidirectional iterators版（可以逆向查找）</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">BidirectionalIterator1</span>, <span class="keyword">class</span> <span class="title class_">BidirectionalIterator2</span>&gt;</span><br><span class="line">BidirectionalIterator1</span><br><span class="line">__find_end(BidirectionalIterator1 first1, BidirectionalIterator1 last1,</span><br><span class="line">		  BidirectionalIterator1 first2, BidirectionalIterator2 last2,</span><br><span class="line">		  bidirectional_iterator_tag, bidirectional_iterator_tag)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//由于查找的是“最后出现地点”，因此反向查找比较快。利用reverse_iterator。</span></span><br><span class="line">    <span class="keyword">typedef</span> reverse_iterator&lt;BidirectionalIterator1&gt; reviter1;</span><br><span class="line">    <span class="keyword">typedef</span> reverse_iterator&lt;BidirectionalIterator2&gt; reviter2;</span><br><span class="line">    </span><br><span class="line">    <span class="function">reviter1 <span class="title">rlast1</span><span class="params">(first1)</span></span>;</span><br><span class="line">    <span class="function">reviter2 <span class="title">rlast2</span><span class="params">(first2)</span></span>;</span><br><span class="line">    <span class="comment">//查找时，将序列一和序列二统统逆转方向</span></span><br><span class="line">    reviter1 rresult = <span class="built_in">search</span>(<span class="built_in">reviter1</span>(last1), rlast1,</span><br><span class="line">                              <span class="built_in">reviter2</span>(last2), rlast2);</span><br><span class="line">	<span class="keyword">if</span> (rresult == rlast1)	<span class="comment">//没找到</span></span><br><span class="line">		<span class="keyword">return</span> last1;		</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		BidirectionalIterator1 result = rresult.<span class="built_in">base</span>(); <span class="comment">//转回正常（非逆向）迭代器</span></span><br><span class="line">		<span class="built_in">advance</span>(result, -<span class="built_in">distance</span>(first2, last2)); <span class="comment">//调整回到子序列的起点处</span></span><br><span class="line">		<span class="keyword">return</span> result;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="find-first-of"><a href="#find-first-of" class="headerlink" title="find_first_of"></a>find_first_of</h5><p>本算法以[first2, last2)区间内的<strong>某些元素</strong>作为查找目标，寻找它们在[first1, last1)区间内的第一次出现地点。如果第一序列并未内含第二序列的任何元素，返回的将是last1。本算法第一个版本使用元素型别所提供的equality操作符，第二个版本允许用户指定一个二元运算pred。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//版本一</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>, <span class="keyword">class</span> <span class="title class_">ForwardIterator</span>&gt;</span><br><span class="line"><span class="function">InputIterator <span class="title">find_first_of</span> <span class="params">(InputIterator first1, InputIterator last1, ForwardIterator first2, ForwardIterator last2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> ( ; first1 != last1; ++first1) <span class="comment">//遍访序列一</span></span><br><span class="line">		<span class="comment">//以下，根据序列二的每个元素</span></span><br><span class="line">		<span class="keyword">for</span> (ForwardIterator iter = first2; iter != last2; ++iter)</span><br><span class="line">			<span class="keyword">if</span> (*first1 == *iter)	<span class="comment">//如果序列一的元素等于序列二的元素</span></span><br><span class="line">				<span class="keyword">return</span> first1;	    <span class="comment">//找到了，结束</span></span><br><span class="line">	<span class="keyword">return</span> last1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//版本二</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>, <span class="keyword">class</span> <span class="title class_">ForwardIterator</span>, <span class="keyword">class</span> <span class="title class_">BinaryPredicate</span>&gt;</span><br><span class="line"><span class="function">InputIterator <span class="title">find_first_of</span> <span class="params">(InputIterator first1, InputIterator last1, ForwardIterator first2, ForwardIterator last2, BinaryPredicate comp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> ( ; first1 != last1; ++first1) <span class="comment">//遍访序列一</span></span><br><span class="line">		<span class="comment">//以下，根据序列二的每个元素</span></span><br><span class="line">		<span class="keyword">for</span> (ForwardIterator iter = first2; iter != last2; ++iter)</span><br><span class="line">			<span class="keyword">if</span> (<span class="built_in">comp</span>(*first1, *iter)) <span class="comment">//如果序列一和序列二的元素满足comp条件</span></span><br><span class="line">				<span class="keyword">return</span> first1;		 <span class="comment">//找到了，结束</span></span><br><span class="line">	<span class="keyword">return</span> last1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="for-each"><a href="#for-each" class="headerlink" title="for_each"></a>for_each</h5><p>将仿函数f施行于[first, last)区间内的每一个元素身上。f不可以改变元素内容，因为first和last都是Inputlterators，不保证接受赋值行为(assignment)。如果想要一一修改元素内容，应该使用算法transform ( )。f可返回一个值，但该值会被忽略。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>, <span class="keyword">class</span> <span class="title class_">Function</span>&gt;</span><br><span class="line"><span class="function">Function <span class="title">for_each</span> <span class="params">(InputIterator first, InputIterator last, Function f)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> ( ; first != last; ++first)</span><br><span class="line">		<span class="built_in">f</span>(*first);	<span class="comment">//调用仿函数f的function call操作符。返回值被忽略</span></span><br><span class="line">	<span class="keyword">return</span> f;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="generate"><a href="#generate" class="headerlink" title="generate"></a>generate</h5><p>将仿函数gen的运算结果填写在[first, last)区间内的所有元素身上。所谓填写，用的是迭代器所指元素之assignment操作符。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">ForwardIterator</span>, <span class="keyword">class</span> <span class="title class_">Generator</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">generate</span><span class="params">(ForwardIterator first, ForwardIterator last, Generator gen)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> ( ; first != last; ++first)		<span class="comment">//整个序列区间</span></span><br><span class="line">		*first = <span class="built_in">gen</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="generate-n"><a href="#generate-n" class="headerlink" title="generate_n"></a>generate_n</h5><p>将仿函数gen的运算结果填写在从first开始的n个元素身上，所谓填写，用的是迭代器所指元素的assignment操作符。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">OutputIterator</span>, <span class="keyword">class</span> <span class="title class_">Size</span>, <span class="keyword">class</span> <span class="title class_">Generator</span>&gt;</span><br><span class="line"><span class="function">OutputIterator <span class="title">generate_n</span> <span class="params">(outputIterator first, Size n, Generator gen)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> ( ; n &gt; <span class="number">0</span>; --n, ++first)	<span class="comment">//只限n个元素</span></span><br><span class="line">		*first = <span class="built_in">gen</span>();</span><br><span class="line">	<span class="keyword">return</span> first;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="includes（应用于有序区间）"><a href="#includes（应用于有序区间）" class="headerlink" title="includes（应用于有序区间）"></a>includes（应用于有序区间）</h5><p>该算法判断序列二S2是否“涵盖于”序列一S1。S1和S2都必须是有序集合，其中的元素可重复（假设某元素在S2出现n次，在S1出现m次，那么如果m &lt; n，此算法会返回false）。</p>
<p>由于判断两个元素是否相等，必须以less或greater运算为依据（当S1元素不小于S2元素且S2元素不小于S1元素，两者即相等；或说当S1元素不大于S2元素且S2元素不大于S1元素，两者即相等），因此配合着两个序列S1和S2的排序方式（递增或递减)，includes算法可供用户选择采用less或greater进行两元素的大小比较(comparison) 。</p>
<p>如果S1和S2是递增排序（以operator&lt;执行比较操作），includes算法应该这么使用：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">includes</span>(S1.<span class="built_in">begin</span>(), S1.<span class="built_in">end</span>(), S2.<span class="built_in">begin</span>(), S2.<span class="built_in">end</span>());</span><br></pre></td></tr></table></figure>

<p>这和下一行完全相同：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">includes</span>(S1.<span class="built_in">begin</span>(), S1.<span class="built_in">end</span>(), S2.<span class="built_in">begin</span>(), S2.<span class="built_in">end</span>(), <span class="built_in">less</span>&lt;<span class="type">int</span>&gt;();</span><br></pre></td></tr></table></figure>


<p>然而如果S1和S2是递减排序（以operator&gt;执行比较操作），includes算法应该这么使用:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">includes</span>(S1.<span class="built_in">begin</span>(), S1.<span class="built_in">end</span>(), S2.<span class="built_in">begin</span>(), S2.<span class="built_in">end</span>(), <span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;());</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//版本一。判断区间二的每个元素值是否都存在于区间一</span></span><br><span class="line"><span class="comment">//前提:区间一和区间二都是sorted ranges</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator1</span>, <span class="keyword">class</span> <span class="title class_">InputIterator2</span>&gt;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">includes</span> <span class="params">(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (first1 != last1 &amp;&amp; first2 != last2) <span class="comment">//两个区间都尚未走完</span></span><br><span class="line">		<span class="keyword">if</span> (*first2 &lt; *first1)		<span class="comment">//序列二的元素小于序列一的元素</span></span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;		   <span class="comment">//“涵盖”的情况必然不成立。结束执行</span></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (*first1 &lt; *first2)      <span class="comment">//序列二的元素大于序列一的元素</span></span><br><span class="line">		++first1;				   <span class="comment">//序列一前进1</span></span><br><span class="line">	<span class="keyword">else</span> 						   <span class="comment">//* first1 == * first2</span></span><br><span class="line">		++first1, ++first2;			<span class="comment">//两序列各自前进1</span></span><br><span class="line">	<span class="keyword">return</span> first2 == last2;	<span class="comment">//有一个序列走完了，判断最后一关</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//版本二。判断序列一内是否有个子序列，其与序列二的每个对应元素都满足二元运算comp</span></span><br><span class="line"><span class="comment">//前提：序列一和序列二都是sorted ranges</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> InputIterator1, <span class="keyword">class</span> InputIterator2, <span class="keyword">class</span> Compare&gt;</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">includes</span> <span class="params">(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2, Compare comp)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (first1 != last1 &amp;&amp; first2 != last2)	<span class="comment">//两个区间都尚未走完</span></span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">comp</span>(*first2, *first1))	<span class="comment">//comp(s2元素,s1元素)为真</span></span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;		   <span class="comment">//“涵盖”的情况必然不成立。结束执行</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">comp</span>(*first1, *first2)) <span class="comment">//comp(s1元素,s2元素)为真</span></span><br><span class="line">			++first1; 					<span class="comment">//S1前进1</span></span><br><span class="line">		<span class="keyword">else</span>						    <span class="comment">//*first1 == *first2</span></span><br><span class="line">			++first1, ++first2;			 <span class="comment">//S1,S2各自前进1</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> first2 == last2;				<span class="comment">//有一个序列走完了，判断最后一关</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="max-element"><a href="#max-element" class="headerlink" title="max_element"></a>max_element</h5><p>该算法返回一个迭代器，指向序列之中数值最大的元素。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//版本一</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">ForwardIterator</span>&gt;</span><br><span class="line"><span class="function">ForwardIterator <span class="title">max_element</span><span class="params">(ForwardIterator first, ForwardIterator last)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (first == last) <span class="keyword">return</span> first;</span><br><span class="line">	ForwardIterator result = first;</span><br><span class="line">	<span class="keyword">while</span> (++first != last)</span><br><span class="line">		<span class="keyword">if</span> (*result &lt; *first) result = first; <span class="comment">//如果目前元素比较大，就登记起来</span></span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//版本二</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">ForwardIterator</span>, <span class="keyword">class</span> <span class="title class_">Compare</span>&gt;</span><br><span class="line"><span class="function">ForwardIterator <span class="title">max_element</span><span class="params">(ForwardIterator first, ForwardIterator last, Compare comp)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (first == last) <span class="keyword">return</span> first;</span><br><span class="line">	ForwardIterator result = first;</span><br><span class="line">	<span class="keyword">while</span> (++first != last)</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">comp</span>(*result, *first)) result = first;</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="merge（应用于有序区间）"><a href="#merge（应用于有序区间）" class="headerlink" title="merge（应用于有序区间）"></a>merge（应用于有序区间）</h5><p>该算法将两个已经排序的集合S1和S2，合并起来置于另一段空间。所得结果也是一个有序（sorted）序列 。返回一个迭代器，指向最后结果序列的最后一个元素的下一位置。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//版本一</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator1</span>, <span class="keyword">class</span> <span class="title class_">InputIterator2</span>, <span class="keyword">class</span> <span class="title class_">OutputIterator</span>&gt;</span><br><span class="line"><span class="function">OutputIterator <span class="title">merge</span><span class="params">(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2, OutputIterator result)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (first1 != last1 &amp;&amp; first2 != last2) &#123;  <span class="comment">// 两个序列都尚未走完</span></span><br><span class="line">		<span class="keyword">if</span> (*first2 &lt; *first1) &#123;	<span class="comment">//序列二的元素比较小</span></span><br><span class="line">			*result = *first2;	    <span class="comment">//登记序列二的元素</span></span><br><span class="line">			++first2;			   <span class="comment">//序列二前进1</span></span><br><span class="line">		&#125;					</span><br><span class="line">		<span class="keyword">else</span> &#123;					   <span class="comment">//序列二的元索不比较小</span></span><br><span class="line">			*result = *first1;	    <span class="comment">//登记序列一的元素</span></span><br><span class="line">			++first1;			   <span class="comment">//序列一前进1</span></span><br><span class="line">		&#125;</span><br><span class="line">		++result;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//最后剩余元素以copy复制到目的端。以下两个序列一定至少有一个为空</span></span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">copy</span>(first2, last2, <span class="built_in">copy</span>(first1, last1, result));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//版本二</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator1</span>, <span class="keyword">class</span> <span class="title class_">InputIterator2</span>, <span class="keyword">class</span> <span class="title class_">OutputIterator</span>, <span class="keyword">class</span> <span class="title class_">Compare</span>&gt;</span><br><span class="line"><span class="function">OutputIterator <span class="title">merge</span><span class="params">(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2, OutputIterator result, Compare comp)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (first1 != last1 &amp;&amp; first2 != last2) &#123; <span class="comment">//两个序列都尚未走完</span></span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">comp</span>(*first2, *first1)) &#123;	<span class="comment">//比较两序列的元素</span></span><br><span class="line">			*result = *first2;		   <span class="comment">//登记序列二的元素</span></span><br><span class="line">			++first2;				  <span class="comment">//序列二前进1</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			*result = *first1;		   <span class="comment">//登记序列一的元素</span></span><br><span class="line">			++first1;				  <span class="comment">//序列一前进1</span></span><br><span class="line">		&#125;</span><br><span class="line">		++result;</span><br><span class="line">		<span class="comment">//最后剩余元素以copy复制到目的端。以下两个序列一定至少有一个为空</span></span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">copy</span>(first2, last2, <span class="built_in">copy</span>(first1, last1, result));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="min-element"><a href="#min-element" class="headerlink" title="min_element"></a>min_element</h5><p>该算法返回一个迭代器，指向序列之中数值最小的元素。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//版本一</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">ForwardIterator</span>&gt;</span><br><span class="line"><span class="function">ForwardIterator <span class="title">min_element</span><span class="params">(ForwardIterator first, ForwardIterator last)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (first == last) <span class="keyword">return</span> first;</span><br><span class="line">	ForwardIterator result = first;</span><br><span class="line">	<span class="keyword">while</span> (++first != last)</span><br><span class="line">		<span class="keyword">if</span> (*first &lt; *result) result = first; <span class="comment">//如果目前元素比较小，就登记起来</span></span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//版本一</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">ForwardIterator</span>, <span class="keyword">class</span> <span class="title class_">Compare</span>&gt;</span><br><span class="line"><span class="function">ForwardIterator <span class="title">min_element</span><span class="params">(ForwardIterator first, ForwardIterator last, Compare comp)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (first == last) <span class="keyword">return</span> first;</span><br><span class="line">	ForwardIterator result = first;</span><br><span class="line">	<span class="keyword">while</span> (++first != last)</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">comp</span>(*first, *result)) result = first; <span class="comment">//如果目前元素比较小，就登记起来</span></span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="partition"><a href="#partition" class="headerlink" title="partition"></a>partition</h5><p>该算法会将区间[first, last)中的元素重新排列。所有被一元条件运算符pred判定为true的元素，都会被放在区间的前端，被判定为false的元素，都会被放在区间的后端。这个算法并不保证保留元素的原始相对位置。如果需要保留原始相对位置，应使用stable_partition。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//所有被pred判定为true的元素，都被放到前段</span></span><br><span class="line"><span class="comment">//被pred判定为false的元素，都被放到后段</span></span><br><span class="line"><span class="comment">//不保证保留原相对位置。(not stable)</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">BidirectionalIterator</span>, <span class="keyword">class</span> <span class="title class_">Predicate</span>&gt;</span><br><span class="line"><span class="function">BidirectionalIterator <span class="title">partition</span> <span class="params">(BidirectionalIterator first, BidirectionalIterator last, Predicate pred)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">		<span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">			<span class="keyword">if</span> (first == last)		<span class="comment">//头指针等于尾指针</span></span><br><span class="line">				<span class="keyword">return</span> first;		<span class="comment">//所有操作结束</span></span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">pred</span>(*first))	 <span class="comment">//头指针所指的元素符合不移动条件</span></span><br><span class="line">				++first;		    <span class="comment">//不移动：头指针前进1</span></span><br><span class="line">			<span class="keyword">else</span>				    <span class="comment">//头指针所指元素符合移动条件</span></span><br><span class="line">				<span class="keyword">break</span>;				<span class="comment">//跳出循环</span></span><br><span class="line">		--last;				        <span class="comment">//尾指针回溯1</span></span><br><span class="line">		<span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">			<span class="keyword">if</span> (first == last)		<span class="comment">//头指针等于尾指针</span></span><br><span class="line">				<span class="keyword">return</span> first;		<span class="comment">//所有操作结束</span></span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">pred</span>(*last))	 <span class="comment">//尾指针所指的元素符合不移动条件</span></span><br><span class="line">				--last;			    <span class="comment">//不移动：尾指针回溯1</span></span><br><span class="line">			<span class="keyword">else</span>				    <span class="comment">//尾指针所指元素符合移动条件</span></span><br><span class="line">				<span class="keyword">break</span>;				<span class="comment">//跳出循环</span></span><br><span class="line">		<span class="built_in">iter_swap</span>(first, last);		  <span class="comment">//头尾指针所指元素彼此交换</span></span><br><span class="line">		++first;					 <span class="comment">//头指针前进1，准备下一个外循环迭代</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="remove-移除（但不删除）"><a href="#remove-移除（但不删除）" class="headerlink" title="remove 移除（但不删除）"></a>remove 移除（但不删除）</h5><p>移除[first, last)之中所有与value相等的元素。这一算法并不真正从容器中删除那些元素（换句话说容器大小并未改变），而是将每一个不与value相等（也就是我们并不打算移除）的元素轮番赋值给first之后的空间。返回值ForwardIterator标示出重新整理后的最后元素的下一位置。</p>
<p><img src="/../img/remove%E7%A4%BA%E4%BE%8B.png" alt="remove示例"></p>
<p>如果想要删除那些残余数据，可将返回的迭代器交给区间所在之容器的erase() member function。</p>
<p>注意，array并不适合使用remove()和remove_if()，因为array无法缩小尺寸，导致残余数据永远存在。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> ForwardIterator, <span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function">ForwardIterator <span class="title">remove</span> <span class="params">(ForwardIterator first, ForwardIterator last, <span class="type">const</span> T&amp; value)</span>  </span>&#123;</span><br><span class="line">	first = <span class="built_in">find</span>(first, last, value); <span class="comment">//利用循序查找法找出第一个相等元</span></span><br><span class="line">	ForwardIterator next = first;	  <span class="comment">//以next标示出来</span></span><br><span class="line">	<span class="comment">//以下利用“remove_copy()允许新旧容器重叠”的性质，进行移除操作</span></span><br><span class="line">	<span class="comment">//并将结果指定置于原容器中</span></span><br><span class="line">	<span class="keyword">return</span> first == last ? first : <span class="built_in">remove_copy</span>(++next, last, first, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="remove-copy"><a href="#remove-copy" class="headerlink" title="remove_copy"></a>remove_copy</h5><p>移除[first, last)区间内所有与value相等的元素。它并不真正从容器中删除哪些元素（换句话说，原容器没有任何改变），而是将结果复制到一个以result标示起始位置的容器身上。新容器可以和原容器重叠，但如果对新容器实际给值时，超越了旧容器的大小，会产生无法预期的结果。返回值OutputIterator指出被复制的最后元素的下一位置。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>, <span class="keyword">class</span> <span class="title class_">OutputIterator</span>, <span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function">OutputIterator <span class="title">remove_copy</span> <span class="params">(InputIterator first, InputIterator last, OutputIterator result, <span class="type">const</span> T&amp; value)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> ( ; first != last; ++first)</span><br><span class="line">		<span class="keyword">if</span>(* first != value) &#123;		<span class="comment">//如果不相等</span></span><br><span class="line">			*result = *first;	    <span class="comment">//就赋值给新容器</span></span><br><span class="line">			++result;			   <span class="comment">//新容器前进一个位置</span></span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="remove-if"><a href="#remove-if" class="headerlink" title="remove_if"></a>remove_if</h5><p>移除[first, last)区间内所有被仿函数pred核定为true的元素。它并不真正从容器中删除那些元素（换句话说，容器大小并未改变）。每一个不符合pred条件的元素都会被轮番赋值给first之后的空间。返回值Forwardlterator标示出重新整理后的最后元素的下一位置。此算法会留有一些残余数据，如果要删除那些残余数据，可将返回的迭代器交给区间所在之容器的erase() member function。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">ForwardIterator</span>, <span class="keyword">class</span> <span class="title class_">Predicate</span>&gt;</span><br><span class="line"><span class="function">ForwardIterator <span class="title">remove_if</span><span class="params">(ForwardIterator first, ForwardIterator last, Predicate pred)</span> </span>&#123;</span><br><span class="line">	first = <span class="built_in">find_if</span>(first, last, pred); <span class="comment">//利用循序查找法找出第一个匹配者</span></span><br><span class="line">	ForwardIterator next = first;	    <span class="comment">//以next标记出来</span></span><br><span class="line">	<span class="comment">//以下利用“remove_copy_if()允许新旧容器重叠”的性质，做删除操作</span></span><br><span class="line">	<span class="comment">//并将结果放到原容器中</span></span><br><span class="line">	<span class="keyword">return</span> first == last ? first : <span class="built_in">remove_copy_if</span>(++next, last, first, pred);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="remove-copy-if"><a href="#remove-copy-if" class="headerlink" title="remove_copy_if"></a>remove_copy_if</h5><p>移除[first, last)区间内所有被仿函数pred评估为true的元素。它并不真正从容器中删除那些元素（换句话说原容器没有任何改变），而是将结果复制到一个以result标示起始位置的容器身上。新容器可以和原容器重叠，但如果针对新容器实际给值时，超越了旧容器的大小，会产生无法预期的结果。返回值OutputIterator指出被复制的最后元素的下一位置。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>, <span class="keyword">class</span> <span class="title class_">OutputIterator</span>, <span class="keyword">class</span> <span class="title class_">Predicate</span>&gt;</span><br><span class="line"><span class="function">OutputIterator <span class="title">remove_copy_if</span> <span class="params">(InputIterator first, InputIterator last, OutputIterator result, Predicate pred)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> ( ; first != last; ++first)</span><br><span class="line">		<span class="keyword">if</span> (!<span class="built_in">pred</span>(*first)) &#123;	<span class="comment">//如果pred核定为false,</span></span><br><span class="line">			*result = *first;	<span class="comment">//就赋值给新容器（保留，不删除)</span></span><br><span class="line">			++result;		   <span class="comment">//新容器前进一个位置</span></span><br><span class="line">        &#125;</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="replace"><a href="#replace" class="headerlink" title="replace"></a>replace</h5><p>将[first, last)区间内的所有old_value都以new_value取代。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">ForwardIterator</span>, <span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">replace</span><span class="params">(ForwardIterator first, ForwardIterator last, <span class="type">const</span> T&amp; old_value, <span class="type">const</span> T&amp; new_value)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//将区间内的所有old_value都以new_value取代</span></span><br><span class="line">	<span class="keyword">for</span> ( ; first != last; ++first)</span><br><span class="line">		<span class="keyword">if</span> (*first == old_value) *first = new_value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="replace-copy"><a href="#replace-copy" class="headerlink" title="replace_copy"></a>replace_copy</h5><p>行为与replace()类似，唯一不同的是新序列会被复制到result所指的容器中。返回值Outputlterator指向被复制的最后一个元素的下一位置。原序列没有任何改变。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>, <span class="keyword">class</span> <span class="title class_">OutputIterator</span>, <span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function">OutputIterator <span class="title">replace_copy</span><span class="params">(InputIterator first, InputIterator last, OutputIterator result, <span class="type">const</span> T&amp; old_value, <span class="type">const</span> T&amp; new_value)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> ( ; first != last; ++first, ++result)</span><br><span class="line">		<span class="comment">//如果旧序列上的元素等于old_value，就放new_value到新序列中</span></span><br><span class="line">		<span class="comment">//否则就将元素拷贝一份放进新序列中</span></span><br><span class="line">		*result = *first == old_value ? new_value : *first;</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="replace-if"><a href="#replace-if" class="headerlink" title="replace_if"></a>replace_if</h5><p>将[first, last)区间内所有“被pred评估为true”的元素，都以new value取而代之。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">ForwardIterator</span>, <span class="keyword">class</span> <span class="title class_">Predicate</span>, <span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">replace_if</span><span class="params">(ForwardIterator first, ForwardIterator last,  Predicate pred, <span class="type">const</span> T&amp; new_value)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> ( ; first != last; ++first)</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">pred</span>(*first)) *first = new_value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="replace-copy-if"><a href="#replace-copy-if" class="headerlink" title="replace_copy_if"></a>replace_copy_if</h5><p>行为与replace_if()类似，但是新序列会被复制到result所指的区间内。返回值Outputlterator指向被复制的最后一个元素的下一位置。原序列无任何改变。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Iterator</span>, <span class="keyword">class</span> <span class="title class_">OutputIterator</span>, <span class="keyword">class</span> <span class="title class_">Predicate</span>, <span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function">OutputIterator <span class="title">replace_copy_if</span><span class="params">(Iterator first, Iterator last, OutputIterator result, Predicate pred, <span class="type">const</span> T&amp; new_value)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> ( ; first ! = last; ++first, ++result)</span><br><span class="line">		<span class="comment">//如果旧序列上的元素被pred评估为true，就放new_value到新序列中，</span></span><br><span class="line">		<span class="comment">//否则就将元素拷贝一份放进新序列中</span></span><br><span class="line">		*result = <span class="built_in">pred</span>(*first) ? new_value : *first;</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="reverse"><a href="#reverse" class="headerlink" title="reverse"></a>reverse</h5><p>将序列[first, last)的元素在原容器中颠倒重排。例如序列{0,1,1,3,5}颠倒重排后为{5,3,1,1,0}。迭代器的双向或随机定位能力，影响了这个算法的效率，所以设计为双层架构：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//分派函数(dispatch function)</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">BidirectionalIterator</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">reverse</span><span class="params">(BidirectionalIterator first, BidirectionalIterator last)</span> </span>&#123;</span><br><span class="line">	__reverse(first, last, <span class="built_in">iterator_category</span>(first));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//reverse的bidirectional iterator版</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">BidirectionalIterator</span>&gt;</span><br><span class="line"><span class="type">void</span> __reverse(BidirectionalIterator first, BidirectionalIterator last, bidirectional_iterator_tag) &#123;</span><br><span class="line">	<span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">		<span class="keyword">if</span> (first == last || first == --last)</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="built_in">iter_swap</span>(first++, last);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//reverse的random access iterator版</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">RandomAccessIterator</span>&gt;</span><br><span class="line"><span class="type">void</span> __reverse(RandomAccessIterator first, RandomAccessIterator last, random_access_iterator_tag) &#123;</span><br><span class="line">	<span class="comment">//以下，头尾两两互换，然后头部累进一个位置，尾部累退一个位置。两者交错时即停止</span></span><br><span class="line">	<span class="comment">//注意，只有random iterators才能做以下的 first &lt; last 判断</span></span><br><span class="line">	<span class="keyword">while</span> (first &lt; last) <span class="built_in">iter_swap</span> (first++, --last);</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h5 id="reverse-copy"><a href="#reverse-copy" class="headerlink" title="reverse_copy"></a>reverse_copy</h5><p>行为类似reverse()，但产生出来的新序列会被置于以result指出的容器中。返回值Outputlterator指向新产生的最后元素的下一位置。原序列没有任何改变。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">BidirectionalIterator</span>, <span class="keyword">class</span> <span class="title class_">OutputIterator</span>&gt;</span><br><span class="line"><span class="function">OutputIterator <span class="title">reverse_copy</span><span class="params">(BidirectionalIterator first, BidirectionalIterator last, OutputIterator result)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (first ! = last) &#123;	<span class="comment">//整个序列走一遍</span></span><br><span class="line">		--last;			       <span class="comment">//尾端前移一个位置</span></span><br><span class="line">		*result = *last;	    <span class="comment">//将尾端所指元素复制到result所指位置</span></span><br><span class="line">		++result;			   <span class="comment">//result前进一个位置</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="rotate"><a href="#rotate" class="headerlink" title="rotate"></a>rotate</h5><p>将[first, middle)内的元素和[middle, last)内的元素互换。middle所指的元素会成为容器的第一个元素。</p>
<p>看起来这和swap_ranges()功能颇为近似，但swap_ranges()只能交换两个长度相同的区间，rotate()可以交换两个长度不同的区间。</p>
<p>迭代器的移动能力，影响了这个算法的效率，所以设计为双层架构：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//分派函数（dispatch function）</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">ForwardIterator</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">rotate</span><span class="params">(ForwardIterator first, ForwardIterator middle, ForwardIterator last)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (first == middle || middle == last) <span class="keyword">return</span>;</span><br><span class="line">	__rotate(first, middle, last, <span class="built_in">distance_type</span>(first), <span class="built_in">iterator_category</span>(first));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面是根据不同的迭代器类型而完成的三个旋转操作：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// rotate 的 forward iterator 版</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">ForwardIterator</span>, <span class="keyword">class</span> <span class="title class_">Distance</span>&gt;</span><br><span class="line"><span class="type">void</span> __rotate(ForwardIterator first, ForwardIterator middle, ForwardIterator last, Distance*, forward_iterator_tag) &#123;</span><br><span class="line">	<span class="keyword">for</span> (ForwardIterator i = middle; ; ) &#123;</span><br><span class="line">		<span class="built_in">iter_swap</span>(first, i);	<span class="comment">//前段、后段的元素一一交换</span></span><br><span class="line">		++first;			   <span class="comment">//双双前进1</span></span><br><span class="line">		++i;</span><br><span class="line">		<span class="comment">//以下判断是前段[first, middle)先结束还是后段[middle, last)先结束</span></span><br><span class="line">		<span class="keyword">if</span> (first == middle) &#123;		<span class="comment">//前段结束了</span></span><br><span class="line">			<span class="keyword">if</span> (i == last ) <span class="keyword">return</span>; <span class="comment">//如果后段同时也结束，整个就结束了</span></span><br><span class="line">			middle = i;	            <span class="comment">//否则调整，对新的前、后段再作交换</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (i == last)		    <span class="comment">//后段先结束</span></span><br><span class="line">			i = middle; 		   <span class="comment">//调整，准备对新的前、后段再作交换</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//rotate 的 bidirectiona1 iterator 版</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">BidirectionalIterator</span>, <span class="keyword">class</span> <span class="title class_">Distance</span>&gt;</span><br><span class="line"><span class="type">void</span> __rotate(BidirectionalIterator first, BidirectionalIterator middle, BidirectionalIterator last, Distance*, bidirectional_iterator_tag) &#123;</span><br><span class="line">	<span class="built_in">reverse</span>(first, middle);</span><br><span class="line">	<span class="built_in">reverse</span>(middle, last);</span><br><span class="line">	<span class="built_in">reverse</span>(first, last);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// rotate 的 random access iterator 版</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">RandomAccessIterator</span>, <span class="keyword">class</span> <span class="title class_">Distance</span>&gt;</span><br><span class="line"><span class="type">void</span> __rotate(RandomaAccessIterator first, RandomAccessIterator middle</span><br><span class="line">			 RandomAccessIterator last, Distance*,</span><br><span class="line">			 random_access_iterator_tag) &#123;</span><br><span class="line">	<span class="comment">//以下迭代器的相减操作，只适用于random access iterators</span></span><br><span class="line">	<span class="comment">//取全长和前段长度的最大公因子</span></span><br><span class="line">	Distance n = __gcd(last - first, middle - first);</span><br><span class="line">	<span class="keyword">while</span> (n--)</span><br><span class="line">		__rotate_cycle(first, last, first + n, middle - first, <span class="built_in">value_type</span>(first));	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//最大公因子，利用辗转相除法</span></span><br><span class="line"><span class="comment">// __gcd()应用于__rotate()的random access iterator版</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">EuclideanRingElement</span>&gt;</span><br><span class="line">EuclideanRingE1ement __gcd(EuclideanRingElement m, EuclideanRingElement n)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">while</span> (n != <span class="number">0</span>) &#123;</span><br><span class="line">		EuclideanRingElement t = m % n;</span><br><span class="line">		m = n;</span><br><span class="line">		n = t;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> m;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">RandomAccessIterator</span>, <span class="keyword">class</span> <span class="title class_">Distance</span>, <span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> __rotate_cycle(RandomAccessIterator first, RandomAccessIterator last, RandomAccessIterator initial, Distance shift, T*) &#123;</span><br><span class="line">	T value = *initial;</span><br><span class="line">	RandomAccessIterator ptr1 = initial;</span><br><span class="line">	RandomAccessIterator ptr2 = ptr1 + shift;</span><br><span class="line">	<span class="keyword">while</span> (ptr2 ! = initial) &#123;</span><br><span class="line">		*ptr1 = *ptr2;</span><br><span class="line">		ptr1 = ptr2;</span><br><span class="line">		<span class="keyword">if</span> (last - ptr2 &gt; shift)</span><br><span class="line">			ptr2 += shift;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			ptr2 = first + (shift - (last - ptr2));</span><br><span class="line">	&#125;</span><br><span class="line">	*ptr1 = value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="rotate-copy"><a href="#rotate-copy" class="headerlink" title="rotate_copy"></a>rotate_copy</h5><p>行为类似rotate()，但产生出来的新序列会被置于result所指出的容器中。返回值OutputIterator指向新产生的最后元素的下一位置。原序列没有改变。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">ForwardIterator</span>, <span class="keyword">class</span> <span class="title class_">OutputIterator</span>&gt;</span><br><span class="line"><span class="function">OutputIterator <span class="title">rotate_copy</span><span class="params">(ForwardIterator first, ForwardIterator middle, ForwardIterator last, OutputIterator result)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">copy</span>(first, middle, <span class="built_in">copy</span>(middle, last, result));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="search"><a href="#search" class="headerlink" title="search"></a>search</h5><p>在序列以[first1, last1)所涵盖的区间中，查找序列二[first2, last2)的首次出现点。如果序列一内不存在与序列二完全匹配的子序列，便返回迭代器last1.版本一使用元素型别所提供的equality操作符，版本二允许用户指定某个二元运算（以仿函数呈现），作为判断相等与否的 依据。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//查找子序列首次出现地点</span></span><br><span class="line"><span class="comment">//版本一</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">ForwardIterator1</span>, <span class="keyword">class</span> <span class="title class_">ForwardIterator2</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ForwardIterator1 <span class="title">search</span><span class="params">(Forwarditerator1 first1, ForwardIterator1 last1, ForwardIterator2 first2, ForwardIterator2 last2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> __search(first1, last1, first2, last2, <span class="built_in">distance_type</span>(first1),</span><br><span class="line">				<span class="built_in">distance_type</span>(first2));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">ForwardIterator1</span>, <span class="keyword">class</span> <span class="title class_">ForwardIterator2</span>, <span class="keyword">class</span> <span class="title class_">Distance1</span>, <span class="keyword">class</span> <span class="title class_">Distance2</span>&gt;</span><br><span class="line">ForwardIterator1 __search (ForwardIterator1 first1, ForwardIterator1 last1, ForwardIterator2 first2, ForwardIterator2 last2, Distance1*, Distance2*) &#123;</span><br><span class="line">	Distance1 d1 = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">distance</span>(first1, last1, d1);</span><br><span class="line">	Distance2 d2 = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">distance</span>(first2, last2, d2);</span><br><span class="line">	<span class="keyword">if</span> (dl &lt; d2) <span class="keyword">return</span> last1; <span class="comment">// 如果第二序列大于第一序列，不可能成为其子序列</span></span><br><span class="line">	</span><br><span class="line">	ForwardIterator1 current1 = first1;</span><br><span class="line">	ForwardIterator2 current2 = first2;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (current2 != last2)	<span class="comment">//遍历整个第二序列</span></span><br><span class="line">		<span class="keyword">if</span> (*current1 == *current2) &#123;	<span class="comment">//如果这个元素相同</span></span><br><span class="line">			++current1;				   <span class="comment">//调整，以便比对下一个元素</span></span><br><span class="line">			++current2;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;					<span class="comment">//如果这个元素不等</span></span><br><span class="line">			<span class="keyword">if</span> (d1 == d2)		<span class="comment">//如果两序列一样长</span></span><br><span class="line">				<span class="keyword">return</span> last1;   <span class="comment">//表示不可能成功了</span></span><br><span class="line">			<span class="keyword">else</span> &#123;			   <span class="comment">//两序列不一样长（至此肯定是序列一大于序列二)</span></span><br><span class="line">				current1 = ++first1;	<span class="comment">//调整第一序列的标兵，</span></span><br><span class="line">				current2 = first2;	    <span class="comment">//准备在新起点上再找一次</span></span><br><span class="line">				--d1;	 <span class="comment">//已经排除了序列的一个元素，所以序列一的长度要减1</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">return</span> first1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="search-n"><a href="#search-n" class="headerlink" title="search_n"></a>search_n</h5><p>在序列[first, last)所涵盖的区间中，查找“连续count个符合条件之元素”所形成的子序列，并返回一个迭代器指向该子序列起始处。如果找不到这样的子序列，就返回迭代器last。上述所谓的“某条件”，在 search_n 版本一指的是相等条件“equality”，在search_n版本二指的是用户指定的某个二元运算（以仿函数呈现）。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//版本一</span></span><br><span class="line"><span class="comment">//查找	“元素value 连续出现 count次”所形成的那个子序列，返回其发生位置</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">ForwardIterator</span>, <span class="keyword">class</span> <span class="title class_">Integer</span>, <span class="keyword">class</span> <span class="title class_">T</span>&gt; </span><br><span class="line"><span class="function">ForwardIterator <span class="title">search_n</span><span class="params">(ForwardIterator first, ForwardIterator last, Integer count, <span class="type">const</span> T&amp; value)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (count &lt;= <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> first;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		first = <span class="built_in">find</span>(first, last, value); <span class="comment">//首先找出value第一次出现点</span></span><br><span class="line">		<span class="keyword">while</span> (first != last) &#123;		   <span class="comment">//继续查找余下元素</span></span><br><span class="line">			Integer n = count - <span class="number">1</span>;	   <span class="comment">//value还应出现n次</span></span><br><span class="line">			ForwardIterator i = first; <span class="comment">//从上次出现点接下去查找</span></span><br><span class="line">			++i;</span><br><span class="line">			<span class="keyword">while</span> (i != last &amp;&amp; n != <span class="number">0</span> &amp;&amp; *i == value) &#123; <span class="comment">//下个元素是value</span></span><br><span class="line">				++i;</span><br><span class="line">				--n;		<span class="comment">//既然找到了，“value应再出现次数”便可减1</span></span><br><span class="line">			&#125;				<span class="comment">//回到内循环内继续查找</span></span><br><span class="line">			<span class="keyword">if</span> (n == <span class="number">0</span>)	<span class="comment">//n==0表示确实找到了“元素值出现n次”的子序列。功德圆满</span></span><br><span class="line">				<span class="keyword">return</span> first;</span><br><span class="line">			<span class="keyword">else</span>		<span class="comment">//功德尚未圆满…</span></span><br><span class="line">				first = <span class="built_in">find</span>(i, last, value); <span class="comment">//找value 的下一个出现点，并准备回到外循环</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> last;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//版本二</span></span><br><span class="line"><span class="comment">//查找“连续count个元素皆满足指定条件”所形成的那个子序列的起点，返回其发生位置</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">ForwardIterator</span>, <span class="keyword">class</span> <span class="title class_">Integer</span>, <span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">BinaryPredicate</span>&gt;</span><br><span class="line"><span class="function">ForwardIterator <span class="title">search_n</span><span class="params">(ForwardIterator first, ForwardIterator last, Integer count, <span class="type">const</span> T&amp; value, BinaryPredicate binary_pred)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (count &lt;= <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> first;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">while</span>(first != last) &#123;</span><br><span class="line">			<span class="keyword">if</span> (<span class="built_in">binary_pred</span>(*first, value)) <span class="keyword">break</span>;   <span class="comment">//首先找出第一个符合条件的元素</span></span><br><span class="line">			++first;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">while</span> (first != last) &#123;		   <span class="comment">//继续查找余下元素</span></span><br><span class="line">			Integer n = count - <span class="number">1</span>;	   <span class="comment">//value还应出现n次</span></span><br><span class="line">			ForwardIterator i = first; <span class="comment">//从上次出现点接下去查找</span></span><br><span class="line">			++i;</span><br><span class="line">			<span class="keyword">while</span> (i != last &amp;&amp; n != <span class="number">0</span> &amp;&amp; <span class="built_in">binary_pred</span>(*i, value)) &#123; <span class="comment">//下个元素是value</span></span><br><span class="line">				++i;</span><br><span class="line">				--n;		<span class="comment">//既然找到了，“value应再出现次数”便可减1</span></span><br><span class="line">			&#125;				<span class="comment">//回到内循环内继续查找</span></span><br><span class="line">			<span class="keyword">if</span> (n == <span class="number">0</span>)	<span class="comment">//n==0表示确实找到了“元素值出现n次”的子序列。功德圆满</span></span><br><span class="line">				<span class="keyword">return</span> first;</span><br><span class="line">			<span class="keyword">else</span> &#123;		<span class="comment">//功德尚未圆满…</span></span><br><span class="line">				<span class="keyword">while</span> (i != last) &#123;</span><br><span class="line">					<span class="keyword">if</span> (<span class="built_in">binary_pred</span>(*i, value)) <span class="keyword">break</span>;                    </span><br><span class="line">					++i;</span><br><span class="line">				&#125;</span><br><span class="line">				first = i;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> last;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="swap-ranges"><a href="#swap-ranges" class="headerlink" title="swap_ranges"></a>swap_ranges</h5><p>将[first1, last1)区间内的元素与“从first2开始、个数相同”的元素互相交换。这两个序列可位于同一容器中，也可位于不同的容器中。如果第二序列的长度小于第一序列，或是两序列在同一容器中且彼此重叠，执行结果未可预期。此算法返回一个迭代器，指向第二序列中的最后一个被交换元素的下一位置。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将两段等长区间内的元素互换</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">ForwardIterator1</span>, <span class="keyword">class</span> <span class="title class_">ForwardIterator2</span>&gt;</span><br><span class="line"><span class="function">ForwardIterator2 <span class="title">swap_ranges</span><span class="params">(ForwardIterator1 first1, ForwardIterator1 last1, ForwardIterator2 first2)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> ( ; first1 != last1; ++first1, ++first2)</span><br><span class="line">		<span class="built_in">iter_swap</span>(first1, first2);</span><br><span class="line">	<span class="keyword">return</span> first2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="transform"><a href="#transform" class="headerlink" title="transform"></a>transform</h5><p>transform()的第一版本以仿函数op作用于[first, last)中的每一个元素身上，并以其结果产生出一个新序列。第二版本以仿函数binary_op作用于一双元素身上（其中一个元素来自 [first1, last)，另一个元素来自“从first2开始的序列”)，并以其结果产生出一个新序列。如果第二序列的元素少于第一序列，执行结果未可预期。</p>
<p>transform()的两个版本都把执行结果放进迭代器result所标示的容器中。result也可以指向源端容器，那么transform()的运算结果就会取代该容器内的元素。返回值OutputIterator将指向结果序列的最后元素的下一位置。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//版本一</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> InputIterator, <span class="keyword">class</span> OutputIterator, <span class="keyword">class</span> UnaryOperation&gt;</span></span><br><span class="line"><span class="function">OutputIterator <span class="title">transform</span><span class="params">(InputIterator first, InputIterator last, OutputIterator result, UnaryOperation op)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> ( ; first != last; ++first, ++result)</span><br><span class="line">		*result = <span class="built_in">op</span>(*first);</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//版本二</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator1</span>, <span class="keyword">class</span> <span class="title class_">InputIterator2</span>, <span class="keyword">class</span> <span class="title class_">OutputIterator</span>, <span class="keyword">class</span> <span class="title class_">BinaryOperation</span>&gt;</span><br><span class="line"><span class="function">OutputIterator <span class="title">transform</span><span class="params">(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, OutputIterator result, BinaryOperation binary_op)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> ( ; first1 != last1; ++first1, ++first2, ++result)</span><br><span class="line">		*result = <span class="built_in">binary_op</span>(*first1, *first2);</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="unique"><a href="#unique" class="headerlink" title="unique"></a>unique</h5><p>算法unique能够移除（remove）重复的元素。每当在[first, last)内遇有重复元素群，它便移除该元素群中第一个以后的所有元素。因此，unique想要移除包括不相邻的所有重复元素，必须先将序列排序，使所有重复元素都相邻。</p>
<p>unique会返回一个迭代器指向新区间的尾端，新区间之内不含相邻的陈聪父元素。</p>
<p>事实上unique并不会改变[first, last)的元素个数，有一些残余数据会留下，情况类似于remove算法。</p>
<p>unique有两个版本，因为所谓“相邻元素是否重复”可有不同的定义。第一版本使用简单的相等（equality）测试，第二版本使用一个 Binary Predicate binary_pred做为测试准则。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//版本一</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">ForwardIterator</span>&gt;</span><br><span class="line"><span class="function">ForwardIterator <span class="title">unique</span><span class="params">(ForwardIterator first, ForwardIterator last)</span> </span>&#123;</span><br><span class="line">	first = <span class="built_in">adjacent_find</span>(first, last);		<span class="comment">//首先找到相邻重复元素的起点</span></span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">unique_copy</span>(first, last, first);	 <span class="comment">//利用unique_copy完成</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="unique-copy"><a href="#unique-copy" class="headerlink" title="unique_copy"></a>unique_copy</h5><p>算法unique_copy可从[first, last)中将元素复制到以result开头的区间上；如果面对相邻重复元素群，只会复制其中第一个元素。返回的迭代器指向以result开头的区间的尾端。</p>
<p>unique_copy有两个版本，因为所谓“相邻元素是否重复”可有不同的定义。第一版本使用简单的相等(equality)测试，第二版本使用一个Binary Predicate binary_pred作为测试准则。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//版本一</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>, <span class="keyword">class</span> <span class="title class_">OutputIterator</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> OutputIterator <span class="title">unique_copy</span><span class="params">(InputIterator first, InputIterator last, OutputIterator result)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (first == last) <span class="keyword">return</span> result;</span><br><span class="line">	<span class="comment">//以下，根据result的iterator category，做不同的处理</span></span><br><span class="line">	<span class="keyword">return</span> __unique_copy(first, last, result, <span class="built_in">iterator_category</span>(result));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//版本一辅助函数，forward_iterator_tag版</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>, <span class="keyword">class</span> <span class="title class_">ForwardIterator</span>&gt;</span><br><span class="line">Forwardrterator __unique_copy(InputIterator first, InputIterator last, ForwardIterator result, forward_iterator_tag) &#123;</span><br><span class="line">	*result = *first;		<span class="comment">//记录第一个元素</span></span><br><span class="line">	<span class="keyword">while</span> (++first != last)	 <span class="comment">//遍历整个区间</span></span><br><span class="line">		<span class="comment">//以下，元素不同，就记录，否则（元素相同），就跳过</span></span><br><span class="line">		<span class="keyword">if</span> (*result != *first) *++result = *first;</span><br><span class="line">	<span class="keyword">return</span> ++result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//版本一辅助函数,output_iterator_tag版</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>, <span class="keyword">class</span> <span class="title class_">OutputIterator</span>&gt;</span><br><span class="line"><span class="keyword">inline</span> OutputIterator __unique_copy(InputIterator first, InputIterator last, OutputIterator result, output_iterator_tag) &#123;</span><br><span class="line">	<span class="comment">//以下,output iterator有一些功能限制，所以必须先知道其value type.</span></span><br><span class="line">	<span class="keyword">return</span> __unique_copy(first, last, result, <span class="built_in">value_type</span>(first));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//由于output iterator为write only，无法像forward iterator那般可以读取</span></span><br><span class="line"><span class="comment">//所以不能有类似*result != *first这样的判断操作，所以才需要设计这一版本</span></span><br><span class="line"><span class="comment">//例如ostream_iterator就是一个output iterator.</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>, <span class="keyword">class</span> <span class="title class_">outputIterator</span>, <span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">OutputIterator __unique_copy(InputIterator first, InputIterator last, OutputIterator result, T*) &#123;</span><br><span class="line">	<span class="comment">// T 为input iterator 的value type</span></span><br><span class="line">	T value = *first;</span><br><span class="line">	*result = value;</span><br><span class="line">	<span class="keyword">while</span> (++first != last)</span><br><span class="line">		<span class="keyword">if</span> (value != *first) &#123;</span><br><span class="line"> 			value = *first;</span><br><span class="line">			*++result = value;</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">return</span> ++result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="lower-bound（应用于有序区间）"><a href="#lower-bound（应用于有序区间）" class="headerlink" title="lower_bound（应用于有序区间）"></a>lower_bound（应用于有序区间）</h4><p>算法利用二分查找（binary search），指出已排序的区间[first, last)中第一个“不小于value”的元素（不破坏排序状态下，可插入value的第一个位置）。如果value大于[first, last)内的任何一个元素，则返回last。</p>
<p>这个算法有两个版本，版本一采用operator&lt;进行比较，版本二采用仿函数comp。更正式地说，版本一返回[first, last)中最远的迭代器i，使得[first, i)中的每个迭代器j都满足*j &lt; value。版本二返回[first, last)中最远的迭代器i，使[first, i)中的每个迭代器j都满足“comp(*j, value)为真”。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//版本一</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">ForwardIterator</span>, <span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ForwardIterator <span class="title">lower_bound</span><span class="params">(ForwardIterator first, ForwardIterator last, <span class="type">const</span> T&amp; value)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> __lower_bound(first, last, value, <span class="built_in">distance_type</span>(first),</span><br><span class="line">						<span class="built_in">iterator_category</span>(first));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//版本二</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">ForwardIterator</span>, <span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Compare</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ForwardIterator <span class="title">lower_bound</span><span class="params">(ForwardIterator first, ForwardIterator last, <span class="type">const</span> T&amp; value, Compare comp)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> __lower_bound(first, last, value, comp, <span class="built_in">distance_type</span>(first),</span><br><span class="line">						<span class="built_in">iterator_category</span>(first));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//版本一的forward_iterator版本</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">ForwardIterator</span>, <span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Distance</span>&gt;</span><br><span class="line">ForwardIterator __lower_bound(ForwardIterator first, ForwardIterator last, <span class="type">const</span> T&amp; value, Distance*, forward_iterator_tag) &#123;</span><br><span class="line">	Distance len = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">distance</span>(first, last, len);	<span class="comment">//求取整个区间的长度len</span></span><br><span class="line">	Distance half;</span><br><span class="line">	ForwardIterator middle;</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">while</span> (len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">		half = len &gt;&gt; <span class="number">1</span>;		<span class="comment">//除以2</span></span><br><span class="line">		middle = first;			<span class="comment">//这两行令middle指向中间位置</span></span><br><span class="line">		<span class="built_in">advance</span>(middle, half);</span><br><span class="line">		<span class="keyword">if</span> (*middle &lt; value) &#123;   <span class="comment">//如果中间位置的元素值 &lt; 标的值</span></span><br><span class="line">			first = middle;		<span class="comment">//这两行令first指向middle的下一位置</span></span><br><span class="line">			++first;</span><br><span class="line">			len = len - half - <span class="number">1</span>;<span class="comment">//修正len，回头测试循环的结束条件</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			len = half;			<span class="comment">//修正len，回头测试循环的结束条件</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> first;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//版本一的random_access_iterator版本</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">RandomAccessIterator</span>, <span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Distance</span>&gt;</span><br><span class="line">RandomAccessIterator __lower_bound(RandomAccessIterator first, RandomAccessiterator last, <span class="type">const</span> T&amp; value, Distance*, random_access_iterator_tag) &#123;</span><br><span class="line">	Distance len = last - first;	<span class="comment">//求取整个区间的长度len</span></span><br><span class="line">	Distance half;</span><br><span class="line">	RandomAccessIterator middle;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">		half = len &gt;&gt; <span class="number">1</span>;			<span class="comment">//除以2</span></span><br><span class="line">		middle = first + half;		<span class="comment">//令middle指向中间位置（r-a-i才能如此)</span></span><br><span class="line">		<span class="keyword">if</span> (*middle &lt; value) &#123;		<span class="comment">//如果中间位置的元素值&lt;目标值</span></span><br><span class="line">			first = middle + <span class="number">1</span>;		<span class="comment">//令first指向middle的下一位置</span></span><br><span class="line">			len = len - half - <span class="number">1</span>;	<span class="comment">//修正len，回头测试循环的结束条件</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			len = half;				<span class="comment">//修正len，回头测试循环的结束条件</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> first;</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>

<h4 id="upper-bound（应用于有序区间）"><a href="#upper-bound（应用于有序区间）" class="headerlink" title="upper_bound（应用于有序区间）"></a>upper_bound（应用于有序区间）</h4><p>算法利用二分查找（binary seaarch），它会返回“在不破坏顺序的情况下，可插入value的最后一个合适位置”。</p>
<p>upper_bound和lower_bound的区别：</p>
<p><img src="/../img/upper_bound%E5%92%8Clower_bound.png" alt="upper_bound和lower_bound"></p>
<p>upper_bound有两个版本，版本一采用operator&lt;进行比较，版本二采用仿函数comp。更正式地说，版本一返回[first, last)区间内最远的迭代器i，使[first, i)内的每个迭代器j都满足“value &lt; *j不为真”。版本二返回[first, last)区间内最远的迭代器i，使[first, i)中的每个迭代器j都满足“comp(value, *j)不为真”。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//版本一</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">ForwardIterator</span>, <span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ForwardIterator <span class="title">upper_bound</span><span class="params">(ForwardIterator first, ForwardIterator last, <span class="type">const</span> T&amp; value)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> __upper_bound(first, last, value, <span class="built_in">distance_type</span>(first),</span><br><span class="line">						<span class="built_in">iterator_category</span>(first));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//版本二</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">ForwardIterator</span>, <span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Compare</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ForwardIterator <span class="title">upper_bound</span><span class="params">(ForwardIterator first, ForwardIterator last, <span class="type">const</span> T&amp; value, Compare comp)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> __upper_bound(first, last, value, comp, <span class="built_in">distance_type</span>(first),</span><br><span class="line">						<span class="built_in">iterator_category</span>(first));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//版本一的forward_iterator版本</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">ForwardIterator</span>, <span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Distance</span>&gt;</span><br><span class="line">ForwardIterator __upper_bound(ForwardIterator first, ForwardIterator last, <span class="type">const</span> T&amp; value, Distance*, forward_iterator_tag) &#123;</span><br><span class="line">	Distance len = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">distance</span>(first, last, len);	<span class="comment">//求取整个区间的长度len</span></span><br><span class="line">	Distance half;</span><br><span class="line">	ForwardIterator middle;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">		half = len &gt;&gt; <span class="number">1</span>;			<span class="comment">//除以2</span></span><br><span class="line">		middle = first;				<span class="comment">//这两行令middle指向中间位置</span></span><br><span class="line">		<span class="built_in">advance</span>(middle, half);</span><br><span class="line">		<span class="keyword">if</span> (value &lt; *middle)		 <span class="comment">//如果中间位置的元素值&gt;标的值</span></span><br><span class="line">			len = half;				<span class="comment">//修正len，回头测试循环的结束条件</span></span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			first = middle;			<span class="comment">//这两行令first指向middle的下一位置</span></span><br><span class="line">			++first;</span><br><span class="line">			len = len - half - <span class="number">1</span>;	<span class="comment">//修正 len，回头测试循环的结束条件</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> first;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//版本一的random_access_iterator版本</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">RandomAccessIterator</span>, <span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Distance</span>&gt;</span><br><span class="line">RandomAccessIterator __upper_bound(RandomAccessIterator first, RandomAccessIterator last, <span class="type">const</span> T&amp; value, Distance*, random_access_iterator_tag) &#123;</span><br><span class="line">	Distance len = last - first;	<span class="comment">//求取整个区间的长度len</span></span><br><span class="line">	Distance half;</span><br><span class="line">	RandomAccessiterator = middle;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">		half = len &gt;&gt; <span class="number">1</span>;				<span class="comment">//除以2</span></span><br><span class="line">		middle = first + half;			<span class="comment">//令middle指向中间位置</span></span><br><span class="line">		<span class="keyword">if</span> (value &lt; *middle)			<span class="comment">//如果中间位置的元素值&gt;目标值</span></span><br><span class="line">			len = half;				    <span class="comment">//修正len，回头测试循环的结束条件</span></span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			first = middle + <span class="number">1</span>;			<span class="comment">//令first指向middle 的下一位置</span></span><br><span class="line">			len = len - half - <span class="number">1</span>;		<span class="comment">//修正len，回头测试循环的结束条件</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> first;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="binary-search（应用于有序区间）"><a href="#binary-search（应用于有序区间）" class="headerlink" title="binary_search（应用于有序区间）"></a>binary_search（应用于有序区间）</h4><p>算法binary_search是一种二分查找法，试图在已排序的[first, last)中寻找元素value。如果[first, last)内有等同于value的元素，便返回true，否则返回false。</p>
<p>事实上binary_search是利用lower_bound先找出“假设value存在的话，应该出现的位置”，然后再对比该位置上的值是否为我们所要查找的目标，并返回对比结果。</p>
<p>binary_search的第一版本采用operator&lt;进行比较，第二版本采用仿函数comp进行比较。</p>
<p>正式地说，当且仅当[first, last)中存在一个迭代器i使得“*i &lt; value和 value &lt; *i皆不为真”，则第一版本返回true。当且仅当[first, last)中存在一个迭代器i使得“comp(*i, value)和comp(value, *i)皆不为真”，则第二版本返回true。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//版本一</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">ForwardIterator</span>, <span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Binary_search</span><span class="params">(ForwardIterator first, ForwardIterator last, <span class="type">const</span> T&amp; value)</span> </span>&#123;</span><br><span class="line">	ForwardIterator i = <span class="built_in">lower_bound</span>(first, last, value);</span><br><span class="line">	<span class="keyword">return</span> i != last &amp;&amp; !(value &lt; *i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//版本二</span></span><br><span class="line">termplate &lt;<span class="keyword">class</span> <span class="title class_">ForwardIterator</span>, <span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Compare</span>&gt;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">binary_search</span><span class="params">(ForwardIterator first, ForwardIterator last, <span class="type">const</span> T&amp; value, Compare comp)</span> </span>&#123;</span><br><span class="line">	ForwardIterator i = <span class="built_in">lower_bound</span>(first, last, value, comp);</span><br><span class="line">	<span class="keyword">return</span> i ! = last &amp;&amp; !<span class="built_in">comp</span>(value, *i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="next-permutation"><a href="#next-permutation" class="headerlink" title="next_permutation"></a>next_permutation</h4><p>该算法会取得[first, last)所标识之序列的下一个排列组合。如果没有下一个排列组合，便返回false；否则返回true。</p>
<p>这个算法有两个版本。版本一使用元素型别所提供的less-than操作符来决定下一个排列组合，版本二则是以仿函数comp来决定。</p>
<h5 id="什么是排列组合？"><a href="#什么是排列组合？" class="headerlink" title="什么是排列组合？"></a>什么是排列组合？</h5><p>考虑三个字符所组成的序列{a,b,c}。这个序列有六个可能的排列组合: abc,acb,bac,bca， cab,cba。这些排列组合根据less-than操作符做字典顺序（lexicographical）的排序。也就是说，abc 名列第一，因为每一个元素都小于其后的元素。acb 是次一个排列组合，因为它是固定了a（序列内最小元素）之后所做的新组合。同样道理，那些固定b（序列内次小元素）而做的排列组合，在次序上将先于那些固定c而做的排列组合。以 bac 和 bca 为例，bac 在 bca 之前，因为序列 ac 小于序列 ca 。面对 bca ，我们可以说其前一个排列组合是 bac ，而其后一个排列组合是 cab 。序列 abc 没有“前一个”排列组合，cba 没有“后一个”排列组合。</p>
<h4 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h4><p>首先，从未断开始往前寻找两个相邻元素，令第一元素为*i，第二元素为*ii，且满足 *i &lt; *ii。找到这样一组相邻元素后，再从最尾端开始往前检验，找出第一个大于*i的元素，令其为*j，将i, j元素对调，再将 ii 之后的所有元素颠倒排列。此即所求之“下一个”排列组合。</p>
<p>算法应用于序列{0, 1, 2, 3, 4}上的示例：</p>
<p><img src="/../img/next_permutation%E7%A4%BA%E4%BE%8B.png" alt="next_permutation示例"></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//版本一</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> BidirectionalIterators&gt;</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">next_permutation</span><span class="params">(BidirectionalIterator first, BidirectionalIterator last)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (first == last) <span class="keyword">return</span> <span class="literal">false</span>;	<span class="comment">//空区间</span></span><br><span class="line">	BidirectionalIterator i = first;</span><br><span class="line">	++i;</span><br><span class="line">	<span class="keyword">if</span> (i == last) <span class="keyword">return</span> <span class="literal">false</span>;		<span class="comment">//只有一个元素</span></span><br><span class="line">	i = last; 	<span class="comment">//i指向尾端</span></span><br><span class="line">	--i;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (;;) &#123;</span><br><span class="line">		BidirectionalIterator ii = i;</span><br><span class="line">		--i;</span><br><span class="line">		<span class="comment">//以上，锁定一组（两个）相邻元素</span></span><br><span class="line">		<span class="keyword">if</span>(*i &lt; *ii) &#123;	<span class="comment">//如果前一个元素小于后一个元素</span></span><br><span class="line">			BidirectionalIterator j = last;	<span class="comment">//令j指向尾端</span></span><br><span class="line">			<span class="keyword">while</span> (!(*i &lt; *--j));	<span class="comment">//由尾端往前找，直到遇上比*i大的元素</span></span><br><span class="line">			<span class="built_in">iter_swap</span>(i, j);		<span class="comment">//交换i，j</span></span><br><span class="line">			<span class="built_in">reverse</span>(ii, last);		<span class="comment">//将ii之后的元素全部逆向重排</span></span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (i == first) &#123;			<span class="comment">//进行至最前面了</span></span><br><span class="line">			<span class="built_in">reverse</span> (first , last);	 <span class="comment">//全部逆向重排</span></span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="prev-permutation"><a href="#prev-permutation" class="headerlink" title="prev_permutation"></a>prev_permutation</h4><p>该算法找出“前一个”排列组合，其意义已在上节阐述。</p>
<h4 id="算法实现-1"><a href="#算法实现-1" class="headerlink" title="算法实现"></a>算法实现</h4><p>首先，从最尾端开始往前寻找两个相邻元素，令第一元素为*i，第二元素为*ii，且满足 *i &gt; *ii。找到这样一组相邻元素后，再从最尾端开始往前检验，找出第一个小于*i 的元素，令为*j，将 i，j元素对调，再将ii 之后的所有元素颠倒排列。此即所求之“前一个”排列组合。</p>
<p>算法应用于序列{0, 1, 2, 3, 4}上的示例：</p>
<p><img src="/../img/prev_permutation%E7%A4%BA%E4%BE%8B.png" alt="prev_permutation示例"></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//版本一</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> BidirectionalIterators&gt;</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">prev_permutation</span><span class="params">(BidirectionalIterator first, BidirectionalIterator last)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (first == last) <span class="keyword">return</span> <span class="literal">false</span>;	<span class="comment">//空区间</span></span><br><span class="line">	BidirectionalIterator i = first;</span><br><span class="line">	++i;</span><br><span class="line">	<span class="keyword">if</span> (i == last) <span class="keyword">return</span> <span class="literal">false</span>;		<span class="comment">//只有一个元素</span></span><br><span class="line">	i = last; 	<span class="comment">//i指向尾端</span></span><br><span class="line">	--i;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (;;) &#123;</span><br><span class="line">		BidirectionalIterator ii = i;</span><br><span class="line">		--i;</span><br><span class="line">		<span class="comment">//以上，锁定一组（两个）相邻元素</span></span><br><span class="line">		<span class="keyword">if</span>(*ii &lt; *i) &#123;	<span class="comment">//如果前一个元素大于后一个元素</span></span><br><span class="line">			BidirectionalIterator j = last;	<span class="comment">//令j指向尾端</span></span><br><span class="line">			<span class="keyword">while</span> (!(*--j &lt; *i));	<span class="comment">//由尾端往前找，直到遇上比*i小的元素</span></span><br><span class="line">			<span class="built_in">iter_swap</span>(i, j);		<span class="comment">//交换i，j</span></span><br><span class="line">			<span class="built_in">reverse</span>(ii, last);		<span class="comment">//将ii之后的元素全部逆向重排</span></span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (i == first) &#123;			<span class="comment">//进行至最前面了</span></span><br><span class="line">			<span class="built_in">reverse</span> (first , last);	 <span class="comment">//全部逆向重排</span></span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="random-shuffle"><a href="#random-shuffle" class="headerlink" title="random_shuffle"></a>random_shuffle</h4><p>概算法将[first，last)的元素次序随机重排。即，在N! 种可能的元素排列顺序中随机选出一种，此处N为last - first。</p>
<p>random_shuffle有两个版本，差别在于随机数的取得。版本一使用内部随机数产生器，版本二使用一个会产生随机随机数的仿函数。特别请你注意，该仿函数的传递方式是by reference 而非一般的by value，这是因为随机随机数产生器有一个重要特质：它拥有局部状态 ( local state)，每次被调用时都会有所改变，并因此保障产生出来的随机数能够随机。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//SGI版本一</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">RandomAccessIterator</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">random_shuffle</span><span class="params">(RandomAccessIterator first, RandomAccessIterator last)</span> </span>&#123;</span><br><span class="line">	__random_shuffle(first, last, <span class="built_in">distance_type</span>(first));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">RandomAccessIterator</span>, <span class="keyword">class</span> <span class="title class_">Distance</span>&gt;</span><br><span class="line"><span class="type">void</span> __random_shuffle(RandomAccessIterator first, RandomAccessIterator last, Distance*) &#123;</span><br><span class="line">	<span class="keyword">if</span> (first == last) <span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">for</span> (RandomAccessIterator i = first + <span class="number">1</span>; i != last; ++i)</span><br><span class="line">        <span class="meta">#<span class="keyword">ifdef</span> __STL_NO_DRAND48</span></span><br><span class="line">		<span class="built_in">iter_swap</span>(i, first + <span class="built_in">Distance</span>(<span class="built_in">rand</span>() % ((i - first) + <span class="number">1</span>)));</span><br><span class="line">		<span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">		<span class="built_in">iter_swap</span>(i, first + <span class="built_in">Distance</span>(<span class="built_in">lrand48</span>() % ((i - first) + <span class="number">1</span>)));</span><br><span class="line">		<span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//SGI版本二</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">RandomAccessIterator</span>, <span class="keyword">class</span> <span class="title class_">RandomNumberGenerator</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">random_shuffle</span><span class="params">(RandomAccessIterator first, RandomAccessIterator last, RandomNumberGenerator&amp; rand)</span> </span>&#123;	<span class="comment">//注意，by reference</span></span><br><span class="line">	<span class="keyword">if</span> (first == last) <span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">for</span> (RandomAccessIterator i = first + <span class="number">1</span>; i != last; ++i)</span><br><span class="line"> 		<span class="built_in">iter_swap</span>(i, first + <span class="built_in">rand</span>((i - first) + <span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="partial-sort-x2F-partial-sort-copy"><a href="#partial-sort-x2F-partial-sort-copy" class="headerlink" title="partial_sort &#x2F; partial_sort_copy"></a>partial_sort &#x2F; partial_sort_copy</h4><p>该算法接受一个middle迭代器（位于序列[first, last)之内），然后重新安排[first, last)，是序列中的middle - first个最小元素以递增顺序排序，置于[first, middle)内。其余last - middle个元素安置于[middle, last)种，不保证有任何特定顺序。因此，只排序前N个元素时，partial_sort的效率要高于sort。</p>
<p>partial_sort有两个版本，其差别在于如何定义某个元素小于另一元素。第一版本使用less-than 操作符，第二版本使用仿函数comp。</p>
<h5 id="算法实现-2"><a href="#算法实现-2" class="headerlink" title="算法实现"></a>算法实现</h5><p>算法内部采用heap sort完成。partial_sort 的任务是找出 middle - first 个最小元素，因此，首先界定出区间[first, middle)，并利用 make_heap()将它组织成一个max-heap，然后就可以将[middle, last)中的每一个元素拿来与max-heap的最大值比较（max-heap的最大值就在第一个元素身上，轻松可以获得）：如果小于该最大值，就互换位置并重新保持max-heap的状态。如此一来，当我们走遍整个[middle, last)时，较大的元素都已经被抽离出[first, middle)，这时候再以sort_heap()将[first, middle)做一次排序，即功德圆满。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//版本一</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">RandomAccessIterator</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">partial_sort</span><span class="params">(RandomAccessIterator first, RandomAccessIterator middle, RandomAccessIterator last)</span> </span>&#123;</span><br><span class="line">	__partial_sort(first, middle, last, <span class="built_in">value_type</span>(first));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">RandomAccessIterator</span>, <span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> __partial_sort(RandomAccessIterator first,  RandomAccessIterator middle, RandomAccessIterator last, T*) &#123;</span><br><span class="line">	<span class="built_in">make_heap</span>(first, middle);</span><br><span class="line">	<span class="comment">//注意，以下的i &lt; last判断操作，只适用于random iterator</span></span><br><span class="line">	<span class="keyword">for</span> (RandomAccessIterator i = middle; i &lt; last; ++i)</span><br><span class="line">		<span class="keyword">if</span> (*i &lt; *first)</span><br><span class="line">			__pop_heap(first, middle, i, <span class="built_in">T</span>(*i), <span class="built_in">distance_type</span>(first));</span><br><span class="line">	<span class="built_in">sort_heap</span>(first, middle);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>partial_sort有一个姊妹，就是partial_sort_copy。partial_sort 和 partial_sort_copy两者行为逻辑完全相同，只不过后者将(last - first)个最小元素（或最大元素，视 comp而定）排序后的所得结果置于[result_first, result_last )。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//版本一</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>, <span class="keyword">class</span> <span class="title class_">RandomAccessIterator</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> RandomAccessIterator</span></span><br><span class="line"><span class="function"><span class="title">partial_sort_copy</span><span class="params">(InputIterator first,  InputIterator last, RandomAccessIterator result_first, RandomAccessIterator result_last)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//版本二</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>, <span class="keyword">class</span> <span class="title class_">RandomAccessIterator</span>, <span class="keyword">class</span> <span class="title class_">Compare</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> RandomAccessIterator</span></span><br><span class="line"><span class="function"><span class="title">partial_sort_copy</span><span class="params">(InputIterator first, InputIterator last, RandomAccessIterator result_first, RandomAccessIterator result_last, Compare comp)</span></span>;</span><br></pre></td></tr></table></figure>

<h4 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h4><p>STL所提供的各式各样算法中，sort()是最复杂最庞大的一个。该算法接受两个RandomAccesslterators（随机存取迭代器），然后将区间内的所有元素以渐增方式由小到大重新排列。第二个版本则允许用户指定一个仿函数（functor），作为排序标准。</p>
<p>STL的所有关系型容器( associative containers）都拥有自动排序功能（底层结构采用RB-tree），所以不需要用到这个sort 算法。至于顺序容器（ sequence containers）中的stack、queue和 priority-queue都有特别的出入口，不允许用户对元素排序。剩下vector、deque、 list和slist，前两者的迭代器属于RandomAccesslterators，适合使用sort算法，list的迭代器属于Bidirectioinalterators， slist的迭代器更属于Forwardlterators，都不适合使用sort 算法。如果要对 list或slist排序，应该使用它们自己提供的 member functions sort ( )。</p>
<p>STL的sort算法，数据量大时采用Quick Sort，分段递归排序。一旦分段后的数据量小于某个门槛，为避免Quick Sort的递归调用带来过大的额外负荷(overhead)，就改用Insertion Sort。如果递归层次过深，还会改用Heap sort。</p>
<h5 id="Insertion-Sort"><a href="#Insertion-Sort" class="headerlink" title="Insertion Sort"></a>Insertion Sort</h5><p>Insertion Sort以双层循环的形式进行。外循环遍历整个序列，每次迭代决定出一个子区间；内循环遍历子区间，将子区间内的每一个“逆转对(inversion)”倒转过来。所谓“逆转对”是指任何两个迭代器 i, j，其中i &lt; j 而*i &gt; *j。一旦不存在“逆转对”，序列即排序完毕。该算法的复杂度为O(N2)，说起来并不理想，但是当数据量很少时，却有不错的效果，原因是实现上有一些技巧（稍后源代码可见)，而且不像其它较为复杂的排序算法有着诸如递归调用等操作带来的额外负荷。</p>
<p>sGI STL的Insertion Sort有两个版本,版本一使以operator&lt;为两元素的比较函数（递增），版本二允许用户指定一个仿函数（functor)，作为两元素的比较函数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//版本一</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">RandomAccessIterator</span>&gt;</span><br><span class="line"><span class="type">void</span> __insertion_sort(RandomAccessIterator first,</span><br><span class="line">					RandomAccessIterator last) &#123;</span><br><span class="line">	<span class="keyword">if</span> (first == last) <span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">for</span> (RandomAccessIterator i = first + <span class="number">1</span>; i != last; ++i)	<span class="comment">//外循环</span></span><br><span class="line">		__linear_insert(first, i, <span class="built_in">value_type</span>(first));</span><br><span class="line">		<span class="comment">//以上，[first, i)形成一个子区间</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//版本一辅助函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">RandomAccessIterator</span>, <span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="type">void</span> __linear_insert(RandomAccessIterator first,</span><br><span class="line">						  RandomAccessIterator last, T*) &#123;</span><br><span class="line">	T value = *last;		<span class="comment">//记录尾元素</span></span><br><span class="line">	<span class="keyword">if</span> (value &lt; *first) &#123; 	<span class="comment">//尾比头还小（注意，头端必为最小元素)</span></span><br><span class="line">        <span class="comment">//那么就别一个个比较了，一次做完爽快些…</span></span><br><span class="line">		<span class="built_in">copy_backward</span>(first, last, last + <span class="number">1</span>); <span class="comment">//将整个区间向右递移一个位置</span></span><br><span class="line">		*first = value;		<span class="comment">//令头元素等于原先的尾元素值</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> 	<span class="comment">//尾不小于头</span></span><br><span class="line">		__unguarded_linear_insert(last, value);</span><br><span class="line">&#125;    </span><br><span class="line">    </span><br><span class="line"><span class="comment">//版本一辅助函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">RandomAccessIterator</span>, <span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> __unguarded_linear_insert(RandomAccessIterator last, T value) &#123;</span><br><span class="line">	RandomAccessIterator next = last;</span><br><span class="line">	--next;</span><br><span class="line">	<span class="comment">//insertion sort 的内循环</span></span><br><span class="line">	<span class="comment">//注意，一旦不再出现逆转对(inversion)，循环就可以结束了</span></span><br><span class="line">	<span class="keyword">while</span> (value &lt; *next) &#123; <span class="comment">//逆转对（ inversion）存在</span></span><br><span class="line">		*last = *next;		<span class="comment">//调整</span></span><br><span class="line">		last = next;		<span class="comment">//调整迭代器</span></span><br><span class="line">		--next;				<span class="comment">//左移一个位置</span></span><br><span class="line">	&#125;</span><br><span class="line">	*last = value;			 <span class="comment">// value的正确落脚处</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="Quick-Sort"><a href="#Quick-Sort" class="headerlink" title="Quick Sort"></a>Quick Sort</h5><p>Quick Sort平均复杂度都为O(N log N)，最坏情况下将达O(N²)。</p>
<p>Quick Sort算法可以叙述如下。假设S代表将被处理的序列：</p>
<ol>
<li>如果S的元素个数为0或1，结束。</li>
<li>取S中的任何一个元素，当作枢轴(pivot) v。</li>
<li>将S分割为L，R两段，使L内的每一个元素都小于或等于v，R内的每一个<br>元素都大于或等于v。</li>
<li>对L,R递归执行Quick Sort。</li>
</ol>
<h6 id="Median-of-Three（三点中值）"><a href="#Median-of-Three（三点中值）" class="headerlink" title="Median-of-Three（三点中值）"></a>Median-of-Three（三点中值）</h6><p>虽然任何一个元素都可以被选来当作枢轴，但是其合适与否会影响Quick Sort的效率。为了避免“元素当初输入时不够随机”所带来的而化效应，最理想的方式就是取整个序列的头、尾、中央三个位置的元素，以其中值作为枢轴。为了能够快速取出中央位置的元素，显然迭代器必须能够随机定位，即必须是个RandomAccessIterators。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回a,b,c之居中者</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="type">const</span> T&amp; __median(<span class="type">const</span> T&amp; a, <span class="type">const</span> T&amp; b, <span class="type">const</span> T&amp; c) &#123;</span><br><span class="line">	<span class="keyword">if</span> (a &lt; b)</span><br><span class="line">		<span class="keyword">if</span> (b &lt; c)		<span class="comment">// a &lt; b &lt; c</span></span><br><span class="line">			<span class="keyword">return</span> b;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (a &lt; c)	<span class="comment">// a &lt; b, b &gt;= c, a &lt; c</span></span><br><span class="line">			<span class="keyword">return</span> c;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="keyword">return</span> a;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (a &lt; c)		<span class="comment">// c &gt; a &gt;= b</span></span><br><span class="line">		<span class="keyword">return</span> a;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (b &lt; c)		<span class="comment">//a &gt;= b, a &gt;= c, b &lt; c</span></span><br><span class="line">		<span class="keyword">return</span> c;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> b;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h6 id="Partitioning（分割）"><a href="#Partitioning（分割）" class="headerlink" title="Partitioning（分割）"></a>Partitioning（分割）</h6><p>分割方法不只一种，以下叙述既简单又有良好成效的做法。令头端迭代器first向尾部移动，尾端迭代器last向头部移动。当*first 大于或等于枢轴时就停下来，当*last 小于或等于枢轴时也停下来，然后检验两个迭代器是否交错。如果 first仍然在左而last 仍然在右，就将两者元素互换，然后各自调整一个位置（向中央逼近)，再继续进行相同的行为。如果发现两个迭代器交错了（亦即! (first &lt; last)) ，表示整个序列已经调整完毕，以此时的first 为轴，将序列分为左右两半，左半部所有元素值都小于或等于枢轴，右半部所有元素值都大于或等于枢轴。</p>
<p>下面是SGI STL提供的分割函数，其返回值是分割后的右端第一个位置：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//版本一</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">RandomAccessIterator</span>, <span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">RandomAccessIterator __unguarded_partition (RandomAccessIterator first, RandomAccessIterator last, T pivot) &#123;</span><br><span class="line">	<span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">		<span class="keyword">while</span> (*first &lt; pivot) ++first; <span class="comment">// first找到 &gt;= pivot的元素就停下来</span></span><br><span class="line">		--last;						  <span class="comment">//调整</span></span><br><span class="line">		<span class="keyword">while</span> (pivot &lt; *last) --last;  <span class="comment">//last找到 &lt;= pivot 的元素就停下来</span></span><br><span class="line">		<span class="comment">//注意，以下first &lt; last 判断操作，只适用于random iterator</span></span><br><span class="line">		<span class="keyword">if</span> (!(first &lt; last)) <span class="keyword">return</span> first;	<span class="comment">//交错，结束循环</span></span><br><span class="line">		<span class="built_in">iter_swap</span>(first, last);				<span class="comment">//大小值交换</span></span><br><span class="line">		++first;						<span class="comment">//调整</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>

<h6 id="threshold（阈值）"><a href="#threshold（阈值）" class="headerlink" title="threshold（阈值）"></a>threshold（阈值）</h6><p>面对小型序列，Quick Sort可能并不比Insertion Sort划算，鉴于这种情况，需要适度评估序列的大小来决定采用Quick Sort或者Insertion Sort。该阈值并无定论，5-20都可能导致差不多的结果，实际的最佳值因设备而异。</p>
<h6 id="final-insertion-sort"><a href="#final-insertion-sort" class="headerlink" title="final insertion sort"></a>final insertion sort</h6><p>如果我们令某个大小以下的序列滞留在“几近排序但尚未完成”的状态，最后再以一次lnsertion Sort将所有这些“几近排序但尚未竟全功”的子序列做一次完整的排序，其效率一般认为会比“将所有子序列彻底排序”更好。这是因为Insertion Sort在面对“几近排序”的序列时，有很好的表现。</p>
<h6 id="introsort"><a href="#introsort" class="headerlink" title="introsort"></a>introsort</h6><p>Introspective Sorting（内省式排序），简称IntroSort，其行为在大部分情况下几乎与median-of-3 Quick Sort完全相同。但是当分割行为( partitioning）有恶化为二次行为的倾向时，能够自我侦测，转而改用Heap Sort，使效率维持在Heap Sort的O(N log N)，又比一开始就使用Heap Sort来得好。</p>
<h6 id="SGI-STL-sort"><a href="#SGI-STL-sort" class="headerlink" title="SGI STL sort"></a>SGI STL sort</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 版本一</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">RandomAccessIterator</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">sort</span><span class="params">(RandomAccessIterator first, RandomAccessIterator last)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (first != last) &#123;</span><br><span class="line">		__introsort_loop(first, last, <span class="built_in">value_type</span>(first), __lg(last - first)  *<span class="number">2</span>);</span><br><span class="line">		__final_insertion_sort(first, last);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;    </span><br><span class="line"></span><br><span class="line"><span class="comment">// __lg()用来控制分割恶化的情况；</span></span><br><span class="line"><span class="comment">//找出 2^k &lt;= n 的最大值k。例: n=7，得k=2，n=20，得k=4，n=8，得k=3</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Size</span>&gt;</span><br><span class="line"><span class="keyword">inline</span> Size __lg (Size n) &#123;</span><br><span class="line">	Size k;</span><br><span class="line">	<span class="keyword">for</span> (k = <span class="number">0</span>; n &gt; <span class="number">1</span>; n &gt;&gt;= <span class="number">1</span>) ++k;</span><br><span class="line">	<span class="keyword">return</span> k;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当元素个数为40时，__introsort_loop()的最后一个参数将是5*2，意思是最多允许分割10层。IntroSort算法如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//版本一</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">RandomAccessIterator</span>, <span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Size</span>&gt;</span><br><span class="line"><span class="type">void</span> __introsort_loop(RandomAccessIterator first, RandomAccessIterator last, T*, Size depth_limit) &#123;</span><br><span class="line"><span class="comment">// 以下，__stl_threshold是个全局常数，稍早定义为const int 16</span></span><br><span class="line">	<span class="keyword">while</span> (last - first &gt; __stl_threshold) &#123;		<span class="comment">// &gt; 16</span></span><br><span class="line">		<span class="keyword">if</span> (depth_limit == <span class="number">0</span> ) &#123;				 <span class="comment">//至此，分割恶化</span></span><br><span class="line">			<span class="built_in">partial_sort</span>(first, last, last);	  <span class="comment">//改用heapsort</span></span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;            </span><br><span class="line">		--depth_limit;</span><br><span class="line">		<span class="comment">//以下是 median-of-3 partition，选择一个够好的枢轴并决定分割点</span></span><br><span class="line">		<span class="comment">//分割点将落在迭代器cut身上</span></span><br><span class="line">		RandomAccessIterator cut = __unguarded_partition(first, last, <span class="built_in">T</span>(__median(*first, *(first + (last - first)/<span class="number">2</span>), *(last - <span class="number">1</span>))));</span><br><span class="line">		<span class="comment">//对右半段递归进行sort.</span></span><br><span class="line">		__introsort_loop(cut，last, <span class="built_in">value_type</span>(first), depth_limit);</span><br><span class="line">		last = cut;</span><br><span class="line">		<span class="comment">//现在回到while循环，准备对左半段递归进行sort</span></span><br><span class="line">		<span class="comment">//这种写法可读性较差，效率并没有比较好</span></span><br><span class="line">		<span class="comment">// RW STL采用一般教科书写法（直观地对左半段和右半段递归），较易阅读</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当__introsort_loop()结束，[first, last)内有多个“元素个数小于16”的子序列，每个子序列都有相当程度的排序，但尚未完全排序（因为元素个数一旦小于__stl_threshold，就被中止进一步的排序操作了）。回到母函数sort()，再进入__final_insertion_sort()：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/版本一</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">RandomAccessIterator</span>&gt;</span><br><span class="line"><span class="type">void</span> __final_insertion_sort(RandomAccessIterator first, RandomAccessIterator last) &#123;</span><br><span class="line">	<span class="keyword">if</span> (last - first &gt; __stl_threshold) &#123;	<span class="comment">// &gt; 16</span></span><br><span class="line">		__insertion_sort(first, first + __stl_threshold);</span><br><span class="line">		__unguarded_insertion_sort(first + __stl_threshold， last);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		__insertion_sort(first, last);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此函数首先判断元素个数是否大于16。如果答案为否，就调用__insertion_sort()加以处理。如果答案为是，就将[first, last)分割为长度16的一段子序列，和另一段剩余子序列，再针对两个子序列分别调用__insertion_sort()和__unguarded_insertion_sort()。前者源代码已前展示过，后者源代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//版本一</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">RandomAccessIterator</span>&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="type">void</span> __unguarded_insertion_sort(RandomAccessIterator first, RandomAccessIterator last) &#123;	</span><br><span class="line">	__unguarded_insertion_sort_aux(first, last, <span class="built_in">value_type</span>(first));</span><br><span class="line">&#125;    </span><br><span class="line"></span><br><span class="line"><span class="comment">//版本一</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">RandomAccessIterator</span>, <span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> __unguarded_insertion_sort_aux(RandomAccessIterator first, RandomAccessIterator last, T*) &#123;</span><br><span class="line">	<span class="keyword">for</span> (RandomAccessIterator i = first; i != last; ++i)</span><br><span class="line">		__unguarded_linear_insert(i, <span class="built_in">T</span>(*i)); <span class="comment">//见先前展示</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>RW STL版本的sort()，纯粹的Quick Sort，不是IntroSort：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">RandomAccessIterator</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">sort</span><span class="params">(RandomAccessIterator first, RandomAccessIterator last)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!(first == last)) &#123;</span><br><span class="line">		__quick_sort_loop(first, last);</span><br><span class="line">		__final_insertion_sort(first, last); <span class="comment">//其内操作与SGI STL完全相同</span></span><br><span class="line">	&#125;        </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">RandomAccessIterator</span>&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="type">void</span> __quick_sort_loop(RandomAccessIterator first, RandomAccessIterator last)</span><br><span class="line">&#123;</span><br><span class="line">	__quick_sort_loop_aux(first, last, _RWSTD_VALUE_TYPE(first));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">RandomAccessIterator</span>, <span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> __quick_sort_loop_aux(RandomAccessIterator first, RandomAccessIterator last, T*)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">while</span> (last - first &gt; __stl_threshold)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//median-of- 3 partitioning</span></span><br><span class="line">		RandomAccessIterator cut = __unguarded_partition(first, last, <span class="built_in">T</span>(__median(*first, *(first + (last - first)/<span class="number">2</span>), *(last - <span class="number">1</span>))));</span><br><span class="line">		<span class="keyword">if</span> (cut - first &gt;= last - cut)</span><br><span class="line">		&#123;</span><br><span class="line">			__quick_sort_loop(cut, last);	<span class="comment">//对右段递归处理</span></span><br><span class="line">			last = cut;</span><br><span class="line">		&#125;            </span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			__quick_sort_loop(first, cut);	<span class="comment">//对左段递归处理</span></span><br><span class="line">			first = cut;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="equal-range（应用于有序区间）"><a href="#equal-range（应用于有序区间）" class="headerlink" title="equal_range（应用于有序区间）"></a>equal_range（应用于有序区间）</h4><p>该算法返回一对迭代器i和j，其中i是在不破坏次序的前提下，value可插入的第一个位置（亦即lower_bound），j则是在不破坏次序的前提下，value可插入的最后一个位置（亦即upper_bound）。因此，[i, j)内的每个元素都等同于value，而且[first, last)之中符合此一性质的最大子区间。</p>
<p>即使[first, last)并未含有“与value 等同”之任何元素，以上叙述仍然合理。这种情况下“与value 等同”之所有元素所形成的，其实是个空区间。在不破坏次序的前提下，只有一个位置可以插入value，而equal_range所返回的 pair，其第一和第二元素（都是迭代器）皆指向该位置。</p>
<p>本算法有两个版本，第一版本采用operator&lt;进行比较，第二版本采用仿函数comp进行比较。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//版本一</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">ForwardIterator</span>, <span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> pair&lt;ForwardIterator, ForwardIterator&gt;</span></span><br><span class="line"><span class="function"><span class="title">equal_range</span><span class="params">(ForwardIterator first, ForwardIterator last, <span class="type">const</span> T&amp; value)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//根据迭代器的种类型（category），采用不同的策略</span></span><br><span class="line">	<span class="keyword">return</span> __equal_range(first, last, value, <span class="built_in">distance_type</span>(first),</span><br><span class="line">					    <span class="built_in">iterator_category</span>(first));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//版本一的random_access_iterator版本</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">RandomAccessIterator</span>, <span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Distance</span>&gt;</span><br><span class="line">pair&lt;RandomAccessIterator, RandomAccessIterator&gt;</span><br><span class="line">__equal_range(RandomAccessIterator first, RandomAccessIterator last, <span class="type">const</span> T&amp; value, Distance*, random_access_iterator_tag) &#123;</span><br><span class="line">	Distance len = last - first;</span><br><span class="line">	Distance half;</span><br><span class="line">	RandomAccessIterator middle, left, right;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (len &gt; <span class="number">0</span> ) &#123;			<span class="comment">//整个区间尚未遍历完毕</span></span><br><span class="line">		half = len &gt;&gt; <span class="number">1</span>;		<span class="comment">//找出中央位置</span></span><br><span class="line">		middle = first + half; 	 <span class="comment">//设定中央迭代器</span></span><br><span class="line">		<span class="keyword">if</span> (*middle &lt; value) &#123; 	 <span class="comment">//如果中央元素&lt;指定值</span></span><br><span class="line">			first = middle + <span class="number">1</span>;	 <span class="comment">//将运作区间缩小（移至后半段），以提高效率</span></span><br><span class="line">			len = len - half - <span class="number">1</span>;</span><br><span class="line">		&#125;            </span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (value &lt; *middle)	<span class="comment">//如果中央元素&gt;指定值</span></span><br><span class="line">			len = half;			   <span class="comment">//将运作区间缩小（移至前半段）以提高效率</span></span><br><span class="line">		<span class="keyword">else</span> &#123;					   <span class="comment">//如果中央元素==指定值</span></span><br><span class="line">			<span class="comment">//在前半段找lower_bound</span></span><br><span class="line">			left = <span class="built_in">lower_bound</span>(first, middle, value);</span><br><span class="line">			<span class="comment">//在后半段找upper_bound</span></span><br><span class="line">			right = <span class="built_in">upper_bound</span>(++middle, first + len, value);</span><br><span class="line">			<span class="keyword">return</span> <span class="built_in">pair</span>&lt;RandomAccessIterator, RandomAccesstterator&gt;(left, right);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;        </span><br><span class="line">	<span class="comment">//整个区间内都没有匹配的值，那么应该返回一对迭代器，指向第一个大于value的元素</span></span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">pair</span>&lt;RandomAccessIterator, RandomAccessIterator&gt;(first, first);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//版本一的forward_iterator版本</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">ForwardIterator</span>, <span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Distance</span>&gt;</span><br><span class="line">pair&lt;ForwardIterator, ForwardIterator&gt;</span><br><span class="line">__equal_range(ForwardIterator first, ForwardIterator last, <span class="type">const</span> T&amp; value, Distance*, forward_iterator_tag) &#123; </span><br><span class="line">	Distance len = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">distance</span>(first, last, len);</span><br><span class="line">	Distance half;</span><br><span class="line">	ForwardIterator middle, left, right;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">		half = len &gt;&gt; <span class="number">1</span>;</span><br><span class="line">		middle = first;		  <span class="comment">//此行及下一行，相当于RandomAccessiterator的</span></span><br><span class="line">		<span class="built_in">advance</span>(middle, half); <span class="comment">//middle = first + half;</span></span><br><span class="line">		<span class="keyword">if</span> (*middle &lt; value) &#123;</span><br><span class="line">			first = middle;	   <span class="comment">//此行及下一行，相当于RandomAccessiterator的</span></span><br><span class="line">			++first;		   <span class="comment">//first = middle + 1;</span></span><br><span class="line">			len = len - half - <span class="number">1</span>;</span><br><span class="line">		&#125;            </span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (value &lt; *middle)</span><br><span class="line">			len = half;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			left = <span class="built_in">lower_bound</span>(first, middle, value);</span><br><span class="line">			<span class="comment">//以下这行相当于RandomAccessIterator的first += len;</span></span><br><span class="line">			<span class="built_in">advance</span>(first, len);</span><br><span class="line">			right = <span class="built_in">upper_bound</span>(++middle, first, value);</span><br><span class="line">			<span class="keyword">return</span> <span class="built_in">pair</span>&lt;ForwardIterator, ForwardIterator&gt;(left, right);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;        </span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">pair</span>&lt;ForwardIterator, ForwardIterator&gt;(first, first);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="inplace-merge（应用于有序区间）"><a href="#inplace-merge（应用于有序区间）" class="headerlink" title="inplace_merge（应用于有序区间）"></a>inplace_merge（应用于有序区间）</h4><p>如果两个连接在一起的序列[first, middle)和[middle, last)都已排序，那么inplace_merge可将它们结合成单一一个序列，并仍保有序性(sorted)。如果原先两个序列是递增排序，执行结果也会是递增排序，如果原先两个序列是递减排序，执行结果也会是递减排序。</p>
<p>和merge一样， inplace_merge也是一种稳定（stable）操作。每个作为数据来源的子序列中的元素相对次序都不会变动；如果两个子序列有等同的元素，第一序列的元素会被排在第二序列元素之前。</p>
<p>inplace_merge 有两个版本，其差别在于如何定义某元素小于另一个元素。第一版本使用operator&lt;进行比较，第二版本使用仿函数（functor）comp进行比较。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">BidirectionalIterator</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">inplace_merge</span><span class="params">(BidirectionalIterator first,</span></span></span><br><span class="line"><span class="params"><span class="function">					    BidirectionalIterator middle,</span></span></span><br><span class="line"><span class="params"><span class="function">					    BidirectionalIterator last)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 只要有任何一个序列为空，就什么都不必做</span></span><br><span class="line">	<span class="keyword">if</span> (first == middle || middle == last) <span class="keyword">return</span>;</span><br><span class="line">	__inplace_merge_aux(first, middle, last, <span class="built_in">value_type</span>(first), <span class="built_in">distance_type</span>(first));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//辅助函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">BidirectionalIterator</span>, <span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Distance</span>&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="type">void</span> __inplace_merge_aux(BidirectionalIterator first, BidirectionalIterator middle, BidirectionalIterator last, T*, Distance*) &#123;</span><br><span class="line">	Distance len1 = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">distance</span>(first, middle, len1);		<span class="comment">// len1表示序列一的长度</span></span><br><span class="line">	Distance len2 = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">distance</span>(middle, last, len2);		<span class="comment">// len2表示序列二的长度</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//注意，本算法会使用额外的内存空间（暂时缓冲区）</span></span><br><span class="line">	<span class="function">temporary_buffer&lt;BidirectionalIterator, T&gt; <span class="title">buf</span><span class="params">(first, last)</span></span>;</span><br><span class="line">	<span class="keyword">if</span> (buf.<span class="built_in">begin</span>() == <span class="number">0</span>)	<span class="comment">//内存配置失败</span></span><br><span class="line">		__merge_without_buffer(first, middle, last, len1, len2);</span><br><span class="line">	<span class="keyword">else</span>					<span class="comment">//在有暂时缓冲区的情况下进行</span></span><br><span class="line">		__merge_adaptive(first, middle, last, len1, len2, buf.<span class="built_in">begin</span>(), <span class="built_in">Distance</span>(buf.<span class="built_in">size</span>()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个算法如果有额外的内存（缓冲区）辅助，效率会好很多。但是在没有缓冲区或缓冲区不足的情况下，也可以运作。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//辅助函数。有缓冲区的情况下</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">BidirectionalIterator</span>, <span class="keyword">class</span> <span class="title class_">Distance</span>, <span class="keyword">class</span> <span class="title class_">Pointer</span>&gt;</span><br><span class="line"><span class="type">void</span> __merge_adaptive(BidirectionalIterator first, BidirectionalIterator middle, BidirectionalIterator last, Distance len1, Distance len2, Pointer buffer, Distance buffer_size) &#123;</span><br><span class="line">	<span class="keyword">if</span> (len1 &lt;= len2 &amp;&amp; len1 &lt;= buffer_size) &#123;</span><br><span class="line">		<span class="comment">//case1．缓冲区足够安置序列一</span></span><br><span class="line">		Pointer end_buffer = <span class="built_in">copy</span>(first, middle, buffer);</span><br><span class="line">		<span class="built_in">merge</span>(buffer, end_buffer, middle, last, first);</span><br><span class="line">	&#125;        </span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (len2 &lt;= buffer_size) &#123;</span><br><span class="line">		<span class="comment">//case2．缓冲区足够安置序列二</span></span><br><span class="line">		Pointer end_buffer = <span class="built_in">copy</span>(middle, last, buffer);</span><br><span class="line">		__merge_backward(first, middle, buffer, end_buffer, last);</span><br><span class="line">    &#125; </span><br><span class="line">	<span class="keyword">else</span> &#123; <span class="comment">// case3. 缓冲区空间不足安置任何一个序列</span></span><br><span class="line">		BidirectionalIterator first_cut = first;</span><br><span class="line">		BidirectionalIterator second_cut = middle;</span><br><span class="line"> 		Distance len11 = <span class="number">0</span>;</span><br><span class="line">		Distance len22 = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span> (len1 &gt; len2) &#123;	<span class="comment">//序列一比较长</span></span><br><span class="line">			len11 = len1 / <span class="number">2</span>;</span><br><span class="line">			<span class="built_in">advance</span>(first_cut, len11);</span><br><span class="line">			second_cut = <span class="built_in">lower_bound</span>(middle, last, *first_cut);</span><br><span class="line">			<span class="built_in">distance</span>(middle, second_cut, len22);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;		<span class="comment">//序列二比较长</span></span><br><span class="line">			len22 = len2 / <span class="number">2</span>;</span><br><span class="line">			<span class="built_in">advance</span>(second_cut, len22);</span><br><span class="line">			first_cut = <span class="built_in">lower_bound</span>(first, middle, *second_cut);</span><br><span class="line">			<span class="built_in">distance</span>(first, first_cut, len11);</span><br><span class="line">		&#125;</span><br><span class="line">		BidirectionalIterator new_middle =</span><br><span class="line">			__rotate_adaptive(first_cut, middle, second_cut, len1 - len11,</span><br><span class="line">							len2 - len22, buffer, buffer_size);</span><br><span class="line">		<span class="comment">//针对左段，递归调用</span></span><br><span class="line">		__merge_adaptive(first, first_cut, new_middle, len11, len22, buffer,</span><br><span class="line">						buffer_size);</span><br><span class="line">		<span class="comment">//针对右段，递归调用</span></span><br><span class="line">		__merge_adaptive(new_middle, second_cut, last, lenl - len11,</span><br><span class="line">						len2 - len22, buffer, buffer_size);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述辅助函数首先判断缓冲区是否足以容纳 inplace_merge 所接受的两个序列中的任何一个。如果空间充裕（源代码中标示case1和 case2之处），工作逻辑很简单：把两个序列中的某一个 copy 到缓冲区中，再使用merge完成其余工作。是的，merge足堪胜任，它的功能就是将两个有序但分离（sorted and separated）的区间合并，形成一个有序区间，因此，我们只需将 merge 的结果置放处（迭代器result）指定为inplace_merge所接受之序列起始点（迭代器first）即可。</p>
<p>但是当缓冲区不足以容纳任何个序列时（源代码中标示 case3之处)，情况就棘手多了。面对这种情况，我们的处理原则是，以递归分割( recursive partitioning )的方式，让处理长度减半，看看能否容纳于缓冲区中。</p>
<p>举例来说，假设缓冲区大小为3，小于序列一的长度4和序列二的长度5，于是，拿较长的序列二开刀，计算出first_cut和 second_cut 如下：</p>
<p><img src="/../img/%E8%AE%A1%E7%AE%97first_cut%E5%92%8Csecond_cut.png" alt="计算first_cut和second_cut"></p>
<p>然后针对上图的淡蓝色阴影部分（{7, 2, 4}）执行旋转操作：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">BidirectionalIterator new_middle =</span><br><span class="line">	__rotate_adaptive(first_cut, middle, second_cut, len1 - len11,</span><br><span class="line">					 len22, buffer, buffer_size);</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">BidirectionalIterator1</span>, <span class="keyword">class</span> <span class="title class_">BidirectionalIterator2</span>, <span class="keyword">class</span> <span class="title class_">Distance</span>&gt;</span><br><span class="line">Bidirectionallterator1 __rotate_adaptive(Bidirectionallterator1 first, BidirectionalIterator1 middle, BidirectionalIterator1 last, Distance len1, Distance len2, BidirectionalIterator2 buffer, Distance buffer_size) &#123;</span><br><span class="line">	BidirectionalIterator2 buffer_end;</span><br><span class="line">	<span class="keyword">if</span> (lenl &gt; len2 &amp;&amp; len2 &lt;= buffer_size) &#123;<span class="comment">//缓冲区足够安置序列二（较短）</span></span><br><span class="line">		buffer_end = <span class="built_in">copy</span>(middle, last, buffer);</span><br><span class="line">		<span class="built_in">copy_backward</span>(first, middle, last);</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">copy</span>(buffer, buffer_end, first);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (len1 &lt;= buffer_size) &#123;		<span class="comment">//缓冲区足够安置序列一	</span></span><br><span class="line">		buffer_end = <span class="built_in">copy</span>(first, middle, buffer);</span><br><span class="line">		<span class="built_in">copy</span>(middle, last, first);</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">copy_backward</span>(buffer, buffer_end, last);</span><br><span class="line">	&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">//缓冲区仍然不足．改用rotate算法（不需缓冲区）</span></span><br><span class="line">		<span class="built_in">rotate</span>(first, middle, last);</span><br><span class="line">		<span class="built_in">advance</span>(first, len2);</span><br><span class="line">		<span class="keyword">return</span> first;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>经过这样的处理，原序列变成里：</p>
<p><img src="/../img/new_middle.png" alt="new_middle"></p>
<p>现在可以分段处理了。首先针对左段[first, first_cut, new_middle)，也就是上图的淡蓝色阴影部分{1, 3, 5, 2, 4}，做递归调用：</p>
<p><img src="/../img/%E5%B7%A6%E6%AE%B5%E9%80%92%E5%BD%92%E8%B0%83%E7%94%A8.png" alt="左段递归调用"></p>
<p>再针对右段[new_middle, second_cut, last)，也就是上图的淡蓝色阴影部分{7, 6, 8, 10}，做递归调用：</p>
<p><img src="/../img/%E5%8F%B3%E6%AE%B5%E9%80%92%E5%BD%92%E8%B0%83%E7%94%A8.png" alt="右段递归调用"></p>
<h4 id="nth-element"><a href="#nth-element" class="headerlink" title="nth_element"></a>nth_element</h4><p>该算法会重新排列[first, last)，使排序后第n个迭代器（nth）所指的元素，与“整个[first, last)序列完整排序后，第n个位置的元素”同值。此外，还保证排序前第n个元素可以在排序后分割整个序列（即左侧[first, nth)的元素全部不大于右侧[nth, last)的元素），但对于[first, nth)和[nth, last)两个子区间内的元素次序则无任何保证。</p>
<p>举例来说，假设有序列{22, 30, 30, 17, 33, 40, 17, 23, 22, 12, 20}，以下操作：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">nth_element</span>(iv.<span class="built_in">begin</span>(), iv.<span class="built_in">begin</span>() + <span class="number">5</span>, iv.<span class="built_in">end</span>());</span><br></pre></td></tr></table></figure>

<p>便是将小于*(iv.begin() + 5)（本例为40）的元素置于该元素之左，其余置于该元素之右，并且不保证维持原有的相对位置。获得的结果为{20, 12, 22, 17, 17, 22, 23, 30, 30, 33, 40}。执行完毕后的第5个位置上的元素值22，与整个序列完整排序后{12, 17, 17, 20, 22, 22, 23, 30, 30, 33, 40}的第5个位置上的元素值相同。</p>
<p>如果以上述结果{20, 12, 22,17,17, 22, 23, 30, 30, 33, 40}为根据，再执行以下操作：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">nth_element</span>(iv.<span class="built_in">begin</span>(), iv.<span class="built_in">begin</span>() + <span class="number">5</span>, iv.<span class="built_in">end</span>(), <span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;());</span><br></pre></td></tr></table></figure>

<p>那便是将大于*(iv.begin() + 5)（本例为22）的元素置于该元素之左，其余置于该元素之右，并且不保证维持原有的相对位置。获得的结果为{40, 33, 30, 30, 23, 22, 17, 17, 22, 12, 20}。</p>
<p>由于nth_element 比partial_sort的保证更少（是的，它不保证两个子序列内的任何次序），所以它当然应该比partial_sort较快。</p>
<p>nth_element有两个版本，其差异在于如何定义某个元素小于另一个元素。第一版本使用operator&lt;进行比较，第二个版本使用仿函数comp进行比较。注意，这个算法只接受RandomAccesslterator。</p>
<p>nth_element的做法是，不断地以median-of-3 partitioning（以首、尾、中央三点中值为枢轴之分割法）将整个序列分割为更小的左(L)、右(R)子序列。如果nth迭代器落于左子序列，就再对左子序列进行分割，否则就再对右子序列进行分割。依此类推，直到分割后的子序列长度不大于3（够小了），便对最后这个待分割的子序列做Insertion Sort，大功告成。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//版本一</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">RandomAccessIterator</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">nth_element</span><span class="params">(RandomAccessIterator first, RandomAccessIterator nth, RandormAccessIterator last)</span> </span>&#123;</span><br><span class="line">	__nth_element(first, nth, last, <span class="built_in">value_type</span>(first));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//版本一辅助函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">RandomAccessIterator</span>, <span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> __nth_element(RandomAccessIterator first, RandomAccessIterator nth, RandomAccessIterator last, T*) &#123;</span><br><span class="line">	<span class="keyword">while</span> (last - first &gt; <span class="number">3</span>) &#123;		<span class="comment">//长度超过3</span></span><br><span class="line">		<span class="comment">//采用median-of-3 partitioning。参数:(first, last, pivot)</span></span><br><span class="line">		<span class="comment">//返回一个迭代器，指向分割后的右段第一个元素</span></span><br><span class="line">		RandomAccessIterator cut = __unguarded_partition(first, last, <span class="built_in">T</span>(__median(*first, *(first + (last - first)/<span class="number">2</span>), *(last - <span class="number">1</span>))));</span><br><span class="line">		<span class="keyword">if</span> (cut &lt;= nth)		<span class="comment">//如果右段起点&lt;=指定位置(nth落于右段</span></span><br><span class="line">			first = cut;	<span class="comment">//再对右段实施分割(partitioning)</span></span><br><span class="line">		<span class="keyword">else</span>				<span class="comment">//否则(nth落于左段)</span></span><br><span class="line">			last = cut;		 <span class="comment">//对左段实施分割(partitioning)</span></span><br><span class="line">	&#125;</span><br><span class="line">	__insertion_sort(first, last);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="merge-sort"><a href="#merge-sort" class="headerlink" title="merge sort"></a>merge sort</h4><p>既然我们知道，将两个有序（sorted）区间归并成一个有序区间，效果不错，那么我们可以利用“分而治之”( devide and conquer )”的概念，以各个击破的方式来对一个区间进行排序。首先，将区间对半分割，左右两段各自排序，再利用inplace_merge重新组合为一个完整的有序序列。对半分割的操作可以递归进行，直到每一小段的长度为0或1（那么该小段也就自动完成了排序）。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">BidirectionalIter</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mergesort</span><span class="params">(BidirectionalIter first, BidirectionalIter last)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">typename</span> iterator_traits&lt;BidirectionalIter&gt;::difference_type n = <span class="built_in">distance</span>(first, last);</span><br><span class="line">	<span class="keyword">if</span> (n == <span class="number">0</span> || n == <span class="number">1</span>)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		BidirectionalIter mid = first + n / <span class="number">2</span>;</span><br><span class="line">		<span class="built_in">mergesort</span>(first, mid);</span><br><span class="line">		<span class="built_in">mergesort</span>(mid, last);</span><br><span class="line">		<span class="built_in">inplace_merge</span>(first, mid, last);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Merge Sort的复杂度为O(N logN)。虽然这和Quick Sort是一样的，但因为Merge Sort需借用额外的内存，而且在内存之间移动（复制）数据也会耗费不少时间，所以Merge Sort的效率比不上 Quick Sort。实现简单、概念简单，是Merge Sort的两大优点。	</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://example.com">lzl121373</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2022/04/08/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E7%AC%AC%E5%85%AD%E7%AB%A0/">http://example.com/2022/04/08/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E7%AC%AC%E5%85%AD%E7%AB%A0/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">😊</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/STL/">STL</a><a class="post-meta__tags" href="/tags/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/">STL源码剖析</a><a class="post-meta__tags" href="/tags/%E7%AE%97%E6%B3%95/">算法</a></div><div class="post_share"><div class="social-share" data-image="/../img/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E5%B0%81%E9%9D%A2.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/gh/overtrue/share.js@master/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/05/09/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E7%AC%AC%E5%85%AB%E7%AB%A0/"><img class="prev-cover" src="/../img/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E5%B0%81%E9%9D%A2.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">&lt;STL源码剖析&gt;第八章——配接器</div></div></a></div><div class="next-post pull-right"><a href="/2022/04/02/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E7%AC%AC%E4%BA%94%E7%AB%A0/"><img class="next-cover" src="/../img/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E5%B0%81%E9%9D%A2.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">&lt;STL源码剖析&gt;第五章——关联式容器</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2022/03/21/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E7%AC%AC%E4%B8%80%E4%BA%8C%E7%AB%A0/" title="&lt;STL源码剖析&gt;第一二章——allocator"><img class="cover" src="/../img/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E5%B0%81%E9%9D%A2.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-03-21</div><div class="title">&lt;STL源码剖析&gt;第一二章——allocator</div></div></a></div><div><a href="/2022/05/09/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E7%AC%AC%E4%B8%83%E7%AB%A0/" title="&lt;STL源码剖析&gt;第七章——仿函数"><img class="cover" src="/../img/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E5%B0%81%E9%9D%A2.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-05-09</div><div class="title">&lt;STL源码剖析&gt;第七章——仿函数</div></div></a></div><div><a href="/2022/03/23/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E7%AC%AC%E4%B8%89%E7%AB%A0/" title="&lt;STL源码剖析&gt;第三章——迭代器"><img class="cover" src="/../img/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E5%B0%81%E9%9D%A2.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-03-23</div><div class="title">&lt;STL源码剖析&gt;第三章——迭代器</div></div></a></div><div><a href="/2022/04/02/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E7%AC%AC%E4%BA%94%E7%AB%A0/" title="&lt;STL源码剖析&gt;第五章——关联式容器"><img class="cover" src="/../img/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E5%B0%81%E9%9D%A2.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-04-02</div><div class="title">&lt;STL源码剖析&gt;第五章——关联式容器</div></div></a></div><div><a href="/2022/05/09/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E7%AC%AC%E5%85%AB%E7%AB%A0/" title="&lt;STL源码剖析&gt;第八章——配接器"><img class="cover" src="/../img/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E5%B0%81%E9%9D%A2.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-05-09</div><div class="title">&lt;STL源码剖析&gt;第八章——配接器</div></div></a></div><div><a href="/2022/03/26/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E7%AC%AC%E5%9B%9B%E7%AB%A0/" title="&lt;STL源码剖析&gt;第四章——序列式容器"><img class="cover" src="/../img/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E5%B0%81%E9%9D%A2.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-03-26</div><div class="title">&lt;STL源码剖析&gt;第四章——序列式容器</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">lzl121373</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">11</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">51</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">2</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/lzl121373" target="_blank" title="Github"><i class="fab fa-github"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%97%E6%B3%95"><span class="toc-number">1.</span> <span class="toc-text">算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E5%80%BC%E7%AE%97%E6%B3%95-lt-stl-numeric-h-gt"><span class="toc-number">1.1.</span> <span class="toc-text">数值算法&lt;stl_numeric.h&gt;</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#accumulate"><span class="toc-number">1.1.1.</span> <span class="toc-text">accumulate</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#adjacent-difference"><span class="toc-number">1.1.2.</span> <span class="toc-text">adjacent_difference</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#inner-producct"><span class="toc-number">1.1.3.</span> <span class="toc-text">inner_producct</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#partial-sum"><span class="toc-number">1.1.4.</span> <span class="toc-text">partial_sum</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#power"><span class="toc-number">1.1.5.</span> <span class="toc-text">power</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#itoa"><span class="toc-number">1.1.6.</span> <span class="toc-text">itoa</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E7%AE%97%E6%B3%95-lt-stl-algobase-h-gt"><span class="toc-number">1.2.</span> <span class="toc-text">基本算法&lt;stl_algobase.h&gt;</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#equal"><span class="toc-number">1.2.1.</span> <span class="toc-text">equal</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#fill"><span class="toc-number">1.2.2.</span> <span class="toc-text">fill</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#fill-n"><span class="toc-number">1.2.3.</span> <span class="toc-text">fill_n</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#iter-swap"><span class="toc-number">1.2.4.</span> <span class="toc-text">iter_swap</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#lexicographical-compare"><span class="toc-number">1.2.5.</span> <span class="toc-text">lexicographical_compare</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#max"><span class="toc-number">1.2.6.</span> <span class="toc-text">max</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#min"><span class="toc-number">1.2.7.</span> <span class="toc-text">min</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#mismatch"><span class="toc-number">1.2.8.</span> <span class="toc-text">mismatch</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#swap"><span class="toc-number">1.2.9.</span> <span class="toc-text">swap</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#copy"><span class="toc-number">1.2.10.</span> <span class="toc-text">copy</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#copy%E7%AE%97%E6%B3%95%E7%9A%84%E5%AE%9E%E7%8E%B0%E7%BB%86%E8%8A%82"><span class="toc-number">1.2.10.1.</span> <span class="toc-text">copy算法的实现细节</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#copy-backward"><span class="toc-number">1.2.11.</span> <span class="toc-text">copy_backward</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#set%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95"><span class="toc-number">1.3.</span> <span class="toc-text">set相关算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#set-union"><span class="toc-number">1.3.1.</span> <span class="toc-text">set_union</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#set-intersection"><span class="toc-number">1.3.2.</span> <span class="toc-text">set_intersection</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#set-difference"><span class="toc-number">1.3.3.</span> <span class="toc-text">set_difference</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#set-symmetric-difference"><span class="toc-number">1.3.4.</span> <span class="toc-text">set_symmetric_difference</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B6%E5%AE%83%E7%AE%97%E6%B3%95"><span class="toc-number">1.4.</span> <span class="toc-text">其它算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%95%E7%BA%AF%E7%9A%84%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86"><span class="toc-number">1.4.1.</span> <span class="toc-text">单纯的数据处理</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#adjacent-find"><span class="toc-number">1.4.1.1.</span> <span class="toc-text">adjacent_find</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#count"><span class="toc-number">1.4.1.2.</span> <span class="toc-text">count</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#count-if"><span class="toc-number">1.4.1.3.</span> <span class="toc-text">count_if</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#find"><span class="toc-number">1.4.1.4.</span> <span class="toc-text">find</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#find-if"><span class="toc-number">1.4.1.5.</span> <span class="toc-text">find_if</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#find-end"><span class="toc-number">1.4.1.6.</span> <span class="toc-text">find_end</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#find-first-of"><span class="toc-number">1.4.1.7.</span> <span class="toc-text">find_first_of</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#for-each"><span class="toc-number">1.4.1.8.</span> <span class="toc-text">for_each</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#generate"><span class="toc-number">1.4.1.9.</span> <span class="toc-text">generate</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#generate-n"><span class="toc-number">1.4.1.10.</span> <span class="toc-text">generate_n</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#includes%EF%BC%88%E5%BA%94%E7%94%A8%E4%BA%8E%E6%9C%89%E5%BA%8F%E5%8C%BA%E9%97%B4%EF%BC%89"><span class="toc-number">1.4.1.11.</span> <span class="toc-text">includes（应用于有序区间）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#max-element"><span class="toc-number">1.4.1.12.</span> <span class="toc-text">max_element</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#merge%EF%BC%88%E5%BA%94%E7%94%A8%E4%BA%8E%E6%9C%89%E5%BA%8F%E5%8C%BA%E9%97%B4%EF%BC%89"><span class="toc-number">1.4.1.13.</span> <span class="toc-text">merge（应用于有序区间）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#min-element"><span class="toc-number">1.4.1.14.</span> <span class="toc-text">min_element</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#partition"><span class="toc-number">1.4.1.15.</span> <span class="toc-text">partition</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#remove-%E7%A7%BB%E9%99%A4%EF%BC%88%E4%BD%86%E4%B8%8D%E5%88%A0%E9%99%A4%EF%BC%89"><span class="toc-number">1.4.1.16.</span> <span class="toc-text">remove 移除（但不删除）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#remove-copy"><span class="toc-number">1.4.1.17.</span> <span class="toc-text">remove_copy</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#remove-if"><span class="toc-number">1.4.1.18.</span> <span class="toc-text">remove_if</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#remove-copy-if"><span class="toc-number">1.4.1.19.</span> <span class="toc-text">remove_copy_if</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#replace"><span class="toc-number">1.4.1.20.</span> <span class="toc-text">replace</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#replace-copy"><span class="toc-number">1.4.1.21.</span> <span class="toc-text">replace_copy</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#replace-if"><span class="toc-number">1.4.1.22.</span> <span class="toc-text">replace_if</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#replace-copy-if"><span class="toc-number">1.4.1.23.</span> <span class="toc-text">replace_copy_if</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#reverse"><span class="toc-number">1.4.1.24.</span> <span class="toc-text">reverse</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#reverse-copy"><span class="toc-number">1.4.1.25.</span> <span class="toc-text">reverse_copy</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#rotate"><span class="toc-number">1.4.1.26.</span> <span class="toc-text">rotate</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#rotate-copy"><span class="toc-number">1.4.1.27.</span> <span class="toc-text">rotate_copy</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#search"><span class="toc-number">1.4.1.28.</span> <span class="toc-text">search</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#search-n"><span class="toc-number">1.4.1.29.</span> <span class="toc-text">search_n</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#swap-ranges"><span class="toc-number">1.4.1.30.</span> <span class="toc-text">swap_ranges</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#transform"><span class="toc-number">1.4.1.31.</span> <span class="toc-text">transform</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#unique"><span class="toc-number">1.4.1.32.</span> <span class="toc-text">unique</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#unique-copy"><span class="toc-number">1.4.1.33.</span> <span class="toc-text">unique_copy</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#lower-bound%EF%BC%88%E5%BA%94%E7%94%A8%E4%BA%8E%E6%9C%89%E5%BA%8F%E5%8C%BA%E9%97%B4%EF%BC%89"><span class="toc-number">1.4.2.</span> <span class="toc-text">lower_bound（应用于有序区间）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#upper-bound%EF%BC%88%E5%BA%94%E7%94%A8%E4%BA%8E%E6%9C%89%E5%BA%8F%E5%8C%BA%E9%97%B4%EF%BC%89"><span class="toc-number">1.4.3.</span> <span class="toc-text">upper_bound（应用于有序区间）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#binary-search%EF%BC%88%E5%BA%94%E7%94%A8%E4%BA%8E%E6%9C%89%E5%BA%8F%E5%8C%BA%E9%97%B4%EF%BC%89"><span class="toc-number">1.4.4.</span> <span class="toc-text">binary_search（应用于有序区间）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#next-permutation"><span class="toc-number">1.4.5.</span> <span class="toc-text">next_permutation</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%8E%92%E5%88%97%E7%BB%84%E5%90%88%EF%BC%9F"><span class="toc-number">1.4.5.1.</span> <span class="toc-text">什么是排列组合？</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.4.6.</span> <span class="toc-text">算法实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#prev-permutation"><span class="toc-number">1.4.7.</span> <span class="toc-text">prev_permutation</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0-1"><span class="toc-number">1.4.8.</span> <span class="toc-text">算法实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#random-shuffle"><span class="toc-number">1.4.9.</span> <span class="toc-text">random_shuffle</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#partial-sort-x2F-partial-sort-copy"><span class="toc-number">1.4.10.</span> <span class="toc-text">partial_sort &#x2F; partial_sort_copy</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0-2"><span class="toc-number">1.4.10.1.</span> <span class="toc-text">算法实现</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#sort"><span class="toc-number">1.4.11.</span> <span class="toc-text">sort</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Insertion-Sort"><span class="toc-number">1.4.11.1.</span> <span class="toc-text">Insertion Sort</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Quick-Sort"><span class="toc-number">1.4.11.2.</span> <span class="toc-text">Quick Sort</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#Median-of-Three%EF%BC%88%E4%B8%89%E7%82%B9%E4%B8%AD%E5%80%BC%EF%BC%89"><span class="toc-number">1.4.11.2.1.</span> <span class="toc-text">Median-of-Three（三点中值）</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#Partitioning%EF%BC%88%E5%88%86%E5%89%B2%EF%BC%89"><span class="toc-number">1.4.11.2.2.</span> <span class="toc-text">Partitioning（分割）</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#threshold%EF%BC%88%E9%98%88%E5%80%BC%EF%BC%89"><span class="toc-number">1.4.11.2.3.</span> <span class="toc-text">threshold（阈值）</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#final-insertion-sort"><span class="toc-number">1.4.11.2.4.</span> <span class="toc-text">final insertion sort</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#introsort"><span class="toc-number">1.4.11.2.5.</span> <span class="toc-text">introsort</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#SGI-STL-sort"><span class="toc-number">1.4.11.2.6.</span> <span class="toc-text">SGI STL sort</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#equal-range%EF%BC%88%E5%BA%94%E7%94%A8%E4%BA%8E%E6%9C%89%E5%BA%8F%E5%8C%BA%E9%97%B4%EF%BC%89"><span class="toc-number">1.4.12.</span> <span class="toc-text">equal_range（应用于有序区间）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#inplace-merge%EF%BC%88%E5%BA%94%E7%94%A8%E4%BA%8E%E6%9C%89%E5%BA%8F%E5%8C%BA%E9%97%B4%EF%BC%89"><span class="toc-number">1.4.13.</span> <span class="toc-text">inplace_merge（应用于有序区间）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#nth-element"><span class="toc-number">1.4.14.</span> <span class="toc-text">nth_element</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#merge-sort"><span class="toc-number">1.4.15.</span> <span class="toc-text">merge sort</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/09/25/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E7%AC%AC%E5%9B%9B%E9%83%A8%E5%88%86/" title="&lt;Redis设计与实现&gt;第四部分"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="&lt;Redis设计与实现&gt;第四部分"/></a><div class="content"><a class="title" href="/2022/09/25/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E7%AC%AC%E5%9B%9B%E9%83%A8%E5%88%86/" title="&lt;Redis设计与实现&gt;第四部分">&lt;Redis设计与实现&gt;第四部分</a><time datetime="2022-09-24T16:00:00.000Z" title="发表于 2022-09-25 00:00:00">2022-09-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/08/28/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E7%AC%AC%E4%B8%89%E9%83%A8%E5%88%86/" title="&lt;Redis设计与实现&gt;第三部分"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="&lt;Redis设计与实现&gt;第三部分"/></a><div class="content"><a class="title" href="/2022/08/28/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E7%AC%AC%E4%B8%89%E9%83%A8%E5%88%86/" title="&lt;Redis设计与实现&gt;第三部分">&lt;Redis设计与实现&gt;第三部分</a><time datetime="2022-08-27T16:00:00.000Z" title="发表于 2022-08-28 00:00:00">2022-08-28</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/05/29/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86/" title="&lt;Redis设计与实现&gt;第二部分"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="&lt;Redis设计与实现&gt;第二部分"/></a><div class="content"><a class="title" href="/2022/05/29/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86/" title="&lt;Redis设计与实现&gt;第二部分">&lt;Redis设计与实现&gt;第二部分</a><time datetime="2022-05-28T16:00:00.000Z" title="发表于 2022-05-29 00:00:00">2022-05-29</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/05/13/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86/" title="&lt;Redis设计与实现&gt;第一部分"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="&lt;Redis设计与实现&gt;第一部分"/></a><div class="content"><a class="title" href="/2022/05/13/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86/" title="&lt;Redis设计与实现&gt;第一部分">&lt;Redis设计与实现&gt;第一部分</a><time datetime="2022-05-12T16:00:00.000Z" title="发表于 2022-05-13 00:00:00">2022-05-13</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/05/09/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E7%AC%AC%E4%B8%83%E7%AB%A0/" title="&lt;STL源码剖析&gt;第七章——仿函数"><img src="/../img/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E5%B0%81%E9%9D%A2.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="&lt;STL源码剖析&gt;第七章——仿函数"/></a><div class="content"><a class="title" href="/2022/05/09/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E7%AC%AC%E4%B8%83%E7%AB%A0/" title="&lt;STL源码剖析&gt;第七章——仿函数">&lt;STL源码剖析&gt;第七章——仿函数</a><time datetime="2022-05-08T16:00:00.000Z" title="发表于 2022-05-09 00:00:00">2022-05-09</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By lzl121373</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>
<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>&lt;STL源码剖析&gt;第五章——关联式容器 | 😊</title><meta name="keywords" content="STL,STL源码剖析,容器,关联式容器,二叉搜索树,RB-tree,set,map,multiset,multimap,hashtable"><meta name="author" content="lzl121373"><meta name="copyright" content="lzl121373"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="第五章读书笔记，关于关联式容器的源码剖析">
<meta property="og:type" content="article">
<meta property="og:title" content="&lt;STL源码剖析&gt;第五章——关联式容器">
<meta property="og:url" content="http://example.com/2022/04/02/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E7%AC%AC%E4%BA%94%E7%AB%A0/index.html">
<meta property="og:site_name" content="😊">
<meta property="og:description" content="第五章读书笔记，关于关联式容器的源码剖析">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E5%B0%81%E9%9D%A2.jpg">
<meta property="article:published_time" content="2022-04-01T16:00:00.000Z">
<meta property="article:modified_time" content="2022-04-07T16:00:00.000Z">
<meta property="article:author" content="lzl121373">
<meta property="article:tag" content="STL">
<meta property="article:tag" content="STL源码剖析">
<meta property="article:tag" content="容器">
<meta property="article:tag" content="关联式容器">
<meta property="article:tag" content="二叉搜索树">
<meta property="article:tag" content="RB-tree">
<meta property="article:tag" content="set">
<meta property="article:tag" content="map">
<meta property="article:tag" content="multiset">
<meta property="article:tag" content="multimap">
<meta property="article:tag" content="hashtable">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E5%B0%81%E9%9D%A2.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2022/04/02/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E7%AC%AC%E4%BA%94%E7%AB%A0/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '<STL源码剖析>第五章——关联式容器',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-04-08 00:00:00'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="😊" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">11</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">51</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">2</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-images"></i><span> Photo</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/../img/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E5%B0%81%E9%9D%A2.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">😊</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-images"></i><span> Photo</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">&lt;STL源码剖析&gt;第五章——关联式容器</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-04-01T16:00:00.000Z" title="发表于 2022-04-02 00:00:00">2022-04-02</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-04-07T16:00:00.000Z" title="更新于 2022-04-08 00:00:00">2022-04-08</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">STL源码剖析读书笔记</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">9.5k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>40分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="&lt;STL源码剖析&gt;第五章——关联式容器"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h2><p><img src="/../img/%E5%AE%B9%E5%99%A8.png" alt="容器"></p>
<p>容器将运用最广的一些数据结构实现出来。这里的衍生不是inheritance关系，而是containment关系，例如：heap内含一个vector，priority-queue内含一个heap。</p>
<h2 id="关联式容器"><a href="#关联式容器" class="headerlink" title="关联式容器"></a>关联式容器</h2><p>所谓关联式容器，观念上类似关联式数据库（实际上则简单许多）：每笔数据（每个元素）都有一个键值（key）和一个实值（value）。当元素被插人到关联式容器中时，容器内部结构（可能是RB-tree，也可能是hash-table）便依照其键值大小，以某种特定规则将这个元素放置于适当位置。关联式容器没有所谓头尾（只有最大元素和最小元素），所以不会有所谓push_back()、push_front()、pop_back()、pop_front()、begin()、 end()这样的操作行为。</p>
<p>一般而言，关联式容器的内部结构是一个balanced binary tree(平衡二叉树)，以便获得良好的搜寻效率。balanced binary tree有许多种类型，包括AVL-tree、RB-tree、AA-tree，其中最广泛被运用于STL的是RB-tree。</p>
<h3 id="二叉搜索树（binary-search-tree）"><a href="#二叉搜索树（binary-search-tree）" class="headerlink" title="二叉搜索树（binary search tree）"></a>二叉搜索树（binary search tree）</h3><p>二叉搜索树可提供对数时间的元素插入和访问，二叉搜索树的节点放置规则是：任何节点的键值一定大于其左子树中的每一个节点的键值，并小于其右子树中的每一个节点的键值。因此，从根节点一直往左走，直至无左路可走，即得到最小元素；从根节点一直往右走，直至无右路可走，即得最大元素。</p>
<p><img src="/../img/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.png" alt="二叉搜索树"></p>
<h3 id="平衡二叉搜索树（balanced-binary-search-tree）"><a href="#平衡二叉搜索树（balanced-binary-search-tree）" class="headerlink" title="平衡二叉搜索树（balanced binary search tree）"></a>平衡二叉搜索树（balanced binary search tree）</h3><p>二叉搜索树可能会因为输入值不够随机或者一些插入删除操作的原因失去平衡，造成搜寻效率低的情况。</p>
<p><img src="/../img/%E4%B8%8D%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91.png" alt="不平衡二叉树"></p>
<p>“平衡”的大致意义是：没有任何一个节点过深，并没有一个绝对的衡量标准，因此，出现了不同的平衡条件造就的数种特殊结构如AVL-tree、RB-tree、AA-tree，他们都比一般的二叉搜索树复杂，因此，插入和删除节点的平均时间更长，但是可以避免不平衡的情况而实现更少的元素平均访问时间。</p>
<h3 id="AVL-tree"><a href="#AVL-tree" class="headerlink" title="AVL tree"></a>AVL tree</h3><p>AVL-tree要求任何节点的左右子树高度相差最多1，虽然要求每个节点的左右子树有着相同的高度是直观上的最佳平衡条件，但这样太过苛刻以至于难以在插入新元素时又保持着这种平衡状态。</p>
<p>AVL-tree的平衡策略是：调整“插入点至根节点”路径上，平衡状态被破坏之各节点中最深的那一个，使整棵树重新获得平衡。假设该最深节点为X，“平衡破坏”意味着X的左右两颗子树的高度相差2，可以将情况分为四种：</p>
<ol>
<li>插人点位于X的左子节点的左子树——左左。</li>
<li>插人点位于X的左子节点的右子树——左右。</li>
<li>插人点位于X的右子节点的左子树——右左。</li>
<li>插入点位于X的右子节点的右子树——右右。</li>
</ol>
<p>情况1，4称为外侧插入，可以用单旋操作调整；情况2，3称为内侧插入，可以采用双旋操作调整。</p>
<p><img src="/../img/AVL-tree%E7%A0%B4%E5%9D%8F%E5%B9%B3%E8%A1%A1.png" alt="AVL-tree破坏平衡"></p>
<h4 id="单旋转"><a href="#单旋转" class="headerlink" title="单旋转"></a>单旋转</h4><p><img src="/../img/%E5%8D%95%E6%97%8B%E8%BD%AC.png" alt="单旋转"></p>
<p>通过k1上提，k2下滑来获得平衡（以k1为新的根节点）。</p>
<h4 id="双旋转"><a href="#双旋转" class="headerlink" title="双旋转"></a>双旋转</h4><p><img src="/../img/%E5%8F%8C%E6%97%8B%E8%BD%AC.png" alt="双旋转"></p>
<p>以k2为新的根节点来获得平衡。</p>
<p>可拆解为两次单循环：</p>
<p><img src="/../img/%E5%8F%8C%E5%BE%AA%E7%8E%AF%E6%8B%86%E8%A7%A3.png" alt="双循环拆解"></p>
<h3 id="RB-tree（红黑树）"><a href="#RB-tree（红黑树）" class="headerlink" title="RB-tree（红黑树）"></a>RB-tree（红黑树）</h3><p>AVL-tree之外，另一个平衡二叉搜索树是RB-tree（红黑树），红黑树不仅是一个二叉搜索树，还必须满足以下规则：</p>
<ol>
<li>每个节点不是红色就是黑色（图中深色底纹代表黑色，浅色底纹代表红色，下同)。</li>
<li>根节点为黑色。</li>
<li>如果节点为红，其子节点必须为黑。</li>
<li>任一节点至 NULL（树尾端）的任何路径，所含之黑节点数必须相同。</li>
</ol>
<p>根据规则4，新增节点必须为红，根据规则3，新增节点之父节点必须为黑。</p>
<p><img src="/../img/%E7%BA%A2%E9%BB%91%E6%A0%91.png" alt="红黑树"></p>
<h4 id="插入节点"><a href="#插入节点" class="headerlink" title="插入节点"></a>插入节点</h4><p>假设新节点为X，其父节点为P，祖父节点为G，父节点的兄弟节点为S，曾祖父节点为GG。</p>
<p>首先，二叉搜索树的新增节点必为叶节点，因此，X节点必为叶节点即必是红色，如果此时P节点也为红色，就违反了规则，此时G必为黑，于是插入节点后需调整的情况可根据X插入位置以及S和GG的颜色分为四类：</p>
<ol>
<li>S为黑且X为外侧插入。此时，先对P，G做一次单旋转，再更改P,G颜色。</li>
</ol>
<p><img src="/../img/S%E9%BB%91%E5%A4%96%E6%8F%92.png" alt="S黑外插"></p>
<ol start="2">
<li>S为黑且X为内侧插入。此时，做一次双旋转（先对P，X做一次单旋转且更改G，X颜色，再对G做一次单旋转）。</li>
</ol>
<p><img src="/../img/S%E9%BB%91%E5%86%85%E6%8F%92.png" alt="S黑内插"></p>
<ol start="3">
<li>S为红且X为外侧插入。此时，先对P，G做一次单旋转，并改变X的颜色，此时如果GG为黑，则搞定。</li>
</ol>
<p><img src="/../img/S%E7%BA%A2%E5%A4%96%E6%8F%92GG%E9%BB%91.png" alt="S红外插GG黑"></p>
<ol start="4">
<li>S为红且X为外侧插入，此时，先对P，G做一次单旋转，并改变X的颜色，此时如果GG为红，则不应该这样做，而是应该先实行一个由上而下的程序：假设新增节点为A，那么就沿着A的路径，只要看到有某节点X的两个子节点皆为红色，就把X改为红色，并把两个子节点改为黑色，如果X的父节点P以为红色，就得像状况1做一次单旋转并改变颜色或是像状况2做一次双旋转并改变颜色。程序结束后再插入就很简单了。</li>
</ol>
<h4 id="RB-tree节点设计"><a href="#RB-tree节点设计" class="headerlink" title="RB-tree节点设计"></a>RB-tree节点设计</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">bool</span> __rb_tree_color_type;</span><br><span class="line"><span class="type">const</span> __rb_tree_color_type __rb_tree_red = <span class="literal">false</span>; <span class="comment">//红色为0</span></span><br><span class="line"><span class="type">const</span> __rb_tree_color_type __rb_tree_black = <span class="literal">true</span>; <span class="comment">//黑色为1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__rb_tree_node_base</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">typedef</span> __rb_tree_color_type color_type;</span><br><span class="line">	<span class="keyword">typedef</span> __rb_tree_node_base* base_ptr;</span><br><span class="line"></span><br><span class="line">	color_type color;  <span class="comment">//节点颜色，非红即黑	</span></span><br><span class="line">	base_ptr parent;   <span class="comment">//RB树的许多操作，必须知道父节点</span></span><br><span class="line">	base_ptr left;     <span class="comment">//指向左节点</span></span><br><span class="line">	base_ptr right;    <span class="comment">//指向右节点</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">static</span> base_ptr <span class="title">mininum</span><span class="params">(base_ptr x)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">while</span> (x-&gt;left != <span class="number">0</span>) x = x-&gt;left;   <span class="comment">//一直向左走，就会找到最小值,</span></span><br><span class="line">		<span class="keyword">return</span> x;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">static</span> base_ptr <span class="title">maximum</span><span class="params">(base_ptr x)</span> </span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">while</span> (x-&gt;right != <span class="number">0</span>) x = x-&gt;right; <span class="comment">//一直向右走，就会找到最大,</span></span><br><span class="line">		<span class="keyword">return</span> x;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Value</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__rb_tree_node</span> : <span class="keyword">public</span> __rb_tree_node_base</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">typedef</span> __rb_tree_node&lt;Value&gt;* link_type;</span><br><span class="line">	Value value_field;   <span class="comment">//节点值</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="RB-tree的迭代器"><a href="#RB-tree的迭代器" class="headerlink" title="RB-tree的迭代器"></a>RB-tree的迭代器</h4><p>RB-tree的节点和迭代器（Bidirectional Iterator）结构设计和slist类似，为两层结构：</p>
<p><img src="/../img/RB-tree%E8%8A%82%E7%82%B9%E5%92%8C%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%BB%93%E6%9E%84.png" alt="RB-tree节点和迭代器结构"></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//基层迭代器</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__rb_tree_base_iterator</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">typedef</span> __rb_tree_node_base::base_ptr base_ptr;</span><br><span class="line">	<span class="keyword">typedef</span> bidirectional_iterator_tag iterator_category;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="type">ptrdiff_t</span> difference_type;</span><br><span class="line"></span><br><span class="line">	base_ptr node; <span class="comment">// 它用来与容器之间产生一个连结关系(make a reference)</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//以下其实可实现于operator++内，因为再无他处会调用此函数了</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">increment</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (node-&gt;right != <span class="number">0</span>) &#123;			<span class="comment">//如果有右子节点。状况(1)</span></span><br><span class="line">			node = node-&gt;right;         <span class="comment">//就向右走</span></span><br><span class="line">			<span class="keyword">while</span> (node-&gt;left != <span class="number">0</span>）    <span class="comment">//然后一直往左子树走到底</span></span><br><span class="line">				node = node-&gt;left;      <span class="comment">//即是解答</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;                           <span class="comment">//没有右子节点。状况(2)</span></span><br><span class="line">			base_ptr y = node-&gt;parent;   <span class="comment">//找出父节点</span></span><br><span class="line">			<span class="keyword">while</span> (node == y-&gt;right) &#123;   <span class="comment">//如果现行节点本身是个右子节点，</span></span><br><span class="line">				node = y;                <span class="comment">//就一直上溯，直到“不为右子节点”止</span></span><br><span class="line">				y = y-&gt;parent;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (node-&gt;right != y)        <span class="comment">//若此时的右子节点不等于此时的父节点</span></span><br><span class="line">				node = y;                <span class="comment">//状况(3)此时的父节点即为解答</span></span><br><span class="line">           							    <span class="comment">//否则此时的node为解答。状况(4)</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//注意，以上判断“若此时的右子节点不等于此时的父节点”，是为了应付一种</span></span><br><span class="line">		<span class="comment">//特殊情况:我们欲寻找根节点的下一节点，而恰巧根节点无右子节点</span></span><br><span class="line">		<span class="comment">//当然，以上特殊做法必须配合RB-tree 根节点与特殊之header之间的</span></span><br><span class="line">		<span class="comment">//特殊关系</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//以下其实可实现于operator--内，因为再无他处会调用此函数了</span></span><br><span class="line">	<span class="type">void</span> <span class="built_in">decrement</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (node-&gt;color == __rb_tree_red &amp;&amp; <span class="comment">//如果是红节点，且</span></span><br><span class="line">			node-&gt;parent-&gt;parent == node)   <span class="comment">//父节点的父节点等于自己，</span></span><br><span class="line">			node = node-&gt;right;             <span class="comment">//状况(1)右子节点即为解答</span></span><br><span class="line">		<span class="comment">//以上情况发生于node为header时(亦即node为end()时)</span></span><br><span class="line">		<span class="comment">//注意，header之右子节点即mostright，指向整棵树的max节点</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (node-&gt;left != <span class="number">0</span>) &#123;         <span class="comment">//如果有左子节点。状况(2)</span></span><br><span class="line">			base_ptr y = node-&gt;left;        <span class="comment">//令y指向左子节点</span></span><br><span class="line">			<span class="keyword">while</span> (y-&gt;right ! = <span class="number">0</span>)          <span class="comment">//当y有右子节点时</span></span><br><span class="line">				y = y-&gt;right;              <span class="comment">//一直往右子节点走到底</span></span><br><span class="line">			node = y;                      <span class="comment">//最后即为答案</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;                             <span class="comment">//既非根节点，亦无左子节点</span></span><br><span class="line">			base_ptr y = node-&gt;parent;     <span class="comment">//状况(3）找出父节点</span></span><br><span class="line">			<span class="keyword">while</span> (node == y-&gt;left) &#123;      <span class="comment">//当现行节点身为左子节点</span></span><br><span class="line">				node = y;                  <span class="comment">//一直交替往上走，直到现行节点</span></span><br><span class="line">				y = y-&gt;parent;             <span class="comment">//不为左子节点</span></span><br><span class="line">			&#125;</span><br><span class="line">			node = y;				      <span class="comment">//此时之父节点即为答案</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;           </span><br><span class="line"></span><br><span class="line"><span class="comment">//RB-tree的正规迭代器</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> Value, <span class="keyword">class</span> Ref, <span class="keyword">class</span> Ptr&gt;</span><br><span class="line"><span class="keyword">struct</span> __rb_tree_iterator : <span class="keyword">public</span> __rb_tree_base_iterator</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">typedef</span> Value value_type;</span><br><span class="line">	<span class="keyword">typedef</span> Ref reference;</span><br><span class="line">	<span class="keyword">typedef</span> Ptr pointer;</span><br><span class="line">	<span class="keyword">typedef</span> __rb_tree_iterator&lt;Value, Value&amp;, Value*&gt; iterator;</span><br><span class="line">	<span class="keyword">typedef</span> __rb_tree_iterator&lt;Value, <span class="type">const</span> Value&amp;, <span class="type">const</span> value*&gt; const_iterator;</span><br><span class="line">	<span class="keyword">typedef</span> __rb_tree_iterator&lt;Value, Ref, Ptr&gt; self;</span><br><span class="line">	<span class="keyword">typedef</span> __rb_tree_node&lt;Value&gt;*    link_type;</span><br><span class="line"></span><br><span class="line">	__rb_tree_iterator() &#123; &#125;</span><br><span class="line">	__rb_tree_iterator(link_type x) &#123; node = x; &#125;</span><br><span class="line">	__rb_tree_iterator(<span class="type">const</span> iterator&amp; it) &#123; node = it.node; &#125;</span><br><span class="line">	</span><br><span class="line">	reference <span class="keyword">operator</span>*() <span class="type">const</span> &#123; <span class="keyword">return</span> <span class="built_in">link_type</span>(node) -&gt; value_field; &#125;</span><br><span class="line">	<span class="meta">#<span class="keyword">ifndef</span> __SGI_STL_NO_ARROW_OPERATOR</span></span><br><span class="line">	pointer <span class="keyword">operator</span>-&gt;() <span class="type">const</span> &#123; <span class="keyword">return</span> &amp;(<span class="keyword">operator</span>*()); &#125;</span><br><span class="line">	<span class="meta">#<span class="keyword">endif</span> <span class="comment">/*__SGI_STL_NO_ARROW_OPERATOR */</span></span></span><br><span class="line">	</span><br><span class="line">	self&amp; <span class="keyword">operator</span>++() &#123; <span class="built_in">increment</span>(); <span class="keyword">return</span> *<span class="keyword">this</span>; &#125;</span><br><span class="line">	self <span class="keyword">operator</span>++(<span class="type">int</span>) &#123;</span><br><span class="line">		self tmp = *<span class="keyword">this</span>;</span><br><span class="line">		<span class="built_in">increment</span>();</span><br><span class="line">		<span class="keyword">return</span> tmp;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">	self&amp; <span class="keyword">operator</span>--() &#123; <span class="built_in">decrement</span>(); <span class="keyword">return</span> *<span class="keyword">this</span>; &#125;</span><br><span class="line">	self <span class="keyword">operator</span>--(<span class="type">int</span>) &#123;</span><br><span class="line">		self tmp = *<span class="keyword">this</span>;</span><br><span class="line">		<span class="built_in">decrement</span>();		</span><br><span class="line">		<span class="keyword">return</span> temp;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;              </span><br></pre></td></tr></table></figure>

<p><img src="/../img/inc%E5%92%8Cdec%E7%9A%84%E8%B4%B9%E8%A7%A3%E6%83%85%E5%86%B5.png" alt="inc和dec的费解情况"></p>
<h4 id="RB-tree的数据结构"><a href="#RB-tree的数据结构" class="headerlink" title="RB-tree的数据结构"></a>RB-tree的数据结构</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Key</span>, <span class="keyword">class</span> <span class="title class_">Value</span>, <span class="keyword">class</span> <span class="title class_">KeyOfValue</span>, <span class="keyword">class</span> <span class="title class_">Compare</span>,</span><br><span class="line">		 <span class="keyword">class</span> <span class="title class_">Alloc</span> = alloc&gt;</span><br><span class="line"><span class="keyword">class</span> rb_tree &#123;</span><br><span class="line">	<span class="keyword">protected</span>:</span><br><span class="line">		<span class="keyword">typedef</span> <span class="type">void</span>* void_pointer;</span><br><span class="line">		<span class="keyword">typedef</span> __rb_tree_node_base* base_ptr;</span><br><span class="line">		<span class="keyword">typedef</span> __rb_tree_node&lt;Value&gt; rb_tree_node;</span><br><span class="line">		<span class="keyword">typedef</span> simple_alloc&lt;rb_tree_node, Alloc&gt; rb_tree_node_allocator;</span><br><span class="line">		<span class="keyword">typedef</span> __rb_tree_color_type color_type;</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">protected</span>:</span><br><span class="line">		<span class="comment">//RB-tree只以三笔数据表现</span></span><br><span class="line">		size_type node_count; <span class="comment">//追踪记录树的大小</span></span><br><span class="line">		link_type header;     <span class="comment">//这是实现的一个技巧</span></span><br><span class="line">		Compare key_compare;  <span class="comment">//节点间的键值大小比较准则，function object</span></span><br><span class="line">    </span><br><span class="line">		<span class="comment">//以下三个函数用来方便取得header的成员</span></span><br><span class="line">		<span class="function">link_type&amp; <span class="title">root</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> (link_type&amp;) header-&gt;parent; &#125;</span><br><span class="line">		<span class="function">link_type&amp; <span class="title">leftmost</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> (link_type&amp;) header-&gt;left; &#125;</span><br><span class="line">		<span class="function">link_type&amp; <span class="title">rightmost</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> (link_type&amp;) header-&gt;right;&#125;</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="keyword">typedef</span> __rb_tree_iterator&lt;value_type, reference, pointer&gt; iterator;</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		iterator __insert(base_ptr x, base_ptr y, <span class="type">const</span> value_type&amp; v);</span><br><span class="line">		link_type __copy(link_type x, link_type p);</span><br><span class="line">		<span class="type">void</span> __erase(link_type x);</span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			header = <span class="built_in">get_node</span>();  <span class="comment">//产生一个节点空间，令header指向它</span></span><br><span class="line">			<span class="built_in">color</span>(header) = __rb_tree_red; <span class="comment">//令header为红色，用来区分header</span></span><br><span class="line">										<span class="comment">//和root，在iterator.operator++之中</span></span><br><span class="line">			<span class="built_in">root</span>() = <span class="number">0</span>;</span><br><span class="line">			<span class="built_in">leftmost</span>() = header;	<span class="comment">//令header的左子节点为自己</span></span><br><span class="line">			<span class="built_in">rightmost</span>() = header;   <span class="comment">//令header 的右子节点为自己</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:				</span><br><span class="line">    					<span class="comment">//allocation / deallocation</span></span><br><span class="line">		<span class="built_in">rb_tree</span>(<span class="type">const</span> Compare&amp; comp = <span class="built_in">Compare</span>())</span><br><span class="line">			: <span class="built_in">node_count</span>(<span class="number">0</span>), <span class="built_in">key_compare</span>(comp) &#123; <span class="built_in">init</span>(); &#125;</span><br><span class="line">		</span><br><span class="line">		~<span class="built_in">rb_tree</span>() &#123;</span><br><span class="line">			<span class="built_in">clear</span>();</span><br><span class="line">			<span class="built_in">put_node</span>(header);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		rb_tree&lt;Key, Value, KeyOfValue, Comapre, Alloc&gt;&amp;</span><br><span class="line">		<span class="keyword">operator</span>=(<span class="type">const</span> rb_tree&lt;Key, Value, KeyOfValue, Compare, Alloc&gt;&amp; x);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">								<span class="comment">//accessors:</span></span><br><span class="line">		<span class="function">Compare <span class="title">key_comp</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> key_compare; &#125;</span><br><span class="line">		<span class="function">iterator <span class="title">begin</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">leftmost</span>(); &#125; <span class="comment">//RB树的起头为最左（最小）节点处</span></span><br><span class="line">		<span class="function">iterator <span class="title">end</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> header; ) <span class="comment">//RB树的终点为header所指处</span></span><br><span class="line">		<span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> node_count == <span class="number">0</span>; &#125;</span><br><span class="line">		<span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> node_count; &#125;</span><br><span class="line">		<span class="function">size_type <span class="title">max_size</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">size_type</span> (<span class="number">-1</span>); &#125;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">							<span class="comment">// insert / erase</span></span><br><span class="line">		<span class="comment">//将x插入到RB-tree中(保持节点值独一无二)</span></span><br><span class="line">		<span class="function">pair&lt;iterator, <span class="type">bool</span>&gt; <span class="title">insert_unique</span><span class="params">(<span class="type">const</span> value_type&amp; x)</span></span>;</span><br><span class="line">		<span class="comment">//将x插入到RB-tree中(允许节点值重复)</span></span><br><span class="line">		<span class="function">iterator <span class="title">insert_equal</span><span class="params">(<span class="type">const</span> value_type&amp; x)</span></span>;</span><br><span class="line">	...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>树状结构的各种操作，最需注意的就是边界情况的发生。为了简化处理，SGI STL特别为根节点再设计一个父节点，名为header。</p>
<p><img src="/../img/RB-treeheader.png" alt="RB-treeheader"></p>
<p>每当插入新节点使，不但要按照RB-tree的规则来调整，并且维护header的正确性，使其父节点指向根节点，左子节点指向最小节点，右子节点指向最大节点。</p>
<h4 id="RB-tree的元素操作"><a href="#RB-tree的元素操作" class="headerlink" title="RB-tree的元素操作"></a>RB-tree的元素操作</h4><p>RB-tree提供两种插入操作：insert_unique()和Insert_equal()，前者表示被插入节点的键值在整棵树中必须独一无二，后者表示被插入节点的键值在整棵树中可以重复。以下以最简单的版本作为说明对象：</p>
<h5 id="元素插入操作insert-equal"><a href="#元素插入操作insert-equal" class="headerlink" title="元素插入操作insert_equal()"></a>元素插入操作insert_equal()</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//插人新值:节点键值允许重复</span></span><br><span class="line"><span class="comment">//注意，返回值是一个RB-tree迭代器，指向新增节点</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">key</span>, <span class="keyword">class</span> <span class="title class_">Value</span>, <span class="keyword">class</span> <span class="title class_">Keyofvalue</span>, <span class="keyword">class</span> <span class="title class_">Compare</span>, <span class="keyword">class</span> <span class="title class_">Alloc</span>&gt;</span><br><span class="line"><span class="keyword">typename</span> rb_tree&lt;Key, Value, KeyOfvalue, Compare, Alloc&gt;::iterator</span><br><span class="line">rb_tree&lt;Key, value, KeyofValue, Compare, Alloc&gt;::<span class="built_in">insert_equal</span>(<span class="type">const</span> Value&amp; v)</span><br><span class="line">&#123;</span><br><span class="line">	link_type y = header;</span><br><span class="line">	link_type x = <span class="built_in">root</span>();      <span class="comment">//从根节点开始</span></span><br><span class="line">	<span class="keyword">while</span>(x != <span class="number">0</span>) &#123;            <span class="comment">//从根节点开始，往下寻找适当的插人点</span></span><br><span class="line">		y = x;</span><br><span class="line">		x = <span class="built_in">key_compare</span>(<span class="built_in">KeyOfvalue</span>()(v), <span class="built_in">key</span>(x)) ? <span class="built_in">left</span>(x) : <span class="built_in">right</span>(x);</span><br><span class="line">		<span class="comment">//以上，遇“大”则往左，遇“小于或等于”则往右</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> __insert(x, y, v);</span><br><span class="line">	<span class="comment">//以上，x为新值插人点，y为插人点之父节点，v为新值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="元素插入操作insert-unique"><a href="#元素插入操作insert-unique" class="headerlink" title="元素插入操作insert_unique()"></a>元素插入操作insert_unique()</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//插人新值：节点键值不允许重复，若重复则插人无效</span></span><br><span class="line"><span class="comment">//注意，返回值是个pair，第一元素是个RB-tree迭代器，指向新增节点，</span></span><br><span class="line"><span class="comment">//第二元素表示插入成功与否</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Key</span>, <span class="keyword">class</span> <span class="title class_">Value</span>, <span class="keyword">class</span> <span class="title class_">KeyOfValue</span>,</span><br><span class="line">		 <span class="keyword">class</span> <span class="title class_">Compare</span>, <span class="keyword">class</span> <span class="title class_">Alloc</span>&gt;</span><br><span class="line">pair&lt;<span class="keyword">typename</span> rb_tree&lt;Key, Value, KeyOfValue, Compare, Alloc&gt;::iterator, <span class="type">bool</span>&gt;</span><br><span class="line">rb_tree&lt;Key, Value, KeyOfValue, Compare, Alloc&gt;::<span class="built_in">insert_unique</span>(<span class="type">const</span> value&amp; v)</span><br><span class="line">&#123;</span><br><span class="line">	link_type y = header;</span><br><span class="line">	link_type x = <span class="built_in">root</span>();          <span class="comment">//从根节点开始</span></span><br><span class="line">	<span class="type">bool</span> comp = <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">while</span> (x != <span class="number">0</span>) &#123;               <span class="comment">//从根节点开始，往下寻找适当的插人点</span></span><br><span class="line">		y = x;</span><br><span class="line">		comp = <span class="built_in">key_compare</span>(<span class="built_in">KeyOfValue</span>()(v), <span class="built_in">key</span>(x));<span class="comment">//v键值小于目前节点之键值?</span></span><br><span class="line">		x = comp ? <span class="built_in">left</span>(x) : <span class="built_in">right</span> (x);<span class="comment">//遇“大”则往左，遇“小于或等于”则往右</span></span><br><span class="line">	&#125;</span><br><span class="line">        </span><br><span class="line">	<span class="comment">//离开while循环之后，y所指即插入点之父节点（此时的它必为叶节点）</span></span><br><span class="line">	iterator j = <span class="built_in">iterator</span>(y);   <span class="comment">//令迭代器j指向插入点之父节点y</span></span><br><span class="line">	<span class="keyword">if</span> (comp)  <span class="comment">// 如果离开while循环时comp为真（表示遇“大”，将插入于左侧)</span></span><br><span class="line">		<span class="keyword">if</span> (j == <span class="built_in">begin</span>())   <span class="comment">//如果插入点之父节点为最左节点</span></span><br><span class="line">			<span class="keyword">return</span> <span class="built_in">pair</span>&lt;iterator, <span class="type">bool</span>&gt;(__insert (x, y, v), <span class="literal">true</span>);</span><br><span class="line">			<span class="comment">//以上，x为插入点，y为插入点之父节点，v为新值</span></span><br><span class="line">		<span class="keyword">else</span> <span class="comment">//否则(插人点之父节点不为最左节点)</span></span><br><span class="line">			--j;</span><br><span class="line">			<span class="comment">//调整j，回头准备测试...</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">key_compare</span>(<span class="built_in">key</span>(j.node), <span class="built_in">KeyOfValue</span>()(v)))</span><br><span class="line">		<span class="comment">//小于新值（表示遇“小”，将插入于右侧)</span></span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">pair</span>&lt;iterator, <span class="type">bool</span>&gt;(__insert (x, y, v), <span class="literal">true</span>);</span><br><span class="line">		<span class="comment">//以上，x为新值插人点，y 为插人点之父节点，v为新值</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//进行至此，表示新值一定与树中键值重复，那么就不该插入新值</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">pair</span>&lt;iterator, <span class="type">bool</span>&gt;(j, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>真正的插入执行程序__insert()</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Key</span>, <span class="keyword">class</span> <span class="title class_">Value</span>, <span class="keyword">class</span> <span class="title class_">KeyOfValue</span>,</span><br><span class="line">		 <span class="keyword">class</span> <span class="title class_">Compare</span>, <span class="keyword">class</span> <span class="title class_">Alloc</span>&gt;</span><br><span class="line"><span class="keyword">typename</span> rb_tree&lt;Key, Value, KeyOfValue, Compare, Alloc&gt;::iterator</span><br><span class="line">rb_tree&lt;Key, Value, KeyOfValue, Compare, Alloc&gt;::__insert(base_ptr x_, base_ptr y_, <span class="type">const</span> Value&amp; v) &#123;</span><br><span class="line"><span class="comment">//参数x_为新值插人点，参数y_为插人点之父节点，参数v为新值</span></span><br><span class="line">	link_type x = (link_type)x_;</span><br><span class="line">	link_type y = (link_type)y_;</span><br><span class="line">	link_type z;</span><br><span class="line"></span><br><span class="line"><span class="comment">//key_compare是键值大小比较准则。应该会是个function object</span></span><br><span class="line">	<span class="keyword">if</span> (y == header || x != <span class="number">0</span> || <span class="built_in">key_compare</span>(<span class="built_in">KeyOfValue</span>()(v), <span class="built_in">key</span>(y))) &#123;</span><br><span class="line">		z = <span class="built_in">create_node</span>(v); <span class="comment">//产生一个新节点</span></span><br><span class="line">		<span class="built_in">left</span>(y) = z;        <span class="comment">//这使得当y即为header时，leftmost() = z</span></span><br><span class="line">		<span class="keyword">if</span> (y == header) &#123;</span><br><span class="line">			<span class="built_in">root</span>() = z;</span><br><span class="line">			<span class="built_in">rightmost</span>() = z;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (y == <span class="built_in">leftmost</span>())             <span class="comment">//如果y为最左节点</span></span><br><span class="line">			<span class="built_in">leftmost</span>() = z;        <span class="comment">//维护leftmost()，使它永远指向最左节点</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		z = <span class="built_in">create_node</span>(v);            <span class="comment">//产生一个新节点</span></span><br><span class="line">		<span class="built_in">right</span>(y) = z;            <span class="comment">//令新节点成为插人点之父节点y的右子节点</span></span><br><span class="line">		<span class="keyword">if</span> (y == <span class="built_in">rightmost</span>())</span><br><span class="line">			<span class="built_in">rightmost</span>() = z;      <span class="comment">//维护rightmost()，使它永远指向最右节点</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">parent</span>(z) = y;                 <span class="comment">//设定新节点的父节点</span></span><br><span class="line">	<span class="built_in">left</span>(z) = <span class="number">0</span>;                   <span class="comment">//设定新节点的左子节点</span></span><br><span class="line">	<span class="built_in">right</span>(z) = <span class="number">0</span>;                  <span class="comment">//设定新节点的右子节点</span></span><br><span class="line">					<span class="comment">//新节点的颜色将在__rb_tree_rebalance()设定（并调整）</span></span><br><span class="line">	__rb_tree_rebalance(z, header-&gt;parent); <span class="comment">//参数一为新增节点，参数二为root</span></span><br><span class="line">	++node_count;   <span class="comment">//节点数累加</span></span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">iterator</span>(z);<span class="comment">//返回一个迭代器，指向新增节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="调整RB-tree（旋转及改变颜色）"><a href="#调整RB-tree（旋转及改变颜色）" class="headerlink" title="调整RB-tree（旋转及改变颜色）"></a>调整RB-tree（旋转及改变颜色）</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//全局函数</span></span><br><span class="line"><span class="comment">//重新令树形平衡（改变颜色及旋转树形）</span></span><br><span class="line"><span class="comment">//参数一为新增节点，参数二为root</span></span><br><span class="line"><span class="keyword">inline</span> <span class="type">void</span></span><br><span class="line">__rb_tree_rebalance(__rb_tree_node_base* x, __rb_tree_node_base*&amp; root) &#123;</span><br><span class="line">	x-&gt;color = __rb_tree_red;	<span class="comment">//新节点必为红</span></span><br><span class="line">	<span class="keyword">while</span> (x != root &amp;&amp; x-&gt;parent-&gt;color == __rb_tree_red) &#123; <span class="comment">//父节点为红</span></span><br><span class="line">		<span class="keyword">if</span> (x-&gt;parent == x-&gt;parent-&gt;parent-&gt;left) &#123; <span class="comment">//父节点为祖父节点之左子节点</span></span><br><span class="line">			__rb_tree_node_base* y = x-&gt;parent-&gt;parent-&gt;right;<span class="comment">//令y为伯父节点</span></span><br><span class="line">			<span class="keyword">if</span> (y &amp;&amp; y-&gt;color == __rb_tree_red) &#123;   <span class="comment">//伯父节点存在，且为红</span></span><br><span class="line">				x-&gt;parent-&gt;color = __rb_tree_black; <span class="comment">//更改父节点为黑</span></span><br><span class="line">				y-&gt;color = __rb_tree_black;         <span class="comment">//更改伯父节点为黑</span></span><br><span class="line">				x-&gt;parent-&gt;parent-&gt;color = __rb_tree_red;<span class="comment">//更改祖父节点为红</span></span><br><span class="line">				x = x-&gt;parent-&gt;parent;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123; <span class="comment">//无伯父节点，或伯父节点为黑</span></span><br><span class="line">				<span class="keyword">if</span> (x = x-&gt;parent-&gt;right) &#123;<span class="comment">//如果新节点为父节点之右子节点</span></span><br><span class="line">					x = x-&gt;parent;</span><br><span class="line">					__rb_tree_rotate_left(x, root); <span class="comment">//第一参数为左旋点</span></span><br><span class="line">				&#125;</span><br><span class="line">				x-&gt;parent-&gt;color = __rb_tree_black;<span class="comment">//改变颜色</span></span><br><span class="line">				x-&gt;parent-&gt;parent-&gt;color = __rb_tree_red;</span><br><span class="line">				__rb_tree_rotate_right(x-&gt;parent-&gt;parent, root); <span class="comment">//第一参数为右旋点</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;    <span class="comment">//父节点为祖父节点之右子节点</span></span><br><span class="line">			__rb_tree_node_base* y = x-&gt;parent-&gt;parent-&gt;left; <span class="comment">//令y为伯父节点</span></span><br><span class="line">			<span class="keyword">if</span> (y &amp;&amp; y-&gt;color == __rb_tree_red) &#123;   <span class="comment">//有伯父节点，且为红</span></span><br><span class="line">				x-&gt;parent-&gt;color = __rb_tree_black; <span class="comment">//更改父节点为黑</span></span><br><span class="line">				y-&gt;color = __rb_tree_black;        <span class="comment">//更改伯父节点为黑</span></span><br><span class="line">				x-&gt;parent-&gt;parent-&gt;color = __rb_tree_red;<span class="comment">//更改祖父节点为红</span></span><br><span class="line">				x = x-&gt;parent-&gt;parent;<span class="comment">//准备继续往上层检查</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123; <span class="comment">//无伯父节点，或伯父节点为黑</span></span><br><span class="line">				<span class="keyword">if</span> (x == x-&gt;parent-&gt;left) &#123; <span class="comment">//如果新节点为父节点之左子节点</span></span><br><span class="line">					x= x-&gt;parent;</span><br><span class="line">					__rb_tree_rotate_right(x, root);<span class="comment">//第一参数为右旋点</span></span><br><span class="line">				&#125;</span><br><span class="line">				x-&gt;parent-&gt;color = __rb_tree_black;<span class="comment">//改变颜色</span></span><br><span class="line">				x-&gt;parent -&gt;parent-&gt;color = __rb_tree_red;</span><br><span class="line">				__rb_tree_rotate_left(x-&gt;parent-&gt;parent, root); <span class="comment">//第一参数为左旋点</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;<span class="comment">//while 结束</span></span><br><span class="line">	root-&gt;color = __rb_tree_black;<span class="comment">//根节点永远为黑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面是左旋函数和右旋函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//全局函数</span></span><br><span class="line"><span class="comment">//新节点必为红节点。如果插入处之父节点亦为红节点，就违反红黑树规则，此时必须</span></span><br><span class="line"><span class="comment">//做树形旋转（及颜色改变，在程序它处）</span></span><br><span class="line"><span class="keyword">inline</span> <span class="type">void</span></span><br><span class="line">__rb_tree_rotate_left (__rb_tree_node_base* x, __rb_tree_node_base*&amp; root)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//x为旋转点</span></span><br><span class="line">	__rb_tree_node__base* y = x-&gt;right; <span class="comment">//令y为旋转点的右子节点</span></span><br><span class="line">	x-&gt;right = y-&gt;left;</span><br><span class="line">	<span class="keyword">if</span> (y-&gt;left != <span class="number">0</span>)</span><br><span class="line">		y-&gt;left-&gt;parent = x;   <span class="comment">//别忘了回马枪设定父节点</span></span><br><span class="line">	y-&gt;parent = x-&gt;parent;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//令y完全顶替x的地位（必须将x对其父节点的关系完全接收过来)</span></span><br><span class="line">	<span class="keyword">if</span> (x == root)       <span class="comment">//x为根节点</span></span><br><span class="line">		root = y;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (x == x-&gt;parent-&gt;left)   <span class="comment">//x为其父节点的左子节点</span></span><br><span class="line">		x-&gt;parent-&gt;left = y;</span><br><span class="line">	<span class="keyword">else</span>                             <span class="comment">//x为其父节点的右子节点</span></span><br><span class="line">		x-&gt;parent-&gt;right = y;</span><br><span class="line">	y-&gt;left = x;</span><br><span class="line">	x-&gt;parent = y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//全局函数</span></span><br><span class="line"><span class="comment">//新节点必为红节点。如果插入处之父节点亦为红节点，就违反红黑树规则，此时必须</span></span><br><span class="line"><span class="comment">//做树形旋转（及颜色改变，在程序它处）</span></span><br><span class="line"><span class="keyword">inline</span> <span class="type">void</span></span><br><span class="line">__rb_tree_rotate_right (__rb_tree_node_base* x,</span><br><span class="line">				      __rb_tree_node_base*&amp; root)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//x为旋转点</span></span><br><span class="line">	__rb_tree_node__base* y = x-&gt;left; <span class="comment">//令y为旋转点的左子节点</span></span><br><span class="line">	x-&gt;left = y-&gt;right;</span><br><span class="line">	<span class="keyword">if</span> (y-&gt;right != <span class="number">0</span>)</span><br><span class="line">		y-&gt;right-&gt;parent = x;   <span class="comment">//别忘了回马枪设定父节点</span></span><br><span class="line">	y-&gt;parent = x-&gt;parent;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//令y完全顶替x的地位（必须将x对其父节点的关系完全接收过来)</span></span><br><span class="line">	<span class="keyword">if</span> (x == root)       <span class="comment">//x为根节点</span></span><br><span class="line">		root = y;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (x == x-&gt;parent-&gt;right)   <span class="comment">//x为其父节点的右子节点</span></span><br><span class="line">		x-&gt;parent-&gt;right = y;</span><br><span class="line">	<span class="keyword">else</span>                             <span class="comment">//x为其父节点的左子节点</span></span><br><span class="line">		x-&gt;parent-&gt;left = y;</span><br><span class="line">	y-&gt;right = x;</span><br><span class="line">	x-&gt;parent = y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="元素的搜寻"><a href="#元素的搜寻" class="headerlink" title="元素的搜寻"></a>元素的搜寻</h5><p>RB-tree提供的find函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//寻找RB树中是否有键值为k的节点</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Key</span>, <span class="keyword">class</span> <span class="title class_">Value</span>, <span class="keyword">class</span> <span class="title class_">KeyOfValue</span>, <span class="keyword">class</span> <span class="title class_">Compare</span>, <span class="keyword">class</span> <span class="title class_">Alloc</span>&gt;</span><br><span class="line"><span class="keyword">typename</span> rb_tree&lt;Key, Value, KeyOfValue, Compare, Alloc&gt;::iterator</span><br><span class="line">rb_tree&lt;Key, Value, KeyOfValue, Compare, Alloc&gt;::<span class="built_in">find</span> (<span class="type">const</span> Key&amp; k &#123;</span><br><span class="line">	link_type y = header;     <span class="comment">//Last node which is not less than k.</span></span><br><span class="line">	link_type x = <span class="built_in">root</span>();     <span class="comment">//current node.</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span> (x != <span class="number">0</span>)</span><br><span class="line">		<span class="comment">//以下，key_compare是节点键值大小比较准则。应该会是个function object</span></span><br><span class="line">		<span class="keyword">if</span>(!<span class="built_in">key_compare</span>(<span class="built_in">key</span>(x), k))</span><br><span class="line">			<span class="comment">//进行到这里,表示x键值大于k。遇到大值就向左走</span></span><br><span class="line">			y = x, x = <span class="built_in">left</span>(x);<span class="comment">//注意语法!</span></span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="comment">//进行到这里，表示×键值小于k。遇到小值就向右走</span></span><br><span class="line">			x = <span class="built_in">right</span>(x);</span><br><span class="line">		</span><br><span class="line">	iterator j = <span class="built_in">iterator</span>(y);</span><br><span class="line">	<span class="built_in">return</span> (j == <span class="built_in">end</span>() || <span class="built_in">key_compare</span>(k, <span class="built_in">key</span>(j.node))) ? <span class="built_in">end</span>() : j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="set"><a href="#set" class="headerlink" title="set"></a>set</h3><p>set的所有元素都会根据元素的键值自动被排序。</p>
<p>set元素的键值就是实值，实值就是键值。set不被允许两个元素有相同的键值。</p>
<p>set的迭代器是一种constant iterators，杜绝写入操作，不能改变set的元素值：因为set的元素值就是其键值，关系到set元素的排列规则。同时，set在进行元素新增操作或删除操作时，操作之前的所有迭代器（除了被删除的那个迭代器）在操作完成之后依然有效（类似于list）。</p>
<p>由于RB-tree是一种平衡二叉搜索树，自动排序的效果很不错，所以标准的STL set即以RB-tree为底层机制。又由于set所开放的各种操作接口，RB-tree也都提供了，所以几乎所有的set操作行为，都只是转调用RB-tree的操作行为而已。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Key</span>,</span><br><span class="line">		 <span class="keyword">class</span> <span class="title class_">Compare</span> = less&lt;Key&gt;,        <span class="comment">//缺省情况下采用递增排序</span></span><br><span class="line">		 <span class="keyword">class</span> Alloc = alloc&gt;</span><br><span class="line"><span class="keyword">class</span> set &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">// typedefs :</span></span><br><span class="line">	<span class="keyword">typedef</span> Key key_type;</span><br><span class="line">	<span class="keyword">typedef</span> Key value_type;</span><br><span class="line">	<span class="comment">//注意，以下key_compare和value_compare使用同一个比较函数</span></span><br><span class="line">	<span class="keyword">typedef</span> Compare ke _compare;</span><br><span class="line">	<span class="keyword">typedef</span> Compare value_compare;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="comment">//注意，以下的identity定义于&lt;stl_function.h&gt;，参见第7章，其定义为:</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	template &lt;class T&gt;</span></span><br><span class="line"><span class="comment">	struct identity : public unary_function&lt;T,T&gt; &#123;</span></span><br><span class="line"><span class="comment">		const T&amp; operator() (const T&amp; x) const &#123; return x; &#125;</span></span><br><span class="line"><span class="comment">	&#125;;</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="keyword">typedef</span> rb_tree&lt;key_type, value_type,</span><br><span class="line">				identity&lt;value_type&gt;, key_compare, Alloc&gt; rep_type;</span><br><span class="line">	rep_type t; <span class="comment">//采用红黑树(RB-tree)来表现set</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type::const_pointer pointer;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type::const_pointer const_pointer;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type::const_reference reference;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type::const_reference const_reference;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type::const_iterator iterator;</span><br><span class="line">	<span class="comment">//注意上一行，iterator定义为RB-tree的const_iterator，这表示sets的</span></span><br><span class="line">    <span class="comment">//迭代器无法执行写入操作。这是因为set的元素有一定次序安排</span></span><br><span class="line">	<span class="comment">//不允许用户在任意处进行写人操作</span></span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type::const_iterator const_iterator;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type::const_reverse_iterator reverse_iterator;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type::const_reverse_iterator const_reverse_iterator;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type::size_type size_type;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type::difference_type difference_type;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// allocation / deallocation</span></span><br><span class="line">	<span class="comment">//注意,set一定使用RB-tree的insert_unique()而非insert_equal()</span></span><br><span class="line">	<span class="comment">//multiset才使用RB-tree的insert__equal()</span></span><br><span class="line">	<span class="comment">//因为set不允许相同键值存在，multiset才允许相同键值存在</span></span><br><span class="line">	<span class="built_in">set</span>() : <span class="built_in">t</span> (<span class="built_in">Compare</span>()) &#123; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">explicit</span> <span class="title">set</span><span class="params">(<span class="type">const</span> Compare&amp; comp)</span> : t(comp)&#123;</span> &#125;</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>&gt;</span><br><span class="line">	<span class="built_in">set</span>(InputIterator first, InputIterator last)</span><br><span class="line">		: <span class="built_in">t</span>(<span class="built_in">Compare</span>()) &#123; t.<span class="built_in">insert_unique</span>(first, last); &#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>&gt;</span><br><span class="line">	<span class="built_in">set</span>(InputIterator first, InputIterator last, <span class="type">const</span> Compare&amp; comp)</span><br><span class="line">        : <span class="built_in">t</span>(comp) &#123; t.<span class="built_in">insert_unique</span>(first, last); &#125;</span><br><span class="line">    </span><br><span class="line">	<span class="built_in">set</span>(<span class="type">const</span> set&lt;Key, Compare, Alloc&gt;&amp; x) : <span class="built_in">t</span>(x.t) &#123;&#125;</span><br><span class="line">	set&lt;Key, Compare, Alloc&gt;&amp; <span class="keyword">operator</span>=(<span class="type">const</span> set&lt;Key, Compare, Alloc&gt;&amp; x) &#123; </span><br><span class="line">		t = x.t;</span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line">   </span><br><span class="line">	<span class="comment">//以下所有的set操作行为，RB-tree都已提供，所以set只要传递调用即可</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//accessors:</span></span><br><span class="line">	<span class="function">key_compare <span class="title">key_comp</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> t.<span class="built_in">key_comp</span>(); &#125;</span><br><span class="line">	<span class="comment">//以下注意,set的value_comp()事实上为RB-tree的key_comp()</span></span><br><span class="line">	<span class="function">value_compare <span class="title">value_comp</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> t.<span class="built_in">key_comp</span>(); &#125;</span><br><span class="line">	<span class="function">iterator <span class="title">begin</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> t.<span class="built_in">begin</span>(); &#125;</span><br><span class="line">	<span class="function">iterator <span class="title">end</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> t.<span class="built_in">end</span>(); &#125;</span><br><span class="line">	<span class="function">reverse_iterator <span class="title">rbegin</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> t.<span class="built_in">rbegin</span>(); &#125;</span><br><span class="line">	<span class="function">reverse_iterator <span class="title">rend</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> t.<span class="built_in">rend</span>(); &#125;</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> t.<span class="built_in">empty</span>(); &#125;</span><br><span class="line">	<span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> t.<span class="built_in">size</span>(); &#125;</span><br><span class="line">	<span class="function">size_type <span class="title">max_size</span><span class="params">( )</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> t.<span class="built_in">max_size</span>(); &#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(set&lt;Key, Compare, Alloc&gt;&amp; x)</span> </span>&#123; t.<span class="built_in">swap</span>(x.t); &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// insert/erase</span></span><br><span class="line">	<span class="keyword">typedef</span> pair&lt;iterator, <span class="type">bool</span>&gt; pair_iterator_bool;</span><br><span class="line">	<span class="function">pair&lt;iterator, <span class="type">bool</span>&gt; <span class="title">insert</span><span class="params">(<span class="type">const</span> value_type&amp; x)</span> </span>&#123;</span><br><span class="line">		pair&lt;<span class="keyword">typename</span> rep_type::iterator, <span class="type">bool</span>&gt; p = t.<span class="built_in">insert_unique</span>(x);</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">pair</span>&lt;iterator, <span class="type">bool</span>&gt;(p.first, p.second);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">iterator <span class="title">insert</span><span class="params">(iterator position, <span class="type">const</span> value_type&amp; x)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type::iterator rep_iterator;</span><br><span class="line">		<span class="keyword">return</span> t.<span class="built_in">insert_unique</span>((rep_iterator&amp;)position, x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>&gt;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(InputIterator first, InputIterator last)</span> </span>&#123;</span><br><span class="line">		t.<span class="built_in">insert__unique</span>(first, last);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">erase</span><span class="params">(iterator position)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type::iterator rep_iterator;</span><br><span class="line">		t.<span class="built_in">erase</span>((rep_iterator&amp;)position);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">size_type <span class="title">erase</span><span class="params">(<span class="type">const</span> key_type&amp; x)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> t.<span class="built_in">erase</span>(x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">erase</span> <span class="params">(iterator first, iterator last)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type::iterator rep_iterator;</span><br><span class="line">         t.<span class="built_in">erase</span>((rep_iterator&amp;)first, (rep_iterator&amp;)Last);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123; t.<span class="built_in">clear</span>(); &#125;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// set operations:</span></span><br><span class="line">	<span class="function">iterator <span class="title">find</span><span class="params">(<span class="type">const</span> key_type&amp; x)</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> t.<span class="built_in">find</span>(x); &#125;</span><br><span class="line">	<span class="function">size_type <span class="title">count</span> <span class="params">(<span class="type">const</span> key_type&amp; x)</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> t.<span class="built_in">count</span>(x); &#125;</span><br><span class="line">	<span class="function">iterator <span class="title">lower_bound</span> <span class="params">(<span class="type">const</span> key_type&amp; x)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> t.<span class="built_in">lower_bound</span>(x); </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">iterator <span class="title">upper_bound</span> <span class="params">(<span class="type">const</span> key_type&amp; x)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> t.<span class="built_in">upper_bound</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="function">pair&lt;iterator, iterator&gt; <span class="title">equal_range</span><span class="params">(<span class="type">const</span> key type&amp; x)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> t.<span class="built_in">equal_range</span>(x);</span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><p>map与set类似，都以RB-tree为底层，不同的是map的所有元素都是pair，同时拥有实值（value）和键值（key）。pair的第一元素被视为键值，第二元素被视为实值。map不允许两个元素拥有相同的键值，因此，map的迭代器可以修改元素的实值但不可以修改元素的键值。map iterators既不是一种constant iterators，也不是一种mutable iterators。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注意，以下Key为键值(key)型别，T为实值(value)型别</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Key</span>, <span class="keyword">class</span> <span class="title class_">T</span>,</span><br><span class="line">		 <span class="keyword">class</span> <span class="title class_">Compare</span> = less&lt;Key&gt;,       <span class="comment">//缺省采用递增排序</span></span><br><span class="line">		 <span class="keyword">class</span> Alloc = alloc&gt;</span><br><span class="line"><span class="keyword">class</span> map &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="comment">//typedefs:</span></span><br><span class="line">	<span class="keyword">typedef</span> Key key_type;   <span class="comment">//键值型别</span></span><br><span class="line">	<span class="keyword">typedef</span> T data_type;    <span class="comment">//数据（实值）型别</span></span><br><span class="line">	<span class="keyword">typedef</span> T mapped_type;</span><br><span class="line">	<span class="keyword">typedef</span> pair&lt;<span class="type">const</span> Key, T&gt; value_type;<span class="comment">//元素型别（键值/实值)</span></span><br><span class="line">	<span class="keyword">typedef</span> Compare key_compare; <span class="comment">//键值比较函数</span></span><br><span class="line">    </span><br><span class="line">	<span class="comment">//以下定义一个functor，其作用就是调用“元素比较函数”</span></span><br><span class="line">	<span class="keyword">class</span> <span class="title class_">value_compare</span></span><br><span class="line">	: <span class="keyword">public</span> binary_function&lt;value_type, value_type, <span class="type">bool</span>&gt; &#123;</span><br><span class="line">		<span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">map</span>&lt;Key, T, Compare, Alloc&gt;;</span><br><span class="line">		<span class="keyword">protected</span> :</span><br><span class="line">			Compare comp;</span><br><span class="line">			<span class="built_in">value_compare</span>(Compare c) : <span class="built_in">comp</span>(c) &#123;&#125;</span><br><span class="line">		<span class="keyword">public</span> :</span><br><span class="line">			<span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="type">const</span> value_type&amp; x, <span class="type">const</span> value_type&amp; y)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="built_in">comp</span>(x.first, y.first);</span><br><span class="line">			&#125;</span><br><span class="line">	&#125;</span><br><span class="line">        </span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		<span class="keyword">typedef</span> rb_tree&lt;key_type, value_type, select1st&lt;value_type&gt;, key_compare, Alloc&gt; rep_type;</span><br><span class="line">		rep_type t;</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">	...</span><br><span class="line">		<span class="comment">//注意下标操作符</span></span><br><span class="line">		T&amp; <span class="keyword">operator</span>[](<span class="type">const</span> key_type&amp; k) &#123;</span><br><span class="line">			<span class="keyword">return</span> (*((<span class="built_in">insert</span>(<span class="built_in">value_type</span>(k, <span class="built_in">T</span>()))).first)).second;</span><br><span class="line">		&#125;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="multiset"><a href="#multiset" class="headerlink" title="multiset"></a>multiset</h3><p>multiset和set的唯一差别在于它允许键值重复，因此它的插入操作采用的是底层机制RB-tree的insert_equal()而非insert_unique()。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Key</span>, <span class="keyword">class</span> <span class="title class_">Compare</span> = less&lt;Key&gt;, <span class="keyword">class</span> Alloc = alloc&gt;</span><br><span class="line"><span class="keyword">class</span> multiset &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//typedefs:</span></span><br><span class="line">	...(与set相同)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// allocation/deallocation</span></span><br><span class="line">	<span class="comment">//注意, multiset一定使用insert_equal()而不使用insert_unique()</span></span><br><span class="line">	<span class="comment">//set才使用insert_unique()</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">template</span> &lt;<span class="keyword">class</span> InputIterator&gt;</span><br><span class="line">	<span class="built_in">multiset</span>(InputIterator first, InputIterator last)</span><br><span class="line">        : <span class="built_in">t</span>(<span class="built_in">Compare</span>()) &#123; t.<span class="built_in">insert_equal</span>(first, last); &#125;</span><br><span class="line">	<span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>&gt;</span><br><span class="line">	<span class="built_in">multiset</span>(InputIterator first, InputIterator last, <span class="type">const</span> Compare&amp; comp)</span><br><span class="line">        : <span class="built_in">t</span>(comp) &#123; t.<span class="built_in">insert_equal</span>(first, last); &#125;</span><br><span class="line">	...(其它与set相同)</span><br><span class="line">        </span><br><span class="line">	<span class="comment">// insert/erase</span></span><br><span class="line">	<span class="function">iterator <span class="title">insert</span><span class="params">(<span class="type">const</span> value_type&amp; x)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> t.<span class="built_in">insert_equal</span>(x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">iterator <span class="title">insert</span><span class="params">(iterator position, <span class="type">const</span> value_type&amp; x)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type::iterator rep_iterator;</span><br><span class="line">		<span class="keyword">return</span> t.<span class="built_in">insert_equal</span>((rep_iterator&amp;)position,x);</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>&gt;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(InputIterator first, InputIterator last)</span> </span>&#123;</span><br><span class="line">		t.<span class="built_in">insert_equal</span>(first, last);</span><br><span class="line">	&#125;</span><br><span class="line">	...(其它与set相同)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="multimap"><a href="#multimap" class="headerlink" title="multimap"></a>multimap</h3><p>multimap和map的唯一差别在于它允许键值重复，因此它的插入操作采用的是底层机制RB-tree的insert_equal()而非insert_unique()。</p>
<h3 id="hashtable"><a href="#hashtable" class="headerlink" title="hashtable"></a>hashtable</h3><p>SGI STL的hashtable采用的开链（separate chaining）法来处理冲突。因此，SGI命名称hash table表格内的元素为桶（bucket），此名称的意义是表格内的每个单元涵盖的不只是个节点（元素），甚至可能是一“桶”节点。</p>
<p><img src="/../img/bucket_hashtable.png" alt="bucket_hashtable"></p>
<p>hash table的节点定义：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Value</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__hashtable_node</span></span><br><span class="line">&#123;</span><br><span class="line">	__hashtable_node* next;</span><br><span class="line">	Value val;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>bucket所维护的linked list，并不采用STL的list或slist，而是自行维护上述的hash table node。而buckets聚合体，则以vector完成以便有动态扩充能力。</p>
<h4 id="hashtable的迭代器"><a href="#hashtable的迭代器" class="headerlink" title="hashtable的迭代器"></a>hashtable的迭代器</h4><p>定义：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Value</span>, <span class="keyword">class</span> <span class="title class_">Key</span>, <span class="keyword">class</span> <span class="title class_">HashFcn</span>,</span><br><span class="line">		 <span class="keyword">class</span> <span class="title class_">ExtractKey</span>, <span class="keyword">class</span> <span class="title class_">EqualKey</span>, <span class="keyword">class</span> <span class="title class_">Alloc</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__hashtable_iterator</span> &#123;</span><br><span class="line">	<span class="keyword">typedef</span> hashtable&lt;Value, Key, HashFcn, ExtractKey, EqualKey, Alloc&gt; hashtable;</span><br><span class="line">	<span class="keyword">typedef</span> __hashtable_iterator&lt;value, Key, HashFcn, ExtractKey, EqualKey,  Alloc&gt; iterator;</span><br><span class="line">	<span class="keyword">typedef</span> __hashtable_const_iterator&lt;Value, Key, HashFcn, ExtractKey, EqualKey, Alloc&gt; const_iterator;</span><br><span class="line">	<span class="keyword">typedef</span> __hashtable_node&lt;value&gt; node;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">typedef</span> forward_iterator_tag iterator_category;</span><br><span class="line">	<span class="keyword">typedef</span> Value value_type;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="type">ptrdiff_t</span> difference_type;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="type">size_t</span> size_type;</span><br><span class="line">	<span class="keyword">typedef</span> value&amp; reference;</span><br><span class="line">	<span class="keyword">typedef</span> value* pointer;</span><br><span class="line"></span><br><span class="line">	node* cur;		<span class="comment">//迭代器目前所指之节点	</span></span><br><span class="line">	hashtable* ht;	<span class="comment">//保持对容器的连结关系(因为可能需要从bucket跳到bucket)</span></span><br><span class="line"></span><br><span class="line">	__hashtable_iterator(node* n, hashtable* tab) : <span class="built_in">cur</span>(n), <span class="built_in">ht</span>(tab) &#123; &#125;</span><br><span class="line">	__hashtable_iterator() &#123; &#125;</span><br><span class="line">	reference <span class="keyword">operator</span>*() <span class="type">const</span> &#123; <span class="keyword">return</span> cur-&gt;val; &#125;</span><br><span class="line">	pointer <span class="keyword">operator</span>-&gt;() <span class="type">const</span> &#123; <span class="keyword">return</span> &amp;(<span class="keyword">operator</span>*()); &#125;</span><br><span class="line">	iterator&amp; <span class="keyword">operator</span>++();</span><br><span class="line">	iterator <span class="keyword">operator</span>++(<span class="type">int</span>);</span><br><span class="line">	<span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> iterator&amp; it) <span class="type">const</span> &#123; <span class="keyword">return</span> cur == it.cur; &#125;</span><br><span class="line">	<span class="type">bool</span> <span class="keyword">operator</span>!=(<span class="type">const</span> iterator&amp; it) <span class="type">const</span> &#123; <span class="keyword">return</span> cur != it.cur; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>hashtable迭代器需维系着与整个“buckets vector”的关系，并记录目前所指的节点。是因为其前进操作中，若下一步在同一bucket内，则利用节点的next指针完成操作（需要目前节点）；若目前节点正好是list的尾端，则跳至下一个bucket上（需要整个“bucket vector”）。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">V</span>, <span class="keyword">class</span> <span class="title class_">K</span>, <span class="keyword">class</span> <span class="title class_">HF</span>, <span class="keyword">class</span> <span class="title class_">ExK</span>, <span class="keyword">class</span> <span class="title class_">EqK</span>, <span class="keyword">class</span> <span class="title class_">A</span>&gt;</span><br><span class="line">__hashtable_iterator&lt;V, K, HF, EXK, EqK, A&gt;&amp;</span><br><span class="line">__hashtable_iterator&lt;V, K, HF, ExK, EqK, A&gt;::<span class="keyword">operator</span>++()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">const</span> node* old = cur;</span><br><span class="line">	cur = cur-&gt;next;      <span class="comment">//如果存在，就是它。否则进入以下if流程</span></span><br><span class="line">	<span class="keyword">if</span> (!cur) &#123;</span><br><span class="line">		<span class="comment">//根据元素值，定位出下一个bucket。其起头处就是我们的目的地</span></span><br><span class="line">		size_type bucket = ht-&gt;<span class="built_in">bkt_num</span>(old-&gt;val);</span><br><span class="line">		<span class="keyword">while</span> (!cur &amp;&amp; ++bucket &lt; ht-&gt;buckets.<span class="built_in">size</span>()) <span class="comment">//注意，operator++</span></span><br><span class="line">			cur = ht-&gt;buckets[bucket];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">V</span>, <span class="keyword">class</span> <span class="title class_">K</span>, <span class="keyword">class</span> <span class="title class_">HF</span>, <span class="keyword">class</span> <span class="title class_">ExK</span>, <span class="keyword">class</span> <span class="title class_">EqK</span>, <span class="keyword">class</span> <span class="title class_">A</span>&gt;</span><br><span class="line">__hashtable_iterator&lt;V, K, HF, EXK, EqK, A&gt;</span><br><span class="line">__hashtable_iterator&lt;V, K, HF, ExK, EqK, A&gt;::<span class="keyword">operator</span>++(<span class="type">int</span>)</span><br><span class="line">&#123;</span><br><span class="line">	iterator tmp = *<span class="keyword">this</span>;</span><br><span class="line">	++*<span class="keyword">this</span>;   <span class="comment">//调用operator++()</span></span><br><span class="line">	<span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，hashtable的迭代器没有后退操作（operator–()），也没有定义所谓的逆向迭代器（reverse iterator）。</p>
<h4 id="hashtable的数据结构"><a href="#hashtable的数据结构" class="headerlink" title="hashtable的数据结构"></a>hashtable的数据结构</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Value</span>, <span class="keyword">class</span> <span class="title class_">Key</span>, <span class="keyword">class</span> <span class="title class_">HashFcn</span>,</span><br><span class="line">		 <span class="keyword">class</span> <span class="title class_">ExtractKey</span>, <span class="keyword">class</span> <span class="title class_">EqualKey</span>, <span class="keyword">class</span> <span class="title class_">Allo</span> = alloc&gt;</span><br><span class="line"><span class="keyword">class</span> hashtable;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Value</span>, <span class="keyword">class</span> <span class="title class_">Key</span>, <span class="keyword">class</span> <span class="title class_">HashFcn</span>,</span><br><span class="line">		<span class="keyword">class</span> <span class="title class_">ExtractKey</span>, <span class="keyword">class</span> <span class="title class_">EqualKey</span>,</span><br><span class="line">		<span class="keyword">class</span> <span class="title class_">Alloc</span>&gt;    <span class="comment">//先前声明时，已给予Alloc默认值alloc</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">hashtable</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">typedef</span> HashFcn hasher;</span><br><span class="line">	<span class="keyword">typedef</span> EqualKey key_equal;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="type">size_t</span> size_type;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="comment">//以下三者都是function objects.&lt;stl_hash_fun.h&gt;中定义有数个</span></span><br><span class="line">	<span class="comment">//标准型别（如int, c-style string等）的hasher</span></span><br><span class="line">	hasher hash;</span><br><span class="line">	key_equal equals;</span><br><span class="line">	ExtractKey get_key;</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">typedef</span> __hashtable_node&lt;Value&gt; node;</span><br><span class="line">	<span class="keyword">typedef</span> simple_alloc&lt;node, Alloc&gt; node_allocator;</span><br><span class="line">    </span><br><span class="line">	vector&lt;node*, Alloc&gt; buckets; <span class="comment">//以vector完成</span></span><br><span class="line">	size_type num_elements;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//bucket个数即buckets vector的大小</span></span><br><span class="line">	<span class="function">size_type <span class="title">bucket_count</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> buckets.<span class="built_in">size</span>(); &#125;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>hashtable的模板参数的意义：</p>
<ul>
<li>Value: 节点的实值类型。</li>
<li>Key: 节点的键值类型。</li>
<li>HashFcn: hash function的函数类型。</li>
<li>ExtractKey: 从节点中去除键值的方法（函数或仿函数）。</li>
<li>EqualKey: 判断键值相同与否的方法（函数或仿函数）。</li>
<li>Alloc: 空间配置器，缺省使用std::alloc。</li>
</ul>
<p>虽然开链法并不要求表格大小必须为质数，但SGI STL仍然一直输来设计表格大小，并先将28个质数计算好，以备随时访问，同时提供一个函数，用来查询在这28个质数之中，“最接近某数并大于某数”的质数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注意:假设long至少有32bits</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">int</span> __stl_num_primes = <span class="number">28</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">unsigned</span> <span class="type">long</span> __stl_prime_list [__stl_num_primes] = </span><br><span class="line">&#123;</span><br><span class="line">	<span class="number">53</span>,		<span class="number">97</span>,		<span class="number">193</span>,	<span class="number">389</span>,	<span class="number">769</span>,	<span class="number">1543</span>,</span><br><span class="line">    <span class="number">3079</span>,	<span class="number">6151</span>,	 <span class="number">12289</span>,	  <span class="number">24593</span>,   <span class="number">49157</span>,   <span class="number">98317</span>,</span><br><span class="line">	<span class="number">196613</span>,	<span class="number">393241</span>,	  <span class="number">786433</span>,   <span class="number">1572869</span>,   <span class="number">3145739</span>,   <span class="number">6291469</span>, 				<span class="number">12582917</span>,	<span class="number">25165843</span>,	<span class="number">50331653</span>, 	<span class="number">100663319</span>, 	<span class="number">201326611</span>, </span><br><span class="line">    <span class="number">402653189</span>,    <span class="number">805306457</span>,   <span class="number">1610612741</span>,   <span class="number">3221225473ul</span>, <span class="number">4294967291ul</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//以下找出上述28个质数之中，最接近并大于n的那个质数</span></span><br><span class="line"><span class="keyword">inline</span> <span class="type">unsigned</span> <span class="type">long</span> __stl_next_prime(<span class="type">unsigned</span> <span class="type">long</span> n)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">const</span> <span class="type">unsigned</span> <span class="type">long</span>* first = __stl_prime_list;</span><br><span class="line">	<span class="type">const</span> <span class="type">unsigned</span> <span class="type">long</span>* last = __stl_prime_list + __stl_num_primes;</span><br><span class="line">	<span class="type">const</span> <span class="type">unsigned</span> <span class="type">long</span>* pos = <span class="built_in">lower_bound</span>(first, last, n);</span><br><span class="line">	<span class="comment">//以上，lower_bound()是泛型算法，见第6章</span></span><br><span class="line">	<span class="comment">//使用lower_bound()，序列需先排序。没问题，上述数组已排序</span></span><br><span class="line">	<span class="keyword">return</span> pos == last ? *(last - <span class="number">1</span>) : *pos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//总共可以有多少buckets.以下是hast_table的一个member function</span></span><br><span class="line"><span class="function">size_type <span class="title">max_bucket_count</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="keyword">return</span> __stl_prime__list[__stl_num_primes - <span class="number">1</span>]; &#125;</span><br><span class="line"><span class="comment">//其值将为4294967291</span></span><br></pre></td></tr></table></figure>

<h4 id="hashtable的构造与内存管理"><a href="#hashtable的构造与内存管理" class="headerlink" title="hashtable的构造与内存管理"></a>hashtable的构造与内存管理</h4><p>构造函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">hashtable</span> (size_type n, <span class="type">const</span> HashFcn&amp;	hf, <span class="type">const</span> EqualKey&amp;	 eql)</span><br><span class="line">	: <span class="built_in">hash</span>(hf), <span class="built_in">equals</span>(eql), <span class="built_in">get_key</span>(<span class="built_in">ExtractKey</span>()), <span class="built_in">num_elements</span>(<span class="number">0</span>) </span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">initialize_buckets</span>(n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">initialize_buckets</span><span class="params">(size_type n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">const</span> size_type n_buckets = <span class="built_in">next_size</span>(n);</span><br><span class="line">	<span class="comment">//举例:传人 50，返回53。以下首先保留53个元素空间，然后将其全部填0</span></span><br><span class="line">	buckets.<span class="built_in">reserve</span>(n_buckets);</span><br><span class="line">	buckets.<span class="built_in">insert</span>(buckets.<span class="built_in">end</span>(), n_buckets, (node*)<span class="number">0</span>);</span><br><span class="line">	num_elements = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中的next_size()返回最接近n并大于n的质数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">size_type <span class="title">next_size</span><span class="params">(size_type n)</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> __stl_next_prime(n); &#125;</span><br></pre></td></tr></table></figure>

<p>然后，为buckets vector保留空间，并将所有buckets初始化为null指针。</p>
<h5 id="insert操作与表格重整（resize）"><a href="#insert操作与表格重整（resize）" class="headerlink" title="insert操作与表格重整（resize）"></a>insert操作与表格重整（resize）</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//插人元素，不允许重复</span></span><br><span class="line"><span class="function">pair&lt;iterator, <span class="type">bool</span>&gt; <span class="title">insert_unique</span><span class="params">(<span class="type">const</span> value_type&amp; obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">resize</span>(num_elements + <span class="number">1</span>);<span class="comment">//判断是否需要重建表格，如需要就扩充</span></span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">insert_unique_noresize</span>(obj);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//以下函数判断是否需要重建表格。如果不需要，立刻回返。如果需要，就动手…</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">V</span>, <span class="keyword">class</span> <span class="title class_">K</span>, <span class="keyword">class</span> <span class="title class_">HF</span>, <span class="keyword">class</span> <span class="title class_">Ex</span>, <span class="keyword">class</span> <span class="title class_">Eq</span>, <span class="keyword">class</span> <span class="title class_">A</span>&gt;</span><br><span class="line"><span class="type">void</span> hashtable&lt;V, K, HF, Ex, Eq, A&gt;::<span class="built_in">resize</span>(size_type num_elements_hint)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//以下，“表格重建与否”的判断原则颇为奇特，是拿元素个数（把新增元素计人后）和</span></span><br><span class="line">	<span class="comment">//bucket vector的大小来比。如果前者大于后者，就重建表格</span></span><br><span class="line">	<span class="comment">//由此可判知，每个bucket(list)的最大容量和buckets vector的大小相同</span></span><br><span class="line">	<span class="type">const</span> size_type old_n = buckets.<span class="built_in">size</span>();</span><br><span class="line">	<span class="keyword">if</span> (num_elements_hint &gt; old_n) &#123; <span class="comment">//确定真的需要重新配置</span></span><br><span class="line">		<span class="type">const</span> size_type n = <span class="built_in">next_size</span>(num_elements_hint);  <span class="comment">//找出下一个质数</span></span><br><span class="line">		<span class="keyword">if</span> (n &gt; old_n) &#123;</span><br><span class="line">			<span class="function">vector&lt;node*, A&gt; <span class="title">tmp</span><span class="params">(n, (node*)<span class="number">0</span>)</span></span>; <span class="comment">//设立新的buckets</span></span><br><span class="line">			__STL_TRY &#123;</span><br><span class="line">				<span class="comment">//以下处理每一个旧的bucket</span></span><br><span class="line">				<span class="keyword">for</span> (size_type bucket = <span class="number">0</span>; bucket &lt; old_n; ++bucket) &#123;</span><br><span class="line">					node* first = buckets[bucket]; <span class="comment">//指向节点所对应之串行的起始节点</span></span><br><span class="line">					<span class="comment">//以下处理每一个旧bucket所含（串行）的每一个节点</span></span><br><span class="line">					<span class="keyword">while</span>(first) &#123;<span class="comment">//串行还没结束时</span></span><br><span class="line">						<span class="comment">//以下找出节点落在哪一个新bucket内</span></span><br><span class="line">						size_type new_bucket = <span class="built_in">bkt_num</span>(first-&gt;val, n);</span><br><span class="line">						<span class="comment">//以下四个操作颇为微妙</span></span><br><span class="line">						<span class="comment">//(1)令旧bucket指向其所对应之串行的下一个节点(以便迭代处理)</span></span><br><span class="line">						buckets[bucket] = first-&gt;next;</span><br><span class="line">						<span class="comment">//(2)(3）将当前节点插人到新bucket内，成为其对应串行的第一个节点</span></span><br><span class="line">						first-&gt;next = tmp[new_bucket];</span><br><span class="line">						tmp[new_bucket] = first;</span><br><span class="line">						<span class="comment">//(4)回到旧bucket所指的待处理串行，准备处理下一个节点</span></span><br><span class="line">						first = buckets[bucket];</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				buckets.<span class="built_in">swap</span>(tmp);<span class="comment">//vector::swap。新旧两个buckets对调</span></span><br><span class="line">				<span class="comment">//注意，对调两方如果大小不同，大的会变小，小的会变大</span></span><br><span class="line">				<span class="comment">//离开时释放local tmp的内存</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//在不需重建表格的情况下插人新节点。键值不允许重复</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">V</span>, <span class="keyword">class</span> <span class="title class_">K</span>, <span class="keyword">class</span> <span class="title class_">HF</span>, <span class="keyword">class</span> <span class="title class_">Ex</span>, <span class="keyword">class</span> <span class="title class_">Eq</span>, <span class="keyword">class</span> <span class="title class_">A</span>&gt;</span><br><span class="line">pair&lt;<span class="keyword">typename</span> hashtable&lt;V, K, HF, Ex, Eq, A&gt;::iterator, <span class="type">bool</span>&gt;</span><br><span class="line">hashtable&lt;V, K, HF, Ex, Eq, A&gt;::<span class="built_in">insert_unique_noresize</span>(<span class="type">const</span> value_type&amp; obj)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">const</span> size_type n = <span class="built_in">bkt_num</span>(obj); <span class="comment">//决定obj应位于#n bucket</span></span><br><span class="line">	node* first = buckets[n]; <span class="comment">//令first指向bucket对应之串行头部</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//如果buckets[n]已被占用，此时first将不为0，于是进人以下循环，</span></span><br><span class="line">	<span class="comment">//走过bucket所对应的整个链表</span></span><br><span class="line">	<span class="keyword">for</span> (node* cur = first; cur; cur = cur-&gt;next)</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">equals</span>(<span class="built_in">get_key</span>(cur-&gt;val), <span class="built_in">get_key</span>(obj)))</span><br><span class="line">			<span class="comment">//如果发现与链表中的某键值相同，就不插人，立刻返回</span></span><br><span class="line">			<span class="keyword">return</span> <span class="built_in">pair</span>&lt;iterator, <span class="type">bool</span>&gt; (<span class="built_in">iterator</span>(cur, <span class="keyword">this</span>), <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//离开以上循环（或根本未进人循环）时， first 指向bucket所指链表的头部节点</span></span><br><span class="line">	node* tmp = <span class="built_in">new_node</span>(obj);	<span class="comment">//产生新节点</span></span><br><span class="line">	tmp-&gt;next = first;</span><br><span class="line">	buckets[n] = tmp;		   <span class="comment">//令新节点成为链表的第一个节点</span></span><br><span class="line">	++num__elements;		   <span class="comment">//节点个数累加1</span></span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">pair</span>&lt;iterator, <span class="type">bool</span>&gt;(<span class="built_in">iterator</span>(tmp, <span class="keyword">this</span>), <span class="literal">true</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>insert_equal()与insert_unique的差别在于发现key值相同时立马插入：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">V</span>, <span class="keyword">class</span> <span class="title class_">K</span>, <span class="keyword">class</span> <span class="title class_">HF</span>, <span class="keyword">class</span> <span class="title class_">Ex</span>, <span class="keyword">class</span> <span class="title class_">Eq</span>, <span class="keyword">class</span> <span class="title class_">A</span>&gt;</span><br><span class="line"><span class="keyword">typename</span> hashtable&lt;V, K, HF, Ex, Eq, A&gt;::iterator, <span class="type">bool</span></span><br><span class="line">hashtable&lt;V, K, HF, Ex, Eq, A&gt;::<span class="built_in">insert_equal_noresize</span>(<span class="type">const</span> value_type&amp; obj)</span><br><span class="line">&#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="comment">//如果buckets[n]已被占用，此时first将不为0，于是进人以下循环，</span></span><br><span class="line">	<span class="comment">//走过bucket所对应的整个链表</span></span><br><span class="line">	<span class="keyword">for</span> (node* cur = first; cur; cur = cur-&gt;next)</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">equals</span>(<span class="built_in">get_key</span>(cur-&gt;val), <span class="built_in">get_key</span>(obj))) &#123;</span><br><span class="line">			node* tmp = <span class="built_in">new_node</span>(obj);	<span class="comment">//产生新节点</span></span><br><span class="line">			tmp-&gt;next = cur-&gt;next;</span><br><span class="line">			cur-&gt;next = tmp;		   <span class="comment">//令将新节点插入于目前位置</span></span><br><span class="line">			++num__elements;		   <span class="comment">//节点个数累加1</span></span><br><span class="line">			<span class="keyword">return</span> <span class="built_in">iterator</span>(tmp, <span class="keyword">this</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="判断元素的落脚处（bkt-num）"><a href="#判断元素的落脚处（bkt-num）" class="headerlink" title="判断元素的落脚处（bkt_num）"></a>判断元素的落脚处（bkt_num）</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//版本1:接受实值(value)和buckets个数</span></span><br><span class="line"><span class="function">size_type <span class="title">bkt_num</span><span class="params">(<span class="type">const</span> value_type&amp; obj, <span class="type">size_t</span> n)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">bkt_num_key</span>(<span class="built_in">get_key</span>(obj), n); <span class="comment">//调用版本4</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//版本2:只接受实值(value)</span></span><br><span class="line"><span class="function">size_type <span class="title">bkt_num</span><span class="params">(<span class="type">const</span> value_type&amp; obj)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">bkt_num_key</span>(<span class="built_in">get_key</span>(obj));     <span class="comment">//调用版本3</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//版本3:只接受键值</span></span><br><span class="line"><span class="function">size_type <span class="title">bkt_num_key</span><span class="params">(<span class="type">const</span> key_type&amp; key)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">bkt_num_key</span>(key, buckets.<span class="built_in">size</span>());<span class="comment">//调用版本4</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//版本4:接受键值和buckets个数</span></span><br><span class="line"><span class="function">size_type <span class="title">bkt_num_key</span><span class="params">(<span class="type">const</span> key_type&amp; key, <span class="type">size_t</span> n)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">hash</span>(key) % n;  <span class="comment">// SGI 的所有内建的hash( )列于5.7.7节</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="复制（copy-from）和整体删除（clear）"><a href="#复制（copy-from）和整体删除（clear）" class="headerlink" title="复制（copy_from）和整体删除（clear）"></a>复制（copy_from）和整体删除（clear）</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">V</span>, <span class="keyword">class</span> <span class="title class_">K</span>, <span class="keyword">class</span> <span class="title class_">HF</span>, <span class="keyword">class</span> <span class="title class_">Ex</span>, <span class="keyword">class</span> <span class="title class_">Eq</span>, <span class="keyword">class</span> <span class="title class_">A</span>&gt;</span><br><span class="line"><span class="type">void</span> hashtable&lt;V, K, HF, Ex, Eq, A&gt;::<span class="built_in">clear</span>()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//针对每一个bucket.</span></span><br><span class="line">	<span class="keyword">for</span> (size_type i = <span class="number">0</span>; i &lt; buckets.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">		node* cur = buckets[i];</span><br><span class="line">		<span class="comment">//将bucket list中的每一个节点删除掉</span></span><br><span class="line">		<span class="keyword">while</span> (cur != <span class="number">0</span>) &#123;</span><br><span class="line">			node* next = cur-&gt;next;</span><br><span class="line">			<span class="built_in">delete_node</span>(cur);</span><br><span class="line">			cur = next;</span><br><span class="line">		&#125;</span><br><span class="line">		buckets [i] = <span class="number">0</span>;<span class="comment">//令bucket内容为null指针</span></span><br><span class="line">	&#125;</span><br><span class="line">	num_elements = <span class="number">0</span> ;	<span class="comment">//令总节点个数为0</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//注意，buckets vector并未释放掉空间，仍保有原来大小</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">V</span>, <span class="keyword">class</span> <span class="title class_">K</span>, <span class="keyword">class</span> <span class="title class_">HF</span>, <span class="keyword">class</span> <span class="title class_">Ex</span>, <span class="keyword">class</span> <span class="title class_">Eq</span>, <span class="keyword">class</span> <span class="title class_">A</span>&gt;</span><br><span class="line"><span class="type">void</span> hashtable&lt;V, K, HF, Ex, Eq, A&gt;::<span class="built_in">copy_from</span>(<span class="type">const</span> hashtable&amp; ht)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//先清除己方的buckets vector.这操作是调用vector::clear.造成所有元素为0</span></span><br><span class="line">	buckets.<span class="built_in">clear</span>();</span><br><span class="line">	<span class="comment">//为己方的buckets vector保留空间，使与对方相同</span></span><br><span class="line">	<span class="comment">//如果己方空间大于对方，就不动，如果己方空间小于对方，就会增大</span></span><br><span class="line">	buckets.<span class="built_in">reserve</span>(ht.buckets.<span class="built_in">size</span>());</span><br><span class="line">	<span class="comment">//从己方的buckets vector尾端开始，插人n个元素，其值为null指针</span></span><br><span class="line">	<span class="comment">//注意，此时buckets vector为空，所以所谓尾端，就是起头处</span></span><br><span class="line">	buckets.<span class="built_in">insert</span>(buckets.<span class="built_in">end</span>(), ht.buckets.<span class="built_in">size</span>(), (node*)<span class="number">0</span>);</span><br><span class="line">	__STL_TRY &#123;</span><br><span class="line">		<span class="comment">//针对buckets vector</span></span><br><span class="line">		<span class="keyword">for</span> (size_type i = <span class="number">0</span>; i &lt; ht.buckets.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">			<span class="comment">//复制vector的每一个元素（是个指针，指向hashtable节点)</span></span><br><span class="line">			<span class="keyword">if</span> (<span class="type">const</span> node* cur = ht.buckets[i]) &#123;</span><br><span class="line">				node* copy = <span class="built_in">new_node</span>(cur-&gt;val);</span><br><span class="line">				buckets [i] = copy;</span><br><span class="line">				</span><br><span class="line">				<span class="comment">//针对同一个bucket list，复制每一个节点</span></span><br><span class="line">				<span class="keyword">for</span> (node* next = cur-&gt;next; next; cur = next, next = cur-&gt;next) &#123;</span><br><span class="line">					copy-&gt;next = <span class="built_in">new_node</span>(next-&gt;val);</span><br><span class="line">					copy = copy-&gt;next;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		num_elements = ht.num_elements; <span class="comment">//重新登录节点个数(hashtable 的大小)</span></span><br><span class="line">	&#125;</span><br><span class="line">	__STL_UNWIND(<span class="built_in">clear</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="hash-functions"><a href="#hash-functions" class="headerlink" title="hash functions"></a>hash functions</h4><p>&lt;stl_hash_fun.h&gt;定义有数个现成的hash functions，全都是仿函数，除了对于字符字符串（const char*）设计了一个转换函数外，其余char，short，int，long整型类型的hash functions几乎都什么都没做 ：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//以下定义于&lt;stl_hash_fun.h&gt;</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Key</span>&gt; <span class="keyword">struct</span> <span class="title class_">hash</span> &#123; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="type">size_t</span> __stl_hash_string (<span class="type">const</span> <span class="type">char</span>* s )</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> h = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> ( ; *s; ++s)</span><br><span class="line">		h = <span class="number">5</span>*h + *s;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">size_t</span>(h);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//以下所有的__STL_TEMPLATE_NULL，在&lt;stl_config.h&gt;中皆被定义为template&lt;&gt;</span></span><br><span class="line">__STL_TEMPLATE_NULL <span class="keyword">struct</span> <span class="title class_">hash</span>&lt;<span class="type">char</span>*&gt;</span><br><span class="line">&#123;</span><br><span class="line">	<span class="function"><span class="type">size_t</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="type">const</span> <span class="type">char</span>* s)</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> __stl_hash_string(s);&#125; </span><br><span class="line">&#125;;</span><br><span class="line">__STL_TEMPLATE_NULL <span class="keyword">struct</span> <span class="title class_">hash</span>&lt;<span class="type">const</span> <span class="type">char</span>*&gt;</span><br><span class="line">&#123;</span><br><span class="line">	<span class="function"><span class="type">size_t</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="type">const</span> <span class="type">char</span>* s)</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> __stl_hash_string(s);&#125; </span><br><span class="line">&#125;;</span><br><span class="line">__STL_TEMPLATE_NULL <span class="keyword">struct</span> <span class="title class_">hash</span>&lt;<span class="type">char</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">	<span class="function"><span class="type">size_t</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="type">char</span> x)</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> x;&#125; </span><br><span class="line">&#125;;</span><br><span class="line">__STL_TEMPLATE_NULL <span class="keyword">struct</span> <span class="title class_">hash</span>&lt;<span class="type">unsigned</span> <span class="type">char</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">	<span class="function"><span class="type">size_t</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="type">unsigned</span> <span class="type">char</span> x)</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> x;&#125; </span><br><span class="line">&#125;;</span><br><span class="line">__STL_TEMPLATE_NULL <span class="keyword">struct</span> <span class="title class_">hash</span>&lt;<span class="type">signed</span> <span class="type">char</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">	<span class="function"><span class="type">size_t</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="type">unsigned</span> <span class="type">char</span> x)</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> x;&#125; </span><br><span class="line">&#125;;</span><br><span class="line">__STL_TEMPLATE_NULL <span class="keyword">struct</span> <span class="title class_">hash</span>&lt;<span class="type">short</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">	<span class="function"><span class="type">size_t</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="type">short</span> x)</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> x;&#125; </span><br><span class="line">&#125;;</span><br><span class="line">__STL_TEMPLATE_NULL <span class="keyword">struct</span> <span class="title class_">hash</span>&lt;<span class="type">unsigned</span> <span class="type">short</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">	<span class="function"><span class="type">size_t</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="type">unsigned</span> <span class="type">short</span> x)</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> x;&#125; </span><br><span class="line">&#125;;</span><br><span class="line">__STL_TEMPLATE_NULL <span class="keyword">struct</span> <span class="title class_">hash</span>&lt;<span class="type">int</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">	<span class="function"><span class="type">size_t</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="type">int</span> x)</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> x;&#125; </span><br><span class="line">&#125;;</span><br><span class="line">__STL_TEMPLATE_NULL <span class="keyword">struct</span> <span class="title class_">hash</span>&lt;<span class="type">unsigned</span> <span class="type">int</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">	<span class="function"><span class="type">size_t</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="type">unsigned</span> <span class="type">int</span> x)</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> x;&#125; </span><br><span class="line">&#125;;</span><br><span class="line">__STL_TEMPLATE_NULL <span class="keyword">struct</span> <span class="title class_">hash</span>&lt;<span class="type">long</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">	<span class="function"><span class="type">size_t</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="type">long</span> x)</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> x;&#125; </span><br><span class="line">&#125;;</span><br><span class="line">__STL_TEMPLATE_NULL <span class="keyword">struct</span> <span class="title class_">hash</span>&lt;<span class="type">unsigned</span> <span class="type">long</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">	<span class="function"><span class="type">size_t</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="type">unsigned</span> <span class="type">long</span> x)</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> x;&#125; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>除了上述定义过hash function的类型之外的类型，例如string，double，float。欲处理这些类型，用户必须自行为它们定义hash function。</p>
<h3 id="hash-set和hash-multiset"><a href="#hash-set和hash-multiset" class="headerlink" title="hash_set和hash_multiset"></a>hash_set和hash_multiset</h3><p>hash_set不同于set的地方是hash_set的底层机制时hashtable而set的底层机制是RB-tree。因此，set的元素具有自动排序功能而hash_set没有，除此之外，使用方式完全相同。</p>
<p>而hash_multiset与hash_set的区别仅在于对不同插入函数的调用（insert_equal()和insert_unique()）。</p>
<h3 id="hash-map和hash-multimap"><a href="#hash-map和hash-multimap" class="headerlink" title="hash_map和hash_multimap"></a>hash_map和hash_multimap</h3><p>hash_map不同于map的地方是hash_map的底层机制时hashtable而map的底层机制是RB-tree。因此，map的元素具有自动排序功能而hash_map没有，除此之外，使用方式完全相同。</p>
<p>而hash_multimap与hash_map的区别仅在于对不同插入函数的调用（insert_equal()和insert_unique()）。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://example.com">lzl121373</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2022/04/02/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E7%AC%AC%E4%BA%94%E7%AB%A0/">http://example.com/2022/04/02/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E7%AC%AC%E4%BA%94%E7%AB%A0/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">😊</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/STL/">STL</a><a class="post-meta__tags" href="/tags/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/">STL源码剖析</a><a class="post-meta__tags" href="/tags/%E5%AE%B9%E5%99%A8/">容器</a><a class="post-meta__tags" href="/tags/%E5%85%B3%E8%81%94%E5%BC%8F%E5%AE%B9%E5%99%A8/">关联式容器</a><a class="post-meta__tags" href="/tags/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/">二叉搜索树</a><a class="post-meta__tags" href="/tags/RB-tree/">RB-tree</a><a class="post-meta__tags" href="/tags/set/">set</a><a class="post-meta__tags" href="/tags/map/">map</a><a class="post-meta__tags" href="/tags/multiset/">multiset</a><a class="post-meta__tags" href="/tags/multimap/">multimap</a><a class="post-meta__tags" href="/tags/hashtable/">hashtable</a></div><div class="post_share"><div class="social-share" data-image="/../img/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E5%B0%81%E9%9D%A2.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/gh/overtrue/share.js@master/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/04/08/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E7%AC%AC%E5%85%AD%E7%AB%A0/"><img class="prev-cover" src="/../img/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E5%B0%81%E9%9D%A2.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">&lt;STL源码剖析&gt;第六章——算法</div></div></a></div><div class="next-post pull-right"><a href="/2022/03/26/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E7%AC%AC%E5%9B%9B%E7%AB%A0/"><img class="next-cover" src="/../img/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E5%B0%81%E9%9D%A2.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">&lt;STL源码剖析&gt;第四章——序列式容器</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2022/03/26/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E7%AC%AC%E5%9B%9B%E7%AB%A0/" title="&lt;STL源码剖析&gt;第四章——序列式容器"><img class="cover" src="/../img/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E5%B0%81%E9%9D%A2.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-03-26</div><div class="title">&lt;STL源码剖析&gt;第四章——序列式容器</div></div></a></div><div><a href="/2022/03/21/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E7%AC%AC%E4%B8%80%E4%BA%8C%E7%AB%A0/" title="&lt;STL源码剖析&gt;第一二章——allocator"><img class="cover" src="/../img/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E5%B0%81%E9%9D%A2.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-03-21</div><div class="title">&lt;STL源码剖析&gt;第一二章——allocator</div></div></a></div><div><a href="/2022/05/09/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E7%AC%AC%E4%B8%83%E7%AB%A0/" title="&lt;STL源码剖析&gt;第七章——仿函数"><img class="cover" src="/../img/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E5%B0%81%E9%9D%A2.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-05-09</div><div class="title">&lt;STL源码剖析&gt;第七章——仿函数</div></div></a></div><div><a href="/2022/03/23/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E7%AC%AC%E4%B8%89%E7%AB%A0/" title="&lt;STL源码剖析&gt;第三章——迭代器"><img class="cover" src="/../img/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E5%B0%81%E9%9D%A2.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-03-23</div><div class="title">&lt;STL源码剖析&gt;第三章——迭代器</div></div></a></div><div><a href="/2022/04/08/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E7%AC%AC%E5%85%AD%E7%AB%A0/" title="&lt;STL源码剖析&gt;第六章——算法"><img class="cover" src="/../img/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E5%B0%81%E9%9D%A2.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-04-08</div><div class="title">&lt;STL源码剖析&gt;第六章——算法</div></div></a></div><div><a href="/2022/05/09/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E7%AC%AC%E5%85%AB%E7%AB%A0/" title="&lt;STL源码剖析&gt;第八章——配接器"><img class="cover" src="/../img/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E5%B0%81%E9%9D%A2.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-05-09</div><div class="title">&lt;STL源码剖析&gt;第八章——配接器</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">lzl121373</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">11</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">51</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">2</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/lzl121373" target="_blank" title="Github"><i class="fab fa-github"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8"><span class="toc-number">1.</span> <span class="toc-text">容器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B3%E8%81%94%E5%BC%8F%E5%AE%B9%E5%99%A8"><span class="toc-number">2.</span> <span class="toc-text">关联式容器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%EF%BC%88binary-search-tree%EF%BC%89"><span class="toc-number">2.1.</span> <span class="toc-text">二叉搜索树（binary search tree）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%EF%BC%88balanced-binary-search-tree%EF%BC%89"><span class="toc-number">2.2.</span> <span class="toc-text">平衡二叉搜索树（balanced binary search tree）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AVL-tree"><span class="toc-number">2.3.</span> <span class="toc-text">AVL tree</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%95%E6%97%8B%E8%BD%AC"><span class="toc-number">2.3.1.</span> <span class="toc-text">单旋转</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%8C%E6%97%8B%E8%BD%AC"><span class="toc-number">2.3.2.</span> <span class="toc-text">双旋转</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RB-tree%EF%BC%88%E7%BA%A2%E9%BB%91%E6%A0%91%EF%BC%89"><span class="toc-number">2.4.</span> <span class="toc-text">RB-tree（红黑树）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8F%92%E5%85%A5%E8%8A%82%E7%82%B9"><span class="toc-number">2.4.1.</span> <span class="toc-text">插入节点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#RB-tree%E8%8A%82%E7%82%B9%E8%AE%BE%E8%AE%A1"><span class="toc-number">2.4.2.</span> <span class="toc-text">RB-tree节点设计</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#RB-tree%E7%9A%84%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-number">2.4.3.</span> <span class="toc-text">RB-tree的迭代器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#RB-tree%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">2.4.4.</span> <span class="toc-text">RB-tree的数据结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#RB-tree%E7%9A%84%E5%85%83%E7%B4%A0%E6%93%8D%E4%BD%9C"><span class="toc-number">2.4.5.</span> <span class="toc-text">RB-tree的元素操作</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%83%E7%B4%A0%E6%8F%92%E5%85%A5%E6%93%8D%E4%BD%9Cinsert-equal"><span class="toc-number">2.4.5.1.</span> <span class="toc-text">元素插入操作insert_equal()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%83%E7%B4%A0%E6%8F%92%E5%85%A5%E6%93%8D%E4%BD%9Cinsert-unique"><span class="toc-number">2.4.5.2.</span> <span class="toc-text">元素插入操作insert_unique()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%B0%83%E6%95%B4RB-tree%EF%BC%88%E6%97%8B%E8%BD%AC%E5%8F%8A%E6%94%B9%E5%8F%98%E9%A2%9C%E8%89%B2%EF%BC%89"><span class="toc-number">2.4.5.3.</span> <span class="toc-text">调整RB-tree（旋转及改变颜色）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%83%E7%B4%A0%E7%9A%84%E6%90%9C%E5%AF%BB"><span class="toc-number">2.4.5.4.</span> <span class="toc-text">元素的搜寻</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#set"><span class="toc-number">2.5.</span> <span class="toc-text">set</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#map"><span class="toc-number">2.6.</span> <span class="toc-text">map</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#multiset"><span class="toc-number">2.7.</span> <span class="toc-text">multiset</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#multimap"><span class="toc-number">2.8.</span> <span class="toc-text">multimap</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#hashtable"><span class="toc-number">2.9.</span> <span class="toc-text">hashtable</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#hashtable%E7%9A%84%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-number">2.9.1.</span> <span class="toc-text">hashtable的迭代器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#hashtable%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">2.9.2.</span> <span class="toc-text">hashtable的数据结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#hashtable%E7%9A%84%E6%9E%84%E9%80%A0%E4%B8%8E%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-number">2.9.3.</span> <span class="toc-text">hashtable的构造与内存管理</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#insert%E6%93%8D%E4%BD%9C%E4%B8%8E%E8%A1%A8%E6%A0%BC%E9%87%8D%E6%95%B4%EF%BC%88resize%EF%BC%89"><span class="toc-number">2.9.3.1.</span> <span class="toc-text">insert操作与表格重整（resize）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%A4%E6%96%AD%E5%85%83%E7%B4%A0%E7%9A%84%E8%90%BD%E8%84%9A%E5%A4%84%EF%BC%88bkt-num%EF%BC%89"><span class="toc-number">2.9.3.2.</span> <span class="toc-text">判断元素的落脚处（bkt_num）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%8D%E5%88%B6%EF%BC%88copy-from%EF%BC%89%E5%92%8C%E6%95%B4%E4%BD%93%E5%88%A0%E9%99%A4%EF%BC%88clear%EF%BC%89"><span class="toc-number">2.9.3.3.</span> <span class="toc-text">复制（copy_from）和整体删除（clear）</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#hash-functions"><span class="toc-number">2.9.4.</span> <span class="toc-text">hash functions</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#hash-set%E5%92%8Chash-multiset"><span class="toc-number">2.10.</span> <span class="toc-text">hash_set和hash_multiset</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#hash-map%E5%92%8Chash-multimap"><span class="toc-number">2.11.</span> <span class="toc-text">hash_map和hash_multimap</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/09/25/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E7%AC%AC%E5%9B%9B%E9%83%A8%E5%88%86/" title="&lt;Redis设计与实现&gt;第四部分"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="&lt;Redis设计与实现&gt;第四部分"/></a><div class="content"><a class="title" href="/2022/09/25/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E7%AC%AC%E5%9B%9B%E9%83%A8%E5%88%86/" title="&lt;Redis设计与实现&gt;第四部分">&lt;Redis设计与实现&gt;第四部分</a><time datetime="2022-09-24T16:00:00.000Z" title="发表于 2022-09-25 00:00:00">2022-09-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/08/28/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E7%AC%AC%E4%B8%89%E9%83%A8%E5%88%86/" title="&lt;Redis设计与实现&gt;第三部分"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="&lt;Redis设计与实现&gt;第三部分"/></a><div class="content"><a class="title" href="/2022/08/28/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E7%AC%AC%E4%B8%89%E9%83%A8%E5%88%86/" title="&lt;Redis设计与实现&gt;第三部分">&lt;Redis设计与实现&gt;第三部分</a><time datetime="2022-08-27T16:00:00.000Z" title="发表于 2022-08-28 00:00:00">2022-08-28</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/05/29/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86/" title="&lt;Redis设计与实现&gt;第二部分"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="&lt;Redis设计与实现&gt;第二部分"/></a><div class="content"><a class="title" href="/2022/05/29/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86/" title="&lt;Redis设计与实现&gt;第二部分">&lt;Redis设计与实现&gt;第二部分</a><time datetime="2022-05-28T16:00:00.000Z" title="发表于 2022-05-29 00:00:00">2022-05-29</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/05/13/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86/" title="&lt;Redis设计与实现&gt;第一部分"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="&lt;Redis设计与实现&gt;第一部分"/></a><div class="content"><a class="title" href="/2022/05/13/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86/" title="&lt;Redis设计与实现&gt;第一部分">&lt;Redis设计与实现&gt;第一部分</a><time datetime="2022-05-12T16:00:00.000Z" title="发表于 2022-05-13 00:00:00">2022-05-13</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/05/09/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E7%AC%AC%E4%B8%83%E7%AB%A0/" title="&lt;STL源码剖析&gt;第七章——仿函数"><img src="/../img/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E5%B0%81%E9%9D%A2.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="&lt;STL源码剖析&gt;第七章——仿函数"/></a><div class="content"><a class="title" href="/2022/05/09/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E7%AC%AC%E4%B8%83%E7%AB%A0/" title="&lt;STL源码剖析&gt;第七章——仿函数">&lt;STL源码剖析&gt;第七章——仿函数</a><time datetime="2022-05-08T16:00:00.000Z" title="发表于 2022-05-09 00:00:00">2022-05-09</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By lzl121373</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>
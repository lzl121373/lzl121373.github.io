<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>&lt;Redis设计与实现&gt;第四部分 | 😊</title><meta name="keywords" content="Redis,Redis设计与实现,独立功能的实现,发布与订阅,事务,Lua脚本,排序,二进制位数组,慢查询日志,监视器"><meta name="author" content="lzl121373"><meta name="copyright" content="lzl121373"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="第四部分，Redis相关独立功能的实现">
<meta property="og:type" content="article">
<meta property="og:title" content="&lt;Redis设计与实现&gt;第四部分">
<meta property="og:url" content="http://example.com/2022/09/25/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E7%AC%AC%E5%9B%9B%E9%83%A8%E5%88%86/index.html">
<meta property="og:site_name" content="😊">
<meta property="og:description" content="第四部分，Redis相关独立功能的实现">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2022-09-24T16:00:00.000Z">
<meta property="article:modified_time" content="2022-09-24T16:00:00.000Z">
<meta property="article:author" content="lzl121373">
<meta property="article:tag" content="Redis">
<meta property="article:tag" content="Redis设计与实现">
<meta property="article:tag" content="独立功能的实现">
<meta property="article:tag" content="发布与订阅">
<meta property="article:tag" content="事务">
<meta property="article:tag" content="Lua脚本">
<meta property="article:tag" content="排序">
<meta property="article:tag" content="二进制位数组">
<meta property="article:tag" content="慢查询日志">
<meta property="article:tag" content="监视器">
<meta name="twitter:card" content="summary"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2022/09/25/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E7%AC%AC%E5%9B%9B%E9%83%A8%E5%88%86/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '<Redis设计与实现>第四部分',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-09-25 00:00:00'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="😊" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">11</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">51</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">2</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-images"></i><span> Photo</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">😊</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-images"></i><span> Photo</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">&lt;Redis设计与实现&gt;第四部分</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-09-24T16:00:00.000Z" title="发表于 2022-09-25 00:00:00">2022-09-25</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-09-24T16:00:00.000Z" title="更新于 2022-09-25 00:00:00">2022-09-25</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">Redis设计与实现读书笔记</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">24.7k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>81分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="&lt;Redis设计与实现&gt;第四部分"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="独立功能的实现"><a href="#独立功能的实现" class="headerlink" title="独立功能的实现"></a>独立功能的实现</h1><h2 id="发布与订阅"><a href="#发布与订阅" class="headerlink" title="发布与订阅"></a>发布与订阅</h2><p>Redis的发布与订阅功能由PUBLISH、SUBSCRIBE、PSUBSCRIBE等命令组成。</p>
<p>通过执行SUBSCRIBE命令，客户端可以订阅一个或多个频道，从而成为这些频道的订阅者（subscriber）：每当有其他客户端向被订阅的频道发送消息（message）时，频道的所有订阅者都会收到这条消息。</p>
<p>除了订阅频道之外，客户端还可以通过执行PSUBSCRIBE命令订阅一个或多个模式，从而成为这些模式的订阅者：每当有其他客户端向某个频道发送消息时，消息不仅会被发送给这个频道的所有订阅者，它还会被发送给所有与这个频道相匹配的模式的订阅者。</p>
<h3 id="频道的订阅与退订"><a href="#频道的订阅与退订" class="headerlink" title="频道的订阅与退订"></a>频道的订阅与退订</h3><p>当一个客户端执行SUBSCRIBE命令订阅某个或某些频道的时候，这个客户端与被订阅频道之间就建立起了一种订阅关系。</p>
<p>Redis将所有频道的订阅关系都保存在服务器状态的pubsub_channels字典里面，这个字典的键是某个被订阅的频道，而键的值则是一个链表，链表里面记录了所有订阅这个频道的客户端：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span> &#123;</span></span><br><span class="line">	</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">	<span class="comment">//保存所有频道的订阅关系</span></span><br><span class="line">    dict *pubsub_channels;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="/..%5Cimg%5CRedis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%5Cpubsub_channels%E5%AD%97%E5%85%B8%E7%A4%BA%E4%BE%8B.png" alt="pubsub_channels字典示例"></p>
<h4 id="订阅频道"><a href="#订阅频道" class="headerlink" title="订阅频道"></a>订阅频道</h4><p>每当客户端执行SUBSCRIBE命令订阅某个或某些频道的时候，服务器都会将客户端与被订阅的频道在pubsub_channels字典中进行关联。</p>
<p>根据频道是否已经有其他订阅者，关联操作分为两种情况执行：</p>
<ul>
<li>如果频道已经有其他订阅者，那么它在pubsub_channels字典中必然有相应的订阅者链表，程序唯一要做的就是将客户端添加到订阅者链表的末尾。</li>
<li>如果频道还未有任何订阅者，那么它必然不存在于pubsub_channels字典，程序首先要在pubsub_channels字典中为频道创建一个键，并将这个键的值设置为空链表，然后再将客户端添加到链表，成为链表的第一个元素。</li>
</ul>
<p>SUBSCRIBE命令的实现可以用以下伪代码来描述：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">def subscribe (*all_input_channels):</span><br><span class="line">	# 遍历输入的所有频道</span><br><span class="line">	for channel in all_input_channels:</span><br><span class="line">		#如果channel不存在于pubsub_channels字典（没有任何订阅者）</span><br><span class="line">		#那么在字典中添加channel键，并设置它的值为空链表</span><br><span class="line">		if channel not in server.pubsub_channels:</span><br><span class="line">			server.pubsub_channels[channel] = []</span><br><span class="line"></span><br><span class="line">		#将订阅者添加到频道所对应的链表的末尾</span><br><span class="line">		server.pubsub_channels[channel].append(client)</span><br></pre></td></tr></table></figure>

<h4 id="退订频道"><a href="#退订频道" class="headerlink" title="退订频道"></a>退订频道</h4><p>UNSUBSCRIBE命令的行为和SUBSCRIBE命令的行为正好相反，当一个客户端退订某个或某些频道的时候，服务器将从pubsub_channels中解除客户端与被退订频道之间的关联：</p>
<ul>
<li>程序会根据被退订频道的名字，在pubsub_channels字典中找到频道对应的订阅者链表，然后从订阅者链表中删除退订客户端的信息。</li>
<li>如果删除退订客户端之后，频道的订阅者链表变成了空链表，那么说明这个频道已经没有任何订阅者了，程序将从pubsub_channels字典中删除频道对应的键。</li>
</ul>
<p>UNSUBSCRIBE命令的实现可以用以下伪代码来描述：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">def unsubscribe(*all_input_channels):</span><br><span class="line">	#遍历要退订的所有频道</span><br><span class="line">	for channel in all_input_channels:</span><br><span class="line">		#在订阅者链表中删除退订的客户端</span><br><span class="line">		server.pubsub_channels[channel].remove(client)</span><br><span class="line">		#如果频道已经没有任何订阅者了（订阅者链表为空）</span><br><span class="line">		#那么将频道从字典中删除</span><br><span class="line">		if len(server.pubsub_channels[channel]) == 0:</span><br><span class="line">			server.pubsub_channels.remove (channel)</span><br></pre></td></tr></table></figure>

<h3 id="模式的订阅与退订"><a href="#模式的订阅与退订" class="headerlink" title="模式的订阅与退订"></a>模式的订阅与退订</h3><p>前面说过，服务器将所有频道的订阅关系都保存在服务器状态的pubsub_channels属性里面，与此类似，服务器也将所有模式的订阅关系都保存在服务器状态的pubsub_patterns属性里面：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span> &#123;</span></span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//保存所有模式订阅关系</span></span><br><span class="line">    <span class="built_in">list</span> *pubsub_patterns;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<p>pubsub_patterns属性是一个链表，链表中的每个节点都包含着一个pubsubPattern结构，这个结构的pattern属性记录了被订阅的模式，而client属性则记录了订阅模式的客户端：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">pubsubPattern</span> &#123;</span></span><br><span class="line">	</span><br><span class="line">    <span class="comment">//订阅模式的客户端</span></span><br><span class="line">    redisClient *client;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//被订阅的模式</span></span><br><span class="line">	robj *pattern;</span><br><span class="line">&#125; pubsubPattern;</span><br></pre></td></tr></table></figure>

<h4 id="订阅模式"><a href="#订阅模式" class="headerlink" title="订阅模式"></a>订阅模式</h4><p>每当客户端执行PSUBSCRIBE命令订阅某个或某些模式的时候，服务器会对每个被订阅的模式执行以下两个操作：</p>
<ol>
<li>新建一个pubsubPattern结构，将结构的pattern属性设置为被订阅的模式，client属性设置为订阅模式的客户端。</li>
<li>将pubsubPattern结构添加到pubsub_patterns链表的表尾。</li>
</ol>
<p>PSUBSCRIBE命令的实现原理可以用以下伪代码来描述：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">def psubscribe(*all_input_patterns):</span><br><span class="line">	#遍历输入的所有模式</span><br><span class="line">	for pattern in all_input_patterns:</span><br><span class="line">		#创建新的pubsubPattern结构</span><br><span class="line">		#记录被订阅的模式，以及订阅模式的客户端</span><br><span class="line">		pubsubPattern = create_new_pubsubPattern()</span><br><span class="line">		pubsubPattern.client = client</span><br><span class="line">		pubsubPattern.pattern = pattern</span><br><span class="line"></span><br><span class="line">		#将新的pubsubPattern追加到pubsub_patterns链表末尾</span><br><span class="line">		server.pubsub_patterns.append(pubsubPattern)</span><br></pre></td></tr></table></figure>

<h4 id="退订模式"><a href="#退订模式" class="headerlink" title="退订模式"></a>退订模式</h4><p>模式的退订命令PUNSUBSCRIBE是PSUBSCRIBE命令的反操作：当一个客户端退订某个或某些模式的时候，服务器将在pubsub_patterns链表中查找并删除那些pattern属性为被退订模式，并且client属性为执行退订命令的客户端的pubsubPattern结构。</p>
<p>PUNSUBSCRIBE命令的实现原理可以用以下伪代码来描述：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">def punsubscribe(*all_input_patterns):</span><br><span class="line">	#遍历所有要退订的模式</span><br><span class="line">	for pattern in all_input_patterns:</span><br><span class="line">		#遍历pubsub_patterns链表中的所有pubsubPattern结构</span><br><span class="line">		for pubsubPattern in server.pubsub_patterns:</span><br><span class="line">		</span><br><span class="line">			#如果当前客户端和pubsubPattern记录的客户端相同</span><br><span class="line">			#并且要退订的模式也和pubsubPattern记录的模式相同</span><br><span class="line">			if client == pubsubPattern.client and \</span><br><span class="line">				pattern == pubsubPattern.pattern:</span><br><span class="line"></span><br><span class="line">				#那么将这个pubsubPattern从链表中删除</span><br><span class="line">				server.pubsub_patterns.remove(pubsubPattern)</span><br></pre></td></tr></table></figure>

<h3 id="发送消息"><a href="#发送消息" class="headerlink" title="发送消息"></a>发送消息</h3><p>当一个Redis客户端执行PUBLISH &lt;channel&gt; &lt;message&gt;命令将消息message发送给频道channel的时候，服务器需要执行以下两个动作：</p>
<ol>
<li>将消息message发送给channel频道的所有订阅者。</li>
<li>如果有一个或多个模式pattern与频道channel相匹配，那么将消息message发送给pattern模式的订阅者。</li>
</ol>
<h4 id="将消息发送给频道订阅者"><a href="#将消息发送给频道订阅者" class="headerlink" title="将消息发送给频道订阅者"></a>将消息发送给频道订阅者</h4><p>因为服务器状态中的pubsub_channels字典记录了所有频道的订阅关系，所以为了将消息发送给channel频道的所有订阅者，PUBLISH命令要做的就是在pubsub_channels字典里找到频道channel的订阅者名单（一个链表），然后将消息发送给名单上的所有客户端。</p>
<p>PUBLISH命令将消息发送给频道订阅者的方法可以用以下伪代码来描述：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">def channel_publish(channel, message):</span><br><span class="line">	#如果channel键不存在于pubsub_channels字典中</span><br><span class="line">	#那么说明channel频道没有任何订阅者</span><br><span class="line">	#程序不做发送动作，直接返回</span><br><span class="line">	if channel not in server.pubsub_channels:</span><br><span class="line">		return</span><br><span class="line"></span><br><span class="line">	#运行到这里，说明channel频道至少有一个订阅者</span><br><span class="line">	#程序遍历channel频道的订阅者链表</span><br><span class="line">	#将消息发送给所有订阅者</span><br><span class="line">	for subscriber in server.pubsub_channels[channel]:</span><br><span class="line">		send_message(subscriber, message)</span><br></pre></td></tr></table></figure>

<h4 id="将消息发送给模式订阅者"><a href="#将消息发送给模式订阅者" class="headerlink" title="将消息发送给模式订阅者"></a>将消息发送给模式订阅者</h4><p>因为服务器状态中的pubsub_patterns链表记录了所有模式的订阅关系，所以为了将消息发送给所有与channel频道相匹配的模式的订阅者，PUBLISH命令要做的就是遍历整个pubsub_patterns链表，查找那些与channel频道相匹配的模式，并将消息发送给订阅了这些模式的客户端。</p>
<p>PUBLISH命令将消息发送给模式订阅者的方法可以用以下伪代码来描述：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def pattern_publish(channel, message):</span><br><span class="line">	#遍历所有模式订阅消息</span><br><span class="line">	for pubsubPattern in server.pubsub_patterns:</span><br><span class="line">		#如果频道和模式相匹配</span><br><span class="line">		if match(channel, pubsubPattern.pattern):</span><br><span class="line">			#那么将消息发送给订阅该模式的客户端</span><br><span class="line">			send_message(pubsubPattern.client, message)</span><br></pre></td></tr></table></figure>


<p>最后，PUBLISH命令的实现可以用以下伪代码来描述：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def publish(channel, message):</span><br><span class="line">	#将消息发送给channel频道的所有订阅者</span><br><span class="line">	channel_publish(channel, message)</span><br><span class="line">	#将消息发送给所有和channel频道相匹配的模式的订阅者</span><br><span class="line">	pattern_publish(channel,message)</span><br></pre></td></tr></table></figure>

<h3 id="查看订阅消息"><a href="#查看订阅消息" class="headerlink" title="查看订阅消息"></a>查看订阅消息</h3><p>PUBSUB命令是Redis 2.8新增加的命令之一，客户端可以通过这个命令来查看频道或者模式的相关信息，比如某个频道目前有多少订阅者，又或者某个模式目前有多少订阅者，诸如此类。</p>
<h4 id="PUBSUB-CHANNELS"><a href="#PUBSUB-CHANNELS" class="headerlink" title="PUBSUB CHANNELS"></a>PUBSUB CHANNELS</h4><p>PUBSUB CHANNELS [pattern]子命令用于返回服务器当前被订阅的频道，其中pattern参数是可选的：</p>
<ul>
<li>如果不给定pattern参数，那么命令返回服务器当前被订阅的所有频道。</li>
<li>如果给定pattern参数，那么命令返回服务器当前被订阅的频道中那些与pattern模式相匹配的频道。</li>
</ul>
<p>这个子命令是通过遍历服务器pubsub_channels字典的所有键（每个键都是一个被订阅的道道)，然后记录并返回所有符合条件的频道来实现的，这个过程可以用以下伪代码来描述：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">def pubsub_channels(pattern=None):</span><br><span class="line">	#一个列表，用于记录所有符合条件的频道</span><br><span class="line">	channel_list = []</span><br><span class="line">	</span><br><span class="line">	#遍历服务器中的所有频道</span><br><span class="line">	#（也即是pubsub_channels字典的所有键）</span><br><span class="line">	for channel in server.pubsub_channels:</span><br><span class="line">		#当以下两个条件的任意一个满足时，将频道添加到链表里面:</span><br><span class="line">		#1)用户没有指定pattern参数</span><br><span class="line">		#2)用户指定了pattern参数，并且channel和pattern匹配</span><br><span class="line">		if (pattern is None) or match (channel, pattern):</span><br><span class="line">			channel_list.append(channel)</span><br><span class="line"></span><br><span class="line">	#向客户端返回频道列表</span><br><span class="line">	return channel_list</span><br></pre></td></tr></table></figure>

<h4 id="PUBSUB-NUMSUB"><a href="#PUBSUB-NUMSUB" class="headerlink" title="PUBSUB NUMSUB"></a>PUBSUB NUMSUB</h4><p>PUBSUB NUMSUB [channel-1 channel-2 … channel-n]子命令接受任意多个频道作为输入参数，并返回这些频道的订阅者数量。</p>
<p>这个子命令是通过在pubsub_channels字典中找到频道对应的订阅者链表，然后返回订阅者链表的长度来实现的（订阅者链表的长度就是频道订阅者的数量），这个过程可以用以下伪代码来描述：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">def pubsub_numsub(*all_input_channels):</span><br><span class="line">	#遍历输入的所有频道</span><br><span class="line">	for channel in all_input_channels:</span><br><span class="line">		#如果pubsub_channels字典中没有channel这个键</span><br><span class="line">		#那么说明channel频道没有任何订阅者</span><br><span class="line">		if channel not in server.pubsub_channels:</span><br><span class="line">			#返回频道名</span><br><span class="line">			reply_channel_name(channel)</span><br><span class="line">			#订阅者数量为0</span><br><span class="line">			reply_subscribe_count(0)</span><br><span class="line"></span><br><span class="line">		#如果pubsub_channels字典中存在channel键</span><br><span class="line">		#那么说明channel频道至少有一个订阅者</span><br><span class="line">		else:</span><br><span class="line">			#返回频道名</span><br><span class="line">			reply_channel_name(channel)</span><br><span class="line">			#订阅者链表的长度就是订阅者数量</span><br><span class="line">			reply_subscribe_count(len(server.pubsub_channels[channel]))</span><br></pre></td></tr></table></figure>

<h4 id="PUBSUB-NUMPAT"><a href="#PUBSUB-NUMPAT" class="headerlink" title="PUBSUB NUMPAT"></a>PUBSUB NUMPAT</h4><p>PUBSUB NUMPAT子命令用于返回服务器当前被订阅模式的数量。</p>
<p>这个子命令是通过返回pubsub_patterns链表的长度来实现的，因为这个链表的长度就是服务器被订阅模式的数量，这个过程可以用以下伪代码来描述：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">def pubsub_numpat():</span><br><span class="line">	# pubsub_patterns链表的长度就是被订阅模式的数量</span><br><span class="line">	reply_pattern_count(len(server.pubsub_patterns))</span><br></pre></td></tr></table></figure>

<h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><p>Redis通过MULTI、EXEC、WATCH等命令来实现事务（transaction）功能。事务提供了一种将多个命令请求打包，然后一次性、按顺序地执行多个命令的机制，并且在事务执行期间，服务器不会中断事务而改去执行其他客户端的命令请求，它会将事务中的所有命令都执行完毕，然后才去处理其他客户端的命令请求。</p>
<p>以下是一个事务执行的过程，该事务首先以一个MULTI命令为开始，接着将多个命令放入事务当中，最后由EXEC命令将这个事务提交（commit）给服务器执行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; MULTI</span><br><span class="line">OK</span><br><span class="line">redis&gt; SET &quot;name&quot; &quot;Practical Common Lisp&quot;</span><br><span class="line">QUEUED</span><br><span class="line">redis&gt; GET &quot;name&quot;</span><br><span class="line">QUEUED</span><br><span class="line">redis&gt; SET &quot;author&quot; &quot;Peter seibel&quot;</span><br><span class="line">QUEUED</span><br><span class="line">redis&gt; GET &quot;author&quot;</span><br><span class="line">QUEUED</span><br><span class="line">redis&gt; EXEC</span><br><span class="line">1)OK</span><br><span class="line">2)&quot;Practical Common Lisp&quot;</span><br><span class="line">3)OK</span><br><span class="line">4)&quot;Peter seibel&quot;</span><br></pre></td></tr></table></figure>

<h3 id="事务的实现"><a href="#事务的实现" class="headerlink" title="事务的实现"></a>事务的实现</h3><p>一个事务从开始到结束通常会经历以下三个阶段：</p>
<ol>
<li>事务开始。</li>
<li>命令入队。</li>
<li>事务执行。</li>
</ol>
<h4 id="事务开始"><a href="#事务开始" class="headerlink" title="事务开始"></a>事务开始</h4><p>MULTI命令的执行标志着事务的开始：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; MULTI</span><br><span class="line">OK</span><br></pre></td></tr></table></figure>


<p>MULTI命令可以将执行该命令的客户端从非事务状态切换至事务状态，这一切换是通过在客户端状态的flags属性中打开REDIS_MULTI标识来完成的，MULTI命令的实现可以用以下伪代码来表示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def MULTI():</span><br><span class="line">	#打开事务标识</span><br><span class="line">	client.flags |= REDIS_MULTI</span><br><span class="line">	#返回OK回复</span><br><span class="line">	replyOK()</span><br></pre></td></tr></table></figure>

<h4 id="命令入队"><a href="#命令入队" class="headerlink" title="命令入队"></a>命令入队</h4><p>当一个客户端处于非事务状态时，这个客户端发送的命令会立即被服务器执行。</p>
<p>与此不同的是，当一个客户端切换到事务状态之后，服务器会根据这个客户端发来的不同命令执行不同的操作：</p>
<ul>
<li>如果客户端发送的命令为EXEC、DISCARD、WATCH、MULTI四个命令的其中一个，那么服务器立即执行这个命令。</li>
<li>与此相反，如果客户端发送的命令是EXEC、DISCARD、WATCH、MULTI四个命令以外的其他命令，那么服务器并不立即执行这个命令，而是将这个命令放入一个事务队列里面，然后向客户端返回QUEUED回复。</li>
</ul>
<h4 id="事务队列"><a href="#事务队列" class="headerlink" title="事务队列"></a>事务队列</h4><p>每个Redis客户端都有自己的事务状态，这个事务状态保存在客户端状态的mstate属性里面：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisClient</span> &#123;</span></span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">	</span><br><span class="line">    <span class="comment">//事务状态</span></span><br><span class="line">	multiState mstate;	<span class="comment">/* MULTI/EXEC state */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125; redisClient;</span><br></pre></td></tr></table></figure>


<p>事务状态包含一个事务队列，以及一个已人队命令的计数器（也可以说是事务队列的长度）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">multiState</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//事务队列，FIFO顺序</span></span><br><span class="line">    multiCmd *commands;</span><br><span class="line">    <span class="comment">//已入队命令计数</span></span><br><span class="line">    <span class="type">int</span> count;</span><br><span class="line"></span><br><span class="line">&#125; multiState;</span><br></pre></td></tr></table></figure>

<p>事务队列是一个multiCmd类型的数组，数组中的每个multiCmd结构都保存了一个已入队命令的相关信息，包括指向命令实现函数的指针、命令的参数，以及参数的数量：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">multiCmd</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//参数</span></span><br><span class="line">	robj **argv;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//参数数量</span></span><br><span class="line">    <span class="type">int</span> argc;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//命令指针</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">redisCommand</span> *<span class="title">cmd</span>;</span></span><br><span class="line">&#125; multiCmd;</span><br></pre></td></tr></table></figure>


<p>事务队列以先进先出（FIFO）的方式保存入队的命令，较先人队的命令会被放到数组的前面，而较后入队的命令则会被放到数组的后面。</p>
<h4 id="执行事务"><a href="#执行事务" class="headerlink" title="执行事务"></a>执行事务</h4><p>当一个处于事务状态的客户端向服务器发送EXEC命令时，这个EXEC命令将立即被服务器执行。服务器会遍历这个客户端的事务队列，执行队列中保存的所有命令，最后将执行命令所得的结果全部返回给客户端。</p>
<p>EXEC命令的实现原理可以用以下伪代码来描述：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">def <span class="title function_">EXEC</span><span class="params">()</span>:</span><br><span class="line"></span><br><span class="line">	#创建空白的回复队列</span><br><span class="line">	reply_queue = []</span><br><span class="line"></span><br><span class="line">	#遍历事务队列中的每个项</span><br><span class="line">	#读取命令的参数，参数的个数，以及要执行的命令</span><br><span class="line">	<span class="keyword">for</span> argv, argc, cmd in client.mstate.commands:</span><br><span class="line"></span><br><span class="line">		#执行命令，并取得命令的返回值</span><br><span class="line">		reply = execute_command(cmd, argv, argc)</span><br><span class="line">		#将返回值追加到回复队列末尾</span><br><span class="line">		reply_queue.append(reply)</span><br><span class="line"></span><br><span class="line">	#移除REDIS_MULTI标识，让客户端回到非事务状态</span><br><span class="line">	client.flags &amp;= ~REDIS_MULTI</span><br><span class="line"></span><br><span class="line">	#清空客户端的事务状态，包括:</span><br><span class="line">	#<span class="number">1</span>)清零入队命令计数器</span><br><span class="line">	#<span class="number">2</span>)释放事务队列</span><br><span class="line">	client.mstate.count = <span class="number">0</span></span><br><span class="line">	release_transaction_queue(client.mstate.commands)</span><br><span class="line">	#将事务的执行结果返回给客户端</span><br><span class="line">	send_reply_to_client(client, reply_queue)</span><br></pre></td></tr></table></figure>

<h3 id="WATCH命令的实现"><a href="#WATCH命令的实现" class="headerlink" title="WATCH命令的实现"></a>WATCH命令的实现</h3><p>WATCH命令是一个乐观锁（optimistic locking），它可以在EXEC命令执行之前，监视任意数量的数据库键，并在EXEC命令执行时，检查被监视的键是否至少有一个已经被修改过了，如果是的话，服务器将拒绝执行事务，并向客户端返回代表事务执行失败的空回复。</p>
<h4 id="使用WATCH命令监视数据库键"><a href="#使用WATCH命令监视数据库键" class="headerlink" title="使用WATCH命令监视数据库键"></a>使用WATCH命令监视数据库键</h4><p>每个Redis数据库都保存着一个watched_keys字典，这个字典的键是某个被WATCH命令监视的数据库键，而字典的值则是一个链表，链表中记录了所有监视相应数据库键的客户端：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisDb</span> &#123;</span></span><br><span class="line">	</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//正在被WATCH命令监视的键</span></span><br><span class="line">    dict *watched_keys;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125; redisDb;</span><br></pre></td></tr></table></figure>


<p>通过watched_keys字典，服务器可以清楚地知道哪些数据库键正在被监视，以及哪些客户端正在监视这些数据库键。</p>
<h4 id="监视机制的触发"><a href="#监视机制的触发" class="headerlink" title="监视机制的触发"></a>监视机制的触发</h4><p>所有对数据库进行修改的命令，比如SET、LPUSH、SADD、ZREM、DEL、FLUSHDB等等，在执行之后都会调用multi.c&#x2F;touchWatchKey函数对watched_keys字典进行检查，查看是否有客户端正在监视刚刚被命令修改过的数据库键，如果有的话，那么touchWatchKey函数会将监视被修改键的客户端的REDIS_DIRTY_CAS标识打开，表示该客户端的事务安全性已经被破坏。</p>
<p>touchWatchKey函数的定义可以用以下伪代码来描述：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">def touchWatchKey(db, key):</span><br><span class="line">	#如果键key存在于数据库的watched_keys字典中</span><br><span class="line">	#那么说明至少有一个客户端在监视这个key</span><br><span class="line">	if key in db.watched_keys:</span><br><span class="line">		#遍历所有监视键key的客户端</span><br><span class="line">		for client in db.watched_keys[key]:</span><br><span class="line">			#打开标识</span><br><span class="line">			client.flags |= REDIS_DIRTY_CAS</span><br></pre></td></tr></table></figure>

<h4 id="判断事务是否安全"><a href="#判断事务是否安全" class="headerlink" title="判断事务是否安全"></a>判断事务是否安全</h4><p>当服务器接收到一个客户端发来的EXEC命令时，服务器会根据这个客户端是否打开了REDIS_DIRTY_CAS标识来决定是否执行事务：</p>
<ul>
<li>如果客户端的REDIS_DIRTY_CAS标识已经被打开，那么说明客户端所监视的键当中，至少有一个键已经被修改过了，在这种情况下，客户端提交的事务已经不再安全，所以服务器会拒绝执行客户端提交的事务。</li>
<li>如果客户端的REDIS_DIRTY_CAS标识没有被打开，那么说明客户端监视的所有键都没有被修改过（或者客户端没有监视任何键），事务仍然是安全的，服务器将执行客户端提交的这个事务。</li>
</ul>
<h3 id="事务的ACID性质"><a href="#事务的ACID性质" class="headerlink" title="事务的ACID性质"></a>事务的ACID性质</h3><p>在传统的关系式数据库中，常常用ACID性质来检验事务功能的可靠性和安全性。在Redis中，事务总是具有原子性（Atomicity）、一致性（Consistency）和隔离性（Isolation），并且当Redis运行在某种特定的持久化模式下时，事务也具有耐久性（Durability）。</p>
<h4 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h4><p>事务具有原子性指的是，数据库将事务中的多个操作当作一个整体来执行，服务器要么就执行事务中的所有操作，要么就一个操作也不执行。</p>
<p>对于Redis的事务功能来说，事务队列中的命令要么就全部都执行，要么就一个都不执行，因此，Redis的事务是具有原子性的。</p>
<p>Redis的事务和传统的关系型数据库事务的最大区别在于，Redis不支持事务回滚机制（rollback），即使事务队列中的某个命令在执行期间出现了错误，整个事务也会继续执行下去，直到将事务队列中的所有命令都执行完毕为止。</p>
<h4 id="一致性"><a href="#一致性" class="headerlink" title="一致性"></a>一致性</h4><p>事务具有一致性指的是，如果数据库在执行事务之前是一致的，那么在事务执行之后，无论事务是否执行成功，数据库也应该仍然是一致的。</p>
<p>“一致”指的是数据符合数据库本身的定义和要求，没有包含非法或者无效的错误数据。</p>
<p>Redis通过谨慎的错误检测和简单的设计来保证事务的一致性，以下三个小节将分别介绍三个Redis事务可能出错的地方，并说明Redis是如何妥善地处理这些错误，从而确保事务的一致性的。</p>
<h5 id="入队错误"><a href="#入队错误" class="headerlink" title="入队错误"></a>入队错误</h5><p>如果一个事务在入队命令的过程中，出现了命令不存在，或者命令的格式不正确等情况，那么Redis将拒绝执行这个事务。</p>
<p>因为服务器会拒绝执行入队过程中出现错误的事务，所以Redis事务的一致性不会被带有入队错误的事务影响。</p>
<h5 id="执行错误"><a href="#执行错误" class="headerlink" title="执行错误"></a>执行错误</h5><p>除了入队时可能发生错误以外，事务还可能在执行的过程中发生错误。关于这种错误有两个需要说明的地方：</p>
<ul>
<li>执行过程中发生的错误都是一些不能在入队时被服务器发现的错误，这些错误只会在命令实际执行时被触发。</li>
<li>即使在事务的执行过程中发生了错误，服务器也不会中断事务的执行，它会继续执行事务中余下的其他命令，并且已执行的命令（包括执行命令所产生的结果）不会被出错的命令影响。</li>
</ul>
<p>因为在事务执行的过程中，出错的命令会被服务器识别出来，并进行相应的错误处理，所以这些出错命令不会对数据库做任何修改，也不会对事务的一致性产生任何影响。</p>
<h5 id="服务器停机"><a href="#服务器停机" class="headerlink" title="服务器停机"></a>服务器停机</h5><p>如果Redis服务器在执行事务的过程中停机，那么根据服务器所使用的持久化模式，可能有以下情况出现：</p>
<ul>
<li>如果服务器运行在无持久化的内存模式下，那么重启之后的数据库将是空白的，因此数据总是一致的。</li>
<li>如果服务器运行在RDB模式下，那么在事务中途停机不会导致不一致性，因为服务器可以根据现有的RDB文件来恢复数据，从而将数据库还原到一个一致的状态。如果找不到可供使用的RDB文件，那么重启之后的数据库将是空白的，而空白数据库总是一致的。</li>
<li>如果服务器运行在AOF模式下，那么在事务中途停机不会导致不一致性，因为服务器可以根据现有的AOF文件来恢复数据，从而将数据库还原到一个一致的状态。如果找不到可供使用的AOF文件，那么重启之后的数据库将是空白的，而空白数据库总是一致的。</li>
</ul>
<p>综上所述，无论Redis服务器运行在哪种持久化模式下，事务执行中途发生的停机都不会影响数据库的一致性。</p>
<h4 id="隔离性"><a href="#隔离性" class="headerlink" title="隔离性"></a>隔离性</h4><p>事务的隔离性指的是，即使数据库中有多个事务并发地执行，各个事务之间也不会互相影响，并且在并发状态下执行的事务和串行执行的事务产生的结果完全相同。</p>
<p>因为Redis使用单线程的方式来执行事务（以及事务队列中的命令），并且服务器保证，在执行事务期间不会对事务进行中断，因此，Redis的事务总是以串行的方式运行的，并且事务也总是具有隔离性的。	</p>
<h4 id="耐久性"><a href="#耐久性" class="headerlink" title="耐久性"></a>耐久性</h4><p>事务的耐久性指的是，当一个事务执行完毕时，执行这个事务所得的结果已经被保存到永久性存储介质（比如硬盘）里面了，即使服务器在事务执行完毕之后停机，执行事务所得的结果也不会丢失。</p>
<p>因为Redis的事务不过是简单地用队列包裹起了一组Redis命令，Redis并没有为事务提供任何额外的持久化功能，所以Redis事务的耐久性由Redis所使用的持久化模式决定：</p>
<ul>
<li>当服务器在无持久化的内存模式下运作时，事务不具有耐久性：一旦服务器停机，包括事务数据在内的所有服务器数据都将丢失。</li>
<li>当服务器在RDB持久化模式下运作时，服务器只会在特定的保存条件被满足时，才会执行BGSAVE命令，对数据库进行保存操作，并且异步执行的BGSAVE不能保证事务数据被第一时间保存到硬盘里面，因此RDB持久化模式下的事务也不具有耐久性。</li>
<li>当服务器运行在AOF持久化模式下，并且appendfsync选项的值为always时，程序总会在执行命令之后调用同步（sync）函数，将命令数据真正地保存到硬盘里面，因此这种配置下的事务是具有耐久性的。</li>
<li>当服务器运行在AOF持久化模式下，并且appendfsync选项的值为everysec时，程序会每秒同步一次命令数据到硬盘。因为停机可能会恰好发生在等待同步的那一秒钟之内，这可能会造成事务数据丢失，所以这种配置下的事务不具有耐久性。</li>
<li>当服务器运行在AOF持久化模式下，并且appendfsync选项的值为no时，程序会交由操作系统来决定何时将命令数据同步到硬盘。因为事务数据可能在等待同步的过程中丢失，所以这种配置下的事务不具有耐久性。</li>
</ul>
<h2 id="Lua脚本"><a href="#Lua脚本" class="headerlink" title="Lua脚本"></a>Lua脚本</h2><p>Redis从2.6版本开始引入对Lua脚本的支持，通过在服务器中嵌入Lua环境，Redis客户端可以使用Lua脚本，直接在服务器端原子地执行多个Redis命令。</p>
<p>其中，使用EVAL命令可以直接对输入的脚本进行求值：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; EVAL &quot;return &#x27;hello world&#x27;&quot; 0</span><br><span class="line">&quot;hello world&quot;</span><br></pre></td></tr></table></figure>


<p>而使用EVALSHA命令则可以根据脚本的SHA1校验和来对脚本进行求值，但这个命令要求校验和对应的脚本必须至少被EVAL命令执行过一次：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; EVAL &quot;return 1+1&quot; 0</span><br><span class="line">(integer)2</span><br><span class="line">redis&gt; EVALSHA &quot;a27e7e8a43702b7046d4f6a7ccf5b60cef6b9bd9&quot; 0 //上一个脚本的校验和</span><br><span class="line">integer) 2</span><br></pre></td></tr></table></figure>


<p>或者这个校验和对应的脚本曾经被SCRIPT LOAD命令载入过：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SCRIPT LOAD &quot;return 2*2&quot;</span><br><span class="line">&quot;4475bfb5919b5ad16424cb5074d4724ae833e72&quot;</span><br><span class="line">redis&gt; EVALSHA &quot;4475bfb5919b5ad16424cb50f7464724ae833e72&quot; 0</span><br><span class="line">(integer) 4</span><br></pre></td></tr></table></figure>


<p>本章将对Redis服务器中与Lua脚本有关的各个部分进行介绍。</p>
<p>首先，本章将介绍Redis服务器初始化Lua环境的整个过程，说明Redis对Lua环境进行了哪些修改，而这些修改又对用户执行Lua脚本产生了什么影响和限制。</p>
<p>接着，本章将介绍与Lua环境进行协作的两个组件，它们分别是负责执行Lua脚本中包含Redis命令的伪客户端，以及负责保存传入服务器的Lua脚本的脚本字典。了解伪客户端可以知道脚本中的Redis命令在执行时，服务器与Lua环境的交互过程，而了解脚本字典则有助于理解SCRIPT EXISTS命令和脚本复制功能的实现原理。</p>
<p>在这之后，本章将介绍EVAL命令和EVALSHA命令的实现原理，说明Lua脚本在Redis服务器中是如何被执行的，并对管理脚本的四个命令——SCRIPT FLUSH命令、SCRIPT EXISTS命令、SCRIPT LOAD命令、SCRIPT KILL 命令的实现原理进行介绍。</p>
<p>最后，本章将以介绍Redis在主从服务器之间复制Lua脚本的方法作为本章的结束。</p>
<h3 id="创建并修改Lua环境"><a href="#创建并修改Lua环境" class="headerlink" title="创建并修改Lua环境"></a>创建并修改Lua环境</h3><p>为了在Redis服务器中执行Lua脚本，Redis在服务器内嵌了一个Lua环境（environ-ment），并对这个Lua环境进行了一系列修改，从而确保这个Lua环境可以满足Redis服务器的需要。<br>Redis服务器创建并修改Lua环境的整个过程由以下步骤组成：</p>
<ol>
<li>创建一个基础的Lua环境，之后的所有修改都是针对这个环境进行的。</li>
<li>载人多个函数库到Lua环境里面，让Lua脚本可以使用这些函数库来进行数据操作。</li>
<li>创建全局表格redis，这个表格包含了对Redis进行操作的函数，比如用于在Lua脚本中执行Redis命令的redis.call函数。</li>
<li>使用Redis自制的随机函数来替换Lua原有的带有副作用的随机函数，从而避免在脚本中引入副作用。</li>
<li>创建排序辅助函数，Lua环境使用这个辅佐函数来对一部分Redis命令的结果进行排序，从而消除这些命令的不确定性。</li>
<li>创建redis.pcall函数的错误报告辅助函数，这个函数可以提供更详细的出错信息。</li>
<li>对Lua环境中的全局环境进行保护，防止用户在执行Lua脚本的过程中，将额外的全局变量添加到Lua环境中。</li>
<li>将完成修改的Lua环境保存到服务器状态的lua属性中，等待执行服务器传来的Lua脚本。</li>
</ol>
<h4 id="创建Lua环境"><a href="#创建Lua环境" class="headerlink" title="创建Lua环境"></a>创建Lua环境</h4><p>在最开始的这一步，服务器首先调用Lua的CAPI函数lua_open，创建一个新的Lua环境。</p>
<p>因为lua_open函数创建的只是一个基本的Lua环境，为了让这个Lua环境可以满足Redis的操作要求，接下来服务器将对这个Lua环境进行一系列修改。</p>
<h4 id="载入函数库"><a href="#载入函数库" class="headerlink" title="载入函数库"></a>载入函数库</h4><p>Redis修改Lua环境的第一步，就是将以下函数库载入到Lua环境里面：</p>
<ul>
<li>基础库（base library）：这个库包含Lua的核心（core）函数，error、pairs、tostring、pcal等。另外，为了防止用户从外部文件中引入不安全的代码，库中的loadfile函数会被删除。</li>
<li>表格库（table library）：这个库包含用于处理表格的通用函数，比如table.concat、table.insert、table.remove、table.sort等。</li>
<li>字符串库（string library）：这个库包含用于处理字符串的通用函数，比如用于对字符串进行查找的string.find函数，对字符串进行格式化的string.format函数，查看字符串长度的string.len函数，对字符串进行翻转的string.reverse函数等。</li>
<li>数学库（math library）：这个库是标准C语言数学库的接口，它包括计算绝对值的math.abs函数，返回多个数中的最大值和最小值的math.max函数和math.min函数，计算二次方根的math.sqrt函数，计算对数的math.log函数等。</li>
<li>调试库（debug library）：这个库提供了对程序进行调试所需的函数，比如对程序设置钩子和取得钩子的debug.sethook函数和debug.gethook函数，返回给定函数相关信息的debug. getinfo函数，为对象设置元数据的debug.setmetatable函数，获取对象元数据的debug.getmetatable函数等。</li>
<li>Lua CJSON库：这个库用于处理UTF-8编码的JSON格式，其中cjson.decode函数将一个JSON格式的字符串转换为一个Lua值，而cjson.encode函数将一个Lua值序列化为JSON格式的字符串。</li>
<li>Struct库：这个库用于在Lua值和C结构（struct）之间进行转换，函数struct.pack将多个Lua值打包成一个类结构（struct-like）字符串，而函数struct.unpack则从一个类结构字符串中解包出多个Lua值。</li>
<li>Lua cmsgpack库：这个库用于处理MessagePack格式的数据，其中cmsgpack.pack 函数将Lua值转换为MessagePack数据，而cmsgpack.unpack函数则将MessagePack数据转换为Lua值。</li>
</ul>
<p>通过使用这些功能强大的函数库，Lua脚本可以直接对执行Redis命令获得的数据进行复杂的操作。</p>
<h4 id="创建redis全局表格"><a href="#创建redis全局表格" class="headerlink" title="创建redis全局表格"></a>创建redis全局表格</h4><p>在这一步，服务器将在Lua环境中创建一个redis表格（table），并将它设为全局变量。这个redis表格包含以下函数：</p>
<ul>
<li>用于执行Redis命令的redis.call和redis.pcall函数。</li>
<li>用于记录Redis日志（log）的redis.log函数，以及相应的日志级别（level）常量：redis.LOG_DEBUG，redis.LOG_VERBOSE，redis.LOG_NOTICE，以及redis.LOG_WARNING。</li>
<li>用于计算SHA1校验和的redis.sha1hex函数。</li>
<li>用于返回错误信息的redis.error_reply函数和redis.status_reply函数。</li>
</ul>
<p>在这些函数里面，最常用也最重要的要数redis.call函数和redis.pcall函数，通过这两个函数，用户可以直接在Lua脚本中执行Redis命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis &gt; EVAL &quot;return redis.call(&#x27;PING&#x27;)&quot; 0</span><br><span class="line">PONG</span><br></pre></td></tr></table></figure>

<h4 id="使用Redis自制的随机函数来替换Lua原有的随机函数"><a href="#使用Redis自制的随机函数来替换Lua原有的随机函数" class="headerlink" title="使用Redis自制的随机函数来替换Lua原有的随机函数"></a>使用Redis自制的随机函数来替换Lua原有的随机函数</h4><p>为了保证相同的脚本可以在不同的机器上产生相同的结果，Redis要求所有传入服务器的Lua脚本，以及Lua环境中的所有函数，都必须是无副作用（side effect）的纯函数（pure function）。</p>
<p>但是，在之前载入Lua环境的math函数库中，用于生成随机数的math.random函数和math.randomseed函数都是带有副作用的，它们不符合Redis对Lua环境的无副作用要求。</p>
<p>因为这个原因，Redis使用自制的函数替换了math库中原有的math.random函数和math.randomseed函数，替换之后的两个函数有以下特征：</p>
<ul>
<li>对于相同的seed来说，math.random总产生相同的随机数序列，这个函数是一个纯函数。</li>
<li>除非在脚本中使用math.randomseed显式地修改seed，否则每次运行脚本时，Lua环境都使用固定的math.randomseed(0)语句来初始化seed。</li>
</ul>
<h4 id="创建排序辅助函数"><a href="#创建排序辅助函数" class="headerlink" title="创建排序辅助函数"></a>创建排序辅助函数</h4><p>对于Lua脚本来说，另一个可能产生不一致数据的地方是那些带有不确定性质的命令。比如对于一个集合键来说，因为集合元素的排列是无序的，所以即使两个集合的元素完全相同，它们的输出结果也可能并不相同。</p>
<p>考虑下面这个集合例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SADD fruit apple banana cherry</span><br><span class="line">(integer) 3</span><br><span class="line"></span><br><span class="line">redis&gt; SMEMBERS fruit</span><br><span class="line">1) &quot;cherry&quot;</span><br><span class="line">2) &quot;banana&quot;</span><br><span class="line">3) &quot;apple&quot;</span><br><span class="line"></span><br><span class="line">redis&gt; SADD another-fruit cherry banana apple</span><br><span class="line">(integer) 3</span><br><span class="line"></span><br><span class="line">redis&gt; SMEMBERS another-fruit</span><br><span class="line">1) &quot;apple&quot;</span><br><span class="line">2) &quot;banana&quot;</span><br><span class="line">3) &quot;cherry&quot;</span><br></pre></td></tr></table></figure>

<p>这个例子中的fruit集合和another-fruit集合包含的元素是完全相同的，只是因为集合添加元素的顺序不同，SMEMBERS命令的输出就产生了不同的结果。</p>
<p>Redis将SMEMBERS这种在相同数据集上可能会产生不同输出的命令称为“带有不确定性的命令”，这些命令包括：</p>
<ul>
<li>SINTER</li>
<li>SUNION</li>
<li>SDIFF</li>
<li>SMEMBERS</li>
<li>HKEYS</li>
<li>HVALS</li>
<li>KEYS</li>
</ul>
<p>为了消除这些命令带来的不确定性，服务器会为Lua环境创建一个排序辅助函数__redis__compare_helper，当Lua脚本执行完一个带有不确定性的命令之后，程序会使用__redis__compare_helper作为对比函数，自动调用table.sort函数对命令的返回值做一次排序，以此来保证相同的数据集总是产生相同的输出。</p>
<p>举个例子，如果我们在Lua脚本中对fruit集合和another-fruit集合执行SMEMBERS命令，那么两个脚本将得出相同的结果，因为脚本已经对SMEMBERS命令的输出进行过排序了：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; EVAL &quot;return redis.call(&#x27;SMEMBERS&#x27;, KEYS[1])&quot; 1 fruit</span><br><span class="line">1）&quot;apple&quot;</span><br><span class="line">2) &quot;banana&quot;</span><br><span class="line">3) &quot;cherry&quot;</span><br><span class="line"></span><br><span class="line">redis&gt; EVAL &quot;return redis.call(&#x27;SMEMBERS&#x27;, KEYS[1])&quot; 1 another-fruit</span><br><span class="line">1) &quot;apple&quot;</span><br><span class="line">2) &quot;banana&quot;</span><br><span class="line">3) &quot;cherry&quot;</span><br></pre></td></tr></table></figure>

<h4 id="创建redis-pcall函数的错误报告辅助函数"><a href="#创建redis-pcall函数的错误报告辅助函数" class="headerlink" title="创建redis.pcall函数的错误报告辅助函数"></a>创建redis.pcall函数的错误报告辅助函数</h4><p>在这一步，服务器将为Lua环境创建一个名为__redis__err__handler的错误处理函数，当脚本调用redis.pcall函数执行Redis命令，并且被执行的命令出现错误时，__redis__err__handler就会打印出错代码的来源和发生错误的行数，为程序的调试提供方便。</p>
<h4 id="保护Lua的全局环境"><a href="#保护Lua的全局环境" class="headerlink" title="保护Lua的全局环境"></a>保护Lua的全局环境</h4><p>在这一步，服务器将对Lua环境中的全局环境进行保护，确保传入服务器的脚本不会因为忘记使用local关键字而将额外的全局变量添加到Lua环境里面。</p>
<p>不过Redis并未禁止用户修改已存在的全局变量，所以在执行Lua脚本的时候，必须非常小心，以免错误地修改了已存在的全局变量。</p>
<h4 id="将Lua环境保存到服务器状态的lua属性里面"><a href="#将Lua环境保存到服务器状态的lua属性里面" class="headerlink" title="将Lua环境保存到服务器状态的lua属性里面"></a>将Lua环境保存到服务器状态的lua属性里面</h4><p>经过以上的一系列修改，Redis服务器对Lua环境的修改工作到此就结束了，在最后的这一步，服务器会将Lua环境和服务器状态的lua属性关联起来。</p>
<p><img src="/..%5Cimg%5CRedis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%5C%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%8A%B6%E6%80%81%E4%B8%AD%E7%9A%84Lua%E7%8E%AF%E5%A2%83.png" alt="服务器状态中的Lua环境"></p>
<p>因为Redis使用串行化的方式来执行Redis命令，所以在任何特定时间里，最多都只会有一个脚本能够被放进Lua环境里面运行，因此，整个Redis服务器只需要创建一个Lua环境即可。</p>
<h3 id="Lua环境协作组件"><a href="#Lua环境协作组件" class="headerlink" title="Lua环境协作组件"></a>Lua环境协作组件</h3><p>除了创建并修改Lua环境之外，Redis服务器还创建了两个用于与Lua环境进行协作的组件，它们分别是负责执行Lua脚本中的Redis命令的伪客户端，以及用于保存Lua脚本的lua_scripts字典。</p>
<h4 id="伪客户端"><a href="#伪客户端" class="headerlink" title="伪客户端"></a>伪客户端</h4><p>因为执行Redis命令必须有相应的客户端状态，所以为了执行Lua脚本中包含的Redis命令，Redis服务器专门为Lua环境创建了一个伪客户端，并由这个伪客户端负责处理Lua脚本中包含的所有Redis命令。</p>
<p>Lua脚本使用redis.call函数或者redis.pcall函数执行一个Redis命令，需要完成以下步骤：</p>
<ol>
<li>Lua环境将redis.call函数或者redis.pcall函数想要执行的命令传给伪客户端。</li>
<li>伪客户端将脚本想要执行的命令传给命令执行器。</li>
<li>命令执行器执行伪客户端传给它的命令，并将命令的执行结果返回给伪客户端。</li>
<li>伪客户端接收命令执行器返回的命令结果，并将这个命令结果返回给Lua环境。</li>
<li>Lua环境在接收到命令结果之后，将该结果返回给redis.call函数或者redis.pcall函数。</li>
<li>接收到结果的redis.call函数或者redis.pcall函数会将命令结果作为函数返回值返回给脚本中的调用者。</li>
</ol>
<p><img src="/..%5Cimg%5CRedis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%5CLua%E8%84%9A%E6%9C%AC%E6%89%A7%E8%A1%8CRedis%E5%91%BD%E4%BB%A4%E6%97%B6%E7%9A%84%E9%80%9A%E4%BF%A1%E6%AD%A5%E9%AA%A4.png" alt="Lua脚本执行Redis命令时的通信步骤"></p>
<h4 id="lua-scripts字典"><a href="#lua-scripts字典" class="headerlink" title="lua_scripts字典"></a>lua_scripts字典</h4><p>除了伪客户端之外，Redis服务器为Lua环境创建的另一个协作组件是lua_scripts字典，这个字典的键为某个Lua脚本的SHA1校验和（checksum），而字典的值则是SHA1校验和对应的Lua脚本：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span> &#123;</span></span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">	dict *lua_scripts;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<p>Redis服务器会将所有被EVAL命令执行过的Lua脚本，以及所有被SCRIPT LOAD命令载入过的Lua脚本都保存到lua_scripts 字典里面。</p>
<p>lua_scripts字典有两个作用，一个是实现SCRIPT EXISTS命令，另一个是实现脚本复制功能。</p>
<h3 id="EVAL命令的实现"><a href="#EVAL命令的实现" class="headerlink" title="EVAL命令的实现"></a>EVAL命令的实现</h3><p>EVAL命令的执行过程可以分为以下三个步骤：</p>
<ol>
<li>根据客户端给定的Lua脚本，在 Lua环境中定义一个Lua函数。</li>
<li>将客户端给定的脚本保存到lua_scripts字典，等待将来进一步使用。</li>
<li>执行刚刚在Lua环境中定义的函数，以此来执行客户端给定的Lua脚本。</li>
</ol>
<p>以下三个小节将以：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; EVAL &quot;return &#x27;hello world&#x27;&quot; 0</span><br><span class="line">&quot;hello world&quot;</span><br></pre></td></tr></table></figure>


<p>命令为示例，分别介绍EVAL命令执行的三个步骤。</p>
<h4 id="定义脚本函数"><a href="#定义脚本函数" class="headerlink" title="定义脚本函数"></a>定义脚本函数</h4><p>当客户端向服务器发送EVAL命令，要求执行某个Lua脚本的时候，服务器首先要做的就是在Lua环境中，为传入的脚本定义一个与这个脚本相对应的Lua函数，其中，Lua函数的名字由f_前缀加上脚本的SHA1校验和（四十个字符长）组成，而函数的体（body）则是脚本本身。<br>举个例子，对于命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EVAL &quot;return &#x27;hello world&#x27;&quot; 0</span><br></pre></td></tr></table></figure>


<p>来说，服务器将在Lua环境中定义以下函数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function f_5332031c6b470dc5a0dd9b4bf2030dea6d65de91()</span><br><span class="line">	return &#x27;hello world&#x27;</span><br><span class="line">end</span><br></pre></td></tr></table></figure>


<p>因为客户端传入的脚本为return ‘hello world ‘，而这个脚本的SHA1校验和为5332031c6b470dc5a0dd9b4bf2030dea6d65de91，所以函数的名字为f_5332031c6b470dc5a0dd9b4bf2030dea6d65de91，而函数的体则为return ‘hello world ‘。</p>
<p>使用函数来保存客户端传入的脚本有以下好处：</p>
<ul>
<li>执行脚本的步骤非常简单，只要调用与脚本相对应的函数即可。</li>
<li>通过函数的局部性来让Lua环境保持清洁，减少了垃圾回收的工作量，并且避免了使用全局变量。</li>
<li>如果某个脚本所对应的函数在Lua环境中被定义过至少一次，那么只要记得这个脚本的SHA1校验和，服务器就可以在不知道脚本本身的情况下，直接通过调用Lua函数来执行脚本，这是EVALSHA命令的实现原理。</li>
</ul>
<h4 id="将脚本保存到lua-scripts字典"><a href="#将脚本保存到lua-scripts字典" class="headerlink" title="将脚本保存到lua_scripts字典"></a>将脚本保存到lua_scripts字典</h4><p>EVAL命令要做的第二件事是将客户端传入的脚本保存到服务器的lua_scripts字典里面。举个例子，对于命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EVAL &quot;return &#x27;hello worid&#x27;&quot; 0</span><br></pre></td></tr></table></figure>


<p>来说，服务器将在lua_scripts字典中新添加一个键值对，其中键为Lua脚本的SHA1校验和：</p>
<p>5332031c6b470dc5a0dd9b4bf2030dea6d65de91</p>
<p>而值则为Lua脚本本身：</p>
<p>return ‘hello world’</p>
<h4 id="执行脚本函数"><a href="#执行脚本函数" class="headerlink" title="执行脚本函数"></a>执行脚本函数</h4><p>在为脚本定义函数，并且将脚本保存到lua_scripts字典之后，服务器还需要进行一些设置钩子、传入参数之类的准备动作，才能正式开始执行脚本。</p>
<p>整个准备和执行脚本的过程如下：</p>
<ol>
<li>将EVAL命令中传入的键名（key name）参数和脚本参数分别保存到KEYS数组和ARGV数组，然后将这两个数组作为全局变量传入到Lua环境里面。</li>
<li>为Lua环境装载超时处理钩子（hook），这个钩子可以在脚本出现超时运行情况时，让客户端通过SCRIPT KILL命令停止脚本，或者通过SHUTDOWN命令直接关闭服务器。</li>
<li>执行脚本函数。</li>
<li>移除之前装载的超时钩子。</li>
<li>将执行脚本函数所得的结果保存到客户端状态的输出缓冲区里面，等待服务器将结果返回给客户端。</li>
<li>对Lua环境执行垃圾回收操作。</li>
</ol>
<h3 id="EVALSHA命令的实现"><a href="#EVALSHA命令的实现" class="headerlink" title="EVALSHA命令的实现"></a>EVALSHA命令的实现</h3><p>本章前面介绍EVAL命令的实现时说过，每个被EVAL命令成功执行过的Lua脚本，在Lua环境里面都有一个与这个脚本相对应的Lua函数，函数的名字由f_前缀加上40个字符长的SHA1校验和组成，例如f_5332031c6b470dc5a0dd9b4bf2030dea6d65de91。</p>
<p>只要脚本对应的函数曾经在Lua环境里面定义过，那么即使不知道脚本的内容本身，客户端也可以根据脚本的SHA1校验和来调用脚本对应的函数，从而达到执行脚本的目的，这就是EVALSHA命令的实现原理。</p>
<p>可以用伪代码来描述这一原理：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">def EVALSHA(sha1):</span><br><span class="line">	#拼接出函数的名字</span><br><span class="line">	#例如:f_5332031c6b470dc5a0dd9b4bf2030dea6d65de91func name = &quot;f_&quot;+ sha1</span><br><span class="line">	#查看这个函数在Lua环境中是否存在</span><br><span class="line">	if function_exists_in_lua_env(func_name):</span><br><span class="line">		#如果函数存在，那么执行它</span><br><span class="line">		execute_lua_function(func_name)</span><br><span class="line">	else:</span><br><span class="line">		#如果函数不存在，那么返回一个错误</span><br><span class="line">		send_script_error(&quot;SCRIPT NOT FOUND&quot;)</span><br></pre></td></tr></table></figure>

<h3 id="脚本管理命令的实现"><a href="#脚本管理命令的实现" class="headerlink" title="脚本管理命令的实现"></a>脚本管理命令的实现</h3><p>除了EVAL命令和EVALSHA命令之外，Redis中与Lua脚本有关的命令还有四个，它们分别是SCRIPT FLUSH命令、SCRIPT EXISTS命令、SCRIPT LOAD命令、以及SCRIPT KILL命令。</p>
<h4 id="SCRIPT-FLUSH"><a href="#SCRIPT-FLUSH" class="headerlink" title="SCRIPT FLUSH"></a>SCRIPT FLUSH</h4><p>SCRIPT FLUSH命令用于清除服务器中所有和Lua脚本有关的信息，这个命令会释放并重建lua_scripts字典，关闭现有的Lua环境并重新创建一个新的Lua环境。</p>
<p>以下为SCRIPT FLUSH命令的实现伪代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">def SCRIPT_FLUSH():</span><br><span class="line">	#释放脚本字典</span><br><span class="line">	dictRelease(server.lua_scripts)</span><br><span class="line">	#重建脚本字典</span><br><span class="line">	server.lua_scripts = dictCreate(...)</span><br><span class="line">	#关闭Lua环境</span><br><span class="line">	lua_close(server.lua)</span><br><span class="line">	#初始化一个新的Lua环境</span><br><span class="line">	server.lua = init_lua_env()</span><br></pre></td></tr></table></figure>

<h4 id="SCRIPT-EXISTS"><a href="#SCRIPT-EXISTS" class="headerlink" title="SCRIPT EXISTS"></a>SCRIPT EXISTS</h4><p>SCRIPT EXISTS命令根据输入的SHA1校验和，检查校验和对应的脚本是否存在于服务器中。</p>
<p>SCRIPT EXISTS命令是通过检查给定的校验和是否存在于lua_scripts字典来实现的，以下是该命令的实现伪代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">def SCRIPT_EXISTS(*sha1_list):</span><br><span class="line">	#结果列表</span><br><span class="line">	result_list = []</span><br><span class="line">	#遍历输入的所有SHA1校验和</span><br><span class="line">	for sha1 in sha1_list:</span><br><span class="line">		#检查校验和是否为lua_scripts字典的键</span><br><span class="line">		#如果是的话，那么表示校验和对应的脚本存在</span><br><span class="line">		#否则的话，脚本就不存在</span><br><span class="line">		if sha1 in server.lua_scripts:</span><br><span class="line">			#存在用1表示</span><br><span class="line">			result_list.append(1)</span><br><span class="line">		else:</span><br><span class="line">			#不存在用0表示</span><br><span class="line">			result_list.append(0)</span><br><span class="line">	#向客户端返回结果列表</span><br><span class="line">	send_list_reply(result_list)</span><br></pre></td></tr></table></figure>

<p>实现SCRIPT EXISTS实际上并不需要lua_scripts字典的值。如果lua_scripts字典只用于实现SCRIPT EXISTS命令的话，那么字典只需要保存Lua脚本的SHA1校验和就可以了，并不需要保存Lua脚本本身。lua_scripts字典既保存脚本的SHA1校验和，又保存脚本本身的原因是为了实现脚本复制功能。</p>
<h4 id="SCRIPT-LOAD"><a href="#SCRIPT-LOAD" class="headerlink" title="SCRIPT LOAD"></a>SCRIPT LOAD</h4><p>SCRIPT LOAD命令所做的事情和EVAL命令执行脚本时所做的前两步完全一样：命令首先在Lua环境中为脚本创建相对应的函数，然后再将脚本保存到lua_scripts字典里面。完成了这些步骤之后，客户端就可以使用EVALSHA命令来执行前面被SCRIPT LOAD命令载入的脚本了。</p>
<h4 id="SCRIPT-KILL"><a href="#SCRIPT-KILL" class="headerlink" title="SCRIPT KILL"></a>SCRIPT KILL</h4><p>如果服务器设置了lua-time-limit配置选项，那么在每次执行Lua脚本之前，服务器都会在Lua环境里面设置一个超时处理钩子（hook）。</p>
<p>超时处理钩子在脚本运行期间，会定期检查脚本已经运行了多长时间，一旦钩子发现脚本的运行时间已经超过了lua-time-limit选项设置的时长，钩子将定期在脚本运行的间隙中，查看是否有SCRIPT KILL命令或者SHUTDOWN命令到达服务器。</p>
<p>如果超时运行的脚本未执行过任何写入操作，那么客户端可以通过SCRIPTKILL命令来指示服务器停止执行这个脚本，并向执行该脚本的客户端发送一个错误回复。处理完SCRIPT KILL命令之后，服务器可以继续运行。</p>
<p>另一方面，如果脚本已经执行过写入操作，那么客户端只能用SHUTDOWN nosave命令来停止服务器，从而防止不合法的数据被写入数据库中。</p>
<h3 id="脚本复制"><a href="#脚本复制" class="headerlink" title="脚本复制"></a>脚本复制</h3><p>与其他普通Redis命令一样，当服务器运行在复制模式之下时，具有写性质的脚本命令也会被复制到从服务器，这些命令包括EVAL命令、EVALSHA命令、SCRIPT FLUSH命令，以及SCRIPT LOAD命令。</p>
<h4 id="复制EVAL命令、SCRIPT-FLUSH命令和SCRIPT-LOAD命令"><a href="#复制EVAL命令、SCRIPT-FLUSH命令和SCRIPT-LOAD命令" class="headerlink" title="复制EVAL命令、SCRIPT FLUSH命令和SCRIPT LOAD命令"></a>复制EVAL命令、SCRIPT FLUSH命令和SCRIPT LOAD命令</h4><p>Redis复制EVAL、SCRIPT FLUSH、SCRIPT LOAD三个命令的方法和复制其他普通Redis命令的方法一样，当主服务器执行完以上三个命令的其中一个时，主服务器会直接将被执行的命令传播（propagate）给所有从服务器，如下图所示。</p>
<p><img src="/..%5Cimg%5CRedis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%5C%E5%B0%86%E8%84%9A%E6%9C%AC%E5%91%BD%E4%BB%A4%E4%BC%A0%E6%92%AD%E7%BB%99%E4%BB%8E%E6%9C%8D%E5%8A%A1%E5%99%A8.png" alt="将脚本命令传播给从服务器"></p>
<h5 id="EVAL"><a href="#EVAL" class="headerlink" title="EVAL"></a>EVAL</h5><p>对于EVAL命令来说，在主服务器执行的Lua脚本同样会在所有从服务器中执行。</p>
<p>主服务器在执行这个EVAL命令之后，将向所有从服务器传播这条EVAL命令，从服务器会接收并执行这条EVAL命令，最终结果是，主从服务器双方都会执行该脚本并将脚本保存在脚本字典里面。</p>
<h5 id="SCRIPT-FLUSH-1"><a href="#SCRIPT-FLUSH-1" class="headerlink" title="SCRIPT FLUSH"></a>SCRIPT FLUSH</h5><p>如果客户端向主服务器发送SCRIPT FLUSH命令，那么主服务器也会向所有从服务器传播SCRIPT FLUSH命令。<br>最终的结果是，主从服务器双方都会重置自己的Lua环境，并清空自己的脚本字典。</p>
<h5 id="SCRIPT-LOAD-1"><a href="#SCRIPT-LOAD-1" class="headerlink" title="SCRIPT LOAD"></a>SCRIPT LOAD</h5><p>如果客户端使用SCRIPT LOAD命令，向主服务器载人一个Lua脚本，那么主服务器将向所有从服务器传播相同的SCRIPTLOAD命令，使得所有从服务器也会载人相同的Lua脚本。</p>
<p>最终的结果是，主从服务器双方都会载入脚本。</p>
<h4 id="复制EVALSHA命令"><a href="#复制EVALSHA命令" class="headerlink" title="复制EVALSHA命令"></a>复制EVALSHA命令</h4><p>EVALSHA命令是所有与Lua脚本有关的命令中，复制操作最复杂的一个，因为主服务器与从服务器载入Lua脚本的情况可能有所不同，所以主服务器不能像复制EVAL命令、SCRIPT LOAD命令或者SCRIPT FLUSH命令那样，直接将EVALSHA命令传播给从服务器。对于一个在主服务器被成功执行的EVALSHA命令来说，相同的EVALSHA命令在从服务器执行时却可能会出现脚本未找到（not found）错误。</p>
<p>举个例子，假设现在有一个主服务器master，如果客户端向主服务器发送命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">master&gt; SCRIPT LOAD &quot;return &#x27;hello world&#x27;&quot;</span><br><span class="line">&quot;5332031c6b470dc5a0dd9b4bf2030dea6d65de91&quot;</span><br></pre></td></tr></table></figure>


<p>那么在执行这个SCRIPT LOAD命令之后，SHA1值为5332031c6b470dc5a0dd9b4bf2030dea6d65de91的脚本就存在于主服务器中了。</p>
<p>现在，假设一个从服务器slave1开始复制主服务器master，如果master不想办法将脚本：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;return &#x27;hello world&#x27;&quot;</span><br></pre></td></tr></table></figure>


<p>传送给slave1载入的话，那么当客户端向主服务器发送命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">master&gt; EVALSHA &quot;5332031c6b470dc5a0dd9b4bf2030dea6d65de91&quot; 0</span><br><span class="line">&quot;hello world&quot;</span><br></pre></td></tr></table></figure>


<p>的时候，master将成功执行这个EVALSHA命令，而当master将这个命令传播给slave1执行的时候，slave1却会出现脚本未找到错误：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">slave1&gt; EVALSHA &quot;5332031c6b470dc5a0dd9b4bf2030dea6d65de91&quot; 0</span><br><span class="line">(error) NOSCRIPT No matching script. Please use EVAL.</span><br></pre></td></tr></table></figure>


<p>更为复杂的是，因为多个从服务器之间载入Lua脚本的情况也可能各有不同，所以即使一个 EVALSHA命令可以在某个从服务器成功执行，也不代表这个EVALSHA命令就一定可以在另一个从服务器成功执行。</p>
<p>举个例子，假设有主服务器master和从服务器slave1，并且slave1一直复制着master，所以master载入的所有Lua脚本，slave1也有载入（通过传播EVAL命令或者SCRIPT LOAD命令来实现)。</p>
<p>例如说，如果客户端向master发送命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">master&gt; SCRIPT LOAD &quot;return &#x27;hello world&#x27;&quot;</span><br><span class="line">&quot;5332031c6b470dc5a0dd9b4bf2030dea6d65de91&quot;</span><br></pre></td></tr></table></figure>


<p>那么这个命令也会被传播到slave1上面，所以master和slave1都会成功载人SHA1校验和为5332031c6b470dc5a0dd9b4bf2030dea6d65de91的Lua脚本。</p>
<p>如果这时，一个新的从服务器slave2开始复制主服务器master，如果master不想办法将脚本：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;return &#x27;hello world&#x27;&quot;</span><br></pre></td></tr></table></figure>


<p>传送给slave2的话，那么当客户端向主服务器发送命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">master&gt; EVALSHA &quot;5332031c6b470dc5a0dd9b4bf2030dea6d65de91&quot; 0</span><br><span class="line">&quot;hello world&quot;</span><br></pre></td></tr></table></figure>


<p>的时候，master和slave1都将成功执行这个EVALSHA命令，而slave2却会发生脚本未找到错误。</p>
<p>为了防止以上假设的情况出现，Redis要求主服务器在传播EVALSHA命令的时候，必须确保EVALSHA命令要执行的脚本已经被所有从服务器载入过，如果不能确保这一点的话，主服务器会将EVALSHA命令转换成一个等价的EVAL命令，然后通过传播EVAL命令来代替EVALSHA命令。</p>
<p>传播EVALSHA命令，或者将EVALSHA命令转换成EVAL命令，都需要用到服务器状态的lua_scripts字典和repl_scriptcache_dict字典。</p>
<h5 id="判断传播EVALSHA命令是否安全的方法"><a href="#判断传播EVALSHA命令是否安全的方法" class="headerlink" title="判断传播EVALSHA命令是否安全的方法"></a>判断传播EVALSHA命令是否安全的方法</h5><p>主服务器使用服务器状态的repl_scriptcache_dict字典记录自己已经将哪些脚本传播给了所有从服务器：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span> &#123;</span></span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">	dict *repl_scriptcache_dict;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<p>repl_scriptcache_dict字典的键是一个个Lua脚本的SHA1校验和，而字典的值则全部都是NULL，当一个校验和出现在repl_scriptcache_dict字典时，说明这个校验和对应的Lua脚本已经传播给了所有从服务器，主服务器可以直接向从服务器传播包含这个SHA1校验和的EVALSHA命令，而不必担心从服务器会出现脚本未找到错误。</p>
<p>另一方面，如果一个脚本的SHA1校验和存在于lua_scripts字典，但是却不存在于repl_scriptcache_dict字典，那么说明校验和对应的Lua脚本已经被主服务器载人，但是并没有传播给所有从服务器，如果我们尝试向从服务器传播包含这个SHA1校验和的EVALSHA命令，那么至少有一个从服务器会出现脚本未找到错误。</p>
<h5 id="清空repl-scriptcache-dict字典"><a href="#清空repl-scriptcache-dict字典" class="headerlink" title="清空repl_scriptcache_dict字典"></a>清空repl_scriptcache_dict字典</h5><p>每当主服务器添加一个新的从服务器时，主服务器都会清空自己的repl_scriptcache_dict字典，这是因为随着新从服务器的出现，repl_scriptcache_dict字典里面记录的脚本已经不再被所有从服务器载入过，所以主服务器会清空repl_scriptcache_dict字典，强制自己重新向所有从服务器传播脚本，从而确保新的从服务器不会出现脚本未找到错误。</p>
<h5 id="EVALSHA命令转换成EVAL命令的方法"><a href="#EVALSHA命令转换成EVAL命令的方法" class="headerlink" title="EVALSHA命令转换成EVAL命令的方法"></a>EVALSHA命令转换成EVAL命令的方法</h5><p>通过使用EVALSHA命令指定的SHA1校验和，以及lua_scripts字典保存的Lua脚本，服务器总可以将一个EVALSHA命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EVALSHA &lt;sha1&gt; &lt;numkeys&gt; [key...] [arg...]</span><br></pre></td></tr></table></figure>


<p>转换成一个等价的EVAL命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EVAL &lt;script&gt; &lt;numkeys&gt; [key...] [arg...]</span><br></pre></td></tr></table></figure>

<p>具体的转换方法如下：</p>
<ol>
<li>根据SHA1校验和sha1，在lua_scripts字典中查找sha1对应的Lua脚本script。</li>
<li>将原来的EVALSHA命令请求改写成EVAL命令请求，并且将校验和sha1改成脚本script，至于numkeys、key、arg等参数则保持不变。</li>
</ol>
<p>如果一个SHA1值所对应的Lua脚本没有被所有从服务器载入过，那么主服务器可以将EVALSHA命令转换成等价的EVAL命令，然后通过传播等价的EVAL命令来代替原本想要传播的EVALSHA命令，以此来产生相同的脚本执行效果，并确保所有从服务器都不会出现脚本未找到错误。</p>
<p>另外，因为主服务器在传播完EVAL命令之后，会将被传播脚本的SHA1校验和（也即是原本EVALSHA命令指定的那个校验和）添加到repl_scriptcache_dict字典里面，如果之后EVALSHA命令再次指定这个SHA1校验和，主服务器就可以直接传播EVALSHA命令，而不必再次对EVALSHA命令进行转换。</p>
<h5 id="传播EVALSHA命令的方法"><a href="#传播EVALSHA命令的方法" class="headerlink" title="传播EVALSHA命令的方法"></a>传播EVALSHA命令的方法</h5><p>当主服务器成功在本机执行完一个EVALSHA命令之后，它将根据EVALSHA命令指定的SHA1校验和是否存在于repl_scriptcache_dict字典来决定是向从服务器传播EVALSHA命令还是EVAL命令：</p>
<ol>
<li>如果EVALSHA命令指定的SHA1校验和存在于repl_scriptcache_dict字典，那么主服务器直接向从服务器传播EVALSHA命令。</li>
<li>如果EVALSHA命令指定的SHA1校验和不存在于repl_scriptcache_dict字典，那么主服务器会将EVALSHA命令转换成等价的EVAL命令，然后传播这个等价的EVAL命令，并将EVALSHA命令指定的SHA1校验和添加到repl_scriptcache_dict字典里面。</li>
</ol>
<p><img src="/..%5Cimg%5CRedis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%5C%E4%B8%BB%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%88%A4%E6%96%AD%E4%BC%A0%E6%92%ADEVAL%E8%BF%98%E6%98%AFEVALSHA%E7%9A%84%E8%BF%87%E7%A8%8B.png" alt="主服务器判断传播EVAL还是EVALSHA的过程"></p>
<h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><p>Redis的SORT命令可以对列表键、集合键或者有序集合键的值进行排序。</p>
<h3 id="SORT-lt-key-gt-命令的实现"><a href="#SORT-lt-key-gt-命令的实现" class="headerlink" title="SORT &lt;key&gt;命令的实现"></a>SORT &lt;key&gt;命令的实现</h3><p>SORT命令的最简单执行形式为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SORT &lt;key&gt;</span><br></pre></td></tr></table></figure>


<p>这个命令可以对一个包含数字值的键key进行排序。</p>
<p>以下示例展示了如何使用SORT命令对一个包含三个数字值的列表键进行排序：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; RPUSH numbers 3 1 2</span><br><span class="line">(integer) 3</span><br><span class="line"></span><br><span class="line">redis&gt; SORT numbers</span><br><span class="line">1) &quot;1&quot;</span><br><span class="line">2) &quot;2&quot;</span><br><span class="line">3) &quot;3&quot;</span><br></pre></td></tr></table></figure>

<p>服务器执行SORT numbers命令的详细步骤如下：</p>
<ol>
<li>创建一个和numbers列表长度相同的数组，该数组的每个项都是一个redis.h&#x2F;redissortObject结构，如图21-1所示。</li>
<li>遍历数组，将各个数组项的obj指针分别指向numbers列表的各个项，构成obj指针和列表项之间的一对一关系，如图21-2所示。</li>
<li>遍历数组，将各个obj指针所指向的列表项转换成一个double类型的浮点数，并将这个浮点数保存在相应数组项的u.score属性里面，如图21-3所示。</li>
<li>根据数组项u.score属性的值，对数组进行数字值排序，排序后的数组项按u.score属性的值从小到大排列，如图21-4所示。</li>
<li>遍历数组，将各个数组项的obj指针所指向的列表项作为排序结果返回给客户端，程序首先访问数组的索引0，返回u.score值为1.0的列表项”1”；然后访问数组的索引1，返回u.score值为2.0的列表项”2”；最后访问数组的索引2，返回u.score值为3.0的列表项”3”。</li>
</ol>
<p>其他sORT <key>命令的执行步骤也和这里给出的SORT numbers命令的执行步骤类似。</p>
<p><img src="/..%5Cimg%5CRedis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%5CredisSortObject%E6%95%B0%E7%BB%84.png" alt="redisSortObject数组.png"></p>
<p><img src="/..%5Cimg%5CRedis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%5C%E5%B0%86obj%E6%8C%87%E9%92%88%E6%8C%87%E5%90%91%E5%88%97%E8%A1%A8%E7%9A%84%E5%90%84%E4%B8%AA%E9%A1%B9.png" alt="将obj指针指向列表的各个项.png"></p>
<p><img src="/..%5Cimg%5CRedis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%5C%E8%AE%BE%E7%BD%AE%E6%95%B0%E7%BB%84%E9%A1%B9%E7%9A%84u.score%E5%B1%9E%E6%80%A7.png" alt="设置数组项的u.score属性"></p>
<p><img src="/..%5Cimg%5CRedis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%5C%E6%8E%92%E5%BA%8F%E5%90%8E%E7%9A%84%E6%95%B0%E7%BB%84.png" alt="排序后的数组"></p>
<p>以下是redisSortObject结构的完整定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">redisSortObject</span> &#123;</span></span><br><span class="line">	<span class="comment">//被排序键的值</span></span><br><span class="line">	robj *obj;</span><br><span class="line">	<span class="comment">//权重</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">		<span class="comment">//排序数字值时使用</span></span><br><span class="line">        <span class="type">double</span> score;</span><br><span class="line">		<span class="comment">//排序带有BY选项的字符串值时使用</span></span><br><span class="line">        robj *cmpobj;</span><br><span class="line">	&#125; u;</span><br><span class="line">&#125; redisSortObject;</span><br></pre></td></tr></table></figure>


<p>SORT命令为每个被排序的键都创建一个与键长度相同的数组，数组的每个项都是一个redisSortObject结构，根据SORT命令使用的选项不同，程序使用redisSortObject结构的方式也不同。</p>
<h3 id="ALPHA选项的实现"><a href="#ALPHA选项的实现" class="headerlink" title="ALPHA选项的实现"></a>ALPHA选项的实现</h3><p>通过使用ALPHA选项，SORT命令可以对包含字符串值的键进行排序：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SORT &lt;key&gt; ALPHA</span><br></pre></td></tr></table></figure>

<p>以下命令展示了如何使用SORT命令对一个包含三个字符串值的集合键进行排序：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SADD fruits apple banana cherry</span><br><span class="line">(integer) 3</span><br><span class="line"></span><br><span class="line">#元素在集合中是乱序存放的</span><br><span class="line">redis&gt; SMEMBERS fruits</span><br><span class="line">1) &quot;apple&quot;</span><br><span class="line">2) &quot;cherry&quot;</span><br><span class="line">3) &quot;banana&quot;</span><br><span class="line"></span><br><span class="line">#对fruits键进行字符串排序</span><br><span class="line">redis&gt; SORT fruits ALPHA</span><br><span class="line">1) &quot;apple&quot;</span><br><span class="line">2) &quot;banana&quot;</span><br><span class="line">3) &quot;cherry&quot;</span><br></pre></td></tr></table></figure>

<p>服务器执行SORT fruits ALPHA命令的详细步骤如下：</p>
<ol>
<li>创建一个redisSortObject结构数组，数组的长度等于fruits集合的大小。</li>
<li>遍历数组，将各个数组项的obj指针分别指向fruits集合的各个元素，如图21-5所示。</li>
<li>根据obj指针所指向的集合元素，对数组进行字符串排序，排序后的数组项按集合元素的字符串值从小到大排列：因为”apple”、”banana”、 “cherry”三个字符串的大小顺序为”apple”&lt;”banana”&lt;”cherry”，所以排序后数组的第一项指向”apple”元素，第二项指向”banana”元素，第三项指向”cherry”元素，如图21-6所示。</li>
<li>遍历数组，依次将数组项的obj指针所指向的元素返回给客户端。</li>
</ol>
<p>其他SORT &lt;key&gt; ALPHA命令的执行步骤也和这里给出的SORT fruits ALPHA命令的执行步骤类似。</p>
<p>![sort alpha示例](..\img\Redis设计与实现\sort alpha示例.png)</p>
<h3 id="ASC选项和DESC选项"><a href="#ASC选项和DESC选项" class="headerlink" title="ASC选项和DESC选项"></a>ASC选项和DESC选项</h3><p>在默认情况下，SORT命令执行升序排序，排序后的结果按值的大小从小到大排列，以下两个命令是完全等价的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SORT &lt;key&gt;</span><br><span class="line">SORT &lt;key&gt; ASC</span><br></pre></td></tr></table></figure>


<p>相反地，在执行SORT命令时使用DESC选项，可以让命令执行降序排序，让排序后的结果按值的大小从大到小排列：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SORT &lt;key&gt; DESC</span><br></pre></td></tr></table></figure>

<p>升序排序和降序排序都由相同的快速排序算法执行，它们之间的不同之处在于：</p>
<ul>
<li>在执行升序排序时，排序算法使用的对比函数产生升序对比结果。</li>
<li>而在执行降序排序时，排序算法所使用的对比函数产生降序对比结果。</li>
</ul>
<p>因为升序对比和降序对比的结果正好相反，所以它们会产生元素排列方式正好相反的两种排序结果。</p>
<h3 id="BY选项的实现"><a href="#BY选项的实现" class="headerlink" title="BY选项的实现"></a>BY选项的实现</h3><p>在默认情况下，SORT命令使用被排序键包含的元素作为排序的权重，元素本身决定了元素在排序之后所处的位置。</p>
<p>例如，在下面这个例子里面，排序fruits集合所使用的权重就是”apple”、”banana”、”cherry”三个元素本身：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SADD fruits &quot;apple&quot; &quot;banana&quot; &quot;cherry&quot;</span><br><span class="line">(integer) 3</span><br><span class="line">redis&gt; SORT fruits ALPHA</span><br><span class="line">1) &quot;apple&quot;</span><br><span class="line">2) &quot;banana&quot;</span><br><span class="line">3) &quot;cherry&quot;</span><br></pre></td></tr></table></figure>


<p>另一方面，通过使用BY选项，SORT命令可以指定某些字符串键或者某个哈希键所包含的某些域（field）来作为元素的权重，对一个键进行排序。</p>
<p>例如，以下这个例子就使用苹果、香蕉、樱桃三种水果的价钱，对集合键fruits进行了排序：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; MSET apple-price 8 banana-price 5.5 cherry-price 7</span><br><span class="line">OK</span><br><span class="line">redis&gt; SORT fruits BY *-price</span><br><span class="line">1) &quot;banana&quot;</span><br><span class="line">2) &quot;cherry”</span><br><span class="line">3) &quot;apple&quot;</span><br></pre></td></tr></table></figure>

<p>服务器执行SORT fruits BY *-price命令的详细步骤如下：</p>
<ol>
<li>创建一个redisSortObject结构数组，数组的长度等于fruits集合的大小。</li>
<li>遍历数组，将各个数组项的obj指针分别指向fruits集合的各个元素，如图21-9所示。</li>
<li>遍历数组，根据各个数组项的obj指针所指向的集合元素，以及BY选项所给定的模式*-price，查找相应的权重键：<ul>
<li>对于”apple”元素，查找程序返回权重键”apple-price”。</li>
<li>对于”banana”元素，查找程序返回权重键”banana-price”。</li>
<li>对于”cherry”元素，查找程序返回权重键”cherry-price”。</li>
</ul>
</li>
<li>将各个权重键的值转换成一个double类型的浮点数，然后保存在相应数组项的u.score属性里面，如图21-10所示：<ul>
<li>“apple”元素的权重键”apple-price”的值转换之后为8.0。</li>
<li>“banana”元素的权重键”banana-price”的值转换之后为5.5。</li>
<li>“cherry”元素的权重键”cherry-price”的值转换之后为7.0。</li>
</ul>
</li>
<li>以数组项u.score属性的值为权重，对数组进行排序，得到一个按u.score属性的值从小到大排序的数组,如图21-11所示：<ul>
<li>权重为5.5的”banana”元素位于数组的索引0位置上。</li>
<li>权重为7.0的”cherry”元素位于数组的索引1位置上。</li>
<li>权重为8.0的”apple”元素位于数组的索引2位置上。</li>
</ul>
</li>
<li>遍历数组，依次将数组项的obj指针所指向的集合元素返回给客户端。</li>
</ol>
<p>其他SORT &lt;key&gt; BY &lt;pattern&gt;命令的执行步骤也和这里给出的步骤类似。</p>
<p><img src="/..%5Cimg%5CRedis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%5CBY%E6%8E%92%E5%BA%8F%EF%BC%881%EF%BC%89.png" alt="BY排序（1）"></p>
<p><img src="/..%5Cimg%5CRedis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%5CBY%E6%8E%92%E5%BA%8F%EF%BC%882%EF%BC%89.png" alt="BY排序（2）"></p>
<p><img src="/..%5Cimg%5CRedis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%5CBY%E6%8E%92%E5%BA%8F%EF%BC%883%EF%BC%89.png" alt="BY排序（3）"></p>
<h3 id="带有ALPHA选项的BY选项的实现"><a href="#带有ALPHA选项的BY选项的实现" class="headerlink" title="带有ALPHA选项的BY选项的实现"></a>带有ALPHA选项的BY选项的实现</h3><p>BY选项默认假设权重键保存的值为数字值，如果权重键保存的是字符串值的话，那么就需要在使用BY选项的同时，配合使用ALPHA选项。</p>
<p>服务器执行SORT fruits BY *-id ALPHA命令的详细步骤如下：</p>
<ol>
<li>创建一个redisSortObject结构数组，数组的长度等于fruits集合的大小。</li>
<li>遍历数组，将各个数组项的obj指针分别指向fruits集合的各个元素。</li>
<li>遍历数组，根据各个数组项的obj指针所指向的集合元素，以及BY选项所给定的模式*-id，查找相应的权重键。</li>
<li>将各个数组项的u.cmpobj指针分别指向相应的权重键（一个字符串对象）。</li>
<li>以各个数组项的权重键的值为权重，对数组执行字符串排序。</li>
<li>遍历数组，依次将数组项的obj指针所指向的集合元素返回给客户端。</li>
</ol>
<p>其他SORT &lt;key&gt; BY &lt;pattern&gt; ALPHA命令的执行步骤也和这里给出的步骤类似。</p>
<h3 id="LIMIT选项的实现"><a href="#LIMIT选项的实现" class="headerlink" title="LIMIT选项的实现"></a>LIMIT选项的实现</h3><p>在默认情况下，SORT命令总会将排序后的所有元素都返回给客户端。</p>
<p>但是，通过LIMIT选项，我们可以让SORT命令只返回其中一部分已排序的元素。LIMIT选项的格式为LIMIT &lt;offset&gt; &lt;count&gt;：</p>
<ul>
<li>offset参数表示要跳过的已排序元素数量。</li>
<li>count参数表示跳过给定数量的已排序元素之后，要返回的已排序元素数量。</li>
</ul>
<p>服务器执行SORT alphabet ALPHA LIMIT 0 4命令的详细步骤如下：</p>
<ol>
<li>创建一个redisSortObject结构数组，数组的长度等于alphabet集合的大小。</li>
<li>遍历数组，将各个数组项的obj指针分别指向alphabet集合的各个元素。</li>
<li>根据obj指针所指向的集合元素，对数组进行字符串排序。</li>
<li>根据选项LIMIT 0 4，将指针移动到数组的索引0上面，然后依次访问array [0]、array[1]、array[2]、array[3]这4个数组项，并将数组项的obj指针所指向的元素”a”、”b”、”c”、”d”返回给客户端。</li>
</ol>
<h3 id="GET选项的实现"><a href="#GET选项的实现" class="headerlink" title="GET选项的实现"></a>GET选项的实现</h3><p>在默认情况下，SORT命令在对键进行排序之后，总是返回被排序键本身所包含的元素。</p>
<p>但是，通过使用GET选项，我们可以让SORT命令在对键进行排序之后，根据被排序的元素，以及GET选项所指定的模式，查找并返回某些键的值。</p>
<p>服务器执行SORT students ALPHA GET*-name命令的详细步骤如下：</p>
<ol>
<li>创建一个redisSortObject结构数组，数组的长度等于students集合的大小。</li>
<li>遍历数组，将各个数组项的obj指针分别指向students集合的各个元素。</li>
<li>根据obj指针所指向的集合元素，对数组进行字符串排序。</li>
<li>遍历数组，根据数组项obj指针所指向的集合元素，以及GET选项所给定的*一name模式，查找相应的键。</li>
<li>遍历查找程序返回的三个键，并向客户端返回它们的值。</li>
</ol>
<p>因为一个SORT命令可以带有多个GET选项，所以随着GET选项的增多，命令要执行的查找操作也会增多。</p>
<p>SORT命令在执行其他带有GET选项的排序操作时，执行的步骤也和这里给出的步骤类似。</p>
<h3 id="STORE选项的实现"><a href="#STORE选项的实现" class="headerlink" title="STORE选项的实现"></a>STORE选项的实现</h3><p>在默认情况下，SORT命令只向客户端返回排序结果，而不保存排序结果。但是，通过使用STORE 选项，我们可以将排序结果保存在指定的键里面，并在有需要时重用这个排序结果。</p>
<p>服务器执行SORT students ALPHA STORE sorted_students命令的详细步骤如下：</p>
<ol>
<li>创建一个redisSortObject结构数组，数组的长度等于students集合的大小。</li>
<li>遍历数组，将各个数组项的obj指针分别指向students集合的各个元素。</li>
<li>根据obj指针所指向的集合元素，对数组进行字符串排序。</li>
<li>检查sorted_students键是否存在，如果存在的话，那么删除该键。</li>
<li>设置sorted_students为空白的列表键。</li>
<li>遍历数组，将排序后的三个元素”jack”、”peter”和”tom”依次推入sorted_students列表的末尾，相当于执行命令RPUSH sorted_students “jack”、”peter”、”tom”。</li>
<li>遍历数组，向客户端返回”jack”、”peter”、”tom”三个元素。</li>
</ol>
<p>SORT命令在执行其他带有STORE选项的排序操作时，执行的步骤也和这里给出的步骤类似。</p>
<h3 id="多个选项的执行顺序"><a href="#多个选项的执行顺序" class="headerlink" title="多个选项的执行顺序"></a>多个选项的执行顺序</h3><h4 id="选项的执行顺序"><a href="#选项的执行顺序" class="headerlink" title="选项的执行顺序"></a>选项的执行顺序</h4><p>如果按照选项来划分的话，一个SORT命令的执行过程可以分为以下四步：</p>
<ol>
<li>排序：在这一步，命令会使用ALPHA、ASC或DESC、BY这几个选项，对输入键进行排序，并得到一个排序结果集。</li>
<li>限制排序结果集的长度：在这一步，命令会使用LIMIT选项，对排序结果集的长度进行限制，只有LIMIT选项指定的那部分元素会被保留在排序结果集中。</li>
<li>获取外部键：在这一步，命令会使用GET选项，根据排序结果集中的元素，以及GET选项指定的模式，查找并获取指定键的值，并用这些值来作为新的排序结果集。</li>
<li>保存排序结果集：在这一步，命令会使用STORE选项，将排序结果集保存到指定的键上面去。</li>
<li>向客户端返回排序结果集：在最后这一步，命令遍历排序结果集，并依次向客户端返回排序结果集中的元素。</li>
</ol>
<p>在以上这些步骤中，后一个步骤必须在前一个步骤完成之后进行。</p>
<h4 id="选项的摆放顺序"><a href="#选项的摆放顺序" class="headerlink" title="选项的摆放顺序"></a>选项的摆放顺序</h4><p>另外要提醒的一点是，调用SORT命令时，除了GET选项之外，改变选项的摆放顺序并不会影响SORT命令执行这些选项的顺序。</p>
<p>例如，命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SORT &lt;key&gt; ALPHA DESC BY &lt;by-pattern&gt; LIMIT &lt;offset&gt; &lt;count&gt; GET &lt;get-pattern&gt; STORE &lt;store_key&gt;</span><br><span class="line"></span><br><span class="line">SORT &lt;key&gt; LIMIT &lt;offset&gt; &lt;count&gt; BY &lt;by-pattern&gt; ALPHA GET &lt;get-pattern&gt; STORE &lt;store_key&gt; DESC</span><br><span class="line"></span><br><span class="line">SORT &lt;key&gt; STORE &lt;store_key&gt; DESC BY &lt;by-pattern&gt; GET &lt;get-pattern&gt; ALPHA LIMIT &lt;offset&gt; &lt;count&gt;</span><br></pre></td></tr></table></figure>

<p>都产生完全相同的排序数据集。不过，如果命令包含了多个GET选项，那么在调整选项的位置时，我们必须保证多个GET选项的摆放顺序不变，这才可以让排序结果集保持不变。<br>例如，命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SORT &lt;key&gt; GET &lt;pattern-a&gt; GET &lt;pattern-b&gt; STORE &lt;store_key&gt;</span><br><span class="line"></span><br><span class="line">SORT &lt;key&gt; STORE &lt;store_key&gt; GET &lt;pattern-a&gt; GET &lt;pattern-b&gt;</span><br></pre></td></tr></table></figure>

<p>产生的排序结果集是完全一样的，但如果将两个GET选项的顺序调整一下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SORT &lt;key&gt; STORE &lt;store_key&gt; GET &lt;pattern-b&gt; GET &lt;pattern-a&gt;</span><br></pre></td></tr></table></figure>


<p>那么这个命令产生的排序结果集就会和前面两个命令产生的排序结果集不同。因此在调整SORT命令各个选项的摆放顺序时，必须小心处理GET选项。</p>
<h2 id="二进制位数组"><a href="#二进制位数组" class="headerlink" title="二进制位数组"></a>二进制位数组</h2><p>Redis提供了SETBIT、GETBIT、BITCOUNT、BITOP四个命令用于处理二进制位数组（bit array，又称“位数组”）。</p>
<p>其中，SETBIT命令用于为位数组指定偏移量上的二进制位设置值，位数组的偏移量从0开始计数，而二进制位的值则可以是0或者1：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SETBIT bit 0 1	# 0000 0001</span><br><span class="line">(integer) 0</span><br><span class="line">redis&gt; SETBIT bit 3 1	# 0000 1001</span><br><span class="line">(integer) 0</span><br><span class="line">redis&gt; SETBIT bit 0 0	# 0000 1000</span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure>


<p>而GETBIT命令则用于获取位数组指定偏移量上的二进制位的值：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; GETBIT bit 0		# 0000 1000</span><br><span class="line">(integer) 0</span><br><span class="line">redis&gt; GETBIT bit 3 	# 0000 1000</span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure>


<p>BITCOUNT命令用于统计位数组里面，值为1的二进制位的数量：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; BITCOUNT bit		# 0000 1000</span><br><span class="line">(integer) 1</span><br><span class="line">redis&gt; SETBIT bit 0 1	# 0000 1001</span><br><span class="line">(integer) 0</span><br><span class="line">redis&gt; BITCOUNT bit</span><br><span class="line">(integer) 2</span><br><span class="line">redis&gt; SETBIT bit 1 1	# 0000 1011</span><br><span class="line">(integer) 0</span><br><span class="line">redis&gt; BITCOUNT bit</span><br><span class="line">(integer) 3</span><br></pre></td></tr></table></figure>


<p>最后，BITOP命令既可以对多个位数组进行按位与（and）、按位或（or）、按位异或（xor）运算：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SETBIT x 3 1		# x = 0000 1011</span><br><span class="line">(integer) 0</span><br><span class="line">redis&gt; SETBIT x 1 1</span><br><span class="line">(integer) 0</span><br><span class="line">redis&gt; SETBIT x 0 1</span><br><span class="line">(integer) 0</span><br><span class="line">redis&gt; SETBIT y 2 1		# y = 0000 0110</span><br><span class="line">(integer) 0</span><br><span class="line">redis&gt; SETBIT y 1 1</span><br><span class="line">(integer) 0</span><br><span class="line">redis&gt; SETBIT z 2 1		# z = 0000 0101</span><br><span class="line">(integer) 0</span><br><span class="line">redis&gt; SETBIT z 0 1</span><br><span class="line">(integer) 0</span><br><span class="line">redis&gt; BITOP AND and-result x y z	# 0000 0000</span><br><span class="line">(integer) 1</span><br><span class="line">redis&gt; BITOP OR or-result x y z		# 0000 1111</span><br><span class="line">(integer) 1</span><br><span class="line">redis&gt; BITOP XOR xor-result x y z	# 0000 1000</span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure>


<p>也可以对给定的位数组进行取反（not）运算：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SETBIT value 0 1		# 0000 1001</span><br><span class="line">(integer) 0</span><br><span class="line">redis&gt; SETBIT value 3 1</span><br><span class="line">(integer) 0</span><br><span class="line">redis&gt; BITOP NOT not-value value 	# 1111 0110</span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure>


<p>本章将对Redis表示位数组的方法进行说明，并介绍GETBIT、SETBIT、BITCOUNT、BITOP四个命令的实现原理。</p>
<h3 id="位数组的表示"><a href="#位数组的表示" class="headerlink" title="位数组的表示"></a>位数组的表示</h3><p>Redis使用字符串对象来表示位数组，因为字符串对象使用的SDS数据结构是二进制安全的，所以程序可以直接使用SDS结构来保存位数组，并使用SDS结构的操作函数来处理位数组。</p>
<p>图22-1展示了用SDS表示的，一字节长的位数组：</p>
<ul>
<li>redisObject.type的值为REDIS_STRING，表示这是一个字符串对象。</li>
<li>sdshdr.len的值为1，表示这个SDS保存了一个一字节长的位数组。</li>
<li>buf数组中的buf[0]字节保存了一字节长的位数组。</li>
<li>buf数组中的buf [1]字节保存了SDS程序自动追加到值的末尾的空字符’\0’。</li>
</ul>
<p><img src="/..%5Cimg%5CRedis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%5CSDS%E4%BD%8D%E6%95%B0%E7%BB%84.png" alt="SDS位数组"></p>
<p>因为本章介绍的操作涉及二进制位，为了清晰地展示各个位的值，本章会对SDS中buf数组的展示方式进行一些修改，让各个字节的各个位都可以清楚地展现出来。比如说，本章会将前面图22-1展示的SDS值改成图22-2所示的样子。</p>
<p><img src="/..%5Cimg%5CRedis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%5C%E4%B8%80%E5%AD%97%E8%8A%82%E9%95%BF%E7%9A%84%E4%B8%BA%E6%95%B0%E7%BB%84%E7%9A%84SDS%E8%A1%A8%E7%A4%BA.png" alt="一字节长的为数组的SDS表示"></p>
<p>现在，buf数组的每个字节都用一行来表示，每行的第一个格子buf[i]表示这是buf数组的哪个字节，而buf[i]之后的八个格子则分别代表这一字节中的八个位。</p>
<p>需要注意的是，buf数组保存位数组的顺序和我们平时书写位数组的顺序是完全相反的，例如，在图22-2的buf[0]字节中，各个位的值分别是1、0、1、1、0、0、1、0，这表示buf[0]字节保存的位数组为0100 1101。使用逆序来保存位数组可以简化SETBIT命令的实现，详细的情况稍后在介绍SETBIT命令的实现原理时会说到。</p>
<p>图22-3展示了另一个位数组示例：</p>
<ul>
<li>sdshdr.len属性的值为3，表示这个SDS保存了一个三字节长的位数组。</li>
<li>位数组由buf数组中的buf[0]、buf[1]、buf[2]三个字节保存，和之前说明的一样，buf数组使用逆序来保存位数组：位数组1111 0000 1100 0011 1010 0101在buf数组中会被保存为1010 0101 1100 0011 0000 1111。</li>
</ul>
<p><img src="/..%5Cimg%5CRedis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%5C%E4%B8%89%E5%AD%97%E8%8A%82%E9%95%BF%E7%9A%84%E4%BD%8D%E6%95%B0%E7%BB%84%E7%9A%84SDS%E8%A1%A8%E7%A4%BA.png" alt="三字节长的位数组的SDS表示"></p>
<h3 id="GETBIT命令的实现"><a href="#GETBIT命令的实现" class="headerlink" title="GETBIT命令的实现"></a>GETBIT命令的实现</h3><p>GETBIT命令用于返回位数组bitarray在offset偏移量上的二进制位的值：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GETBIT &lt;bitarray&gt; &lt;offset&gt;</span><br></pre></td></tr></table></figure>

<p>GETBIT命令的执行过程如下：</p>
<ol>
<li>计算byte&#x3D;⌊offset ÷ 8⌋,byte值记录了offset偏移量指定的二进制位保存在位数组的哪个字节。</li>
<li>计算bit&#x3D;(offset mod 8)+1，bit值记录了offset偏移量指定的二进制位是byte字节的第几个二进制位。</li>
<li>根据byte值和bit值，在位数组bitarray中定位offset偏移量指定的二进制位，并返回这个位的值。</li>
</ol>
<p>因为GETBIT命令执行的所有操作都可以在常数时间内完成，所以该命令的算法复杂度位O(1)。</p>
<h3 id="SETBIT命令的完成"><a href="#SETBIT命令的完成" class="headerlink" title="SETBIT命令的完成"></a>SETBIT命令的完成</h3><p>SETBIT用于将位数组bitarray在offset偏移量上的二进制位的值设置为value，并向客户端返回二进制位被设置之前的旧值：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SETBIT &lt;bitarray&gt; &lt;offset&gt; &lt;value&gt;</span><br></pre></td></tr></table></figure>

<p>以下是SETBIT命令的执行过程：</p>
<ol>
<li>计算len &#x3D; ⌊offset ÷ 8⌋ + 1，len值记录了保存offset偏移量指定的二进制位至少需要多少字节。</li>
<li>检查bitarray键保存的位数组（也即是SDS）的长度是否小于len，如果是的话，将SDS的长度扩展为len字节，并将所有新扩展空间的二进制位的值设置为0。</li>
<li>计算byte &#x3D; ⌊offset ÷ 8⌋， byte值记录了offset偏移量指定的二进制位保存在位数组的哪个字节。</li>
<li>计算bit &#x3D; (offset mod 8) + 1，bit值记录了offset偏移量指定的二进制位是byte字节的第几个二进制位。</li>
<li>根据byte值和bit值，在bitarray键保存的位数组中定位offset偏移量指定的二进制位，首先将指定二进制位现在值保存在oldvalue变量，然后将新值value设置为这个二进制位的值。</li>
<li>向客户端返回oldvalue变量的值。</li>
</ol>
<p>因为SETBIT命令执行的所有操作都可以在常数时间内完成，所以该命令的时间复杂度为O(1)。</p>
<h4 id="带扩展操作的SETBIT命令示例"><a href="#带扩展操作的SETBIT命令示例" class="headerlink" title="带扩展操作的SETBIT命令示例"></a>带扩展操作的SETBIT命令示例</h4><p><img src="/..%5Cimg%5CRedis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%5C%E4%B8%80%E5%AD%97%E8%8A%82%E9%95%BF%E7%9A%84%E4%B8%BA%E6%95%B0%E7%BB%84%E7%9A%84SDS%E8%A1%A8%E7%A4%BA.png" alt="一字节长的为数组的SDS表示"><br>假设我们对上图所示的位数组执行命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SETBIT &lt;bitarray&gt; 12 1</span><br></pre></td></tr></table></figure>

<p>那么服务器将执行以下操作：</p>
<ol>
<li>计算⌊12 ÷ 8⌋ + 1，得出值2，这表示保存偏移量为12的二进制位至少需要2字节长的位数组。</li>
<li>对位数组的长度进行检查，得知位数组现在的长度为1字节，这比执行命令所需的最小长度2字节要小，所以程序会要求将位数组的长度扩展为2字节。不过，尽管程序只要求2字节长的位数组，但SDS的空间预分配策略会为SDS额外多分配2字节的未使用空间，再加上为保存空字符而额外分配的1字节，扩展之后buf数组的实际长度为5字节，如图22-8所示。</li>
<li>计算⌊12 ÷ 8⌋，得出值1，说明偏移量为12的二进制位位于buf[1]字节中。</li>
<li>计算(12 mod 8) + 1，得出值5，说明偏移量为12的二进制位是buf[1]字节的第5个二进制位。</li>
<li>定位到buf[1]字节的第5个二进制位，将二进制位现在的值0保存到oldvalue变量，然后将二进制位的值设置为1。</li>
<li>向客户端返回oldvalue变量的值0。</li>
</ol>
<p>图22-10则展示了SETBIT命令执行之后，位数组的样子。</p>
<p>注意，因为buf数组使用逆序来保存位数组，所以当程序对buf数组进行扩展之后，写入操作可以直接在新扩展的二进制位中完成，而不必改动位数组原来已有的二进制位。相反地，如果buf数组使用和书写位数组时一样的顺序来保存位数组，那么在每次扩展buf数组之后，程序都需要将位数组已有的位进行移动，然后才能执行写入操作，这比SETBIT命令目前的实现方式要复杂，并且移位带来的CPU时间消耗也会影响命令的执行速度。</p>
<p><img src="/..%5Cimg%5CRedis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%5C%E6%89%A9%E5%B1%95%E7%A9%BA%E9%97%B4%E4%B9%8B%E5%90%8E%E7%9A%84%E4%BD%8D%E6%95%B0%E7%BB%84.png" alt="扩展空间之后的位数组"></p>
<p><img src="/..%5Cimg%5CRedis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%5CSETBIT%E5%91%BD%E4%BB%A4%E4%B9%8B%E5%90%8E%E7%9A%84%E4%BD%8D%E6%95%B0%E7%BB%84.png" alt="SETBIT命令之后的位数组"></p>
<h3 id="BITCOUNT命令的实现"><a href="#BITCOUNT命令的实现" class="headerlink" title="BITCOUNT命令的实现"></a>BITCOUNT命令的实现</h3><p>BITCOUNT命令用于统计给定位数组中，值为1的二进制位的数量。</p>
<p>BITCOUNT命令要做的工作初看上去并不复杂，但实际上要高效地实现这个命令并不容易，需要用到一些精巧的算法。</p>
<p>接下来的几个小节将对BITCOUNT命令可能使用的几种算法进行介绍，并最终给出BITCOUNT命令的具体实现原理。</p>
<h4 id="二进制位统计算法（1）：遍历算法"><a href="#二进制位统计算法（1）：遍历算法" class="headerlink" title="二进制位统计算法（1）：遍历算法"></a>二进制位统计算法（1）：遍历算法</h4><p>实现BITCOUNT命令最简单直接的方法，就是遍历位数组中的每个二进制位，并在遇到值为1的二进制位时，将计数器的值增一。</p>
<p>遍历算法虽然实现起来简单，但效率非常低，因为这个算法在每次循环中只能检查一个二进制位的值是否为1，所以检查操作执行的次数将与位数组包含的二进制位的数量成正比。</p>
<p>例如，假设要检查的位数组的长度为100MB，那么按1MB &#x3D; 1 000 000 Byte &#x3D; 8 000 000bit来计算，使用遍历算法检查长度为100 MB的位数组将需要执行检查操作八亿次（100 * 8 000 000）！而对于长度为500MB的位数组来说，遍历算法将需要执行检查操作四十亿次！</p>
<p>尽管遍历算法对单个二进制位的检查可以在很短的时间内完成，但重复执行上亿次这种检查肯定不是一个高效程序应有的表现，为了让BITCOUNT命令的实现尽可能地高效，程序必须尽可能地增加每次检查所能处理的二进制位的数量，从而减少检查操作执行的次数。</p>
<h4 id="二进制位统计算法（2）：查表算法"><a href="#二进制位统计算法（2）：查表算法" class="headerlink" title="二进制位统计算法（2）：查表算法"></a>二进制位统计算法（2）：查表算法</h4><p>优化检查操作的一个办法是使用查表法：</p>
<ul>
<li>对于一个有限集合来说，集合元素的排列方式是有限的。</li>
<li>而对于一个有限长度的位数组来说，它能表示的二进制位排列也是有限的。</li>
</ul>
<p>根据这个原理，我们可以创建一个表，表的键为某种排列的位数组，而表的值则是相应位数组中，值为1的二进制位的数量。</p>
<p>创建了这种表之后，我们就可以根据输入的位数组进行查表，在无须对位数组的每个位进行检查的情况下，直接知道这个位数组包含了多少个值为1的二进制位。</p>
<p>举个例子，对于8位长的位数组来说，我们可以创建表格22-1，通过这个表格，我们可以一次从位数组中读入8个位，然后根据这8个位的值进行查表，直接知道这个值包含了多少个值为1的位。</p>
<p><img src="/..%5Cimg%5CRedis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%5C%E5%85%AB%E4%BD%8D%E4%BD%8D%E6%95%B0%E7%BB%84%E5%BB%BA%E8%A1%A8.png" alt="八位位数组建表"></p>
<p>通过使用表22-1，我们只需执行一次查表操作，就可以检查8个二进制位，和之前介绍的遍历算法相比,查表法的效率提升了8倍。</p>
<p>如果我们创建一个更大的表的话，那么每次查表所能处理的位就会更多，从而减少查表操作执行的次数。</p>
<p>初看起来，只要我们创建一个足够大的表，那么统计工作就可以轻易地完成，但这个问题实际上并没有那么简单，因为查表法的实际效果会受到内存和缓存两方面因素的限制：</p>
<ul>
<li>因为查表法是典型的空间换时间策略，算法在计算方面节约的时间是通过花费额外的内存换取而来的，节约的时间越多，花费的内存就越大。对于我们这里讨论的统计二进制位的问题来说，创建键长为8位的表仅需数百个字节，创建键长为16位的表也仅需数百个KB，但创建键长为32位的表却需要十多个GB。在实际中，服务器只可能接受数百个字节或者数百KB的内存消耗。</li>
<li>除了内存大小的问题之外，查表法的效果还会受到CPU缓存的限制：对于固定大小的CPU缓存来说，创建的表格越大，CPU缓存所能保存的内容相比整个表格的比例就越少，查表时出现缓存不命中（cache miss）的情况就会越高，缓存的换入和换出操作就会越频繁，最终影响查表法的实际效率。</li>
</ul>
<p>由于以上列举的两个原因，我们可以得出结论，查表法是一种比遍历算法更好的统计办法，但受限于查表法带来的内存压力，以及缓存不命中可能带来的影响，我们只能考虑创建键长为8位或者键长为16位的表，而这两种表带来的效率提升，对于处理非常长的位数组来说仍然远远不够。</p>
<p>为了高效地实现BITCOUNT命令，我们需要一种不会带来内存压力、并且可以在一次检查中统计多个二进制位的算法，接下来要介绍的variable-precision SWAR算法就是这样一种算法。</p>
<h4 id="二进制位统计算法（3）：variable-precision-SWAR算法"><a href="#二进制位统计算法（3）：variable-precision-SWAR算法" class="headerlink" title="二进制位统计算法（3）：variable-precision SWAR算法"></a>二进制位统计算法（3）：variable-precision SWAR算法</h4><p>BITCOUNT命令要解决的问题——统计一个位数组中非0二进制位的数量，在数学上被称为“计算汉明重量（Hamming Weight）”。</p>
<p>因为汉明重量经常被用于信息论、编码理论和密码学，所以研究人员针对计算汉明重量开发了多种不同的算法，一些处理器甚至直接带有计算汉明重量的指令，而对于不具备这种特殊指令的普通处理器来说，目前已知效率最好的通用算法为variable-precision SWAR算法，该算法通过一系列位移和位运算操作，可以在常数时间内计算多个字节的汉明重量，并且不需要使用任何额外的内存。</p>
<p>以下是一个处理32位长度位数组的variable-precision SWAR算法的实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">uint32_t</span> <span class="title function_">swar</span><span class="params">(<span class="type">uint32_t</span> i)</span> &#123;</span><br><span class="line">	<span class="comment">//步骤1</span></span><br><span class="line">	i = (i &amp; <span class="number">0x55555555</span>) + ((i &gt;&gt; <span class="number">1</span>) &amp; <span class="number">0x55555555</span>);</span><br><span class="line">	<span class="comment">//步骤2</span></span><br><span class="line">	i = (i &amp; <span class="number">0x33333333</span>) + ((i &gt;&gt; <span class="number">2</span>) &amp; <span class="number">0x33333333</span>);</span><br><span class="line">	<span class="comment">//步骤3</span></span><br><span class="line">	i = (i &amp; <span class="number">0x0F0F0F0F</span>) + ((i &gt;&gt; <span class="number">4</span>) &amp; <span class="number">0x0F0F0F0F</span>);</span><br><span class="line">	<span class="comment">//步骤4</span></span><br><span class="line">	i = (i * (<span class="number">0x01010101</span>) &gt;&gt; <span class="number">24</span>);</span><br><span class="line">	<span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以下是调用swar (bitarray)的执行步骤：</p>
<ul>
<li>步骤1计算出的值i的二进制表示可以按每两个二进制位为一组进行分组，各组的十进制表示就是该组的汉明重量。</li>
<li>步骤2计算出的值i的二进制表示可以按每四个二进制位为一组进行分组，各组的十进制表示就是该组的汉明重量。</li>
<li>步骤3计算出的值i的二进制表示可以按每八个二进制位为一组进行分组，各组的十进制表示就是该组的汉明重量。</li>
<li>步骤4的i * 0x01010101语句计算出bitarray的汉明重量并记录在二进制位的最高八位，而&gt;&gt;24语句则通过右移运算，将bitarray的汉明重量移动到最低八位，得出的结果就是bitarray的汉明重量。</li>
</ul>
<p>举个例子，对于调用swar(0x3A70F21B)，程序在第一步将计算出值0x2560A116，这个值的每两个二进制位的十进制表示记录了0x3A70F21B每两个二进制位的汉明重量，如表22-2所示。</p>
<p><img src="/..%5Cimg%5CRedis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%5C%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%A4%E4%BD%8D%E5%88%86%E7%BB%84%E4%B8%8B%E7%9A%84%E6%B1%89%E6%98%8E%E9%87%8D%E9%87%8F.png" alt="二进制两位分组下的汉明重量.png"></p>
<p>之后，程序在第二步将计算出值0x22304113，这个值的每四个二进制位的十进制表示记录了0x3A70F21B每四个二进制位的汉明重量，如表22-3所示。</p>
<p><img src="/..%5Cimg%5CRedis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%5C%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%9B%9B%E4%BD%8D%E5%88%86%E7%BB%84%E4%B8%8B%E7%9A%84%E6%B1%89%E6%98%8E%E9%87%8D%E9%87%8F.png" alt="二进制四位分组下的汉明重量.png"></p>
<p>接下来，程序在第三步将计算出值0x4030504，这个值的每八个二进制位的十进制表示记录了0x3A70F21B每八个二进制位的汉明重量，如表22-4所示。</p>
<p><img src="/..%5Cimg%5CRedis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%5C%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%85%AB%E4%BD%8D%E5%88%86%E7%BB%84%E4%B8%8B%E7%9A%84%E6%B1%89%E6%98%8E%E9%87%8D%E9%87%8F.png" alt="二进制八位分组下的汉明重量.png"></p>
<p>在第四步，程序首先计算0x4030504 * 0x01010101 &#x3D; 0x100c0904，将汉明重量聚集到二进制位的最高八位。之后程序计算0x100c0904 &gt;&gt; 24，将汉明重量移动到低八位，最终得出值0x10，也即是十进制值16，这个值就是0x3A70F21B的汉明重量，如表22-6所示。</p>
<p><img src="/..%5Cimg%5CRedis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%5C%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%A7%BB%E4%BD%8D%E5%90%8E%E7%9A%84%E6%B1%89%E6%98%8E%E9%87%8D%E9%87%8F.png" alt="二进制移位后的汉明重量.png"></p>
<p>swar函数每次执行可以计算32个二进制位的汉明重量，它比之前介绍的遍历算法要快32倍，比键长为8位的查表法快4倍，比键长为16位的查表法快2倍，并且因为swar函数是单纯的计算操作，所以它无须像查表法那样，使用额外的内存。</p>
<p>另外，因为swar函数是一个常数复杂度的操作，所以我们可以按照自己的需要，在一次循环中多次执行swar，从而按倍数提升计算汉明重量的效率：</p>
<ul>
<li>例如，如果我们在一次循环中调用两次swar函数，那么计算汉明重量的效率就从之前的一次循环计算32位提升到了一次循环计算64位。</li>
<li>又例如，如果我们在一次循环中调用四次swar函数，那么一次循环就可以计算128个二进制位的汉明重量，这比每次循环只调用一次swar函数要快四倍！</li>
</ul>
<p>当然，在一个循环里执行多个swar调用这种优化方式是有极限的：一旦循环中处理的位数组的大小超过了缓存的大小，这种优化的效果就会降低并最终消失。</p>
<h4 id="二进制位统计算法（4）：Redis的实现"><a href="#二进制位统计算法（4）：Redis的实现" class="headerlink" title="二进制位统计算法（4）：Redis的实现"></a>二进制位统计算法（4）：Redis的实现</h4><p>BITCOUNT命令的实现用到了查表和variable-precision SWAR两种算法：</p>
<ul>
<li>查表算法使用键长为8位的表，表中记录了从0000 0000到1111 1111在内的所有二进制位的汉明重量。</li>
<li>至于variable-precision SWAR算法方面，BITCOUNT命令在每次循环中载入128个二进制位，然后调用四次32位variable-precision SWAR算法来计算这128个二进制位的汉明重量。</li>
</ul>
<p>在执行BITCOUNT命令时，程序会根据未处理的二进制位的数量来决定使用那种算法：</p>
<ul>
<li>如果未处理的二进制位的数量大于等于128位，那么程序使用variable-precision SWAR算法来计算二进制位的汉明重量。</li>
<li>如果未处理的二进制位的数量小于128位，那么程序使用查表算法来计算二进制位的汉明重量。</li>
</ul>
<p>以下伪代码展示了BITCOUNT命令的实现原理：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"># 一个表，记录了所有八位长位数组的汉明重量</span><br><span class="line"># 程序将8位长的位数组转换成无符号整数，并在表中进行索引</span><br><span class="line"># 例如，对于输入0000 0011，程序将二进制转换为无符号整数3</span><br><span class="line"># 然后取出weight_in_byte[3]的值2</span><br><span class="line"># 2就是0000 0011的汉明重量</span><br><span class="line">weight_in_byte = [0,1,1,2,1,2,2,/*...*/,7,7,8]</span><br><span class="line"></span><br><span class="line">def BITCOUNT(bits):</span><br><span class="line">	# 计算位数组包含了多少个二进制位</span><br><span class="line">	count = count_bit(bits)</span><br><span class="line">	# 初始化汉明重量为零</span><br><span class="line">	weight = 0</span><br><span class="line">	# 如果未处理的二进制位大于等于128位</span><br><span class="line">	# 那么使用variable-precision SWAR算法来处理</span><br><span class="line">	while count &gt;= 128:</span><br><span class="line">		# 四个swar调用，每个调用计算32个二进制位的汉明重量</span><br><span class="line">		# 注意:bits[i:j]中的索引j是不包含在取值范围之内的</span><br><span class="line">		weight += swar(bits[0:32])</span><br><span class="line">		weight += swar(bits[32:64])</span><br><span class="line">		weight += swar(bits[64:96])</span><br><span class="line">		weight += swar(bits[96:128])</span><br><span class="line"></span><br><span class="line">		# 移动指针，略过已处理的位，指向未处理的位</span><br><span class="line">		bits = bits [128:]</span><br><span class="line">		# 减少未处理位的长度</span><br><span class="line">		count -= 128</span><br><span class="line">	# 如果执行到这里,说明未处理的位数量不足128位</span><br><span class="line">	# 那么使用查表法来计算汉明重量</span><br><span class="line">	while count:</span><br><span class="line">		# 将8个位转换成无符号整数，作为查表的索引(键)</span><br><span class="line">		index = bits_to_unsigned_int(bits[0:8])</span><br><span class="line">		weight += weight_in_byte[index]</span><br><span class="line"></span><br><span class="line">		# 移动指针，略过已处理的位，指向未处理的位</span><br><span class="line">		bits = bits[8:]</span><br><span class="line">		#减少未处理位的长度</span><br><span class="line">		count -= 8</span><br><span class="line">	# 计算完毕，返回输入二进制位的汉明重量</span><br><span class="line">	return weight</span><br></pre></td></tr></table></figure>

<p>这个BITCOUNT实现的算法复杂度为O(n)，其中n为输人二进制位的数量。</p>
<p>更具体一点，我们可以用以下公式来计算BITCOUNT命令在处理长度为n的二进制位输入时，命令中的两个循环需要执行的次数：</p>
<ul>
<li>第一个循环的执行次数可以用公式loop1 &#x3D; ⌊n ÷ 128⌋计算得出。</li>
<li>第二个循环的执行次数可以用公式loop2 &#x3D; n mod 128计算得出。</li>
</ul>
<p>以100 MB &#x3D; 800 000 000 bit来计算，BITCOUNT命令处理一个100 MB长的位数组共需要执行第一个循环六百二十五万次，第二个循环零次。以500 MB &#x3D; 4 000 000 000 bit来计算，BITCOUNT命令处理一个500 MB长的位数组共需要执行第一个循环三千一百二十五万次，第二个循环零次。</p>
<p>通过使用更好的算法，我们将计算100 MB和500 MB长的二进制位所需的循环次数从最开始使用遍历算法时的数亿甚至数十亿次减少到了数百万次和数千万次。</p>
<h3 id="BITOP命令的实现"><a href="#BITOP命令的实现" class="headerlink" title="BITOP命令的实现"></a>BITOP命令的实现</h3><p>因为C语言直接支持对字节执行逻辑与(&amp;)、逻辑或(|)、逻辑异或(^)和逻辑非(~)操作，所以BITOP命令的AND、OR、XOR和NOT四个操作都是直接基于这些逻辑操作实现的：</p>
<ul>
<li>在执行BITOP AND命令时，程序用&amp;操作计算出所有输人二进制位的逻辑与结果，然后保存在指定的键上面。</li>
<li>在执行BITOP OR命令时，程序用|操作计算出所有输入二进制位的逻辑或结果，然后保存在指定的键上面。</li>
<li>在执行BITOP XOR命令时，程序用^操作计算出所有输人二进制位的逻辑异或结果，然后保存在指定的键上面。</li>
<li>在执行BITOP NOT命令时，程序用～操作计算出输人二进制位的逻辑非结果，然后保存在指定的键上面。</li>
</ul>
<p>因为BITOP AND、BITOP OR、BITOP XOR三个命令可以接受多个位数组作为输人，程序需要遍历输人的每个位数组的每个字节来进行计算，所以这些命令的复杂度为o(n^2)；与此相反，因为BITOP NOT命令只接受一个位数组输入，所以它的复杂度为O(n)。</p>
<h2 id="慢查询日志"><a href="#慢查询日志" class="headerlink" title="慢查询日志"></a>慢查询日志</h2><p>Redis的慢查询日志功能用于记录执行时间超过给定时长的命令请求，用户可以通过这个功能产生的日志来监视和优化查询速度。</p>
<p>服务器配置有两个和慢查询日志相关的选项：</p>
<ul>
<li>slowlog-log-slower-than选项指定执行时间超过多少微秒（1秒等于1 000 000微秒）的命令请求会被记录到日志上。</li>
<li>slowlog-max-len选项指定服务器最多保存多少条慢查询日志。服务器使用先进先出的方式保存多条慢查询日志，当服务器存储的慢查询日志数量等于slowlog-max-len选项的值时，服务器在添加一条新的慢查询日志之前，会先将最旧的一条慢查询日志删除。</li>
</ul>
<h3 id="慢查询记录的保存"><a href="#慢查询记录的保存" class="headerlink" title="慢查询记录的保存"></a>慢查询记录的保存</h3><p>服务器状态中包含了几个和慢查询日志功能有关的属性：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span> &#123;</span></span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">	</span><br><span class="line">    <span class="comment">//下一条慢查询日志的ID</span></span><br><span class="line">	<span class="type">long</span> <span class="type">long</span> slowlog_entry_id;</span><br><span class="line">    <span class="comment">//保存了所有慢查询日志的链表</span></span><br><span class="line">    <span class="built_in">list</span> *slowlog;</span><br><span class="line">	<span class="comment">//服务器配置slowlog-log-slower-than选项的值</span></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> slowlog_log_slower_than;</span><br><span class="line">	<span class="comment">//服务器配置slowlog-max-len选项的值</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> slowlog_max_len;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<p>slowlog_entry_id属性的初始值为0，每当创建一条新的慢查询日志时，这个属性的值就会用作新日志的id值，之后程序会对这个属性的值增一。</p>
<p>例如，在创建第一条慢查询日志时，slowlog_entry_id的值0会成为第一条慢查询日志的ID，而之后服务器会对这个属性的值增一；当服务器再创建新的慢查询日志的时候，slowlog_entry_id的值1就会成为第二条慢查润日志的ID，然石服务器再次对这个属性的值增一，以此类推。</p>
<p>slowlog链表保存了服务器中的所有慢查询日志，链表中的每个节点都保存了一个slowlogEntry结构，每个slowlogEntry结构代表一条慢查询日志：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">slowlogEntry</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//唯一标识符</span></span><br><span class="line">	<span class="type">long</span> <span class="type">long</span> id;</span><br><span class="line">	<span class="comment">//命令执行时的时间，格式为UNIX时间戳</span></span><br><span class="line">    <span class="type">time_t</span> time;</span><br><span class="line">	<span class="comment">//执行命令消耗的时间，以微秒为单位</span></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> duration;</span><br><span class="line">	<span class="comment">//命令与命令参数</span></span><br><span class="line">	robj **argv;</span><br><span class="line">	<span class="comment">//命令与命令参数的数量</span></span><br><span class="line">    <span class="type">int</span> argc;</span><br><span class="line">    </span><br><span class="line">&#125; slowlogEntry;</span><br></pre></td></tr></table></figure>

<p><img src="/..%5Cimg%5CRedis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%5C%E6%85%A2%E6%9F%A5%E8%AF%A2%E6%97%A5%E5%BF%97%E7%BB%93%E6%9E%84%E7%A4%BA%E4%BE%8B.png" alt="慢查询日志结构示例"></p>
<h3 id="慢查询日志的阅览和删除"><a href="#慢查询日志的阅览和删除" class="headerlink" title="慢查询日志的阅览和删除"></a>慢查询日志的阅览和删除</h3><p>弄清楚了服务器状态的slowlog链表的作用之后，我们可以用以下伪代码来定义查看日志的SLOWLOG GET命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">def SLOWLOG_GET(number=None):</span><br><span class="line"></span><br><span class="line">	# 用户没有给定number参数</span><br><span class="line">	# 那么打印服务器包含的全部慢查询日志</span><br><span class="line">	if number is None:</span><br><span class="line">		number = SLOWLOG_LEN()</span><br><span class="line"></span><br><span class="line">	# 遍历服务器中的慢查询日志</span><br><span class="line">	for log in redisServer.slowlog:</span><br><span class="line">		if number &lt;= 0:</span><br><span class="line">			# 打印的日志数量已经足够，跳出循环</span><br><span class="line">			break</span><br><span class="line">		else:</span><br><span class="line">			# 继续打印，将计数器的值减一</span><br><span class="line">			number -= 1</span><br><span class="line">			# 打印日志</span><br><span class="line">			printLog(log)</span><br></pre></td></tr></table></figure>


<p>查看日志数量的SLOWLOG LEN命令可以用以下伪代码来定义：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">def SLOWLOG_LEN():</span><br><span class="line">	# slowlog链表的长度就是慢查询日志的条目数量</span><br><span class="line">	return len(redisServer.slowlog)</span><br></pre></td></tr></table></figure>


<p>另外，用于清除所有慢查询日志的SLOWLOG RESET命令可以用以下伪代码来定义：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def SLOWLOG_RESET():</span><br><span class="line">	# 遍历服务器中的所有慢查询日志</span><br><span class="line">	for log in redisServer.slowlog:</span><br><span class="line">		# 删除日志</span><br><span class="line">		deleteLog(log)</span><br></pre></td></tr></table></figure>

<h3 id="添加新日志"><a href="#添加新日志" class="headerlink" title="添加新日志"></a>添加新日志</h3><p>在每次执行命令的之前和之后，程序都会记录微秒格式的当前UNIX时间戳，这两个时间戳之间的差就是服务器执行命令所耗费的时长，服务器会将这个时长作为参数之一传给slowlogPushEntryIfNeeded函数，而slowlogPushEntryIfNeeded函数则负责检查是否需要为这次执行的命令创建慢查询日志，以下伪代码展示了这一过程：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 记录执行命令前的时间</span><br><span class="line">before = unixtime_now_in_us()</span><br><span class="line"># 执行命令</span><br><span class="line">execute_command(argv, argc, client)</span><br><span class="line"># 记录执行命令后的时间</span><br><span class="line">after = unixtime_now_in_us()</span><br><span class="line"># 检查是否需要创建新的慢查询日志</span><br><span class="line">slowlogPushEntryIfNeeded(argv, argc, before-after)</span><br></pre></td></tr></table></figure>


<p>slowlogPushEntryIfNeeded函数的作用有两个：</p>
<ol>
<li>检查命令的执行时长是否超过slowlog-log-slower-than选项所设置的时间，如果是的话，就为命令创建一个新的日志，并将新日志添加到slowlog链表的表头。</li>
<li>检查慢查询日志的长度是否超过slowlog-max-len选项所设置的长度，如果是的话，那么将多出来的日志从slowlog链表中删除掉。</li>
</ol>
<p>以下是slowlogPushEntryIfNeeded函数的实现代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">slowlogPushEntryIfNeeded</span><span class="params">(robj **argv, <span class="type">int</span> argc, <span class="type">long</span> <span class="type">long</span> duration)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//慢查询功能未开启，直接返回</span></span><br><span class="line">	<span class="keyword">if</span> (server.slowlog_log_slower_than &lt; <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">//如果执行时间超过服务器设置的上限，那么将命令添加到慢查询日志</span></span><br><span class="line">    <span class="keyword">if</span> (duration &gt;= server.slowlog_log_slower_than)</span><br><span class="line">		<span class="comment">//新日志添加到链表表头</span></span><br><span class="line">		listAddNodeHead(server.slowlog, slowlogCreateEntry(argv, argc, duration));</span><br><span class="line">	<span class="comment">//如果日志数量过多，那么进行删除</span></span><br><span class="line">	<span class="keyword">while</span> (listLength(server.slowlog) &gt; server.slowlog_max_len)</span><br><span class="line">		listDelNode(server.slowlog, listLast(server.slowlog));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="监视器"><a href="#监视器" class="headerlink" title="监视器"></a>监视器</h2><p>通过执行MONITOR命令，客户端可以将自己变为一个监视器，实时地接收并打印出服务器当前处理的命令请求的相关信息：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; MONITOR</span><br><span class="line">OK</span><br><span class="line">1378822099.421623 [0 127.0.0.1:56604] &quot;ING&quot;</span><br><span class="line">1378822105.089572 [0 127.0.0.1:56604] &quot;SET&quot; &quot;msg&quot; &quot;hello world&quot;</span><br><span class="line">1378822109.036925 [0 127.0.0.1:56604] &quot;SET&quot; &quot;number&quot; &quot;123&quot;</span><br><span class="line">1378822140.649496 [0 127.0.0.1:56604] &quot;SADD&quot; &quot;fruits&quot; &quot;Apple&quot; &quot;Banana&quot; &quot;Cherry&quot;</span><br><span class="line">1378822154.117160 [0 127.0.0.1:56604] &quot;EXPIRE&quot; &quot;msg&quot; &quot;10086&quot;</span><br><span class="line">1378822257.329412 [0 127.0.0.1:56604] &quot;KEYS&quot; &quot;*&quot;</span><br><span class="line">1378822258.690131 [0 127.0.0.1:56604] &quot;DBSIZE&quot;</span><br></pre></td></tr></table></figure>


<p>每当一个客户端向服务器发送一条命令请求时，服务器除了会处理这条命令请求之外，还会将关于这条命令请求的信息发送给所有监视器。</p>
<p><img src="/..%5Cimg%5CRedis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%5C%E5%8F%91%E9%80%81%E4%BF%A1%E6%81%AF%E7%BB%99%E7%9B%91%E8%A7%86%E5%99%A8.png" alt="发送信息给监视器"></p>
<h3 id="成为监视器"><a href="#成为监视器" class="headerlink" title="成为监视器"></a>成为监视器</h3><p>发送MONITOR命令可以让一个普通客户端变为一个监视器，该命令的实现原理可以用以下伪代码来实现：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def MONITOR()∶</span><br><span class="line">	# 打开客户端的监视器标志</span><br><span class="line">	client.flags |= REDIS_MONITOR</span><br><span class="line">	# 将客户端添加到服务器状态的monitors链表的末尾</span><br><span class="line">	server.monitors.append(client)</span><br><span class="line">	# 向客户端返回OK</span><br><span class="line">	send_reply(&quot;OK&quot;)</span><br></pre></td></tr></table></figure>

<h3 id="向监视器发送命令信息"><a href="#向监视器发送命令信息" class="headerlink" title="向监视器发送命令信息"></a>向监视器发送命令信息</h3><p>服务器在每次处理命令请求之前，都会调用replicationFeedMonitors函数，由这个函数将被处理的命令请求的相关信息发送给各个监视器。</p>
<p>以下是replicationFeedMonitors函数的伪代码定义，函数首先根据传入的参数创建信息，然后将信息发送给所有监视器：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">def replicationFeedMonitors(client, monitors, dbid, argv, argc):</span><br><span class="line">	# 根据执行命令的客户端、当前数据库的号码、命令参数、命令参数个数等参数</span><br><span class="line">	# 创建要发送给各个监视器的信息</span><br><span class="line">	msg = create_message(client, dbid, argv, argc)</span><br><span class="line">	# 遍历所有监视器</span><br><span class="line">	for monitor in monitors:</span><br><span class="line">		# 将信息发送给监视器</span><br><span class="line">		send_message(monitor, msg)</span><br></pre></td></tr></table></figure>

</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://example.com">lzl121373</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2022/09/25/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E7%AC%AC%E5%9B%9B%E9%83%A8%E5%88%86/">http://example.com/2022/09/25/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E7%AC%AC%E5%9B%9B%E9%83%A8%E5%88%86/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">😊</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Redis/">Redis</a><a class="post-meta__tags" href="/tags/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/">Redis设计与实现</a><a class="post-meta__tags" href="/tags/%E7%8B%AC%E7%AB%8B%E5%8A%9F%E8%83%BD%E7%9A%84%E5%AE%9E%E7%8E%B0/">独立功能的实现</a><a class="post-meta__tags" href="/tags/%E5%8F%91%E5%B8%83%E4%B8%8E%E8%AE%A2%E9%98%85/">发布与订阅</a><a class="post-meta__tags" href="/tags/%E4%BA%8B%E5%8A%A1/">事务</a><a class="post-meta__tags" href="/tags/Lua%E8%84%9A%E6%9C%AC/">Lua脚本</a><a class="post-meta__tags" href="/tags/%E6%8E%92%E5%BA%8F/">排序</a><a class="post-meta__tags" href="/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BD%8D%E6%95%B0%E7%BB%84/">二进制位数组</a><a class="post-meta__tags" href="/tags/%E6%85%A2%E6%9F%A5%E8%AF%A2%E6%97%A5%E5%BF%97/">慢查询日志</a><a class="post-meta__tags" href="/tags/%E7%9B%91%E8%A7%86%E5%99%A8/">监视器</a></div><div class="post_share"><div class="social-share" data-image="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/gh/overtrue/share.js@master/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/2022/08/28/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E7%AC%AC%E4%B8%89%E9%83%A8%E5%88%86/"><img class="next-cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">&lt;Redis设计与实现&gt;第三部分</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2022/05/13/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86/" title="&lt;Redis设计与实现&gt;第一部分"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-05-13</div><div class="title">&lt;Redis设计与实现&gt;第一部分</div></div></a></div><div><a href="/2022/08/28/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E7%AC%AC%E4%B8%89%E9%83%A8%E5%88%86/" title="&lt;Redis设计与实现&gt;第三部分"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-08-28</div><div class="title">&lt;Redis设计与实现&gt;第三部分</div></div></a></div><div><a href="/2022/05/29/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86/" title="&lt;Redis设计与实现&gt;第二部分"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-05-29</div><div class="title">&lt;Redis设计与实现&gt;第二部分</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">lzl121373</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">11</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">51</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">2</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/lzl121373" target="_blank" title="Github"><i class="fab fa-github"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%8B%AC%E7%AB%8B%E5%8A%9F%E8%83%BD%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.</span> <span class="toc-text">独立功能的实现</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%91%E5%B8%83%E4%B8%8E%E8%AE%A2%E9%98%85"><span class="toc-number">1.1.</span> <span class="toc-text">发布与订阅</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%91%E9%81%93%E7%9A%84%E8%AE%A2%E9%98%85%E4%B8%8E%E9%80%80%E8%AE%A2"><span class="toc-number">1.1.1.</span> <span class="toc-text">频道的订阅与退订</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%A2%E9%98%85%E9%A2%91%E9%81%93"><span class="toc-number">1.1.1.1.</span> <span class="toc-text">订阅频道</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%80%E8%AE%A2%E9%A2%91%E9%81%93"><span class="toc-number">1.1.1.2.</span> <span class="toc-text">退订频道</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%AE%A2%E9%98%85%E4%B8%8E%E9%80%80%E8%AE%A2"><span class="toc-number">1.1.2.</span> <span class="toc-text">模式的订阅与退订</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.1.2.1.</span> <span class="toc-text">订阅模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%80%E8%AE%A2%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.1.2.2.</span> <span class="toc-text">退订模式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%91%E9%80%81%E6%B6%88%E6%81%AF"><span class="toc-number">1.1.3.</span> <span class="toc-text">发送消息</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%86%E6%B6%88%E6%81%AF%E5%8F%91%E9%80%81%E7%BB%99%E9%A2%91%E9%81%93%E8%AE%A2%E9%98%85%E8%80%85"><span class="toc-number">1.1.3.1.</span> <span class="toc-text">将消息发送给频道订阅者</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%86%E6%B6%88%E6%81%AF%E5%8F%91%E9%80%81%E7%BB%99%E6%A8%A1%E5%BC%8F%E8%AE%A2%E9%98%85%E8%80%85"><span class="toc-number">1.1.3.2.</span> <span class="toc-text">将消息发送给模式订阅者</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E8%AE%A2%E9%98%85%E6%B6%88%E6%81%AF"><span class="toc-number">1.1.4.</span> <span class="toc-text">查看订阅消息</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#PUBSUB-CHANNELS"><span class="toc-number">1.1.4.1.</span> <span class="toc-text">PUBSUB CHANNELS</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#PUBSUB-NUMSUB"><span class="toc-number">1.1.4.2.</span> <span class="toc-text">PUBSUB NUMSUB</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#PUBSUB-NUMPAT"><span class="toc-number">1.1.4.3.</span> <span class="toc-text">PUBSUB NUMPAT</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1"><span class="toc-number">1.2.</span> <span class="toc-text">事务</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.2.1.</span> <span class="toc-text">事务的实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E5%BC%80%E5%A7%8B"><span class="toc-number">1.2.1.1.</span> <span class="toc-text">事务开始</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%91%BD%E4%BB%A4%E5%85%A5%E9%98%9F"><span class="toc-number">1.2.1.2.</span> <span class="toc-text">命令入队</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E9%98%9F%E5%88%97"><span class="toc-number">1.2.1.3.</span> <span class="toc-text">事务队列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%A7%E8%A1%8C%E4%BA%8B%E5%8A%A1"><span class="toc-number">1.2.1.4.</span> <span class="toc-text">执行事务</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#WATCH%E5%91%BD%E4%BB%A4%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.2.2.</span> <span class="toc-text">WATCH命令的实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8WATCH%E5%91%BD%E4%BB%A4%E7%9B%91%E8%A7%86%E6%95%B0%E6%8D%AE%E5%BA%93%E9%94%AE"><span class="toc-number">1.2.2.1.</span> <span class="toc-text">使用WATCH命令监视数据库键</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%91%E8%A7%86%E6%9C%BA%E5%88%B6%E7%9A%84%E8%A7%A6%E5%8F%91"><span class="toc-number">1.2.2.2.</span> <span class="toc-text">监视机制的触发</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A4%E6%96%AD%E4%BA%8B%E5%8A%A1%E6%98%AF%E5%90%A6%E5%AE%89%E5%85%A8"><span class="toc-number">1.2.2.3.</span> <span class="toc-text">判断事务是否安全</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E7%9A%84ACID%E6%80%A7%E8%B4%A8"><span class="toc-number">1.2.3.</span> <span class="toc-text">事务的ACID性质</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%9F%E5%AD%90%E6%80%A7"><span class="toc-number">1.2.3.1.</span> <span class="toc-text">原子性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80%E8%87%B4%E6%80%A7"><span class="toc-number">1.2.3.2.</span> <span class="toc-text">一致性</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%A5%E9%98%9F%E9%94%99%E8%AF%AF"><span class="toc-number">1.2.3.2.1.</span> <span class="toc-text">入队错误</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%89%A7%E8%A1%8C%E9%94%99%E8%AF%AF"><span class="toc-number">1.2.3.2.2.</span> <span class="toc-text">执行错误</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%81%9C%E6%9C%BA"><span class="toc-number">1.2.3.2.3.</span> <span class="toc-text">服务器停机</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9A%94%E7%A6%BB%E6%80%A7"><span class="toc-number">1.2.3.3.</span> <span class="toc-text">隔离性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%80%90%E4%B9%85%E6%80%A7"><span class="toc-number">1.2.3.4.</span> <span class="toc-text">耐久性</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Lua%E8%84%9A%E6%9C%AC"><span class="toc-number">1.3.</span> <span class="toc-text">Lua脚本</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E5%B9%B6%E4%BF%AE%E6%94%B9Lua%E7%8E%AF%E5%A2%83"><span class="toc-number">1.3.1.</span> <span class="toc-text">创建并修改Lua环境</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BALua%E7%8E%AF%E5%A2%83"><span class="toc-number">1.3.1.1.</span> <span class="toc-text">创建Lua环境</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BD%BD%E5%85%A5%E5%87%BD%E6%95%B0%E5%BA%93"><span class="toc-number">1.3.1.2.</span> <span class="toc-text">载入函数库</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BAredis%E5%85%A8%E5%B1%80%E8%A1%A8%E6%A0%BC"><span class="toc-number">1.3.1.3.</span> <span class="toc-text">创建redis全局表格</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8Redis%E8%87%AA%E5%88%B6%E7%9A%84%E9%9A%8F%E6%9C%BA%E5%87%BD%E6%95%B0%E6%9D%A5%E6%9B%BF%E6%8D%A2Lua%E5%8E%9F%E6%9C%89%E7%9A%84%E9%9A%8F%E6%9C%BA%E5%87%BD%E6%95%B0"><span class="toc-number">1.3.1.4.</span> <span class="toc-text">使用Redis自制的随机函数来替换Lua原有的随机函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E6%8E%92%E5%BA%8F%E8%BE%85%E5%8A%A9%E5%87%BD%E6%95%B0"><span class="toc-number">1.3.1.5.</span> <span class="toc-text">创建排序辅助函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BAredis-pcall%E5%87%BD%E6%95%B0%E7%9A%84%E9%94%99%E8%AF%AF%E6%8A%A5%E5%91%8A%E8%BE%85%E5%8A%A9%E5%87%BD%E6%95%B0"><span class="toc-number">1.3.1.6.</span> <span class="toc-text">创建redis.pcall函数的错误报告辅助函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%9D%E6%8A%A4Lua%E7%9A%84%E5%85%A8%E5%B1%80%E7%8E%AF%E5%A2%83"><span class="toc-number">1.3.1.7.</span> <span class="toc-text">保护Lua的全局环境</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%86Lua%E7%8E%AF%E5%A2%83%E4%BF%9D%E5%AD%98%E5%88%B0%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%8A%B6%E6%80%81%E7%9A%84lua%E5%B1%9E%E6%80%A7%E9%87%8C%E9%9D%A2"><span class="toc-number">1.3.1.8.</span> <span class="toc-text">将Lua环境保存到服务器状态的lua属性里面</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Lua%E7%8E%AF%E5%A2%83%E5%8D%8F%E4%BD%9C%E7%BB%84%E4%BB%B6"><span class="toc-number">1.3.2.</span> <span class="toc-text">Lua环境协作组件</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%AA%E5%AE%A2%E6%88%B7%E7%AB%AF"><span class="toc-number">1.3.2.1.</span> <span class="toc-text">伪客户端</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#lua-scripts%E5%AD%97%E5%85%B8"><span class="toc-number">1.3.2.2.</span> <span class="toc-text">lua_scripts字典</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#EVAL%E5%91%BD%E4%BB%A4%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.3.3.</span> <span class="toc-text">EVAL命令的实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E8%84%9A%E6%9C%AC%E5%87%BD%E6%95%B0"><span class="toc-number">1.3.3.1.</span> <span class="toc-text">定义脚本函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%86%E8%84%9A%E6%9C%AC%E4%BF%9D%E5%AD%98%E5%88%B0lua-scripts%E5%AD%97%E5%85%B8"><span class="toc-number">1.3.3.2.</span> <span class="toc-text">将脚本保存到lua_scripts字典</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%A7%E8%A1%8C%E8%84%9A%E6%9C%AC%E5%87%BD%E6%95%B0"><span class="toc-number">1.3.3.3.</span> <span class="toc-text">执行脚本函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#EVALSHA%E5%91%BD%E4%BB%A4%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.3.4.</span> <span class="toc-text">EVALSHA命令的实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%84%9A%E6%9C%AC%E7%AE%A1%E7%90%86%E5%91%BD%E4%BB%A4%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.3.5.</span> <span class="toc-text">脚本管理命令的实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#SCRIPT-FLUSH"><span class="toc-number">1.3.5.1.</span> <span class="toc-text">SCRIPT FLUSH</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SCRIPT-EXISTS"><span class="toc-number">1.3.5.2.</span> <span class="toc-text">SCRIPT EXISTS</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SCRIPT-LOAD"><span class="toc-number">1.3.5.3.</span> <span class="toc-text">SCRIPT LOAD</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SCRIPT-KILL"><span class="toc-number">1.3.5.4.</span> <span class="toc-text">SCRIPT KILL</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%84%9A%E6%9C%AC%E5%A4%8D%E5%88%B6"><span class="toc-number">1.3.6.</span> <span class="toc-text">脚本复制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%8D%E5%88%B6EVAL%E5%91%BD%E4%BB%A4%E3%80%81SCRIPT-FLUSH%E5%91%BD%E4%BB%A4%E5%92%8CSCRIPT-LOAD%E5%91%BD%E4%BB%A4"><span class="toc-number">1.3.6.1.</span> <span class="toc-text">复制EVAL命令、SCRIPT FLUSH命令和SCRIPT LOAD命令</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#EVAL"><span class="toc-number">1.3.6.1.1.</span> <span class="toc-text">EVAL</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#SCRIPT-FLUSH-1"><span class="toc-number">1.3.6.1.2.</span> <span class="toc-text">SCRIPT FLUSH</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#SCRIPT-LOAD-1"><span class="toc-number">1.3.6.1.3.</span> <span class="toc-text">SCRIPT LOAD</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%8D%E5%88%B6EVALSHA%E5%91%BD%E4%BB%A4"><span class="toc-number">1.3.6.2.</span> <span class="toc-text">复制EVALSHA命令</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%A4%E6%96%AD%E4%BC%A0%E6%92%ADEVALSHA%E5%91%BD%E4%BB%A4%E6%98%AF%E5%90%A6%E5%AE%89%E5%85%A8%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">1.3.6.2.1.</span> <span class="toc-text">判断传播EVALSHA命令是否安全的方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B8%85%E7%A9%BArepl-scriptcache-dict%E5%AD%97%E5%85%B8"><span class="toc-number">1.3.6.2.2.</span> <span class="toc-text">清空repl_scriptcache_dict字典</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#EVALSHA%E5%91%BD%E4%BB%A4%E8%BD%AC%E6%8D%A2%E6%88%90EVAL%E5%91%BD%E4%BB%A4%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">1.3.6.2.3.</span> <span class="toc-text">EVALSHA命令转换成EVAL命令的方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BC%A0%E6%92%ADEVALSHA%E5%91%BD%E4%BB%A4%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">1.3.6.2.4.</span> <span class="toc-text">传播EVALSHA命令的方法</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F"><span class="toc-number">1.4.</span> <span class="toc-text">排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#SORT-lt-key-gt-%E5%91%BD%E4%BB%A4%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.4.1.</span> <span class="toc-text">SORT &lt;key&gt;命令的实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ALPHA%E9%80%89%E9%A1%B9%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.4.2.</span> <span class="toc-text">ALPHA选项的实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ASC%E9%80%89%E9%A1%B9%E5%92%8CDESC%E9%80%89%E9%A1%B9"><span class="toc-number">1.4.3.</span> <span class="toc-text">ASC选项和DESC选项</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BY%E9%80%89%E9%A1%B9%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.4.4.</span> <span class="toc-text">BY选项的实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%A6%E6%9C%89ALPHA%E9%80%89%E9%A1%B9%E7%9A%84BY%E9%80%89%E9%A1%B9%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.4.5.</span> <span class="toc-text">带有ALPHA选项的BY选项的实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LIMIT%E9%80%89%E9%A1%B9%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.4.6.</span> <span class="toc-text">LIMIT选项的实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#GET%E9%80%89%E9%A1%B9%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.4.7.</span> <span class="toc-text">GET选项的实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#STORE%E9%80%89%E9%A1%B9%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.4.8.</span> <span class="toc-text">STORE选项的实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E4%B8%AA%E9%80%89%E9%A1%B9%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F"><span class="toc-number">1.4.9.</span> <span class="toc-text">多个选项的执行顺序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%89%E9%A1%B9%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F"><span class="toc-number">1.4.9.1.</span> <span class="toc-text">选项的执行顺序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%89%E9%A1%B9%E7%9A%84%E6%91%86%E6%94%BE%E9%A1%BA%E5%BA%8F"><span class="toc-number">1.4.9.2.</span> <span class="toc-text">选项的摆放顺序</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BD%8D%E6%95%B0%E7%BB%84"><span class="toc-number">1.5.</span> <span class="toc-text">二进制位数组</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%8D%E6%95%B0%E7%BB%84%E7%9A%84%E8%A1%A8%E7%A4%BA"><span class="toc-number">1.5.1.</span> <span class="toc-text">位数组的表示</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#GETBIT%E5%91%BD%E4%BB%A4%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.5.2.</span> <span class="toc-text">GETBIT命令的实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SETBIT%E5%91%BD%E4%BB%A4%E7%9A%84%E5%AE%8C%E6%88%90"><span class="toc-number">1.5.3.</span> <span class="toc-text">SETBIT命令的完成</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%A6%E6%89%A9%E5%B1%95%E6%93%8D%E4%BD%9C%E7%9A%84SETBIT%E5%91%BD%E4%BB%A4%E7%A4%BA%E4%BE%8B"><span class="toc-number">1.5.3.1.</span> <span class="toc-text">带扩展操作的SETBIT命令示例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BITCOUNT%E5%91%BD%E4%BB%A4%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.5.4.</span> <span class="toc-text">BITCOUNT命令的实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BD%8D%E7%BB%9F%E8%AE%A1%E7%AE%97%E6%B3%95%EF%BC%881%EF%BC%89%EF%BC%9A%E9%81%8D%E5%8E%86%E7%AE%97%E6%B3%95"><span class="toc-number">1.5.4.1.</span> <span class="toc-text">二进制位统计算法（1）：遍历算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BD%8D%E7%BB%9F%E8%AE%A1%E7%AE%97%E6%B3%95%EF%BC%882%EF%BC%89%EF%BC%9A%E6%9F%A5%E8%A1%A8%E7%AE%97%E6%B3%95"><span class="toc-number">1.5.4.2.</span> <span class="toc-text">二进制位统计算法（2）：查表算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BD%8D%E7%BB%9F%E8%AE%A1%E7%AE%97%E6%B3%95%EF%BC%883%EF%BC%89%EF%BC%9Avariable-precision-SWAR%E7%AE%97%E6%B3%95"><span class="toc-number">1.5.4.3.</span> <span class="toc-text">二进制位统计算法（3）：variable-precision SWAR算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BD%8D%E7%BB%9F%E8%AE%A1%E7%AE%97%E6%B3%95%EF%BC%884%EF%BC%89%EF%BC%9ARedis%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.5.4.4.</span> <span class="toc-text">二进制位统计算法（4）：Redis的实现</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BITOP%E5%91%BD%E4%BB%A4%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.5.5.</span> <span class="toc-text">BITOP命令的实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%85%A2%E6%9F%A5%E8%AF%A2%E6%97%A5%E5%BF%97"><span class="toc-number">1.6.</span> <span class="toc-text">慢查询日志</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%85%A2%E6%9F%A5%E8%AF%A2%E8%AE%B0%E5%BD%95%E7%9A%84%E4%BF%9D%E5%AD%98"><span class="toc-number">1.6.1.</span> <span class="toc-text">慢查询记录的保存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%85%A2%E6%9F%A5%E8%AF%A2%E6%97%A5%E5%BF%97%E7%9A%84%E9%98%85%E8%A7%88%E5%92%8C%E5%88%A0%E9%99%A4"><span class="toc-number">1.6.2.</span> <span class="toc-text">慢查询日志的阅览和删除</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%BB%E5%8A%A0%E6%96%B0%E6%97%A5%E5%BF%97"><span class="toc-number">1.6.3.</span> <span class="toc-text">添加新日志</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9B%91%E8%A7%86%E5%99%A8"><span class="toc-number">1.7.</span> <span class="toc-text">监视器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%88%90%E4%B8%BA%E7%9B%91%E8%A7%86%E5%99%A8"><span class="toc-number">1.7.1.</span> <span class="toc-text">成为监视器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%91%E7%9B%91%E8%A7%86%E5%99%A8%E5%8F%91%E9%80%81%E5%91%BD%E4%BB%A4%E4%BF%A1%E6%81%AF"><span class="toc-number">1.7.2.</span> <span class="toc-text">向监视器发送命令信息</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/09/25/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E7%AC%AC%E5%9B%9B%E9%83%A8%E5%88%86/" title="&lt;Redis设计与实现&gt;第四部分"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="&lt;Redis设计与实现&gt;第四部分"/></a><div class="content"><a class="title" href="/2022/09/25/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E7%AC%AC%E5%9B%9B%E9%83%A8%E5%88%86/" title="&lt;Redis设计与实现&gt;第四部分">&lt;Redis设计与实现&gt;第四部分</a><time datetime="2022-09-24T16:00:00.000Z" title="发表于 2022-09-25 00:00:00">2022-09-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/08/28/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E7%AC%AC%E4%B8%89%E9%83%A8%E5%88%86/" title="&lt;Redis设计与实现&gt;第三部分"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="&lt;Redis设计与实现&gt;第三部分"/></a><div class="content"><a class="title" href="/2022/08/28/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E7%AC%AC%E4%B8%89%E9%83%A8%E5%88%86/" title="&lt;Redis设计与实现&gt;第三部分">&lt;Redis设计与实现&gt;第三部分</a><time datetime="2022-08-27T16:00:00.000Z" title="发表于 2022-08-28 00:00:00">2022-08-28</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/05/29/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86/" title="&lt;Redis设计与实现&gt;第二部分"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="&lt;Redis设计与实现&gt;第二部分"/></a><div class="content"><a class="title" href="/2022/05/29/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86/" title="&lt;Redis设计与实现&gt;第二部分">&lt;Redis设计与实现&gt;第二部分</a><time datetime="2022-05-28T16:00:00.000Z" title="发表于 2022-05-29 00:00:00">2022-05-29</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/05/13/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86/" title="&lt;Redis设计与实现&gt;第一部分"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="&lt;Redis设计与实现&gt;第一部分"/></a><div class="content"><a class="title" href="/2022/05/13/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86/" title="&lt;Redis设计与实现&gt;第一部分">&lt;Redis设计与实现&gt;第一部分</a><time datetime="2022-05-12T16:00:00.000Z" title="发表于 2022-05-13 00:00:00">2022-05-13</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/05/09/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E7%AC%AC%E4%B8%83%E7%AB%A0/" title="&lt;STL源码剖析&gt;第七章——仿函数"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="&lt;STL源码剖析&gt;第七章——仿函数"/></a><div class="content"><a class="title" href="/2022/05/09/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E7%AC%AC%E4%B8%83%E7%AB%A0/" title="&lt;STL源码剖析&gt;第七章——仿函数">&lt;STL源码剖析&gt;第七章——仿函数</a><time datetime="2022-05-08T16:00:00.000Z" title="发表于 2022-05-09 00:00:00">2022-05-09</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By lzl121373</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>